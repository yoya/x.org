.\" MIT header page and copyright notice
.\" MIT page header and footers
.\" Search to "Beta release" to find commented out text
.\"
.EH ''''
.OH ''''
.EF ''''
.OF ''''
.ps 11
.nr PS 11
\&
.sp 8
.ce 4
\s+2\fBX Toolkit Library - C Language Interface\fP\s-2

\s+1\fBToolkit Beta Version 0.1\fP\s-1

\s+1\fBX Protocol Version 11\fP\s-1
.bp
\&
.ps 9
.nr PS 9
.sp 8
.LP
The X Window System is a trademark of MIT.
.LP
Copyright \(co 1985, 1986, 1987,
Massachusetts Institute of Technology, Cambridge, Massachusetts,
and Digital Equipment Corporation, Maynard, Massachusetts.
.LP
Permission to use, copy, modify and distribute this documentation for
any purpose and without fee is hereby granted, provided that the above
copyright notice appears in all copies and that both that copyright notice and
this permission notice appear in supporting documentation, and that the name of
M.I.T. or Digital not be used in in advertising or publicity pertaining
to distribution of the software without specific, written prior permission.
M.I.T and Digital makes no representations about the suitability of the
software described herein for any purpose.
It is provided ``as is'' without express or implied warranty.
.ps 11
.nr PS 11
.bp 1
.EH '\fBX Toolkit\fP''\fBBeta Version 0.1\fP'
.OH '\fBX Toolkit\fP''\fBBeta Version 0.1\fP'
.EF ''\fB % \fP''
.OF ''\fB % \fP''
.\" Beta release
.\" Original header page
.\"
.\".RP
.\".ND
.\".TL
.\"The \*(tk Intrinsics
.\".ND
.\".AB no
.\"This document describes Version 1.0 of the \*(tk Intrinsics.
.\".AE
.NH 1
Overview
.XS
\*(SN Overview
.XE
.LP
The \*(tk provides the base functionality necessary to build a wide variety
of application environments.
The \*(tk is fully extensible and supportive of the independent development
of new or extended components.
This is accomplished by defining a few, easy-to-use interfaces that mask
implementation details from both applications and common component implementors.
By following a small set of conventions,
a programmer can extend the \*(tk in new ways and have these extensions function 
smoothly with the existing facilities.
.LP
The \*(tk is a library package layered on top of the X Window System.
This layer extends the basic abstractions provided by X and, thus, provides
the ``next layer'' of functionality by supplying mechanisms for intercomponent 
and intracomponent interactions.
As time progresses,
we expect to supply a reasonably complete and cohesive set of sample widgets 
that can be used as the basis for quick applications development.
In the \*(tk, 
a ``widget'' is a combination of an X window (or subwindow) 
and its associated semantics.
.LP
The \*(tk provides flexibility and extensibility.
To the extent possible,
it also is ``policy free''.
The application environment, not the \*(tk, defines, implements, and enforces:
.IP \(bu 5
Policy
.IP \(bu 5
Consistency
.IP \(bu 5
Style
.LP
Each individual widget implementation defines its own policy.
The \*(tk design allows for the development of radically differing
widget implementations.
.NH 1 
Introduction
.XS
\*(SN Introduction
.XE
.LP
The \*(tk provides tools that simplify the design of application user
interfaces in the X Window System programming environment.
It assists application programmers by providing a commonly used set
of underlying user-interface functions that enable you to manage:
.IP \(bu 5
Widgets
.IP \(bu 5
Standard operations
.IP \(bu 5
Toolkit initialization
.IP \(bu 5
Memory
.IP \(bu 5
Input and events
.IP \(bu 5
Widget geometry
.IP \(bu 5
Input focus
.IP \(bu 5
Selections
.IP \(bu 5
Resources and resource conversion
.IP \(bu 5                       
Translation of events
.IP \(bu 5                       
Graphics contexts
.IP \(bu 5
Pixmaps
.IP \(bu 5
Errors
.LP
At present,
the \*(tk consists of:
.IP \(bu 5
A set of intrinsic mechanisms for building widgets
.IP \(bu 5
An architectural model for constructing and composing widgets
.IP \(bu 5
A consistent interface for programming
.LP
The intrinsics mechanisms are intended for the widget programmer.
The architectural model lets the widget programmer design new widgets
by using the intrinsics or by combining other widgets.
The application interface layers built on top of the \*(tk include a 
coordinated set of widgets and composition policies.
Some of these widgets and policies are application domain specific,
while others are common across a number of application domains.
.LP
The \*(tk provides an architectural model that is flexible enough to 
accommodate a number of different application interface layers.
In addition,
the supplied set of toolkit functions are:
.IP \(bu 5
Functionally complete and policy free
.IP \(bu 5
Stylistically and functionally consistent with the X Window System primitives
.IP \(bu 5
Portable across a wide variety of languages, computer architectures, 
and operating systems
.LP
Applications that use the \*(tk must include the following header files:
.IP \(bu 5
.PN <X/Xlib.h>
.IN "<X/Xlib.h>"
.IP \(bu 5
.PN <X/Intrinsic.h>
.IN "<X/Intrinsic.h>"
.IP \(bu 5
.PN <X/Xatoms.h>
.IN "<X/Xatoms.h>"
.IP \(bu 5
.PN <X/Atoms.h>
.IN "<X/Atoms.h>"
.IP \(bu 5
.PN <X/TopLevel.h>
.IN "<X/TopLevel.h>"
.LP
The applications should also include the additional headers for each widget class
that they are to use (for example,
.PN <X/Label.h>
or
.PN <X/Scroll.h> ).
The object library file is named
.PN libXtk.a
and, on a UNIX-based system, is normally referenced as '-lXtk'.
.NH 1
Terminology
.LP
The following terms are used throughout this manual:
.IP Object 2i
A software data abstraction that consists of private data and public and private
routines that operate on the private data.
Users of the abstraction can interact with the object only through calls
to the object's public routines.
In the \*(tk,
some of the object's public routines are called directly by the application,
while others are called indirectly when the application calls the common routines.
In general, if a function is common to all widgets, 
an application uses a single intrinsic routine to invoke the function for all
types of widgets.
If a function is unique to a single widget type,
the widget exports the function as another ``Xt'' routine.
.IP Widget 2i
.IN "Widget"
An object providing a user-interface abstraction (for example, a scroll bar).
.IP Toolkit 2i
.IN "Toolkit"
The name of the user-interface library that is the subject of this manual.
.IP "Application Programmer" 2i
.IN "Application Programmer"
A programmer that uses the \*(tk to produce the application user-interface.
.IP "Widget Programmer" 2i
.IN "Widget Programmer"
A programmer that modifies the \*(tk or adds new widgets to it.
.IP Client 2i
.IN "Client"
A routine that uses a widget in an application or for composing another widget.
.IP Name 2i
.IN "Name"
The name that is specific to a given widget instance in an application.
.IP Class 2i
.IN "Class"
A general group that a widget belongs to.
.NH 1
Widgets
.XS
\*(SN Widgets
.XE
.LP
The fundamental data type of the toolkit is the ``widget,'' which is
dynamically allocated and contains state information.  Every widget
belongs to exactly one ``widget class'' that is statically allocated and
initialized and that contains the operations allowable on widgets of that
class.
.LP
Physically, a widget is a
pointer to a structure which contains fields common to all widgets and some
fields that are specific to widgets of a particular widget class.
In general, the values
of these fields may vary from widget to widget, even for widgets of the same
widget class.  A widget is allocated and initialized by
.IN "XtCreateWidget"
.PN XtCreateWidget .
See ``Creating Widgets'' for further information.
.LP
Physically, a widget class is a pointer to a structure which contains fields
common to all widget classes and some fields that are particular to the widget
class.  The values of these fields are constant for all widgets of the widget
class, though the values may vary from widget class to widget class.
(``Constant'' means the class structure is initialized at compile-time and never
changed, except for a one-shot class initialization and in-place compilation of
resource lists.)
.\" Beta release
.\" 
.\".LP
.\"[[ The term ``widget'' is not used consistently.  Sometimes it means widget
.\"instance, sometime it means widget class, sometimes it means both.
.\"Also, sometimes is an X widget
.\"means is a subclass of. I'd like to clean this up.  Help appreciated.  ]]
.LP
The organization of the declarations and code for a new widget class between a
public ``.h'' file, a private ``.h'' file, and the implementation ``.c''
file is described in ``Widget Subclassing''.  The predefined widget classes
below adhere to these conventions.
.NH 2
Core Widget Definitions
.XS
\*(SN Core Widget Definitions
.XE
.LP
The Core widget contains the generic widget definitions.  All actual widgets
are subclasses of Core.
The structure definitions for Core, Composite and Constraint currently are
contained in the Intrinsic.h file.
.NH 3
CorePart Definition
.XS
\*(SN CorePart Definition
.XE
.LP
The common fields for all widgets are defined in the 
.IN "CorePart"
.PN CorePart 
structure:
.LP
.DS 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	WidgetClass \fIwidget_class\fP;	See ``Widget Classes''
	Widget \fIparent\fP;	See ``Widget Tree''
	String \fIname\fP;	See ``Resource Management''
	XrmName \fIxrm_name\fP;	Private to ``Resource Management''
	Screen *\fIscreen\fP;	See ``Window Attributes''
	Window \fIwindow\fP;	See ``Window Attributes''
	Position \fIx\fP;	See ``Geometry Management''
	Position \fIy\fP;	See ``Geometry Management''
	Dimension \fIwidth\fP;	See ``Geometry Management''
	Dimension \fIheight\fP;	See ``Geometry Management''
	Cardinal \fIdepth\fP;	See ``Window Attributes''
	Dimension \fIborder_width\fP;	See ``Geometry Management''
	Pixel \fIborder_pixel\fP;	See ``Window Attributes''
	Pixmap \fIborder_pixmap\fP;	See ``Window Attributes''
	Pixel \fIbackground_pixel\fP;	See ``Window Attributes''
	Pixmap \fIbackground_pixmap\fP;	See ``Window Attributes''
	_XtEventTable \fIevent_table\fP;	Private to ``Event Management''
	_XtTranslations \fItranslations\fP;	Private to ``Translation Management''
	Boolean \fIvisible\fP;	See ``Widget Visibility and Exposure''
	Boolean \fIsensitive\fP;	See ``XtSetSensitive''
	Boolean \fIancestor_sensitive\fP;	See ``XtSetSensitive''
	Boolean \fImanaged\fP;	See ``Composite Widgets''
	Boolean \fImapped_when_managed\fP;	See ``Composite Widgets''
	Boolean \fIbeing_destroyed\fP;	See ``Destroying Widgets''
	XtCallbackList \fIdestroy_callbacks\fP;	See ``Destroying Widgets''
} CorePart;
.DE
.LP
All widgets have the core fields as their first component.  The prototypical
type 
.IN "Widget"
.PN Widget
is defined with only this set of fields: various routines
may cast these to specific widget types as needed.
.LP
.DS 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	CorePart \fIcore\fP;
} WidgetRec, *Widget;
.DE
.NH 3
CorePart Default Values
.XS
\*(SN CorePart Default Values
.XE
.LP
The default values for the core fields (filled in by the Core resource list and
the Core initialize procedure) are:
.LP
.TS
l l .
_
.sp 6p
Field	Default Value
.sp 6p
_
.sp 6p
widget_class	widget_class argument to XtCreateWidget
parent	parent argument to XtCreateWidget
name	name argument to XtCreateWidget
screen	parent's screen field (top-level widget from display specifier)
window	NULL
x	0
y	0
width	0
height	0
depth	parent's depth field (top-level widget from root window)
border_width	1
border_pixel	black
border_pixmap	NULL
background_pixel	white
background_pixmap	NULL
visible	TRUE
sensitive	TRUE
ancestor_sensitive	parent's (sensitive & ancestor_sensitive)
managed	FALSE
map_when_managed	TRUE
being_destroyed	parent's being_destroyed
destroy_callbacks	NULL
.sp 6p
_
.TE
.NH 3
CoreClassPart Definitions
.XS
\*(SN CoreClassPart Definitions
.XE
.LP
The common fields for all widget classes are defined in the 
.IN "CoreClassPart"
.PN CoreClassPart 
structure:
.LP
.DS 0
.TA .5i 3i
.ta .5i 3i
typedef void (*\fIWidgetProc\fP)();
        Widget \fIw\fP;

typedef struct {
	WidgetClass \fIsuperclass\fP;	See ``Widget Subclassing''
	String \fIclass_name\fP;	See ``Widget Subclassing''
	Cardinal \fIwidget_size\fP;	See ``Creating Widgets''
	XtProc \fIclass_initialize\fP;	See ``Widget Subclassing''
	Boolean \fIclass_inited\fP;	Private to ``XtCreateWidget''
	XtInitProc \fIinitialize\fP;	See ``Creating Widgets''
	XtRealizeProc \fIrealize\fP;	See ``Creating Widgets''
	XtActionList \fIactions\fP;	See ``Translation Management''
	Cardinal \fInum_actions\fP;	See ``Translation Management''
	XtResourceList \fIresources\fP;	See ``Resource Management''
	Cardinal \fInum_resources\fP;	See ``Resource Management''
	XrmClass \fIxrm_class\fP;	Private to ``Resource Management''
	Boolean \fIcompress_motion\fP;	See ``Mouse Motion Compression''
	Boolean \fIcompress_exposure\fP;	See ``Exposure Compression''
	Boolean \fIvisible_interest\fP;	See ``Widget Visibility and Exposure''
	XtWidgetProc \fIdestroy\fP;	See ``Destroying Widgets''
	XtWidgetProc \fIresize\fP;	See ``Geometry Management''
	XtExposeProc \fIexpose\fP;	See ``Widget Visibility and Exposure''
	XtSetValuesProc \fIset_values\fP;	See ``Reading and Writing Widget State''
	XtWidgetProc \fIaccept_focus\fP;	See ``Focus Management''
} CoreClassPart;
.DE
.LP
All widget classes have the core class fields as their first component.
The prototypical type 
.IN "WidgetClass"
.PN WidgetClass 
is defined with only this set of fields.
That is, various routines may cast these to specific widget class types as needed:
.LP
.DS 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	CoreClassPart \fIcore_class\fP;
} WidgetClassRec, *WidgetClass;
.DE
.LP
The predefined class record and pointer for 
.IN "WidgetClassRec"
.PN WidgetClassRec 
are:
.LP
.DS 0
.TA .5i 3i
.ta .5i 3i
extern WidgetClassRec \fIwidgetClassRec\fP;
.sp 6p
extern WidgetClass \fIwidgetClass\fP;
.DE
.LP
Applications that do not define new widget classes usually do not need to access
the internals of widgets. 
The opaque types 
.IN "Widget"
.PN Widget 
and 
.IN "WidgetClass"
.PN WidgetClass 
and the opaque variable 
.IN "widgetClass"
.PN widgetClass 
are defined for generic actions on widgets.
Applications can use these types for generality or can use the widget-specific
types to make the code indicate external representation.
.NH 2
Composite Widget Definitions
.XS
\*(SN Composite Widget Definitions
.XE
.LP
Composite widgets are a subclass of the Core widget and are more fully
described in ``Composite Widgets''.
.NH 3
CompositePart Definition
.XS
\*(SN CompositePart Definition
.XE
.LP
Composite widgets have the following additional fields defined in the 
.IN "CompositePart"
.PN CompositePart 
structure:
.LP
.DS 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	WidgetList \fIchildren\fP;	See ``Widget Tree''
	Cardinal \fInum_children\fP;	See ``Widget Tree''
	Cardinal \fInum_slots\fP;	See ``Composite Widgets''
	Cardinal \fInum_mapped_children\fP;	See ``Composite Widgets''
	XtOrderProc \fIinsert_position\fP;	See ``Creating Widgets''
} CompositePart;
.DE
.LP
Composite widgets have the composite fields immediately following the core
fields:
.LP
.DS 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	CorePart \fIcore\fP;
	CompositePart \fIcomposite\fP;
} CompositeRec, *CompositeWidget;
.DE
.NH 3
CompositePart Default Values
.XS
\*(SN CompositePart Default Values
.XE
.LP
The default values for the composite fields (filled in by the Composite 
resource list and the Composite initialize procedure are:
.LP
.TS
l l .
_
.sp 6p
Field	Default Value
.sp 6p
_
.sp 6p
children	NULL
num_children	0
num_slots	0
num_mapped_children	0
insert_position	internal function InsertAtEnd 
.sp 6p
_
.TE
.NH 3
CompositeClassPart Definitions
.XS
\*(SN CompositeClassPart Definitions
.XE
.LP
Composite widget classes have the following additional fields:
.LP
.DS 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	XtGeometryHandler \fIgeometry_manager\fP;	See ``Geometry Management''
	XtWidgetProc \fIchange_managed\fP;	See ``Composite Widgets''
	XtArgsProc \fIinsert_child\fP;	See ``Composite Widgets''
	XtWidgetProc \fIdelete_child\fP;	See ``Composite Widgets''
	XtWidgetProc \fImove_focus_to_next\fP;	See ``Focus Management''
	XtWidgetProc \fImove_focus_to_prev\fP;	See ``Focus Management''
} CompositeClassPart;
.DE
.LP
Composite widget classes have the composite fields immediately following the
core fields:
.LP
.DS 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	CoreClassPart \fIcore_class\fP;
	CompositeClassPart \fIcomposite_class\fP;
} CompositeClassRec, *CompositeWidgetClass;
.DE
.LP
The predefined class record and pointer for 
.IN "CompositeClassRec"
.PN CompositeClassRec 
are:
.LP
.DS 0
.TA .5i 3i
.ta .5i 3i
extern compositeClassRec \fIcompositeClassRec\fP;
.sp 6p
extern CompositeWidgetClass \fIcompositeWidgetClass\fP;
.DE
.LP
The opaque types 
.IN "CompositeWidget"
.PN CompositeWidget 
and 
.IN "CompositeWidgetClass"
.PN CompositeWidgetClass
and the opaque variable 
.IN "compositeWidgetClass"
.PN compositeWidgetClass 
are defined for generic operations on widgets that are a subclass of 
.IN "CompositeWidget"
.PN CompositeWidget .
.LP
To determine if a widget \fIw\fP is composite (or a subclass),
use the Boolean function
.PN XtIsComposite .
.FN 0
Boolean XtIsComposite\^(\^\fIw\fP\^)
      Widget \fIw\fP\^;
.FN
.NH 2
Constraint Widget Definitions
.XS
\*(SN Constraint Widget Definitions
.XE
.LP
Constraint widgets are a subclass of the Composite widget, and are more fully
described in ``Constrained Composite Widgets''.
.NH 3
ConstraintPart Definition
.XS
\*(SN ConstraintPart Definition
.XE
.LP
Constraint widgets have the following additional fields defined in the 
.IN "ConstraintPart"
.PN ConstraintPart
structure:
.LP
.DS 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	caddr_t \fImumble\fP;	No new fields, keep C compiler happy
} ConstraintPart;
.DE
.LP
Constraint widgets have the constraint fields immediately following the
composite fields:
.LP
.DS 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	CorePart \fIcore\fP;
	CompositePart \fIcomposite\fP;
	ConstraintPart \fIconstraint\fP;
} ConstraintRec, *ConstraintWidget;
.DE
.NH 3
ConstraintClassPart Definitions
.XS
\*(SN ConstraintClassPart Definitions
.XE
.LP
Constraint widget classes have the following additional fields:
.LP
.DS 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	XtResourceList \fIconstraints\fP;	See ``Constrained Composite Widgets''
	Cardinal \fInum_constraints\fP;	See ``Constrained Composite Widgets''
} ConstraintClassPart;
.DE
.LP
Constraint widget classes have the constraint fields immediately following the
composite fields:
.LP
.DS 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	CoreClassPart \fIcore_class\fP;
	CompositeClassPart \fIcomposite_class\fP;
	ConstraintClassPart \fIconstraint_class\fP;
} ConstraintClassRec, *ConstraintWidgetClass;
.DE
.LP
The predefined class record and pointer for 
.IN "ConstraintClassRec"
.PN ConstraintClassRec 
are:
.LP
.DS 0
.TA .5i 3i
.ta .5i 3i
extern ConstraintClassRec \fIconstraintClassRec\fP;
.sp 6p
extern ConstraintWidgetClass \fIconstraintWidgetClass\fP;
.DE
.LP
The opaque types 
.PN "ConstraintWidget"
.PN ConstraintWidget 
and 
.IN "ConstraintWidgetClass"
.PN ConstraintWidgetClass
and the opaque variable 
.IN "constraintWidgetClass"
.PN constraintWidgetClass 
are defined for generic operations on widgets that are a subclass of
.IN "ConstraintWidgetClass"
.PN ConstraintWidgetClass .
.\" Beta release
.\"
\".NH 2
\"Widget Issues
\".XS
\"\*(SN Widget Issues
\".XE
.\".LP
.\"What other attributes should be in the core data record?  Cursor?  Colormap?
.\"Visual?
.NH 1
Widget Classes
.XS
\*(SN Widget Classes
.XE
.IN "Widget Classes"
.LP
The widget_class field of a widget points to its widget class structure.
The widget class structure contains information that is constant across all
widgets of that class.
.LP
This class-oriented structure means that widget classes do not usually implement
directly callable procedures. 
That is, they implement procedures that are available
through their widget class structure.  These class procedures are invoked by
generic procedures, which envelope common actions around the procedures
implemented by the widget class.  Such procedures are applicable to all widgets
of that class and also to widgets that are subclasses of that class.
.NT
In the alpha release toolkit, each widget class
implemented an Xt<\^\fIWidget\fP\^>Create (for example,
.IN "XtLabelCreate"
.PN XtLabelCreate )
function, in which most of the code was identical from widget to widget.
In this toolkit, a single generic 
.IN "XtCreateWidget"
.PN XtCreateWidget
performs most of the common work and then calls the initialize procedure
implemented for the particular widget class.
.LP
Each composite widget class also implemented the procedures
Xt<\^\fIWidget\fP\^>Add and an Xt<\^\fIWidget\fP\^>Delete (for example,
.IN "XtButtonBoxAddButton"
.PN XtButtonBoxAddButton
and
.IN "XtButtonBoxDeleteButton"
.PN XtButtonBoxDeleteButton ).
In the beta release toolkit, the composite generic procedures
.IN "XtManageChildren"
.PN XtManageChildren
and
.IN "XtUnmanageChildren"
.PN XtUnmanageChildren
perform error-checking and screening out of certain children.
Then, they call the changed_managed procedure
implemented for the widget's composite class.
.LP
Note that the new toolkit can be used to implement old-style calls by defining
one-line procedures or macros that invoke a generic routine.  For example,
you can define the macro
.IN "XtCreateLabel"
.PN XtCreateLabel :
.LP
.DS 0
.TA .5i 3i
.ta .5i 3i
#define XtCreateLabel(\fIname\fP, \fIparent\fP, \fIargs\fP, \fInum_args\fP) \\\\ 
	((LabelWidget) XtCreateWidget(\fIname\fP, \fIlabelWidgetClass\fP,    \\\\
	\fIparent\fP, \fIargs\fP, \fInum_args\fP))
.DE
.NE
.NH 1
Widget Subclassing
.XS
\*(SN Widget Subclassing
.XE
.LP
All widget classes are a subclass of the Core class and may be subclassed
further.  For example, Label is a direct subclass of Core. 
That is, it adds a text field.
Command is a direct subclass of Label. 
In addition to a text field, it has a
callback procedure that can be invoked.  Toggle is a direct subclass of
Command. 
In addition to the text and callback, it has a Boolean state that can
be toggled.
.LP
Subclassing reduces the amount of code and declarations you write to make a
new widget class.  For example, you do not have to include every resource
your widget uses in an 
.IN "XtResourceList"
.PN XtResourceList ,
but you do have to include the resources your widget has
that its superclass does not.  
.LP
In order to make good use of subclassing, widget declarations are highly
stylized.  A widget consists of three parts: 
.IP \(bu 5
A public ``.h'' file that is used by client widgets or applications 
.IP \(bu 5
A private ``.h'' file used by widgets that are subclasses of the widget
.IP \(bu 5
A ``.c'' file that implements the widget class
.\" Beta release
.\"
.\".LP
.\"[[ Should also describe naming conventions. ]]
.NH 2
Widget Subclassing in Public ``.h'' Files
.XS
\*(SN Widget Subclassing in Public ``.h'' Files
.XE
.LP
The public ``.h'' file for a widget class is imported by clients
and contains:
.IP \(bu 5
The atom names (strings) of the new resources that this widget adds
to its superclass
.IP \(bu 5
The class record pointer for the widget
.IP \(bu 5
The C type you use to declare widgets of this class
.LP
For example, here is the public ``.h'' file for the Label widget:
.LP
.DS 0
.TA .5i 1.5i 3i
.ta .5i 1.5i 3i
/* New resources */
#define XtNjustify	"justify"
#define XtNforeground	"foreground"
#define XtNlabel	"label"
#define XtNfont	"font"
#define XtNinternalWidth	"internalWidth"
#define XtNinternalHeight	"internalHeight"
 
/* Class record pointer */
extern WidgetClass labelWidgetClass;

/* C Widget type definition */
typedef struct _LabelRec      *LabelWidget;
.DE
.NH 2
Widget Subclassing in Private ``.h'' Files
.XS
\*(SN Widget Subclassing in Private ``.h'' Files
.XE
.LP
The private ``.h'' file for a widget is imported by widget classes that are 
subclasses of the widget and contains:
.IP \(bu 5
The new fields that the widget instance adds to its superclass's
widget structure.
.IP \(bu 5
The complete widget instance structure for this widget.
.IP \(bu 5
The new fields that this widget class adds to its superclass's widget class
structure.
.IP \(bu 5
The complete widget class structure for this widget.
.IP \(bu 5
A ``constant'' of the generic widget class structure.
.LP
For example, here is the private ``.h'' file for the Label widget:
.LP
.DS 0
.TA .5i 3i
.ta .5i 3i
/* New fields for the Label widget record */
typedef struct {
/* Settable resources */
	Pixel foreground;
	XFontStruct *font;
	String label;
	XtJustify justify;
	Dimension internal_width;
	Dimension internal_height;

/* Data derived from resources */
	GC normal_GC;
	GC gray_GC;
	Pixmap gray_pixmap;
	Position label_x;
	Position label_y;
	Dimension label_width;
	Dimension label_height;
	Cardinal label_len;
	Boolean display_sensitive;
} LabelPart;
.DE
.DS 0
.TA .5i 3i
.ta .5i 3i
/* Full instance record declaration */
typedef struct _LabelRec {
	CorePart core;
	LabelPart label;
} LabelRec;

/* New fields for the Label widget class record */
typedef struct {
	int mumble;	/* No new fields, but keep C compiler happy */
} LabelClassPart;

/* Full class record declaration */
typedef struct _LabelClassRec {
	CoreClassPart core_class;
	LabelClassPart label_class;
} LabelClassRec;

/* Class record variable */
extern LabelClassRec labelClassRec;
.DE
.LP
.NH 2
Widget Subclassing in ``.c'' Files
.XS
\*(SN Widget Subclassing in ``.c'' Files
.XE
.LP
The ``.c'' file for a widget contains the initializer for the class record
variable.  This initializer can be broken up into several parts:
.IP \(bu 5
Class information (superclass, class_name, widget_size, class_initialize, class_inited)
.IP \(bu 5
Data Constants (resources and num_resources, actions and num_actions, visible_interest, 
compress_motion, compress_expose)
.IP \(bu 5
Widget Operations (initialize, realize, destroy, resize,
expose, set_values, accept_focus)
.LP
The superclass field points to the superclass 
.PM WidgetClass
record.  For all direct subclass of the generic core widget this means that
superclass is initialized to the address of the 
.IN "widgetClassRec"
.PN widgetClassRec
structure.
.\" Beta release
.\"
.\"[[ Need shorter names for private files. ]]
.LP
The class_name field contains the text name for this class (that is used by
the resource manager).  For example, the Label widget has the string ``Label''.
The widget_size field is the size of the corresponding Widget
structure, not the size of the Class structure.
All other fields are described in their respective sections.
.LP
Here is a somewhat compressed version of ``.h'' file for the Label widget:
.LP
.DS 0
.TA .5i 1.5 3i
.ta .5i 1.5 3i
/* Resources specific to Label */
#define XtRjustify	"Justify"
static XtResource resources[] = {
	{XtNforeground, XtCForeground, XrmRPixel, sizeof(Pixel),
	   XtOffset(LabelWidget, label.foreground), XrmRString, "Black"},
	{XtNfont,  XtCFont, XrmRFontStruct, sizeof(XFontStruct *),
 	   XtOffset(LabelWidget, label.font),XrmRString, "Fixed"},
	{XtNlabel,  XtCLabel, XrmRString, sizeof(String),
	   XtOffset(LabelWidget, label.label), XrmRString, NULL},
		.
		.
		.
}

/* Forward declarations of procedures */
static void ClassInitialize();
static void Initialize();
static void Realize();
	.
	.
	.
.DE
.DS 0
.TA .5i 1.5 3i
.ta .5i 1.5 3i
/* Class record constant */
LabelClassRec labelClassRec = {
  {
/* core_class fields */	
	/* superclass        */	(WidgetClass) &widgetClassRec,
	/* class_name        */	"Label",
	/* widget_size       */	sizeof(LabelRec),
	/* class_initialize  */	ClassInitialize,
	/* class_inited      */	FALSE,
	/* initialize        */	Initialize,
	/* realize           */	Realize,
	/* actions           */	NULL,
	/* num_actions       */	0,
	/* resources         */	resources,
	/* num_resources     */	XtNumber(resources),
	/* xrm_class         */	NULLQUARK,
	/* compress_motion   */	TRUE,
	/* compress_exposure */	TRUE,
	/* visible_interest  */	FALSE,
	/* destroy           */	NULL,
	/* resize            */	Resize,
	/* expose            */	Redisplay,
	/* set_values        */	SetValues,
	/* accept_focus      */	NULL,
  }
};

/* Class record pointer */
WidgetClass labelWidgetClass = (WidgetClass) &labelClassRec;

/* Private procedures */
	.
	.
	.
.DE
.NH 2
Class Initialization: the class_initialize procedure
.XS
\*(SN Class Initialization: the class_initialize procedure
.XE
.LP
.IN "Class Initialization"
.IN "Initialization"
.IN "class_initialize procedure"
Many class records can be initialized completely at compile time.  But in some
cases a class may want to register type converters, inherit procedures from its
superclass by copying them from its superclass's record, register unique
callback kinds, or perform other sorts of ``one-shot'' initialization.
.LP
Because the C language does not have initialization procedures that are invoked
automatically when a program starts up, a widget class can declare a
class_initialize procedure that will be called exactly once automatically
by the toolkit.  A class initialization procedure takes no
parameters and returns no result:
.LP
.IN "XtProc"
.DS 0
.TA .5i 3i
.ta .5i 3i
typedef void (*XtProc)();
.DE
.LP
All widget classes, whether they have a class initialization procedure or not,
should start off with their class_inited field FALSE.
.LP
The first time a widget of that class is created, 
.IN "XtCreateWidget"
.PN XtCreateWidget
ensures that the widget class (and all superclasses) are initialized (in
superclass to subclass order) by checking each class_inited field and
calling the class_initialization procedure if it is FALSE. 
The class_inited field is then set to TRUE.  
After the one-time initialization, a class structure is constant.
.LP
Here is the class initialization procedure for ButtonBox, a subclass of
Composite.  ButtonBox inherits its superclass's insert_child and
delete_child routines. 
That is, it uses whatever routines Composite has defined for these fields:
.LP
.DS 0
.TA .5i 3i
.ta .5i 3i
static void ClassInitialize()
{
	CompositeWidgetClass superclass;
	ButtonBoxWidgetClass myclass;

	myclass = (ButtonBoxWidgetClass) buttonBoxWidgetClass;
	superclass = (CompositeWidgetClass) myclass->core_class.superclass;

/* Inherit insert_child and delete_child from Composite */
	myclass->composite_class.insert_child =
	   superclass->composite_class.insert_child;
	myclass->composite_class.delete_child =
	   superclass->composite_class.delete_child;
}
.DE
.NH 2
XtClass
.XS
\*(SN XtClass
.XE
.FD 0
WidgetClass XtClass(\fIw\fP)
.br
      Widget \fIw\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.LP
.IN "XtClass"
.PN XtClass 
returns a pointer to the widget class structure.  It is simply an abbreviation
for:
.DS 0
.TA .5i 3i
.ta .5i 3i
	\fIw\fP->\fIcore\fP.\fIwidget_class\fP
.DE
.NH 2
XtSuperclass
.XS
\*(SN XtSuperclass
.XE
.FD 0
WidgetClass XtSuperclass(\fIw\fP)
.br
      Widget \fIw\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.LP
.IN "XtSuperclass"
.PN XtSuperclass 
returns a pointer to the widget's superclass class structure.
It is simply an abbreviation for:
.DS 0
.TA .5i 3i
.ta .5i 3i
	\fIw\fP->\fIcore\fP.\fIwidget_class\fP->\fIcore_class\fP.\fIsuperclass\fP
.DE
.NH 2
XtIsSubclass
.XS
\*(SN XtIsSubclass
.XE
.FD 0
Boolean XtIsSubclass(\fIw\fP, \fIwidget_class\fP)
.br
      Widget \fIw\fP;
.br
      WidgetClass \fIwidget_class\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget under question.
.IP \fIwidget_class\fP 1i
Specifies the widget class to test against.
.LP
.IN "XtIsSubclass"
.PN XtIsSubclass 
returns TRUE if the specified w has a class, which is equal to or is a
subclass of widget_class.  Composite widgets that wish to restrict
the class of the items they contain can use 
.IN "XtIsSubclass"
.PN XtIsSubclass 
to find out if a widget belongs to the desired class of objects.
.LP
Note that the Boolean function
.IN "XtIsComposite"
.PN XtIsComposite
is simply an abbreviation for
.PN XtIsSubclass .
.FD 0
XtIsSubclass(\fIw\fP,\|\fIcompositeWidgetClass\fP)
.FN
.NH 2
XtCheckSubclass
.XS
\*(SN XtCheckSubclass
.XE
.FD 0
void XtCheckSubclass(\fIw\fP, \fIwidget_class\fP)
.br
      Widget \fIw\fP;
.br
      WidgetClass \fIwidget_class\fP;
.FN
.IP \fIparent\fP 1i
Specifies the widget under question.
.IP \fIwidget_class\fP 1i
Specifies the widget class to test against.
.LP
.IN "XtCheckSubclass"
.PN XtCheckSubclass 
determines if the specified w has a class that is equal to or is a subclass of
widget_class.  If not,
.PN XtCheckSubclass
issues an error and aborts the program.  It should be used at the entry-point
of routines that can be called by clients in order to determine that the client
has passed in a valid widget class for the exported operation.
.LP
.PN XtCheckSubclass
is only executed when including and linking against the debugging version of
the intrinsics.  Otherwise, it is defined as the empty string and so generates
no code.
.NT
This routine currently is not yet implemented.
.NE
.NH 2
Superclass Chaining
.XS
\*(SN Superclass Chaining
.XE
.LP
.IN "Chaining"
.IN "Superclass Chaining"
.IN "Inheritance"
Some fields defined in the widget class structure are self-contained and are
independent of the values for these fields defined in superclasses.  These are:
.IP \(bu 5
class_name
.IP \(bu 5
widget_size
.IP \(bu 5
realize
.IP \(bu 5
actions
.IP \(bu 5
visible_interest
.IP \(bu 5
resize
.IP \(bu 5
expose
.IP \(bu 5
accept_focus
.LP
Some fields defined in the widget class structure make sense only after their
superclass has been operated on.  In this case, invocation of a single
operation actually first accesses the Core class, then the subclass, and on down
the class chain to the widget class of the widget.  These
superclass-to-subclass fields are:  
.IP \(bu 5
initialize
.IP \(bu 5
set_values
.IP \(bu 5
resources 
(For subclasses of Constraint, 
the constraints field is chained from the Constraint class down to the subclass.)
.LP
Some fields defined in the widget class structure make sense only after their
subclass has been operated on.  In this case, the invocation of a single
operation actually first accesses the widget class, then its superclass, and on
up the class chain to the Core class.  The only subclass-to-superclass
field is ``destroy''.
.NH 2
Inheriting Superclass Operations
.XS
\*(SN Inheriting Superclass Operations
.XE
.LP
A widget class is free to use any of its superclass's self-contained operations
rather than implementing its own code.  The most frequently inherited
operations are:
.IP \(bu 5
expose
.IP \(bu 5
realize
.IP \(bu 5
insert_child
.IP \(bu 5
delete_child
.LP
To inherit an operation, 
you simply write code in the class_initialize procedure to copy the
superclass's procedure into the subclass structure.
See the example above in ``Class Initialization''.
.\" Beta release
.\"
.\".NH 3
.\"Inheriting Superclass Operations Issues
.\".XS
.\"\*(SN Inheriting Superclass Operations Issues
.\".XE
.\".LP
.\"It is a bother to declare a class_initialize procedure simply to inherit
.\"operations from your superclass.  We could define the
.\"routines
.\".PN XtInheritExpose , 
.\".PN XtInheritRealize , 
.\".PN XtInheritInsertChild ,
.\"and
.\".PN XtInheritDeleteChild , 
.\"which call the superclass's corresponding procedure 
.\"and then assign the superclass's procedure into the subclass.
.NH 2
Calling Superclass Operations
.XS
\*(SN Calling Superclass Operations
.XE
.LP
.LP
A widget class sometimes wants to explicitly call a superclass operation that
is not normally chained.  For example, a widget's expose procedure might
call its superclass's expose and then perform a little more work of its own.
Composite classes with fixed children (for example, Scrollbar and the top-level widget)
implement insert_child by first calling their superclass's insert_child procedure 
.IN "insert_child procedure"
and then calling
.IN "XtManageChild"
.PN XtManageChild
to add the child to the managed list.
.LP
Here is the code for the top-level widget's \fIinsert_child\fP:
.LP
.DS 0
.TA .5i 3i
.ta .5i 3i
static void InsertChild(w)
    Widget w;
{
	((CompositeWidgetClass) XtSuperclass(w))->composite_class.insert_child(w);
	XtManageChild(w);	/* Add to managed set now */
}
.DE
.NH 1
The Widget Tree
.XS
\*(SN The Widget Tree
.XE
.LP
Widgets are either ``primitive'' or ``composite''.  
A primitive widget has no children widgets and can never have them. 
A composite widget may in unusual circumstances have zero children 
but usually has at least one.  
Primitive widgets are leaves of the widget tree. 
Composite widgets are intermediate nodes with children 
and the top-level widget returned by
.IN "XtInitialize"
.PN XtInitialize
is the root of the widget tree.
.LP
Except for pop-up widget windows (which are children of the root window so
that they are not clipped), the widget tree exactly duplicates the associated
window tree.
.LP
The widget tree is manipulated by several toolkit functions.  For
example, 
.IN "XtRealizeWidget"
.PN XtRealizeWidget 
traverses the tree downward to recursively realize widgets. 
.IN "XtDestroyWidget"
.PN XtDestroyWidget 
traverses the tree downward to destroy all children. 
The internal routine
.IN "_XtGetResources"
.PN _XtGetResources 
traverses the tree upward to determine the inheritance of resources from a
widget's ancestors.
.IN "XtMakeGeometryRequest"
.PN XtMakeGeometryRequest 
traverses the tree one level upward to get
the geometry manager responsible for the widget's geometry.
.LP
To facilitate up-traversal of the widget tree, each widget has a pointer to its
parent widget.  (The top-level widget returned by 
.IN "XtInitialize"
.PN XtInitialize 
has a parent pointer of NULL.)
.LP
To facilitate down-traversal of the widget tree, each composite widget has a
pointer to an array of children widgets.  This array includes all children
created, not just the subset of children that are managed by the composite 
widget's geometry manager.
.\" Beta release
.\"
.\".NH 2
.\"Widget Tree Issues
.\".XS
.\"\*(SN Widget Tree Issues
.\".XE
.\".LP
.\"This section ignores the breaking of ``window tree = widget tree'' for
.\"pop-ups (menus, dialog boxes) until that gets worked out in more detail.
.NH 1
Window Attributes
.XS
\*(SN Window Attributes
.XE
.LP
The Core widget definition contains screen and window. 
Therefore, widgets and intrinsics do not have to pass them.
The window field may be NULL 
for a while (see ``Creating Widgets'' and ``XtRealizeWidget'').
.LP
The display pointer, screen pointer, and window of a widget are returned by 
the following macros:
.IN "Macros" "XtDisplay"
.IN "XtDisplay"
.FD 0
Display *XtDisplay(\fIw\fP)
.br
      Widget \fIw\fP;
.FN
.IN "Macros" "XtScreen"
.IN "XtScreen"
.FD 0
Screen *XtScreen(\fIw\fP)
.br
      Widget \fIw\fP;
.FN
.IN "Macros" "XtWindow"
.IN "XtWindow"
.FD 0
Window XtWindow(\fIw\fP)
.br
      Widget \fIw\fP;
.FN
They all take a widget and return the specified value.
.LP
Several window attributes are locally cached in the widget, so they can be
set by the resource manager and by 
.IN "XtSetValues"
.PN XtSetValues ,
and can be used by routines that
derive structures from these values (for example, depth for deriving pixmaps,
background_pixel for deriving GCs, and so on), as well as used in the
.IN "XtCreateWindow"
.PN XtCreateWindow 
call.
.\" Beta release
.\"
.\".LP
.\"[[ Discuss pixmaps vs pixels.  When will Xlib (if ever) have a file-to-pixmap
.\"converter? Do we need to write such? ]]
.LP
The x, y, width, height, and border_width window attributes are available to 
geometry managers.  
These fields are maintained synchronously inside the toolkit.
When an 
.IN "XConfigureWindow"
.PN XConfigureWindow 
is issued on the widget's window, these values are updated immediately
rather than sometime later when the server 
gets around to generating a 
.IN "ConfigureNotify"
.PN ConfigureNotify 
event.  (In fact, most widgets do not have 
.IN "SubstructureNotify"
.PN SubstructureNotify 
turned on.)  This ensures that all
geometry calculations are based on the internally consistent toolkit
world, rather than on either of the following:
.IP \(bu 5
An inconsistent world updated by asynchronous
.IN "ConfigureNotify"
.PN ConfigureNotify 
events
.IP \(bu 5
A consistent but slow world in which geometry
managers ask the server for window sizes whenever they need to layout their
managed children
See ``Geometry Management'' for further information.
.NH 1
Creating Widgets
.XS
\*(SN Creating Widgets
.XE
.LP
The creation of widget instances is a two-phase process: 
.IP 1. 5
The widgets are allocated and initialized with resources and are optionally added to
the managed subset of their parent, with whom they negotiate geometry. 
.IP 2. 5
The widgets create X windows and get mapped.
.LP
To start the first phase, the application calls 
.IN "XtCreateWidget"
.PN XtCreateWidget 
on all its widgets and adds some (usually, most or all) of its widgets to their
respective parents' managed set.  Adding a child to its parent's managed set 
involves geometry negotiation. 
That is, the parent may force some of
the child's siblings to change size and position, and the parent may issue
geometry requests to its own parent in order to better accommodate all its
children.  You do not really know where anything should go on the screen
until all widgets have been created and are managed by their respective parents.
Consequently, in the first phase, no X windows are actually created because chances
are they would just get moved around after creation, which is slow.
.LP
After all widgets have been created, the application calls 
.IN "XtRealizeWidget"
.PN XtRealizeWidget 
on the top-level widget to start the second phase.  
.IN "XtRealizeWidget"
.PN XtRealizeWidget
recursively traverses the widget tree, allocates an X window to each widget,
and maps the widgets.
.NH 2
XtCreateWidget
.XS
\*(SN XtCreateWidget
.XE
.FD 0
Widget XtCreateWidget(\fIname\fP, \fIwidget_class\fP, \fIparent\fP, \fIargs\fP, \fInum_args\fP)
.br
      String \fIname\fP;
.br
      WidgetClass \fIwidget_class\fP;
.br
      Widget \fIparent\fP;
.br
      ArgList \fIargs\fP;
.br
      Cardinal \fInum_args\fP;
.FN
.IP \fIname\fP 1i
Specifies the text name for the created widget.
.IP \fIwidget_class\fP 1i
Specifies the widget class pointer for the created widget.
.IP \fIparent\fP 1i
Specifies the parent widget.
.IP \fIargs\fP 1i
Specifies the argument list to override the resource defaults.
.IP \fInum_args\fP 1i
Specifies the number of arguments in args.
.LP
.PN XtCreateWidget 
.IN "XtCreateWidget"
performs much of the ``boiler-plate'' operations of widget creation.  It
.IP \(bu 5
Checks that the parent is a subclass of 
.PN compositeWidgetClass
.IP \(bu 5
Allocates memory for the widget instance
.IP \(bu 5
Initializes the core non-resource data fields (for example, parent and visible)
.IP \(bu 5
Initializes the resource fields (for example, background_pixel) by using the
resource lists specified for this class and all superclasses
.IP \(bu 5
Calls the initialize procedures for the widget, starting at the Core
initialize procedure on down to the widget's initialize procedure.
.IP \(bu 5
Puts the widget into its parent's children list by calling its parent's
insert_child procedure 
.LP
(See ``Adding New Children: the insert_child procedure''.
.NH 3
Widget Initialization: the initialize procedure
.XS
\*(SN Widget Initialization: the initialize procedure
.XE
.IN "Initialization"
.IN "XtInitProc"
.IN "initialize procedure"
.IN "Chaining"
.IN "Superclass Chaining"
.IN "Inheritance"
.LP
typedef void (*\fIXtInitProc\fP) ();
.br
      Widget \fIrequest\fP;
.br
      Widget \fInew\fP;
.br
      ArgList \fIargs\fP;
.br
      Cardinal \fInum_args\fP;
.LP
The main job of an initialization procedure is to fill in fields in the 
new widget record.  These are generally nonresource fields (for example,
GCs that the widget uses) or resource fields left unspecified (for 
example, if width and height are zero (0), the widget fills in 
width and height with appropriate values based on other resources).
.LP
Initialization procedures are called in ``superclass-to-subclass order''.  Most
of the initialization code for a specific widget class deals with fields
defined in that class and not with fields defined in its superclasses.
.LP
However, sometimes a subclass may want to overwrite values filled in by its
superclass.  In particular, size calculations of a superclass are often incorrect
for a subclass.  In this case the subclass must modify or recalculate fields 
declared and computed by its superclass.  
For example, a subclass may visually surround its superclass
display. 
In this case, the width and height calculated by the
superclass initialize procedure are too small and need to be incremented
by the size of the surround.
.LP
The subclass needs to know if its superclass's size was calculated by the
superclass or was specified explicitly.  A typical widget should place itself
into whatever size is specified (if any), but it computes a reasonable
size for itself if no size is requested.  How does a subclass know the
difference between a specified size, and a size computed by a superclass?
.LP
The request and new parameters provide the necessary information.
The request widget is the widget as originally requested.  The ``new''
widget starts with the values in the request and is updated by all superclasses so far.
A subclass initialize procedure may compare these two to resolve any potential
conflicts.  In the above example, the subclass with the visual surround can see
if the width and height in the request widget are zero.  If this is
so, it just adds its surround size to the width and height fields
in the new widget.  If this is not so, it must make do with the size originally
specified.
The ``new'' widget will become the instance record. 
Therefore, any callback lists or similar elements that the initialization
procedure registers should specify ``new'' as the widget instance.
.LP
The arguments specified by args and num_args in the
.IN "XtCreateWidget"
.PN XtCreateWidget
call are passed in to the initialize procedure.  These are are ignored by
most widgets. 
However, these are used by a few widgets that have subparts that are not 
widgets but, nonetheless, have resources that must be filled in. 
See ``XtGetSubresources'' for further information.
.NH 2
XtRealizeWidget
.XS
\*(SN XtRealizeWidget
.XE
.FD 0
void XtRealizeWidget(\fIw\fP)
.br
      Widget \fIw\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.LP
If the widget is already realized, 
.IN "XtRealizeWidget"
.PN XtRealizeWidget 
simply returns.
.LP
Otherwise,
.PN XtRealizeWidget 
constructs an 
.IN "XSetWindowAttributes"
.PN XSetWindowAttributes
structure filled in with information derived from the Core widget fields and
calls the realize procedure for the widget, which adds any widget-specific
attributes and creates the X window.
If the widget is a primitive widget, nothing else need be done, and 
.PN XtRealizeWidget 
returns.
Otherwise 
.PN XtRealizeWidget 
recursively calls itself on each of the widget's managed children.
Finally, 
.PN XtRealizeWidget 
maps all of the managed children windows that have mapped_when_managed TRUE.  
If num_children equals num_mapped_children,
it calls 
.IN "XMapSubwindows"
.PN XMapSubwindows 
to map all the children at once. 
Otherwise, it maps each child individually.
If the widget is the special top-level widget (that is, its parent is NULL), 
.PN XtRealizeWidget 
maps the widget window.
.LP
.IN "XtCreateWidget"
.PN XtCreateWidget , 
.IN "XtRealizeWidget"
.PN XtRealizeWidget , 
.IN "XtAdd/RemoveChildren"
.PN XtAdd/RemoveChildren , 
and
.IN "XtDestroyWidget"
.PN XtDestroyWidget 
maintain the following invariants:
.IP \(bu 5
If w is realized, then all managed children of w are realized.
.IP \(bu 5
If w is realized, then all managed children of w that are also
mapped_when_managed are mapped.
.LP
All intrinsic routines and all widget routines should work with either realized
or unrealized widgets.
.\" Beta release
.\"
.\".NH 2
.\"XtRealizeWidget Issues
.\".LP
.\"You usually use 
.\".PN XtRealizeWidget 
.\"on the special top-level widget after all widgets have been created and added 
.\"to the managed set of their respective parents.  While this
.\"means that every window is created in exactly the right position with
.\"exactly the right size, it also means that the application ships off
.\"billions and billions of 
.\".PN XCreateWindow 
.\"calls to the server and then waits
.\"for them to finish before the applications pops up onto the screen.
.\"This does not make good use of the parallelism offered by a server running on a
.\"different machine from the application.
.\".LP
.\"There are times when an application is pretty sure that a whole subtree
.\"of widgets will not move with respect to their parent and, consequently, would like to
.\"start the process of creating windows before the complete widget tree
.\"has been formed.  
.\".PN XtRealizeWidget 
.\"is defined such that realizing subtrees works just fine.
.\".LP
.\"Should there be another field in the core Widget record (or just in composite
.\"widgets) like realize_immediately, which is a fetched resource?  Who uses
.\"this to call 
.\".PN XtRealizeWidget ,
.\"and when?  Can the
.\"toolkit find out if the application is on the same machine as the server, and
.\"thus properly ignore such a resource?  Or do applications just hardwire this
.\"in, which means some people may get screen flash: 
.\"while most people have data such
.\"that an early realize makes sense (say, a small enough number of folders and a
.\"large xmh window), sometimes it might not (a large number of folders and a small
.\"xmh window).
.\".LP
.\"This issues will be resolved when we have xmh running on the new toolkit, and
.\"can do some performance measurements.  If xmh idles while the windows are being
.\"created by the server, we'll do something about it.  If not, we'll just remove
.\"this section of the document.
.NH 2
Window Creation: the realize procedure
.XS
\*(SN Window Creation: the realize procedure
.XE
.IN "XtRealizeProc"
.FD 0
typedef void (*\fIXtRealizeProc\fP)();
.br
      Widget \fIw\fP;
.br
      XtValueMask \fIvalue_mask\fP;
.br
      XSetWindowAttributes *\fIattributes\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.IP \fIvalue_mask\fP 1i
Specifies which fields in attributes to use.
.IP \fIattributes\fP 1i
Specifies the window attributes to use in the XCreateWindows call.
.LP
The realize procedure must make the window a reality.
.LP
The generic procedure
.IN "XtRealizeWidget"
.PN XtRealizeWidget 
fills in a mask and a corresponding 
.IN "XSetWindowAttributes"
.PN XSetWindowAttributes 
structure.  It
sets the following fields based on information in the widget 
.IN "Core"
.PN Core 
structure:
.IP \(bu 5
background_pixmap (or background_pixel if background_pixmap is NULL) 
is filled in from the corresponding field.
.IP \(bu 5
border_pixmap (or border_pixel if border_pixmap is NULL)
is filled in from the corresponding field.
.IP \(bu 5
event_mask is filled in based on the event handlers registered,
the event translations specified, whether expose is non-NULL, 
and whether visible_interest is TRUE.
.IP \(bu 5
do_not_propagate_mask is set to propagate all mouse and keyboard events
up the window tree.  A composite widget can implement functionality caused by
event anywhere inside it (including on top of children widgets) as long as
children do not specify a translation for the event.
.LP
All other fields in attributes (and the corresponding bits in
value_mask) can be set by the realize procedure.
.LP
.IN "Inheritance"
A widget class can inherit its realize procedure from its superclass.
The realize procedure defined for 
.IN "Core"
.PN Core 
simply calls
.IN "XtCreateWindows"
.PN XtCreateWindows
with the passed value_mask and attributes, as well as with 
windowClass and visual set to 
.PN CopyFromParent .
Both 
.IN "CompositeWidgetClass"
.PN CompositeWidgetClass 
and 
.IN "ContraintWidgetClass"
.PN ContraintWidgetClass 
inherit this realize procedure, and most new widget subclasses can do the same.  
See ``Inheriting Superclass Operations'' for further information.
.LP
The most common noninherited realize procedures set bit_gravity 
to the appropriate value and then create the window.  For example, Label sets
bit_gravity to WestGravity, CenterGravity, or EastGravity.
Consequently, shrinking a Label just moves the bits appropriately, 
and no Expose event is needed for repainting.
\" Beta release
.\"
.\".LP
.\"[[ Strong suspicions that window class and visual id need to be in the core
.\"widget, rather than always copied from parent.  But then how do we convert 
.\"colors, which need the colormap? ]]
.NH 3
XtCreateWindow
.XS
\*(SN XtCreateWindow
.XE
.LP
Rather than call the 
.IN "XCreateWindow"
.PN XCreateWindow
.IN "realize procedure"
X function directly, a realize procedure should call the toolkit analog
.IN "XtCreateWindow"
.PN XtCreateWindow .
This routine simplifies the creation of windows for widgets.
The definition for this function is:
.FD 0
void XtCreateWindow(\fIw\fP, \fIwindow_class\fP, \fIvisual\fP, \fIvalue_mask\fP, \fIattributes\fP)
.br
      Widget \fIw\fP;
.br
      unsigned int \fIwindow_class\fP;
.br
      Visual *\fIvisual\fP;
.br
      XtValueMask \fIvalue_mask\fP;
.br
      XSetWindowAttributes *\fIattributes\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget used to set x, y, and so on
.IP \fIwindow_class\fP 1i
Specifies the Xlib window class (for example, InputOutput, InputOnly, 
or CopyFromParent ).
.IP \fIvisual\fP 1i
Specifies the visual type.
.IP \fIvalue_mask\fP 1i
Specifies which fields in attributes to use.
.IP \fIattributes\fP 1i
Specifies the window attributes to use in the
.PN XCreateWindows
call.
.LP
.PN XtCreateWindow
calls 
.PN XCreateWindow
with values from the widget structure and the passed parameters, as well as assigns
the created window into the widget's window field.
.\" Beta release
.\"
.\".NH 3
.\"Window Creation Issues
.\".XS
.\"\*(SN Window Creation Issues
.\".XE
.\".LP
.\"Because not all window attibutes are stored in the Widget record, each widget
.\"class has its own realize procedure.  If more attributes were in the
.\"record, the realize procedure would not be needed.  However, that takes a
.\"lot more fields, and we suspect that many widgets do not need all that
.\"information. 
.\"Consequently, the space would be wasted.
.\".LP
.\"Probably cursor should be in the list of filled-in fields.
.\".LP
.\"Pop-up window creation will probably fill in a few more fields, like
.\"save_under and override_redirect.
.NH 2
XtIsRealized
.XS
\*(SN XtIsRealized
.XE
.LP
The definition for this function is:
.FD 0
Boolean XtIsRealized(\fIw\fP)
.br
      Widget \fIw\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.LP
.IN "XtIsRealized"
.PN XtIsRealized 
returns TRUE if the widget has been realized. 
That is, if it has a valid X window.
.\" Beta release
.\"
.\".NH 3
.\"XtIsRealized Issues
.\".XS
.\"\*(SN XtIsRealized Issues
.\".XE
.\".LP
.\"Right now the window field is non-NULL 
.\"for realized widgets, but such behavior is not guaranteed forever.
.NH 1
Destroying Widgets
.XS
\*(SN Destroying Widgets
.XE
.LP
Destroying widgets is simple.  The toolkit provides support to:
.IP \(bu 5
Destroy all the children of the widget being destroyed
.IP \(bu 5
Remove (and unmap) the widget from its parent
.IP \(bu 5
Call procedures that have been registered to trigger when the widget
is destroyed
.IP \(bu 5
Minimize the number of things a widget has to deallocate when destroyed
.IP \(bu 5
Minimize the number of XDestroyWindow calls
.NH 2
Adding and Deleting Destroy Callbacks
.XS
\*(SN Adding and Deleting Destroy Callbacks
.XE
.LP
The destroy callback uses the mechanism described in ``Callbacks''. 
.IN "Destroy Callbacks"
The callback list is identified by XtCallbackKind destroyCallback.
To add a destroy callback procedure ClientDestroy with closure \fIclosure\fP
to Widget w, call
.IN "XtAddCallback"
.PN XtAddCallback .
To remove the callback, call
.IN "XtRemoveCallback"
.PN XtRemoveCallback .
Both take the following parameter list:
.LP
.DS 0
(\fIw\fP, \fIdestroyCallback\fP, \fIClientDestroy\fP, \fIclosure\fP)
.DE
.NH 2
XtDestroyWidget
.XS
\*(SN XtDestroyWidget
.XE
.LP
To destroy a widget instance, use 
.IN "XtDestroyWidget"
.PN XtDestroyWidget .
The definition for this function is:
.FD 0
void XtDestroyWidget(\fIw\fP)
.br
      Widget \fIw\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.LP
This routine is the only method of destroying a widget, including widgets that
wish to destroy themselves. It may be called at any time, including from an
application callback routine of the widget being destroyed.  This requires a
two-phase destroy process.
In phase one,
.PN XtDestroyWidget
performs the following actions:
.IP \(bu 5
If being_destroyed is TRUE, 
.PN XtDestroyWidget
returns immediately.
.IP \(bu 5
Removes the widget from its parent's managed set, which in turn causes the 
widget to be unmapped.
.IP \(bu 5
Sets the being_destroyed field to TRUE 
and the visible bit to FALSE for the widget and all descendants.
.IP \(bu 5
Adds the widget to a list of widgets (the destroy list) that should be
destroyed when it is safe to do so.
.LP
Entries on the destroy list satisfy the invariant:
.IP \(bu 5
If w1 occurs before w2 on the destroy list, then there is no
ancestor/child relationship between the two, or w1 is a descendant of w2.
.LP
Phase two occurs when all procedures that should execute as a result of
the current event have been called (including all procedures registered with 
the Event and Translation Managers). That is, phase two occurs when 
.IN "XtNextEvent"
.PN XtNextEvent
is called. 
.LP
In phase two,
.IN "XtDestroyWidget"
.PN XtDestroyWidget
destroy performs the following actions on each entry in the destroy list:
.IP \(bu 5
Calls the destroy callbacks registered on the widget (and all descendants) 
in post-order. 
That is, it calls children callbacks before parent callbacks.  
.IP \(bu 5
Calls the widget's parent's delete_child procedure.  
(See ``Deleting Children: the delete_child procedure''.)
.IP \(bu 5
Calls the destroy procedures for the widget (and all descendants) 
in post-order.  For each such widget, it calls the destroy
procedure for the widget,  then calls the destroy procedure for its superclass,
until finally it calls the 
.IN "Core"
.PN Core 
destroy routine.
.IP \(bu 5
Calls 
.IN "XDestroyWindow"
.PN XDestroyWindow 
if the widget is realized (that is, has an X window) 
Otherwise, recursively descends the tree and calls 
.PN XDestroyWindow 
on the top widget of each realized subtree.  The server recursively destroys all
descendant windows.
.NH 2
Deallocating Dynamic Data: the destroy procedure
.XS
\*(SN Deallocating Dynamic Data: the destroy procedure
.XE
.LP
The destroy procedures are called in subclass-to-superclass order. 
Therefore, a widget's destroy procedure should only deallocate storage
that is specific to the subclass and should not bother with the storage
allocated by any of its superclasses.  If a widget does not need to deallocate
any storage, the destroy procedure entry in its WidgetClass should be NULL.
.LP
Deallocating storage includes, but is not limited to:
.IP \(bu 5
Calling 
.IN "XtFree"
.PN XtFree 
on dynamic storage allocated with
.IN "XtMalloc"
.PN XtMalloc ,
.IN "XtCalloc"
.PN XtCalloc ,
and so on.
.IP \(bu 5
Calling 
.IN "XtRemoveAllCallbacks"
.PN XtRemoveAllCallbacks
on callback lists.
.IP \(bu 5
Calling 
.IN "XtDestroyPixmap"
.PN XtDestroyPixmap
on pixmaps allocated with 
.IN "XtGetPixmap"
.PN XtGetPixmap .
.\" Beta release
.\"
.\"[[ yet to be defined or implemented ]]
.IP \(bu 5
Calling
.IN "XFreePixmap"
.PN XFreePixmap
on pixmaps created with direct X calls.
.IP \(bu 5
Calling 
.IN "XtDestroyGC"
.PN XtDestroyGC
on GCs allocated with 
.IN "XtGetGC"
.PN XtGetGC .
.IP \(bu 5
Calling
.IN "XFreeGC"
.PN XFreeGC
on GCs allocated with direct X calls.
.IP \(bu 5
Calling
.IN "XtRemoveEventHandler"
.PN XtRemoveEventHandler
on event handlers added with
.IN "XtAddEventHandler"
.PN XtAddEventHandler .
.IP \(bu 5
Calling
.IN "XtRemoveTimeOut"
.PN XtRemoveTimeOut
on timers created with
.IN "XtAddTimeOut"
.PN XtAddTimeOut .
.\" Beta release
.\"
.\".NH 2
.\"XtDestroyWidget Issues
.\".XS
.\"\*(SN XtDestroyWidget Issues
.\".XE
.\".LP
.\"The above describes a world in which destroying a widget causes it to be
.\"unmapped immediately, which means any further actions performed on that widget
.\"or its children are never seen.
.\".LP
.\"However, an equally consistent world can be set up such that the unmapping
.\"takes place only in phase 2 and, thus, shows screen updates between the 
.\".PN XtDestroyWidget 
.\"call and the start of phase 2.  There are phrases in the Style Guide that
.\"suggest such behavior.  ``One man's screen flash is another's user
.\"interface.''  The Style Guide should get more explicit on this topic.
.NH 1
Callbacks
.XS
\*(SN Callbacks
.XE
.LP
.IN "Destroy Callbacks"
Applications and other widgets (clients) often want to register a procedure
with a widget that gets called under certain conditions.  For example, when
a widget is destroyed every procedure on the widget's destroy_callbacks
list is called to notify clients of the widget's impending doom.
.LP
Every widget has a destroy_callbacks list.  Widgets may define additional
callback lists as they see fit.  For example the Command widget has a callback
list to notify clients when the button has been activated.
.NH 2
Callback Procedure and CallbackList Definitions
.XS
\*(SN Callback Procedure and CallbackList Definitions
.XE
.IN "XtCallbackList"
.IN "XtCallbackProc"
.FD 0
typedef Opaque XtCallbackList; /* List of Callback procedures */
.sp 6p
typedef void (*\fIXtCallbackProc\fP)();
.br
      Widget \fIw\fP;
.br
      caddr_t \fIclosure\fP;
.br
      caddr_t \fIcall_data\fP;
.FN
.IP \fIw\fP 1i
Specifies widget for which the callback is registered.
.IP \fIclosure\fP 1i
Specifies the client data that the widget should pass back to the client when
the widget executes the client's callback procedure.  This is a way for the
client registering the callback to also register client-specific data:
a pointer to additional information about the widget, a reason for invoking
the callback, and so on.  It is perfectly normal to have a closure of NULL 
if all necessary information is in the widget.
.IP \fIcall_data\fP 1i
Specifies any callback-specific data the widget wants to pass to the client.
For example,  when Scrollbar executes its thumbChanged callback list, it
passes the address of a struct containing the position and height of the thumb.
.NH 2
Registering CallbackKinds
.XS
\*(SN Registering CallbackKinds
.XE
.LP
Whenever a widget contains a callback list for use by clients, it also exports 
in its public ``.h'' file a name of type 
.IN "XtCallbackKind"
.PN XtCallbackKind 
to identify the callback list.  These names are registered by the class_initialize
procedure, which calls
.IN "XtNewCallbackKind"
.PN XtNewCallbackKind
to get a unique identifier of the callback.  The definitions for 
.IN "XtCallbackKind"
.PN XtCallbackKind
and this function are:
.FD 0
typedef Opaque XtCallbackKind;
.sp 6p
XtCallbackKind XtNewCallbackKind(\fIwidget_class\fP, \fIoffset\fP)
.br
      WidgetClass \fIwidget_class\fP;
.br
      Cardinal \fIoffset\fP;
.FN
.IP \fIwidget_class\fP 1i
Specifies the widget class which exports the callback list.
.IP \fIoffset\fP 1i
Specifies the offset of the callback list in the widget structure.  
(See ``XtOffset'' for further information.)
.LP
Clients and widgets never access widget callback fields directly.
Instead, they always identify the desired callback list using the exported
XtCallbackKind variable.  All callback manipulation routines described below
check that the requested callback list is indeed implemented by the widget.
.LP
Because callback kinds are registered by the class_initialize
procedure, clients should not expect the exported callback identifiers to be
valid before creating a widget of that class.
.NH 2
XtAddCallback
.XS
\*(SN XtAddCallback
.XE
.LP
To add a callback procedure to 
.\" Beta release 
.\"
.\"  [[ the end of? ]] 
a callback list, use
.IN "XtAddCallback"
.PN XtAddCallback .
The definition for this function is:
.FD 0
void XtAddCallback(\fIw\fP, \fIcallback_kind, \fP\fIcallback\fP, \fIclosure\fP)
.br
      Widget \fIw\fP;
.br
      XtCallbackKind \fIcallback_kind\fP;
.br
      XtCallbackProc \fIcallback\fP;
.br
      caddr_t \fIclosure\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget to add the callback to.
.IP \fIcallback_kind\fP 1i
Specifies the list of callbacks within the widget to append to.
.IP \fIcallback\fP 1i
Specifies the callback procedure to add.
.IP \fIclosure\fP 1i
Specifies the closure to be passed to the callback when it is invoked by
.IN "XtCallCallbacks"
.PN XtCallCallbacks 
(which may often be NULL).
.NH 2
XtRemoveCallback
.XS
\*(SN XtRemoveCallback
.XE
.LP
To remove a callback procedure from a callback list, use
.IN "XtRemoveCallback"
.PN XtRemoveCallback .
The definition for this function is:
.FD 0
void XtRemoveCallback(\fIw\fP, \fIcallback_kind\fP, \fIcallback\fP, \fIclosure\fP)
.br
      Widget \fIw\fP;
.br
      XtCallbackKind \fIcallback_kind\fP;
.br
      XtCallbackProc \fIcallback\fP;
.br
      caddr_t \fIclosure\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget to delete the callback from.
.IP \fIcallback_kind\fP 1i
Specifies the list of callbacks within the widget to remove the callback from.
.IP \fIcallback\fP 1i
Specifies the callback procedure to delete.
.IP \fIclosure\fP 1i
Specifies the closure to match on the registered callback procedure. (The
.IN "XtRemoveCallback"
.PN XtRemoveCallback
routine removes a callback only if both the procedure and the closure match).
.NH 2
XtRemoveAllCallbacks
.XS
\*(SN XtRemoveAllCallbacks
.XE
.LP
To remove all callback procedures from a callback list (and, thus, free all storage
associated with the callback list), use
.IN "XtRemoveAllCallbacks"
.PN XtRemoveAllCallbacks .
The definition for this function is:
.FD 0
void XtRemoveAllCallbacks(\fIw\fP, \fIcallback_kind\fP)
.br
      Widget \fIw\fP;
.br
      XtCallbackKind \fIcallback_kind\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget to remove the callback from.
.IP \fIcallbacks\fP 1i
Specifies the callback list within the widget to remove.
.NH 2
XtCallCallbacks
.XS
\*(SN XtCallCallbacks
.XE
.LP
To execute the procedures in a callback list, use
.IN "XtCallCallback"
.PN XtCallCallback .
The definition for this function is:
.FD 0
void XtCallCallbacks(\fIw\fP, \fIcallback_kind\fP, \fIcall_data\fP)
.br
      Widget \fIw\fP;
.br
      XtCallbackKind \fIcallback_kind\fP;
.br
      caddr_t \fIcall_data\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget to execute the callbacks of.
.IP \fIcallback_kind\fP 1i
Specifies the list of callbacks within the widget to execute.
.IP \fIcall_data\fP 1i
Specifies a callback-list specific data value to pass to each of the callback
procedure in the list.  The call_data is NULL if no data is needed (for
example, the commandActivated callback list in Command needs only to
notify its clients that the button has been activated); 
the call_data is the actual data if only one (32-bit) word is needed; 
the call_data is the address of the data if more than one word is needed 
(for example, Scrollbar needs to pass back the height and position of the scroll thumb).
.\" Beta release
.\"
.\".LP
.\"[[ Actually, I suppose Scrollbar only really needs to pass the position of the
.\"thumb, which in the current implementation is a float. Consequently, it is not a good
.\"example.  But, then, it should pass back two integers: if you observe
.\"closely the bottom of the scroll thumb in Text can change by one pixel as data
.\"appears on the screen!  If the rounding error introduced by floats are replaced
.\"by perfect integer arithmetic, then the above example is good. ]]
.NH 1
Mapping Strings to Widget Instances and Classes
.XS
\*(SN Mapping Strings to Widget Instances and Classes
.XE
.\" Beta release
.\"
.\".LP
.\"[[ I do not really know why this is needed.  Ann's Widget Editor just stores all
.\"widgets in preorder format and does not need to dynamically map an arbitrary
.\"string to a widget. And since the editor must know about existing widget classes
.\"it does not need to map an arbitrary string to a widget class.  Hence none of
.\"this is implemented. ]]
.NH 2
XtStringToWidget
.XS
\*(SN XtStringToWidget
.XE
.LP
.IN "XtStringToWidget"
.PN XtStringToWidget
maps a fully qualified widget name to a widget instance.
The definition for this function is:
.FD 0
Widget XtStringToWidget(\fIname\fP);
.br
      String \fIname\fP;
.FN
.IP \fIname\fP 1i
The fully qualified name of the desired widget.
.NT
This routine currently is not yet implemented.
.NE
.\" Beta release
.\"
.\".NH 3
.\"XtStringToWidget Issues
.\".XS
.\"\*(SN XtStringToWidget Issues
.\".XE
.\".LP
.\"What format should the name be in?  String form with dot
.\"separating each name?  List of strings?
.\".LP
.\"Who (if anyone) guarantees that all direct children of a widget have distinct
.\"names?  Or at least distinct name/class?
.\"What are semantics of XtStringToWidget if names are non-unique?
.NH 2
XtStringToClass
.XS
\*(SN XtStringToClass
.XE
.LP
.IN "XtStringToClass"
.PN XtStringToClass
maps a fully qualified widget name to a widget class.
The definition for this function is:
.FD 0
WidgetClass XtStringToClass(\fIname\fP);
.br
      String \fIname\fP;
.FN
.IP \fIname\fP 1i
The name of the desired widget class.
.NT
This routine currently is not yet implemented.
.NE
.\" Beta release
.\"
.\".NH 3
.\"XtStringToClass Issues
.\".XS
.\"\*(SN XtStringToClass Issues
.\".XE
.\".LP
.\"How do widget classes get registered?  They cannot just register themselves in
.\"their class_initialize procedure, because unpickling may want to do an 
.\".PN XtStringToClass 
.\"call before any of the classes have initialized.  This seems to
.\"imply a separate initialization procedure for each widget class that the
.\"application must call.  We have studiously avoided this, since C is not as nice as
.\"Modula-2 and requires explicit calls to such procedures.
.NH 1
Composite Widgets
.XS
\*(SN Composite Widgets
.XE
.LP
Composite widgets can have children.  Consequently, they are responsible for much
more than primitive widgets.  Their responsibilities (either implemented
directly by the widget class or indirectly by generic procedures) include:
.IP \(bu 5
Overall management of children from creation to destruction
.IP \(bu 5
Destruction of descendants when the composite widget is destroyed
.IP \(bu 5
Physical arrangement (geometry management) of a displayable subset of 
children (that is, the ``managed'' children)
.IP \(bu 5
Mapping and unmapping of a subset of the managed children
.IP \(bu 5
Focus management for the displayable children
.LP
Overall management is handled by the generic procedures
.IN "XtCreateWidget"
.PN XtCreateWidget
and 
.IN "XtDestroyWidget"
.PN XtDestroyWidget .
.PN XtCreateWidget
adds children to their parent by calling the parent's insert_child 
procedure. 
.PN XtDestroyWidget
removes children from their parent by calling the parent's delete_child
procedure and ensures all children of a destroyed widget also get destroyed.
.LP
Only a subset of the total number of children are actually managed by
the geometry manager and, hence, possibly visible.  For example, an emacs-like
composite editor widget might allocate one
child widget per buffer, but it might only display a small number of the existing
buffers.  Windows that are in this displayable subset are called ``managed''
windows and enter into geometry manager calculations.  The other children are
``unmanaged'' windows and, by definition, are not mapped.
.LP
Children are added to and removed from the managed set by using 
.IN "XtManageChildren"
.PN XtManageChildren
and 
.IN "XtUnmanageChildren"
.PN XtUnmanageChildren ,
which notify the parent to recalculate the physical layout of its children by
calling the parent's change_managed procedure.
.LP
Most managed children are mapped, but some widgets may be in a state where they
take up physical space but do not show anything.  Managed widgets will not be 
mapped if their map_when_managed field is FALSE.  
This field default is TRUE and is changed by using
.IN "XtSetMappedWhenManaged"
.PN XtSetMappedWhenManaged .
.LP
Each composite widget class has a geometry manager, which is responsible for
figuring out where the managed children should appear within the
composite widget's window.  Geometry management techniques fall into three classes:
.\" Beta release
.\"
.\" right now.
.IP \(bu 5
Fixed boxes have a fixed number of children that are created by the parent.
All of these children are managed, and none of them ever make geometry manager requests.
An example is Scrollbar.
.IP \(bu 5
Homogeneous boxes treat all children equally and apply the same geometry
constraints to each child.  Many clients insert and delete widgets freely (for instance,
xmh's folder box).  Examples are Menu, ButtonBox, and Pane.
.IP \(bu 5
Heterogeneous boxes have a specific location where each child is placed.
This location is usually not specified in pixels, because the window may be
resized but is expressed in terms of the relationship between a child
and the parent's borders as well as between the child and other, specific children.
Most clients insert a fixed number of widgets into a homogeneous box.  
Heterogeneous boxes are usually subclasses of Constraint. An example is Form.
.LP
Each composite widget, especially those that are heterogeneous, may define ways
for one child to change focus to another child by means of the move_focus_to_next
and move_focus_to_prev procedures.  For example, typing carriage
return in one child widget may move to the ``next'' child widget, while typing a 
number in one child widget may move focus to any of a number of children 
widgets.
.NH 2
Composite Widget Type Definitions
.XS
\*(SN Composite Widget Type Definitions
.XE
.LP
.DS 0
.TA .5i 3i
.ta .5i 3i
typedef Widget *\fIWidgetList\fP;
.DE
.NH 2
XtIsComposite
.XS
\*(SN XtIsComposite
.XE
.LP
To test if a widget is a subclass of Composite, use
.IN "XtIsComposite"
.PN XtIsComposite .
The definition for this function is:
.FD 0
void XtIsComposite(\fIw\fP)
.br
      Widget \fIw\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget under question.
.LP
.PN XtIsComposite
is just an abbreviation for 
.IN "XtIsSubclass"
.PN XtIsSubclass 
with the following parameters list:
.LP
.DS 0
.TA .5i 3i
.ta .5i 3i
(\fIw\fP, \fIcompositeWidgetClass\fP).
.DE
.NH 2
Adding New Children: the insert_child procedure
.XS
\*(SN Adding New Children: the insert_child procedure
.XE
.LP
.IN "insert_child procedure"
To add the child to
the parent's children array,
.IN "XtCreateWidget"
.PN XtCreateWidget
calls the parent's class routine insert_child.
.LP
Fixed boxes usually insert the child first by calling Composite's 
insert_child routine, then by calling
.IN "XtManageChild"
.PN XtManageChild
to add the child to the box's managed set.
Homogeneous boxes usually just inherit Composite's insert_child routine.
Heterogeneous boxes usually have a separate array of constraint information on
the side and, so, perform the insertion with custom code.
.LP
An insertion procedure takes the widget to insert and the argument list used
to create the widget.  This argument list is usually used only by homogeneous
boxes (subclasses of Constraint).
.IN "XtArgsProc"
.FD 0
typedef void (*\fIXtArgsProc\fP)();
.br
      Widget \fIw\fP;
.br
      ArgList \fIargs\fP;
.br
      Cardinal \fInum_args\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget to insert.
.IP \fIargs\fP 1i
Specifies the argument list passed to
.IN "XtCreateWidget"
.PN XtCreateWidget .
.IP \fInum_args\fP 1i
Specifies the number of arguments in argument list.
.NH 3
Insertion Order
.XS
\*(SN Insertion Order
.XE
.IN "XtOrderProc"
.FD 0
typedef Cardinal (*\fIXtOrderProc\fP)();
.br
      Widget \fIw\fP;
.FN
Instances of composite widgets may care about the order in which their children
are kept.  For example, an application may want a set of command buttons in some
logical order grouped by function, while it
may want buttons that represent file names to be kept in alphabetical order.
Composite widgets that allow clients to order their children (usually
homogeneous boxes) can call their widget instance's insert_position
function from the class's insert_child procedure to determine where a new
child should go in its children array.
.LP
Using zero (0) means before all other children,
while using num_children means after all other children.  
The default insert_position function returns
num_children.   This can be overridden by a specific
composite widget's resource list or by the argument list provided when the
composite widget is created.
.\" Beta release
.\"
.\".LP
.\"[[ What other default functions?  Sort by name?  Sort by label? ]]
.NH 2
Deleting Children: the delete_child procedure
.XS
\*(SN Deleting New Children: the delete_child procedure
.XE
.LP
.IN "delete_child procedure"
.IN "XtDestroyWidget"
.PN XtDestroyWidget
eventually causes a call to the parent's class routine delete_child
in order to remove the child from the parent's children array.
.LP
Fixed boxes usually do not need a delete_children routine because they create
their own children.
Hence, they  need not worry about a client calling
.PN XtDestroyWidget
on one of their children.
Homogeneous boxes usually just inherit Composite's delete_child routine.
Heterogeneous boxes usually have a separate array of constraint information on
the side and, so, perform the deletion with custom code.
.LP
A deletion procedure is of type 
.IN "XtWidgetProc"
.PN XtWidgetProc ,
and it merely takes the widget to delete.
.NH 2
Adding and Removing Children from the Managed Set
.XS
\*(SN Adding and Removing Children from the Managed Set
.XE
.LP
The \*(tk provides a set of generic routines to permit,
without explicit knowledge of the composite widget type.
The addition of widgets to or the removal of widgets from a composite widget's 
managed set.
.IN "change_managed procedure"
These generic routines eventually call the widget's class procedure,
change_managed, which is of type 
.IN "XtWidgetProc"
.PN XtWidgetProc .
.NH 3
XtManageChildren
.XS
\*(SN XtManageChildren
.XE
.LP
To add a list of widgets to the geometry-managed (and, hence, displayable) subset
of their parent widget, the application must first create the widgets by using
.IN "XtCreateWidget"
.PN XtCreateWidget 
and then call 
.IN "XtManageChildren"
.PN XtManageChildren .
(Note that some composite widgets, especially fixed boxes, call 
.IN "XtManageChild"
.PN XtManageChild
from their insert_child procedure.) The definition for 
.PN XtManageChildren
is:
.FD 0
void XtManageChildren(\fIchildren\fP, \fInum_children\fP)
.br
      WidgetList \fIchildren\fP;
.br
      Cardinal \fInum_children\fP;
.FN
.IP \fIchildren\fP 1i
Specifies a list of children to add.
.IP \fInum_children\fP 1i
Specifies the number of children to add.
.LP
.PN XtManageChildren 
performs the following actions:
.IP \(bu 5
Issues an error if the children do not all have the same parent.
.IP \(bu 5
Returns immediately if the common parent is being destroyed.
.IP \(bu 5
Otherwise, it processes the unique, unmanaged children:
.RS
.IP \- 5
A child is ignored if it is already managed or being destroyed.
.IP \- 5
Otherwise, the child is marked as managed, and the parent's
num_mapped_children field is incremented if the child has map_when_managed 
TRUE.
.RE
.IP \(bu 5
Calls the change_managed routine of the widgets' parent.
.IP \(bu 5
If the parent is realized, 
.IN "XtManageChildren"
.PN XtManageChildren
makes (some of) the newly managed children visible:
.RS
.IP \- 5
Calls 
.IN "XtRealizeWidget"
.PN XtRealizeWidget
on each previously unmanaged child that is unrealized.
.IP \- 5
Maps each previously unmanaged child that has map_when_managed TRUE.
.RE
.LP
The composite widget's change_managed procedure is called to notify the
parent that its set of managed children has changed.  It may, as it sees fit,
reposition and resize any of its children.  It moves each child as needed by using the
.IN "XtMoveWidget"
.PN XtMoveWidget
procedure, which first updates the x and y fields.
Then, it calls
.PN XMoveWindow
if the widget is realized.
.LP
If the composite widget wishes to change the size or border width of any of its
children, it calls the
.IN "XtResizeWidget"
.PN XtResizeWidget
procedure, which first updates the width, height, and border_width fields. 
Then, it calls
.IN "XConfigureWindow"
.PN XConfigureWindow
if the widget is realized.
.NH 3
XtManageChild
.XS
\*(SN XtManageChild
.XE
.LP
To add a single child to the managed children of its parent widget, the
application must first create the widget by using 
.IN "XtCreateWidget"
.PN XtCreateWidget 
and then call 
.IN "XtManageChild"
.PN XtManageChild .
The definition for this function is:
.FD 0
void XtManageChild(\fIchild\fP)
.br
      Widget \fIchild\fP;
.FN
.IP \fIchild\fP 1i
Specifies the child to add.
.LP
.PN XtManageChild
constructs a WidgetList of length one (1) and calls 
.IN "XtManageChildren"
.PN XtManageChildren .
.NH 3
XtUnmanageChildren
.XS
\*(SN XtUnmanageChildren
.XE
.LP
To remove a list of children from the managed list of their parent, use
.IN "XtUnmanageChildren"
.PN XtUnmanageChildren .
The definition for this function is:
.FD 0
void XtUnmanageChildren(\fIchildren\fP, \fInum_children\fP)
.br
      WidgetList \fIchildren\fP;
.br
      Cardinal \fInum_children\fP;
.FN
.IP \fIchildren\fP 1i
Specifies the children to remove.
.IP \fInum_children\fP 1i
Specifies the number of children to remove.
.LP
.PN XtUnmanageChildren
performs the following:
.IP \(bu 5
Issues an error if the children do not all have the same parent.
.IP \(bu 5
Returns immediately if the common parent is being destroyed.
.IP \(bu 5
Otherwise, it processes the unique, managed children:
.RS 
.IP \- 5
A child is ignored if it is already unmanaged or being destroyed.
.IP \- 5
Otherwise,
.PN XtUnmanagedChildren
marks the child as unmanaged.
.IP \- 5
If the parent is realized, makes child non-visible by unmapping it.
.IP \- 5
Decrements the parent's num_mapped_children field if the widget has map_when_managed 
TRUE.
.RE
.IP \(bu 5
Calls the change_managed routine of the widgets' parent.
.LP
.PN XtUnmanageChildren
does not destroy the children widgets.  Removing widgets
from a parent's managed set is often a temporary banishment, and
some time later you may add the children again.  To entirely destroy
widgets, see ``XtDestroyWidget''.
.NH 3
XtUnmanageChild
.XS
\*(SN XtUnmanageChild
.XE
.LP
To remove a single child from its parent's managed set, use
.IN "XtUnmanageChild"
.PN XtUnmanageChild .
The definition for this function is:
.FD 0
void XtUnmanageChild(\fIchild\fP)
.br
      Widget \fIchild\fP;
.FN
.IP \fIchild\fP 1i
Specifies the child to remove.
.LP
.PN XtUnmanageChild
constructs a WidgetList of length one (1) and calls 
.IN "XtUnmanageChildren"
.PN XtUnmanageChildren .
.LP
These generic routines are low-level routines used by ``generic''
composite widget building routines. Composite widgets may in
addition provide widget-specific, high-level convenience routines to
allow applications to create and manage children more easily.
.NH 2
XtSetMappedWhenManaged
.XS
\*(SN XtSetMappedWhenManaged
.XE
.LP
A widget is normally mapped if it is managed.  This behavior can be overridden
by setting the map_when_managed field FALSE.  
To change the map_when_managed field, use
.IN "XtSetMappedWhenManaged"
.PN XtSetMappedWhenManaged .
The definition for this function is:
.FD 0
void XtSetMappedWhenManaged(\fIw\fP, \fImap_when_managed\fP)
.br
      Widget \fIw\fP;
.br
      Boolean \fImap_when_managed\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.IP \fImap_when_managed\fP 1i
Specifies the new value.
.LP
If the widget is realized and managed,
.PN XtSetMappedWhenManaged
maps or unmaps the window as appropriate.
.\" Beta release
.\"
.\".NH 1
.\"Constrained Composite Widgets
.\".XS
.\"\*(SN Constrained Composite Widgets
.\".XE
.\".LP
.\"[[ Need to write this section. ]]
.NH 1
Toolkit Initialization
.XS
\*(SN Toolkit Initialization
.XE
.LP
To initialize the \*(tk, call the
.IN " XtInitialize"
.PN XtInitialize 
function.  The definition of the functions is;
.FD 0
Widget XtInitialize(\fIname\fP, \fIclass_name\fP, \fIoptions\fP, \fInum_options\fP, \fIargc\fP, \fIargv\fP)
.br
      String \fIname\fP;
.br
      String \fIclass_name\fP;
.br
      XrmOptionDescRec \fIoptions\fP;
.br
      Cardinal \fInum_options\fP;
.br
      Cardinal *\fIargc\fP;
.br
      char *\fIargv\fP[];
.FN
.IP \fIname\fP 1i
Name of this instance of the application.
.IP \fIclass\fP 1i
Class name of this application. Usually the generic name for all instances of
this application.
.IP \fIoptions\fP 1i
Specifies how to parse the command line for any application-specific resources.
The options is passed as a parameter to 
.IN "XrmParseCommand"
.PN XrmParseCommand .
(See the Xlib manual for further information.)
.IP \fInum_options\fP 1i
The number of entries in options list.
.IP \fIargc\fP 1i
Address of the number of command line parameters.
.IP \fIargv\fP 1i
Command line parameters.
.LP
.IN "XtInitialize"
.PN XtInitialize
must be called before calling any other \*(tk functions.
It parses the command line, opens the display, and initializes the
toolkit. It returns the ``top-level'' widget to use as the parent of the 
application's root widget.
.LP
It modifies argc and argv to contain just the parameters that
were not a display, geometry, or resource specification.  
If the modified argc is not zero (0), most 
applications simply print out the modified argv along with a message 
about the allowable options.
.NH 2
Setting Resources from the Command Line
.XS
\*(SN Setting Resources from the Commmand Line
.XE
.LP
.IN "XtInitialize"
.PN XtInitialize
has a table of standard command line options for adding resources to the
resource database, and it takes as a parameter
additional application-specific resource abbreviations.
The format of this table is described in the Xlib documentation.  
.\" Beta release
.\"
.\"[[ Except in my latest copy I can't find a description anywhere. ]]
.LP
The standard table contains the following entries:
.TS
l l l l .
_
.sp 6p
Option string	Resource name	Argument Kind	Resource value
.sp 6p
_
.sp 6p
\=	geometry	IsArg
-bd	border	SepArg
-bordercolor	border	SepArg
-bg	background	SepArg
-background	background	SepArg
-bw	borderWidth	SepArg
-border	borderWidth	SepArg
-fg	foreground	SepArg
-foreground	foreground	SepArg
-fn	font	SepArg
-font	font	SepArg
-rv	reverseVideo	NoArg	on [not implemented]
-reverse	reverseVideo	NoArg	on [not implemented]
+rv	reverseVideo	NoArg	off [not implemented]
-n	name	SepArg
-name	name	SepArg
-title	title	SepArg
-t	title	SepArg
.sp 6p
_
.TE
.\" Beta release
.\"
.\".LP
.\"[[ XrmParseOptions should implement a general escape mechanism for command line
.\"setting of resource, like
.\".LP
.\"xterm -xrm '*scrollBar.background: red'
.\".LP
.\"]]
.\".NH 2
.\"Window Manager Attributes
.\".XS
.\"\*(SN Window Manager Attributes
.\".XE
.\".LP
.\"[[ Describe the window manager attributes we support, and how. ]]
.\".LP
.\"[[ Info on associating an icon bitmap with an application.  And there should 
.\"be a toolkit interface
.\"to the Bitmap-to-Pixmap stuff, and preferably one for File-to-Pixmap. ]]
.NH 1 
Memory Management
.XS
\*(SN Memory Management
.XE
.LP
The \*(tk memory management routines provide uniform checking for
null pointers, and error reporting on memory allocation errors. These
routines are completely compatible with the standard C language runtime
routines 
.IN "malloc"
.PN malloc , 
.IN "calloc"
.PN calloc , 
.IN "realloc"
.PN realloc , 
and 
.IN "free"
.PN free 
with the added functionality:
.IP \(bu 5
.IN "XtMalloc"
.PN XtMalloc ,
.IN "XtCalloc"
.PN XtCalloc ,
and 
.IN " XtRealloc"
.PN XtRealloc
give an error if there is not enough memory.
.IP \(bu 5
.IN "XtFree"
.PN XtFree
simply returns if passed a NULL pointer.
.IP \(bu 5
.IN "XtRealloc"
.PN XtRealloc
simply allocates new storage if passed a NULL pointer.
.LP
See the C library documentation on 
.IN "malloc"
.PN malloc , 
.IN "calloc"
.PN calloc , 
.IN "realloc"
.PN realloc ,
and 
.IN "free"
.PN free
for more information.
The definitions for the \*(tk memory management routines are:
.IN "XtMalloc"
.FD 0
char *XtMalloc(\fIsize\fP);
.br
      Cardinal \fIsize\fP;
.FN
.IP \fIsize\fP 1i
Number of bytes desired.
.LP
.PN XtMalloc
returns a pointer to a block of storage of at least the specified size bytes.
.IN "XtCalloc"
.FD 0
char *XtCalloc(\fInum\fP, \fIsize\fP);
.br
      Cardinal \fInum\fP;
.br
      Cardinal \fIsize\fP;
.FN
.IP \fInum\fP 1i
Number of array elements to allocate.
.IP \fIsize\fP 1i
Size in bytes of an array element.
.LP
.PN XtCalloc
allocates space for the specified number of array elements of the specified size bytes.
.IN "XtRealloc"
.FD 0
char *XtRealloc(\fIptr\fP, \fInum\fP);
.br
      char *\fIptr\fP;
.br
      Cardinal \fInum\fP;
.FN
.IP \fIptr\fP 1i
Pointer to old storage.
.IP \fInum\fP 1i
Number of bytes desired in new storage.
.LP
.PN XtRealloc
changes the size of a block of storage (possibly moving it).
Then, it copies the old contents into the new block (as much as will fit).
.IN "XtFree"
.FD 0
void XtFree(\fIptr\fP);
.br
      char *\fIptr\fP;
.FN
.IP \fIptr\fP 1i
Pointer to block of storage to free.
.LP
Free returns storage and allows it to be reused.
.NH 1 
Input and Events
.XS
\*(SN Input and Events
.XE
.LP
While X allows the reading and processing of events anywhere in an application,
widgets in the \*(tk neither read events nor grab the server or mouse.  Widgets
merely register procedures to be called when an event or class of events occurs
in that widget.
.LP
A typical application consists of
startup code followed by an event loop (see ``XtMainLoop''),
which reads events and dispatches events by calling the procedures that widgets have
registered.
.LP
The event manager is a collection of routines to:
.IP \(bu 5
Add or remove event sources other that X window events (in particular,
timer interrupts and file input).
.IP \(bu 5
Query the status of event sources.
.IP \(bu 5
Add or remove procedures to be called when an event occurs for a particular
widget.
.IP \(bu 5
Disable the dispatching of user-initiated events (keyboard and mouse events)
for a particular widget.
.IP \(bu 5
Constrain the dispatching of events to a cascade of ``pop-up'' widgets.
.IP \(bu 5
Call the appropriate set of procedures currently registered when an event is read.
.LP
In general, widgets do not use any of the event manager routines.
That is, the normal interface to
X events is through the higher-level Translation Manager, which maps
sequences of X events (with modifiers) into procedure calls.
In general, applications do not use any of the event manager routines, except
.IN "XtMainLoop"
.PN XtMainLoop .
.NH 2
Adding and Deleting Event Sources
.XS
\*(SN Adding and Deleting Event Sources
.XE
.LP
While most applications are driven only by X events, some need to
incorporate other sources of input into the \*(tk event handling philosophy.
The event manager provides routines to integrate timer events and file data
pending events into this mechanism.
.LP
The next two functions provide input gathering from files.  The application
registers the files with the read routine.  When input is pending on one of
the files, a message event containing the window that is to receive
the input is generated.
.\" Beta release
.\"
.\".LP
.\"[[ I have not updated this section in case we change to direct callbacks rather
.\"than going through fake events. ]]
.NH 3
XtAddInput
.XS
\*(SN XtAddInput
.XE
.LP
To register a new file for input, use
.IN "XtAddInput"
.PN XtAddInput .
The definition for this function is:
.FD 0
void XtAddInput(\fIw\fP, \fIsource\fP, \fIcondition\fP)
.br
      Widget \fIw\fP;
.br
      int \fIsource\fP;
.br
      caddr_t \fIcondition\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.IP \fIsource\fP 1i
Specifies the source file descriptor in UNIX or other operating system
dependent device specification.
.IP \fIcondition\fP 1i
Specifies the mask that indicates a read, write, or exception condition. 
.\" Beta release
.\"
.\"[[ Describe as per Intrinsic.h and NextEvent.c ]]
.LP
The 
.PN XtAddInput
function registers with the \*(tk read routine a new source of events, which is
usually file input but can also be file output.  (The word ``file'' should
be loosely interpreted to mean any sink or source of data.)
.PN XtAddInput
also specifies the conditions under which the source can generate events.
When input is pending on this source, a 
.IN "ClientMessage"
.PN ClientMessage 
event that contains the window, the source, and the condition is returned 
to the application.
.\" Beta release
.\"
.\".LP
.\"[[ Describe structure of event, XtINPUT_READ/WRITE/EXCEPT, and XtHasInput ]]
.NH 3
XtRemoveInput
.XS
\*(SN XtRemoveInput
.XE
.LP
To discontinue a source of input, use 
.IN "XtRemoveInput"
.PN XtRemoveInput .
The definition for this function is:
.FD 0
void XtRemoveInput(\fIw\fP, \fIsource\fP, \fIcondition\fP)
.br
      Widget \fIw\fP;
.br
      int \fIsource\fP;
.br
      caddr_t \fIcondition\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.IP \fIsource\fP 1i
Specifies the source file descriptor in UNIX or other operating system
dependent device specification.
.IP \fIcondition\fP 1i
Specifies the mask that indicates a read, write, or exception condition. 
.LP
The 
.PN XtRemoveInput
function causes the X read routine to stop gathering input 
from the input source.  The condition parameter allows the disabling of input
only for certain conditions.
.NH 3
XtAddTimeOut
.XS
\*(SN XtAddTimeOut
.XE
.LP
The timeout facility notifies the application or the widget writer 
through a message event that a specified time interval has elapsed.  
Timeout values are set for a single widget 
and are uniquely identified by an interval ID.
This allows for more than one widget to specify a timeout 
and for a single widget to have multiple timeouts.  
.LP
To create a timeout value for a widget, use 
.IN "XtAddTimeOut"
.PN XtAddTimeOut .
The definition for this function is:
.FD 0
XtIntervalId XtAddTimeOut(\fIw\fP, \fIinterval\fP)
.br
      Widget \fIw\fP;
.br
      unsigned long \fIinterval\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.IP \fIinterval\fP 1i
Specifies the time interval in milliseconds.
.LP
The 
.PN XtAddTimeOut
function creates a timeout value for the widget that is identified
by the widget ID and returns an identifier for that timer.
The timeout value is set to interval.
This causes a message event to be generated for the specified widget window 
whenever the time interval elapses.
.\" Beta release
.\"
.\".LP
.\"[[ Describe event structure and XtTimerExpired. ]]
.NH 3
XtRemoveTimeOut
.XS
\*(SN XtRemoveTimeOut
.XE
.LP
To clear a timeout value, use 
.IN "XtRemoveTimeOut"
.PN XtRemoveTimeOut .
The definition for this function is:
.FD 0
void XtRemoveTimeOut(\fItimer\fP)
.br
      XtIntervalId \fItimer\fP;
.FN
.IP \fItimer\fP 1i
Specifies the unique identifier for the timeout request to be destroyed.
.LP
.PN XtRemoveTimeOut 
removes the timeout, even if it has triggered but has not
been fetched with 
.PN XtNextEvent .
.\" Beta release
.\"
.\".NH 4
.\"XtRemoveTimeOut Issues
.\".XS
.\"\*(SN XtRemoveTimeOut Issues
.\".XE
.\".LP
.\"Do these ``send'' events to windows or widgets?
.\".LP
.\"What happens to a timeout if the widget it is set for has been destroyed?
.NH 2
Filtering X Events
.XS
\*(SN Filtering X Events
.XE
.LP
The event manager provides two filters that can be applied to X user events.
These filters screen out events that are redundant or that are temporarily unwanted.
.NH 3
Mouse Motion Compression
.XS
\*(SN Mouse Motion Compression
.XE
.LP
Widgets may have a hard time keeping up with mouse motion events.  Further,
they usually do not actually care about every motion event.  To throw out
redundant motion events, the widget class field compress_motion should be
TRUE. 
.IN "compress_motion"
All but the last motion event is ignored in a consecutive sequence
of motion events queued for the widget's window, and only
the most recent motion event is delivered.
.NH 3
XtSetSensitive
.XS
\*(SN XtSetSensitive
.XE
.FD 0
void XtSetSensitive(\fIw\fP, \fIsensitive\fP)
.br
      Widget \fIw\fP;
.br
      Boolean \fIsensitive\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.IP \fIsensitive\fP 1i
Specifies whether or not the widget should receive keyboard and mouse events.
.LP
Many widgets, especially those with callback lists that get executed in response
to some user-initiated action (for example, clicking down or up), have a mode
in which they take on a different appearance (for example, greyed out or
stippled) and do not respond any more.
.LP
This dormant state means the widget is ``insensitive''.  If a widget is
insensitive, the Event Manager does not dispatch any events to the widget 
with an event type of 
.PN KeyPress , 
.PN KeyRelease , 
.PN ButtonPress , 
.PN ButtonRelease ,
.PN MotionNotify , 
.PN EnterNotify , 
.PN LeaveNotify , 
.PN FocusIn , 
or 
.PN FocusOut .
.LP
A widget may be insensitive because its sensitive field is FALSE 
or one of its parents is insensitive, and, thus, the widget's
ancestor_sensitive field also is FALSE.  
A widget may but does not nned to distinguish these two cases visually.
.LP
.IN "XtSetSensitive"
.PN XtSetSensitive 
first calls 
.IN "XtSetValues"
.PN XtSetValues 
on the current widget with an
argument list specifying that the sensitive field should change to the new
value.  It then recursively propagates the new value
down the managed children tree by calling 
.PN XtSetValues
on each child to set the ancestor_sensitive to the new value if the new
values for sensitive and ancestor_sensitive are the same.
.IN "XtSetSensitive"
.PN XtSetSensitive
thus maintains the invariant if parent has either sensitive or ancestor_sensitive 
FALSE. 
Then, all children have ancestor_sensitive FALSE.
.LP
.PN XtSetSensitive
calls 
.PN XtSetValues
to change sensitive and ancestor_sensitive.
Therefore, the widget's set_values procedure should take whatever display actions are
needed, such as greying out or stippling the widget, when one of these changes.
.NH 2
Querying Event Sources
.XS
\*(SN Querying Event Sources
.XE
.LP
The event manager provides several routines to examine and read events
(including file and timer events) that are in the queue.
.LP
The next three functions handle \*(tk equivalents of the
.IN "XPending"
.PN XPending , 
.IN "XPeekEvent"
.PN XPeekEvent 
and 
.IN "XNextEvent"
.PN XNextEvent , 
Xlib calls.
.NH 3
XtPending
.XS
\*(SN XtPending
.XE
.LP
.IN "Events
To determine if there are any events on the input queue, 
use
.IN "XtPending"
.PN XtPending .
The definition for this function is:
.FD 0
Boolean XtPending()
.FN
The 
.PN XtPending
function flushes the X output buffer and returns a nonzero value if there are 
events pending from X or other input sources.  
If there are no events pending, it returns a zero value.
.NH 3
XtPeekEvent
.XS
\*(SN XtPeekEvent
.XE
.LP
To flush the X output buffer and return the value 
from the head of the input queue without removing input from the queue,
use
.IN "XtPeekEvent"
.PN XtPeekEvent .
The definition for this function is:
.FD 0
void XtPeekEvent(\fIevent\fP)
.br
      XEvent *\fIevent\fP;
.FN
.IP \fIevent\fP 1i
Returns the event information to the specified event structure.
.LP
If no X input is on the queue, 
.PN XtPeekEvent
looks at all other input sources and
returns the first source that has input pending.  
If no input is pending, however, 
.PN XtPeekEvent
blocks until input is available.
.NH 3
XtNextEvent
.XS
\*(SN XtNextEvent
.XE
.LP
To flush the X output buffer 
and return the value from the head of the input queue, 
use 
.IN "XtNextEvent"
.PN XtNextEvent .
The definition for this function is:
.FD 0
void XtNextEvent(\fIevent\fP)
.br
      XEvent *\fIevent\fP;
.FN
.IP \fIevent\fP 1i
Returns the event information to the specified event structure.
.LP
If no input is on the X input queue, 
.PN XtNextEvent 
looks at the other input sources or timeout values 
and returns input generated by them.
If no input of any sort is available,
.PN XtNextEvent
blocks until an event can be returned.
.LP
Because the toolkit event processing gives preference to X events over source and
timeout events, a call to
.IN "XtPeekEvent"
.PN XtPeekEvent
followed by a call to
.PN XtNextEvent
may not return the same event if 
.PN XtPeekEvent
returns a source or timeout event.
.\" Beta release
.\"
.\".NH 4
.\"Querying Event Sources Issues
.\".XS
.\"\*(SN  Querying Event Sources Issues
.\".XE
.\".LP
.\"Xlib now makes available the list of open displays an application has.  
.\"Assuming we allow different displays for pop-ups, the
.\"toolkit needs to walk down the display list for all these routines,
.\"because it may have
.\"events waiting on any (or none) of the open displays.  Do not ask me why Xlib
.\"is not doing that for us.
.\".LP
.\"Xlib defines a bunch of querying now.  Do we need analogs?  Or are these
.\"sufficient?
.NH 2
Adding and Removing Event Handlers
.XS
\*(SN Adding and Removing Event Handlers
.XE
.LP
Event handlers are procedures that are called when a specified set of events
occurs in a widget.
.IN "XtEventHandler"
.FD 0
typedef void (*\fIXtEventHandler\fP());
.br
      Widget \fIw\fP;
.br
      caddr_t \fIclosure\fP; 
.br
      XEvent *\fIevent\fP;
.FN
.IP \fIw\fP 1i
The widget that this event handler was registered with.
.IP \fIclosure\fP 1i
Client specific information registered with the event handler, this is usually
NULL if the event handler is registered by the widget itself.
.IP \fIevent\fP 1i
The triggering event.
.NH 3
XtAddEventHandler
.XS
\*(SN XtAddEventHandler
.XE
.LP
To register an event handler procedure with the dispatch mechanism, use 
.IN "XtAddEventHandler"
.PN XtAddEventHandler .
The definition for this function is:
.FD 0
void XtAddEventHandler(\fIw\fP, \fIevent_mask\fP, \fInonmaskable\fP, \fIproc\fP, \fIclosure\fP)
.br
      Widget \fIw\fP;
.br
      XtEventMask \fIevent_mask\fP;
.br
      Boolean \fInonmaskable\fP;
.br
      XtEventHandler \fIproc\fP;
.br
      caddr_t \fIclosure\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget for which this event handler is being registered.
.IP \fIevent_mask\fP 1i
Specifies the event mask to call this procedure for.
.IP \fInonmaskable\fP 1i
Specifies whether this procedure should be called on the nonmaskable events.
These are event of type 
.PN GraphicsExpose , 
.PN NoExpose , 
.PN CreateNotify , 
.PN MapRequest ,
.PN ConfigureRequest , 
.PN ResizeRequest , 
.PN CirculateRequest , 
.PN SelectionClear ,
.PN SelectionRequest , 
.PN ClientMessage , 
and 
.PN MappingNotify .
.\" Beta release
.\"
.\"  [[ Is this the correct list? ]]
.IP \fIproc\fP 1i
Specifies the client event handler procedure. 
.IP \fIclosure\fP 1i
Specifies additional data to be passed to the client's event handler.
.IN "XtAddEventHandler"
.LP
The 
.PN XtAddEventHandler
function registers a procedure with the dispatch mechanism that is
to be called when an event that matches the mask occurs on the specified
widget.  If the procedure is already registered, the specified mask is OR'ed into
the existing mask.
If the widget is realized
.IN "XSelectInput"
.PN XtAddEventHandler
calls
.PN XSelectInput 
if necessary.
.NH 3
XtRemoveEventHandler
.XS
\*(SN XtRemoveEventHandler
.XE
.LP
To remove a previously registered event handler, use 
.IN "XtRemoveEventHandler"
.PN XtRemoveEventHandler .
The definition for this function is:
.FD 0
void XtRemoveEventHandler(\fIw\fP, \fIevent_mask\fP, \fInonmaskable\fP, \fIproc\fP, \fIclosure\fP)
.br
      Widget \fIw\fP;
.br
      XtEventMask \fIevent_mask\fP;
.br
      Boolean \fInonmaskable\fP;
.br
      XtEventHandler \fIproc\fP;
.br
      caddr_t \fIclosure\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget for which this procedure is registered.
.IP \fIevent_mask\fP 1i
.IP \fInonmaskable\fP 1i
Specifies the events to unregister this procedure for
.IP \fIproc\fP 1i
Specifies the event handler procedure registered.
.IP \fIclosure\fP 1i
Specifies the closure registered.
.LP
.PN XtRemoveEventHandler
stops the specified procedure from receiving the specified events.
If the widget is realized 
.PN XtRemoveEventHandler
calls
.IN "XSelectInput"
.PN XSelectInput 
if necessary.
.LP
To stop a procedure from receiving any events (which will remove it from the
widget's event_table entirely), call
.PN XtRemoveEventHandler
with an event_mask of 
.PN AllEvents 
and with nonmaskable TRUE.
.NH 2
Constraining Events to a Cascade of Widgets
.XS
\*(SN Constraining Events to a Cascade of Widgets
.XE
.LP
.IN "Grabbing Input"
.IN "Input Grabbing"
Some widgets lock out any user input to the application except input to that
widget.  These are called ``modal'' widgets.
.LP
When a modal menu or modal dialog box is ``popped-up'', user events
(keyboard and mouse events) that occur outside the modal widget should
be delivered to the modal widget or ignored. 
In no case should user events be delivered to widgets outside of the modal widgets.  
Menus may pop-up submenus and dialog boxes may pop-up further dialog
dialog boxes to create a pop-up ``cascade''. 
In this case, user events should 
be delivered to one of several modal widgets in the cascade.
.LP
Display-related events should be delivered outside the modal cascade so that
expose events and the like keep the application's display up-to-date.
Any event that occurs within the cascade is delivered normally.
Events that are delivered to the most recent modal widget in the cascade
are if they occur outside the cascade are: 
.PN KeyPress , 
.PN KeyRelease , 
.PN ButtonPress ,
and
.PN ButtonRelease .
.LP
Events that are ignored if they occur outside the cascade are:
.PN MotionNotify , 
.PN EnterNotify , 
.PN LeaveNotify , 
.PN FocusIn , 
.PN FocusOut , 
.PN KeymapNotify ,
.PN PropertyNotify ,
.PN SelectionClear , 
.PN SelectionRequest , 
.PN ColormapNotify ,
.PN ClientMessage , 
and 
.PN MappingNotify .  
.\" Beta release
.\"
.\"[[ I believe this list is too large. ]]
All other event are delivered normally.
.LP
Modal widgets use the procedures
.PN XtAddGrab
and
.PN XtRemoveGrab
to constrain user events to a modal cascade and to subsequently remove a grab
when the modal widget goes away.
.NH 3
XtAddGrab
.XS
\*(SN XtAddGrab
.XE
.LP
.IN "XtAddGrab"
The definition for this function is:
.FD 0
void XtAddGrab(\fIw\fP, \fIexclusive\fP)
.br
      Widget \fIw\fP;
.br
      Boolean \fIexclusive\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget to add to the modal cascade.
.IP \fIexclusive\fP 1i
Specifies if user events should be dispatched exclusively to this widget or
also to previous widgets in the cascade.
.LP
.PN XtAddGrab
appends the widget to the modal cascade.
.LP
When 
.IN "XtDispatchEvent"
.PN XtDispatchEvent
tries to dispatch a user event and when at least one modal widget is in the widget
cascade, it first determines if the the event should be delivered.  It starts
at the most recent cascade entry and follows the cascade up to and including
the most recent cascade entry added with exclusive TRUE.
.LP
This subset of the modal cascade is the active subset.
User events that occur outside the widgets in this subset are ignored.  
Modal menus generally add a
submenu widget to the cascade with exclusive FALSE.
Modal dialog boxes that wish to restrict user input to the most deeply nested dialog 
box add a subdialog widget to the cascade with exclusive TRUE.
.LP
User events that occur within the active subset are delivered to the
appropriate widget, which is usually a child or further descendant of the modal
widget.
.LP
Regardless of where on the screen they occur,
.PN ButtonRelease 
events are always delivered to the most recent widget in the
cascade. 
.NT
This routine currently is not yet implemented.
.NE
.NH 3
XtRemoveGrab
.XS
\*(SN XtRemoveGrab
.XE
.LP
The definition for this function is:
.FD 0
void XtRemoveGrab(\fIw\fP)
.br
      Widget \fIw\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget to remove from the modal cascade.
.LP
.IN "XtRemoveGrab"
.PN XtRemoveGrab
removes widgets from the modal cascade starting at the most recent widget up to
and including the specified widget.  It issues an error if w is
not on the modal cascade.
.NT
This routine currently is not yet implemented.
.NE
.\" Beta release
.\"
.\".NH 3
.\"Modal Widget Issues
.\".XS
.\"\*(SN Modal Widget Issues
.\".XE
.\".LP
.\"Still up in the air is how you create and attach a pop-up widget to the widget
.\"that pops it up.  I suspect the core widget points to a list of its pop-up
.\"widgets, and we have XtAddPopUps, and so on.
.NH 2
Dispatching Events
.XS
\*(SN Dispatching Events
.XE
.LP
The \*(tk provides functions that dispatch events
to widgets or other application code. 
Every client interested in events on a widget uses
.IN "XtAddEventHandler"
.PN XtAddEventHandler 
to register which events it is 
interested in and a procedure (event handler) that is to be called 
when the event happens in that window. 
.LP
When an event is receeved, it is passed to a dispatching procedure. 
This procedure calls the appropriate
event handlers and passes them the widget, the event,
and client specific data registered with each procedure (a ``closure'').
If there are no handlers for that event
registered, the event is ignored and the dispatcher simply returns.
.LP
The order in which the handlers are called is not defined.
.\" Beta release
.\"
.\".NH 3
.\"Dispatching Events Issues
.\".XS
.\"\*(SN Dispatching Events Issues
.\".XE
.\".LP
.\"The order of handler calls could be defined as either stack or queue.
.NH 3
XtDispatchEvent
.XS
\*(SN XtDispatchEvent
.XE
.LP
To send events to registered functions and widgets, use 
.IN "XtDispatchEvent"
.PN XtDispatchEvent .
Normally, this procedure is not called by client applications
(see ``XtMainLoop'').
The definition for this function is:
.FD 0
void XtDispatchEvent(\fIevent\fP)
.br
      XEvent *\fIevent\fP;
.FN
.IP \fIevent\fP 1i
Specifies a pointer to the event structure that is to be dispatched 
to the appropriate event handler.
.LP
The 
.PN XtDispatchEvent
function sends those events to those event handler functions that
have been previously registered with the dispatch routine.
The most common use of 
.PN XtDispatchEvent
is to dispatch events acquired with the 
.IN "XtNextEvent"
.PN XtNextEvent
or
.IN "XtPeekEvent"
.PN XtPeekEvent
procedure. 
However, it can also be used to dispatch user-constructed events.
.NH 3
XtMainLoop
.XS
\*(SN XtMainLoop
.XE
.LP
Applications normally process input within the \*(tk by calling the
.IN "XtMainLoop"
.PN XtMainLoop 
routine.
.LP
The definition for this function is:
.FD 0
void XtMainLoop()
.FN
.PN XtMainLoop
reads the next incoming file, timer, or X event.
Then, it dispatches this to the appropriate registered procedure.
This is the main loop of
\*(tk applications, and, as such, it does not return.  Applications are expected
to exit directly in response to some user action.
.NH 1
Widget Visibility and Exposure
.XS
\*(SN Widget Visibility and Exposure
.XE
.LP
Every primitive widget (and some composite widgets) displays data on the screen
by means of raw X calls.  Widgets cannot simply write to the screen and forget what
they've done. 
That is, widgets must keep enough state to redisplay the window (or parts
of it) if a portion is obscured and then re-exposed.
.NH 2
Widget Redisplay: the expose procedure
.XS
\*(SN Widget Redisplay: the expose procedure
.XE
.IN "XtExposeProc"
.IN "expose procedure"
.LP
typedef void (*\fIXtExposeProc\fP)();
.br
      Widget \fIw\fP;
.br
      XEvent *\fIevent\fP;
.LP
Redisplay of a widget upon exposure is the responsibility of the 
expose procedure in the widget's class record.  A small simple 
widget (for example, Label) may ignore the bounding box information in the 
Expose event and just redisplay the entire window.  
A more complicated widget (for example, Text) may use the bounding box
information to minimize the amount of calculation and redisplay it does.
The expose procedure is responsible for exposure of all superclass data as
well as its own, because, in general, this operation cannot be cleanly broken up.
.LP
However, it often possible to anticipate the display needs of several levels of
subclassing.  For example, rather than separate display procedures for
the widgets Label, Command, and Toggle, you could write a single display
routine in Label that uses ``display state'' fields like:
.LP
.DS 
Boolean invert
Boolean highlight
Dimension highlight_width
.DE
Label would have invert and highlight always FALSE and
highlight_width  zero(0).  
Command would dynamically set highlight and highlight_width, but it would leave invert 
always FALSE.
Finally, Toggle would dynamically set all three.
.LP
In this case, the expose procedures for Command and Toggle inherit
their superclass's expose procedure. See ``Inheriting Superclass Operations''.
.\" Beta release
.\"
.\".NH 3
.\"Widget Expose Procedure Issues
.\".XS
.\"\*(SN Widget Expose Procedure Issues
.\".XE
.\".LP
.\"What to say about complicated widgets that really want backing store?
.NH 2
Exposure Compression
.XS
\*(SN Exposure Compression
.XE
.LP
.IN "compress_expose field"
Many widgets are so simple that they always redisplay the entire widget in
their expose procedure.  These widgets do not care about getting partial
expose events.  If the compress_expose field in the widget class
structure is TRUE, 
the Event Manager calls the widget's expose 
procedure only for Expose events in which the expose count is zero (0).
.NH 2
Widget Visibility
.XS
\*(SN Widget Visibility
.XE
.LP
Some widgets may use substantial computing resources to display data.  However,
this effort is wasted if the widget is not actually visible on the screen.
That is, the widget may be obscured by another application or iconified.
.LP
.IN "Visibility"
.IN "Visible"
The visible field in the Core widget structure provides a hint to the
widget that it need not display data.  This field is guaranteed TRUE 
(by the time an ExposeNotify event is processed) if the widget is visible 
and is usually FALSE if the widget is not visible.
.LP
Widgets can use or ignore the visible hint as they wish.
If they ignore it, they should have visible_interest in their 
widget class record set FALSE.  
In such cases, the visible field is initialized TRUE and never changes.
If visible_interest is TRUE, 
the Event Manager asks for
.PN VisibilityNotify 
events for the widget, and updates the \fIvisible\fP field accordingly.
.NH 1 
Size and Position of Widgets \*- Geometry Management
.XS
\*(SN Size and Position of Widgets \*- Geometry Management
.XE
.LP
.IN "geometry_manager field"
.IN "Geometry Management"
.IN "Configure Window"
A widget does not directly control its size and location. 
This is the responsibility of the parent of that widget.
In general, the position of children is left up to their parent.
However, the widget itself often has the best idea of its optimal size 
and may also have a preferred location. 
.LP
To resolve physical layout conflicts between sibling widgets and between
a widget and its parent, the \*(tk provides the Geometry Management mechanism. 
Almost all composite widgets have a geometry manager (geometry_manager field
in the widget class record) that is responsible for the size, position, and 
stacking depth of the widget's children.  The only exception are fixed boxes 
like Scrollbar, which create their children themselves and can ensure that
their children will never make a geometry request.
.LP
Widgets that wish to change their size, position, border width, or stacking
depth can not use X calls directly. 
Instead, they must ask their parent's geometry 
manager to change it for them.  When a child makes a request of the parent's 
geometry manager, the geometry manager can do one of the following:
.IP \(bu 5
Allow the request
.IP \(bu 5
Disallow the request
.IP \(bu 5
Suggest a compromise
.LP
Geometry requests are always made by the child itself. 
Clients that wish to change the geometry of a widget should call
.IN "XtSetValues"
.PN XtSetValues
on the appropriate geometry fields.
.LP
When the geometry manager is asked to change the geometry of a
particular child, the geometry manager may also rearrange and
resize any or all of the other children it controls.  The geometry manager
can move children around freely using
.IN "XtMoveWidget"
.PN XtMoveWidget .
When it resizes a child (that is, changes width, height, or 
border_width), it should inform each affected child by calling
.IN "XtResizeWidget"
.PN XtResizeWidget .
.LP
Often, geometry managers find that they can satisfy a request only if
they can reconfigure a widget that they are not in control of (in particular,
when the composite widget wants to change its own size).  In this case,
the geometry manager makes a request to its parent's geometry manager.
Geometry requests can cascade this way to arbitrary depth.
.LP
Because such cascaded arbitration of widget geometry may involve extended
negotiation, windows are not actually allocated to widgets at application
startup until all widgets are satisfied with their geometry.  See
``XtRealizeWidget'' and ``Creating Widgets'' for more details.
.NH 2
Making Geometry Manager Requests
.XS
\*(SN Making Geometry Manager Requests
.XE
.LP
To make a general geometry manager request, use 
.IN "XtMakeGeometryRequest"
.PN XtMakeGeometryRequest .
The definition for this function is:
.FD 0
XtGeometryResult XtMakeGeometryRequest(\fIw\fP, \fIrequest\fP,\fIreply\fP)
.br
      Widget \fIw\fP;
.br
      XtWidgetGeometry *\fIrequest\fP;
.br
      XtWidgetGeometry *\fIreply\fP;	
.FN
.IP \fIw\fP 1i
Specifies the widget.
.IP \fIrequest\fP 1i
Specifies the desired widget geometry (size, position, border width, 
and stacking order).
.IP \fIreply\fP 1i
Specifies an argument in which the allowed widget size is returned.  If a widget
is not interested in handling 
.IN "XtGeometryAlmost"
.PN XtGeometryAlmost , 
the reply parameter can be NULL.
.LP
The return codes from geometry managers are:
.IN "XtGeometryResult"
.LP
.DS 0
.TA .5i 1.75i
.ta .5i 1.75i
typedef enum _XtGeometryResult {
	XtGeometryYes,	
	XtGeometryNo,	
	XtGeometryAlmost,	
} XtGeometryResult; 
.DE
.LP
The 
.IN "XtWidgetGeometry"
.PN XtWidgetGeometry 
structure is quite similar but not
identical to the corresponding Xlib structure:
.LP
.IN "XtGeometryMask"
.DS 0
.TA .5i 3i
.ta .5i 3i
typedef unsigned long XtGeometryMask;

typedef struct {
	XtGeometryMask \fIrequest_mask\fP;
	Position \fIx\fP, \fIy\fP;
	Dimension \fIwidth\fP, \fIheight\fP;
	Dimension \fIborder_width\fP;
	Widget \fIsibling\fP;
	int \fIstack_mode\fP;
} XtWidgetGeometry;
.DE
.LP
The request_mask definitions are from
.IN "<X/X.h>" 
.PN <X/X.h> :
.LP
.DS 0
.TA .5i 2.5i
.ta .5i 2.i
	#define CWX	(1<<0)
	#define CWY	(1<<1)
	#define CWWidth	(1<<2)
	#define CWHeight	(1<<3)
	#define CWBorderWidth	(1<<4)
	#define CWSibling	(1<<5)
	#define CWStackMode	(1<<6)
.DE
.LP
.IN "XtMakeGeometryRequest"
.PN XtMakeGeometryRequest ,
in exactly the same manner
as the Xlib routine 
.IN "XConfigureWindow"
.PN XConfigureWindow ,
uses the request_mask to determine which fields in the 
.IN "XtWidgetGeometry"
.PN XtWidgetGeometry 
structure you want to specify. 
.LP
The stack_mode definitions are from
.IN "<X/X.h>" 
.PN <X/X.h> :
.LP
.DS 0
.TA .5i 2.5i
.ta .5i 2.5i
	#define Above	0
	#define Below	1
	#define TopIf	2
	#define BottomIf	3
	#define Opposite	4
	#define XtDontChange	5
.DE
.\" Beta release
.\"
.\".LP
.\"[[ Make sure ``DontChange'' makes it into the .h file. ]]
.LP
(See the Xlib manual for definition and behavior of 
.PN Above , 
.PN Below , 
.PN TopIf ,
.PN BottomIf , 
and 
.PN Opposite .)
.LP
The
.IN "XtMakeGeometryRequest"
.PN XtMakeGeometryRequest 
function is a simple routine.
If the parent is not a subclass of Composite,
.PN XtMakeGeometryRequest 
issues an error.
If the parent's geometry_manager is NULL,
.PN XtMakeGeometryRequest 
issues an error.
If being_destroyed is TRUE,
.PN XtMakeGeometryRequest 
returns 
.IN "XtGeometryNo"
.PN XtGeometryNo .
If managed is FALSE, 
.PN XtMakeGeometryRequest 
issues a warning and returns 
.PN XtGeometryNo .
Otherwise,
.PN XtMakeGeometryRequest
calls the parent's geometry_manager procedure with the given parameters.
.LP
If the parent's geometry manager returns 
.IN "XtGeometryYes"
.PN XtGeometryYes
and the widget is realized,
.PN XtMakeGeometryRequest
reconfigures the widget's window by calling
.IN "XResizeWindow"
.PN XResizeWindow .
.NH 2
Making Resize Requests
.XS
\*(SN Making Resize Requests
.XE
.LP
To make a simple resize request, use
.IN "XtMakeResizeRequest"
.PN XtMakeResizeRequest .
The definition for this function is:
.FD 0
XtGeometryResult XtMakeResizeRequest(\fIw\fP, \fIwidth\fP, \fIheight\fP, \fIreplyWidth\fP, \fIreplyHeight\fP)
.br
      Widget \fIw\fP;
.br
      Dimension \fIwidth\fP, \fIheight\fP;
.br
      Dimension *\fIreplyWidth\fP, *\fIreplyHeight\fP
.FN
.IP \fIw\fP 1i
Specifies the widget.
.IP \fIwidth\fP 1i
Specifies the desired widget width.
.IP \fIheight\fP 1i
Specifies the desired widget height.
.IP \fIreplyWidth\fP 1i
Specifies an argument in which the allowed widget width is returned.
.IP \fIreplyHeight\fP 1i
Specifies an argument in which the allowed widget height is returned.
.LP
.PN XtMakeResizeRequest
is a simple interface to 
.PN XtMakeGeometryRequest .
It creates a 
.PN XtWidgetGeometry 
structure and specifies that width and height should change. 
The geometry manager is free to modify any of the other window attributes
(position or stacking order) in order to satisfy the resize request. If the
return value is 
.PN XtGeometryAlmost ,
.IN "XtGeometryAlmost"
replyWidth and replyHeight contain a
``compromise'' width and height. If these are acceptable the widget should
immediately make an 
.PN XtResizeRequest
.IN "XtResizeRequest"
requesting the compromise width and height.
.LP
If the widget is not interested in 
.PN XtGeometryAlmost 
replies, it can pass NULL for replyWidth and replyHeight.
.NH 2
Geometry Manager Responsibilities: the geometry_manager procedure
.XS
\*(SN Geometry Manager Responsibilities: the geometry_manager procedure
.XE
.LP
.IN "geometry_manager procedure"
.IN "XtGeometryHandler"
Specific geometry managers are of type XtGeometryHandler:
.FD 0
typedef XtGeometryResult (*\fIXtGeometryHandler\fP)();
.br
      Widget \fIw\fP;
.br
      XtWidgetGeometry *\fIrequest\fP;
.br
      XtWidgetGeometry *\fIreply\fP;	
.FN
A zero (0) bit in the request mask means that you do not care about the value of 
the corresponding field. 
Then, the geometry manager can change it as it wishes.  
A one (1) bit means that you
want that geometry element changed to the value in the corresponding field.
.LP
If the geometry manager can satisfy all changes requested, it updates the
widget's position fields (x, y) with
.IN "XtMoveWidget"
.PN XtMoveWidget ,
and updates width, height, and border_width directly, and
then returns 
.IN "XtGeometryYes"
.PN XtGeometryYes .  
The value of the reply parameter is undefined.  
(The widget's window is resized automatically by
.IN "XtMakeGeometryRequest"
.PN XtMakeGeometryRequest .)
.LP
Note that the geometry manager does not call the widget's resize
procedure if it returns 
.IN "XtGeometryYes"
.PN XtGeometryYes .
Then, the widget must perform whatever
resizing calculations are needed explicitly.  This costs primitive widgets
an extra line, but it substantially simplifies the writing of nice
composite widgets.
.LP
If the geometry manager chooses to disallow the request, 
the widget cannot change it geometry.  The value of the reply parameter is
undefined, and the geometry manager returns 
.IN "XtGeometryNo"
.PN XtGeometryNo .
.LP
Sometimes the geometry manager cannot satisfy the request exactly,
but it may be able to satisfy what it considers a similar request. 
That is, it could
satisfy only a subset of the requests (for example, size but not position),
satisfy a request only if other changes take
place (for example, size can be changed if the widget is moved to a particular
location), or satisfy a lesser request
(for example, it can't make the child as big as the
request but it can make the child bigger than its current size).
.LP
In such cases, the geometry manager fills in reply with the actual changes
it is willing to make and returns 
.IN "XtGeometryAlmost"
.PN XtGeometryAlmost .
If a bit in reply.request_mask is zero (0), the geometry manager will not change
the corresponding value.  If a bit is one (1), the
geometry manager will change that element to the corresponding
value in the reply parameter.
.LP
When 
.IN "XtGeometryAlmost"
.PN XtGeometryAlmost 
is returned, the widget must decide if the compromise
suggested in the reply is acceptable. 
If so, the widget must not change its geometry directly.
Rather, it should make another call to
.IN "XtMakeGeometryRequest"
.PN XtMakeGeometryRequest .
.LP
If the next geometry request on this window uses the reply box filled in by an
.IN "XtGeometryAlmost"
.PN XtGeometryAlmost 
return and if there have been no intervening geometry requests on
either its parent or any of its children, 
the request is guaranteed to succeed. 
That is, if you ask again right away with the returned geometry,
you will get an answer of 
.IN "XtGeometryYes"
.PN XtGeometryYes .
.LP
To return an 
.PN XtGeometryYes , 
the geometry manager will frequently
rearrange the position of other managed children. 
To do this, it should call
the procedure
.IN "XtMoveWidget"
.PN XtMoveWidget
described below.  However, a few geometry managers may sometimes change the size of
other managed children. 
To do this, they should call the procedure
.PN XtResizeWidget
described below.
.NH 3
XtMoveWidget
.XS
\*(SN XtMoveWidget
.XE
.LP
Geometry managers should call
.IN "XtMoveWidget"
.PN XtMoveWidget
to move their children widget around.  The definition for this function is:
.FD 0
void XtMoveWidget(\fIw\fP, \fIx\fP, \fIy\fP)
.br
      Widget \fIw\fP;
.br
      Position \fIx\fP;
.br
      Position \fIy\fP;	
.FN
.IP \fIw\fP 1i
Specifies the widget.
.IP \fIx\fP 1i
.br
.ns
.IP \fIy\fP 1i
Specifies the new widget coordinates.
.LP
.PN XtMoveWidget
writes the new x and y values into the widget and, if the widget is realized, issues an
.IN "XMoveWindow"
.PN XMoveWindow
call on the widget's window.
.NH 3
XtResizeWidget
.XS
\*(SN XtResizeWidget
.XE
.LP
Geometry managers should call
.IN "XtResizeWidget"
.PN XtResizeWidget
to resize children widgets (except the child making the geometry request).
The definition for this function is:
.FD 0
void XtResizeWidget(\fIw\fP, \fIwidth\fP, \fIheight\fP, \fIborder_width\fP)
.br
      Widget \fIw\fP;
.br
      Dimension \fIwidth\fP;
.br
      Dimension \fIheight\fP;	
.br
      Dimension \fIborder_width\fP;	
.FN
.IP \fIw\fP 1i
Specifies the widget.
.br
.IP \fIwidth\fP 1i
.br
.ns
.IP \fIheight\fP 1i
.br
.ns
.IP \fIborder_width\fP 1i
Specify the new widget size.
.LP
.PN XtResizeWidget
writes the new width, height, and border_width values into 
the widget and, if the widget is realized, issues an
.IN "XConfigureWindow"
.PN XConfigureWindow
call on the widget's window.
.LP
If the new width or height are different from the old values, 
.PN XtResizeWidget
calls the widget's resize procedure to notify it of the size change.
.NH 2
Widget Resizing Responsibilities: the resize procedure
.XS
\*(SN Widget Resizing Responsibilities: the resize procedure
.XE
.LP
A child can be involuntarily resized by its parent at any time.
Widgets usually want to know when they have changed size, so they
can re-layout their displayed data to match the new size.  When
a geometry manager resizes a child it calls
.IN "XtResizeWidget"
.PN XtResizeWidget ,
which updates the geometry fields in the widget, configures the window if the
widget is realized, and calls the child's resize procedure to notify 
the child.
.LP
The resize procedure should recalculate the layout of internal data
as needed.  (For example, a centered Label in a window that changes size
should recalculate the starting position of the text.)
The widget must obey resize as a command and must not treat it as a request.
A widget cannot issue an 
.IN "XtMakeGeometryRequest"
.PN XtMakeGeometryRequest
call from its resize procedure.
.NH 1 
Input Focus
.XS
\*(SN Input Focus
.XE
.LP
This section discusses the underlying philosophy of the \*(tk input focus
management.
.LP
.IN "accept_focus procedure"
Widgets that want the input focus can call 
.IN "XSetInput"
.PN XSetInputFocus 
directly. To allow others to cause a widget to get the input focus, 
every widget exports an accept_focus
procedure.  Widgets interested in knowing when they lose the input
focus must use the X11 focus notification mechanism directly.
Widgets that never want the input focus should set their accept_focus procedure to 
NULL.
.LP
.IN "move_focus_to_next procedure"
.IN "move_focus_to_prev procedure"
Composite widgets are required to export two additional functions:
move_focus_to_next and move_focus_to_prev.
.\" Beta release
.\"
.\"[[ Required only if \fIaccept_focus\fP is non-NULL? ]]
These procedures move the input focus to the next child widget that wants it
and to the previous child widget that wants it, respectively. 
The definition of next and previous is left to each individual widget. 
In addition, composite widgets are free to implement other
procedures to move the input focus between their children.
Both move_focus_to_next and move_focus_to_prev should be entered in 
the widget class action table, so that they are available to translation specifications.
.\" Beta release
.\"
.\".NH 2
.\"Input Focus Issues
.\".XS
.\"\*(SN Input Focus Issues
.\".XE
.\".LP
.\"Should there be an 
.\".PN XtFocusWidget
.\"procedure, which (if possible) sets the
.\"focus to a particular widget? An 
.\".PN XtAcceptsFocus
.\"function?
.\".LP
.\"I do not understand how this mechanism is used to make widgets operate
.\"consistently with a real-estate focusing window manager.  That is, say clicking
.\"anywhere on a composite widget (using a click-based focusing window manager)
.\"sets focus to one of its children (say the
.\"file-name text box).  How do I accomplish the isomorphic behavior with a
.\"Enter/ExitWindow focus mechanism \*- entering the composite widget should set
.\"focus to one of its children, but leaving the composite widget should remove
.\"focus again.
.\".LP
.\"And given the mechanism, how does the widget know which type
.\"of focus stuff to use?  Can we define things such that the widgets perform the
.\"same code regardless, and the intrinsics do the right thing depending upon
.\"the type of window manager?
.\".LP
.\"What is the relationship between sensitivity and focus?
.\".LP
.\"How do applications implement ``recover focus''?
.NH 1 
Selections
.XS
\*(SN Selections
.XE
.LP
Arbitrary widgets (possibly not all in the same application) communicate with
each other by means of the selection mechanism defined by the server and Xlib. See
the Xlib manual for details.
.\" Beta release
.\"
.\".LP
.\"[[ Terry has code for registering callbacks for this and for short-circuiting
.\"the server round-trip when doing cut/paste within an application.  We'll
.\"incorporate these when he is happy with them. ]]
.NH 1
Resource Management
.XS
\*(SN Resource Management
.XE
.LP
Writers of widgets need to obtain a large set of resources at widget
creation time.  Some of the resources come from the resource database,
some from the argument list supplied, and some from the
internal defaults specified for the widget.  
Resources are obtained first from the
argument list, then from the resource database for all resources not
specified in the argument list, and lastly from the internal default, if needed.
.LP
A resource is a field in the widget record with a corresponding
resource entry in the widget's resource list (or in a superclass's resource
list).  This means that the field is
settable by 
.IN "XtCreateWidget"
.PN XtCreateWidget
(by naming the field in the argument list), by an
entry in the default file (by using either the name or class), and by
.IN "XtSetValues"
.PN XtSetValues .
In addition, it is readable by 
.IN "XtGetValues"
.PN XtGetValues .
.LP
Not all fields in a widget record are resources.  
Some are for ``bookkeeping'' use by the
generic routines (like managed and being_destroyed). 
Other may be
for local bookkeeping, and still others are derived from resources (many GCs and
Pixmaps).
.\" Beta release
.\"
.\".NH 2
.\"Resource Issues
.\".XS
.\"\*(SN Resource Issues
.\".XE
.\".LP
.\"There is no way of disposing of large resources.  Should
.\"there be a back door into the resource manager caching, which could do
.\"reference counting?
.NH 2
XtOffset
.XS
\*(SN XtOffset
.XE
.LP
To determine the byte offset of a field within a structure, use the macro
.IN "XtOffset"
.PN XtOffset .
The definition for this macro is:
.FD 0
Cardinal XtOffset(\fIpointer_type\fP, \fIfield_name\fP)
.br
      Type \fIpointer_type\fP;
.br
      Field \fIfield_name\fP;
.FN
.IP \fIpointer_type\fP 1i
Specifies a type that points to the structure.
.IP \fIfield_name\fP 1i
Specifies the name of the field to calculate the byte offset from.
.LP
.PN XtOffset
is usually used to determine the offset of various resource fields from the 
beginning of a widget.
.NH 2
XtNumber
.XS
\*(SN XtNumber
.XE
.LP
To determine the number of elements in a fixed-size array, use the macro
.IN "XtNumber"
.PN XtNumber .
The definition for this macro is:
.FD 0
Cardinal XtNumber(\fIarray\fP)
.br
      ArrayVariable \fIarray\fP;
.FN
.IP \fIarray\fP 1i
Specifies a fixed-size array.
.LP
.PN XtNumber
is used to pass the number of elements in argument lists, resources lists, and
other counted arrays.
.NH 2
Resource Lists
.XS
\*(SN Resource Lists
.XE
.LP
.IN "Resource Management"
A resource entry specifies a field in the widget, the textual name and class of
the field that argument lists and external default file use to refer to the
field, and a default value that the field should get if no value is specified.
The declaration for the 
.IN "XtResource"
.PN XtResource 
structure is:
.LP
.DS 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	String \fIresource_name\fP;
	String \fIresource_class\fP;
	String \fIresource_type\fP;
	Cardinal \fIresource_size\fP;
	Cardinal \fIresource_offset\fP;
	String \fIdefault_type\fP;
	caddr_t \fIdefault_address\fP;
} XtResource, *XtResourceList;
.DE
.IN "XtResourceList"
.LP
The resource_name field contains the name used by clients to access the field in the
widget.  By convention, it starts with a lower-case letter and
is spelled almost identically to the field name,
except (underbar, character) is replaced by (capital character). 
For example, the resource name for background_pixel is backgroundPixel.
.LP
The resource_class field contains the class of the resource.  A resource is rarely
a widget.  Therefore, a resource class is not the same as a widget class, but there are
some resemblances.  A resource class offers two functions: 
.IP \(bu 5
It isolates you from different representations that widgets may use for a 
similar resource
.IP \(bu 5
It lets you specify several actual resources with a single name.  A resource class
should be chosen to span a group of closely-related fields.
.LP
For example, a widget may have several resource pixels: background, foreground,
border, block cursor, mouse cursor, and so on.  Typically, the background defaults to 
``white'' and everything else to ``black''.  The resource class for
each of these resources should be chosen so that it takes the minimal number
of entries in the resource database to make background ``offwhite''
and everything else ``darkblue''.
.LP
In this case, giving background a resource class of 
.IN "Background"
.PN Background 
and all the other pixel entries a resource class of 
.IN "Foreground"
.PN Foreground 
is the right thing to do. 
(By convention, resource classes are always spelled starting with a capital
letter.)
.LP
The resource_type field is the physical representation type of the resource.  By
convention, it starts with an upper-case letter and is usually
spelled identically to the type name of the field.
The resource type is used when resources are fetched, to
convert from the resource database format (usually String) or the default
resource format (just about anything) to the desired
physical representation (see ``Resource Conversions'').
.LP
The resource_size field is the size of the physical representation in bytes.
The resource_offset is the offset in bytes of the field within the widget.
The macro 
.IN "XtOffset"
.PN XtOffset
in Intrinsic.h should be used to retrieve this value.
.LP
The default_type field is the representation type of the default resource value.
If default_type is different from resource_type and the 
default_type is needed, the resource manager invokes a conversion 
procedure from default_type to resource_type.
.LP
The default_address field is the address of the default resource value.  The 
default is used only if a resource is not specified in the argument list 
or in the resource database.
.LP
The routines
.IN "XtSetValues"
.PN XtSetValues
and
.IN "XtGetValues"
.PN XtGetValues
also use the resource list to set and get widget state.  See sections
``XtGetValues'' and ``XtSetValues''.
.NH 2
Superclass to Subclass Chaining of Resource Lists
.XS
\*(SN Superclass to Subclass Chaining of Resource Lists
.XE
.LP
.IN "Inheritance"
.IN "Superclass Chaining"
.IN "Chaining"
The procedure
.IN "XtCreateWidget"
.PN XtCreateWidget
gets resources as a ``superclass-to-subclass'' operation.  That is, the
resources specified in Core's resource list are fetched, then those in the
subclass, and on down to the resources specified for this widget's class.
.LP
In general, if a widget field is declared in a superclass,
that field is included in the superclass's resource list and need not be
included in the subclass's resource list.  For example, the Core class
contains a resource entry for background_pixel. 
Consequently, the implementation of ``Label'' need not also have a resource entry 
for background_pixel.
However, a subclass, just by specifying a resource entry for that field in its own
resource list, can override the resource entry for any field declared in a
superclass. 
The translations field is frequently overridden by subclasses.
.NH 2
XtGetSubresources
.XS
\*(SN XtGetSubresources
.XE
.LP
A widget needs to do nothing to get its resources.
That is,
.IN "XtCreateWidget"
.PN XtCreateWidget
does this automatically before calling the initialize procedure.
Some widgets have subparts which are not children, but for which the widget 
would like to fetch resources.  These widgets call
.IN "XtGetSubresources"
.PN XtGetSubresources
to accomplish this.  The definition for this function is:
.FD 0
void XtGetSubresources(\fIw\fP, \fIbase\fP, \fIname\fP, \fIclass\fP, \
\fIresources\fP, \fInum_resources\fP, \fIargs\fP, \fInum_args\fP)
.br
      Widget \fIw\fP;
.br
      caddr_t \fIbase\fP;
.br
      String \fIname\fP;
.br
      String \fIclass\fP;
.br
      XtResourceList \fIresources\fP;
.br
      Cardinal \fInum_resources\fP;
.br
      ArgList \fIargs\fP;
.br
      Cardinal \fInum_args\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget that wants resources for a subpart.
.IP \fIbase\fP 1i
Specifies the base address of the subpart data structure where the resources
should be written.
.IP \fIname\fP 1i
Specifies the name of the subpart.
.IP \fIclass\fP 1i
Specifies the class of the subpart.
.IP \fIresources\fP 1i
Specifies the resource list for the subpart.
.IP \fInum_resources\fP 1i
Specifies the number of resources in \fIresources\fP.
.IP \fIargs\fP 1i
Specifies the argument list to override resources obtained from the resource
database.
.IP \fInum_args\fP 1i
Specifies the number of arguments in the argument list.  
If the specified args is NULL, 
num_args must be zero (0).  However, if num_args is zero (0),
args need not be NULL.
.LP
.PN XtGetSubresources
constructs a name/class list from the widget (and all ancestors) and then appends
the name/class pair passed in.  The resources are fetched from the argument 
list, database, or default in the resource list and are copied into the subpart 
record.
.NH 2
Resource Conversions
.XS
\*(SN Resource Conversions
.XE
.LP
The \*(tk defines all the resources and representations used in the Core widget.
It also registers some resource conversions in addition to the standard
resource conversions described in the Xlib manual.
.\" Beta release
.\"
.\".LP
.\"[[ I can't find any standard conversions documented in the Xlib manual. ]]
.\".LP
.\"[[ Toolkit register String to XtJustify, String to XtIconState, what else ?? ]]
.NH 1
Reading and Writing Widget State
.XS
\*(SN Reading and Writing Widget State
.XE
.LP
Any resource field in a widget can be read or written by a client.  On a write,
the widget decides what changes it will actually allow and updates all
derived fields appropriately.
.NH 2
XtGetValues
.XS
\*(SN XtGetValues
.XE
.LP
To retrieve the current value of a resource associated with a
widget instance, use 
.IN "XtGetValues"
.PN XtGetValues .
The definition for this function is:
.FD 0
void XtGetValues(\fIw\fP, \fIargs\fP, \fInum_args\fP)
.br
      Widget \fIw\fP;
.br
      ArgList \fIargs\fP;
.br
      Cardinal \fInum_args\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.IP \fIargs\fP 1i
Specifies a variable length argument list of name/address
pairs which contain the resource name and the address to store the resource
value into.
The arguments and values passed in args are dependent on
the widget. The storage for argument values which are pointed to by
args must be deallocated by the application when no longer needed.
.IP \fInum_args\fP 1i
Specifies the number of arguments in argument list.
.LP
.IN "XtGetValues"
.PN XtGetValues
starts with the resources specified for the core widget fields
and proceeds down the subclass chain to the widget.
.NH 2
XtSetValues
.XS
\*(SN XtSetValues
.XE
.LP
To modify the current value of an argument associated with a widget
instance, use 
.IN "XtSetValues"
.PN XtSetValues .
The definition for this function is:
.FD 0
void XtSetValues(\fIw\fP, \fIargs\fP, \fInum_args\fP)
.br
      Widget \fIw\fP;
.br
      ArgList \fIargs\fP;
.br
      Cardinal \fInum_args\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.IP \fIargs\fP 1i
Specifies a variable length argument list of name/value
pairs which contain the arguments to be modified and their new
values.
The arguments and values passed are dependent on
the widget being modified.
.IP \fInum_args\fP 1i
Specifies the number of arguments in the argument list.
.LP
.PN XtSetValues
starts with the resources specified for the core widget
fields and proceeds down the subclass chain to the widget.  At each stage, it
writes the new value (if specified by one of the arguments) or the existing
value (if no new value is specified) to a new widget data record.
.LP
.PN XtSetValues
then calls the set_values procedures for the widget in
``superclass-to-subclass'' order.
.NH 3
Setting Widget State: the set_values procedure
.XS
\*(SN Setting Widget State: the set_values procedure
.XE
.IN "set_values procedure"
.IN "XtSetValuesProc"
.FD 0
typedef Boolean (*XtSetValuesProc)();
.br
      Widget \fIcurrent\fP;
.br
      Widget \fIrequest\fP;
.br
      Widget \fInew\fP;
.br
      Boolean \fIlast\fP;
.FN
.IP \fIcurrent\fP 1i
Specifies the existing widget.
.IP \fIrequest\fP 1i
Specifies the widget asked for by the
.IN "XtSetValues"
.PN XtSetValues
call.
.IP \fInew\fP 1i
Specifies a widget with the new values that are actually allowed.
.IP \fIlast\fP 1i
Specifies if this is the last set_values procedure in the chain called by
.PN XtSetValues .
.LP
The set_values procedure should construct any composite
resources that depend upon changed values (for example, many GCs
depend upon foreground and background).  Like the initialize procedure,
set_values mostly deals only with the fields defined in the subclass, but it
has to resolve conflicts with superclass, especially conflicts over width
and height.
In this case, though, the ``reference'' widget is ``current'', not ``request''.
.LP
A ``new'' starts with the values of ``request'' and can be modified
by the superclass.
A widget need not refer to request unless it must resolve conflicts
between ``current'' and ``new''.
Any changes that the widget wishes to make should be made in ``new''.
.PN XtSetValues 
will copy the ``new'' values back into the ``current'' widget instance record 
after class SetValuesProcs have been called.
.LP
If last is TRUE, 
the set_values procedure knows that it is last in
the ``superclass-to-subclass chain''.  
In this case, it should perform any final actions. 
In particular, it should make a geometry request, if needed.
.LP
Finally, the set_values procedure must return a Boolean that indicates whether
the widget needs to be redisplayed.
Note that a change in the geometry fields alone does not require a redisplay.
The X server will eventually generate an Expose event, if necessary.
After calling all the set_values procedures,
.PN XtSetValues
will force a redisplay (by calling
.PN XClearArea )
if any of the set_values procedures returned TRUE.
Therefore, a set_values procedure should not try to do its own redisplaying.
.NH 3
XtSetValuesGeometryRequest
.XS
\*(SN XtSetValuesGeometryRequest
.XE
.LP
.IN "Geometry Management"
To make a geometry request from a set_values procedure, you can use the
procedure
.IN "XtSetValuesGeometryRequest"
.PN XtSetValuesGeometryRequest .
The definition for this function is:
.FD 0
XtGeometryResult XtSetValuesGeometryRequest(\fIcurrent\fP, \fInew\fP, \fIreply\fP)
.br
      Widget \fIcurrent\fP;
.br
      Widget \fInew\fP;
.br
      XtWidgetGeometry *\fIreply\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget as it exists.
.IP \fInew\fP 1i
Specifies the widget as it should be.
.IP \fIreply\fP 1i
Specifies the geometry allowed if result is 
.IN "XtGeometryAlmost"
.PN XtGeometryAlmost .
.LP
.IN "XtSetValuesGeometryRequest"
.PN XtSetValuesGeometryRequest
makes a geometry request if one of the geometry fields in current is
different from the fields in new.  (If no geometry request is needed is
just returns 
.IN "XtGeometryNo"
.PN XtGeometryNo .)
.LP
Note that only the current widget values will be updated.  Do not worry
about this.  The
.IN "XtSetValues"
.PN XtSetValues
procedure knows that it should never just overwrite the widget's geometry
fields.
.NT
This routine currently is not yet implemented.
.NE
.NH 1 
Translation of X Events to Program/Widget functionality
.XS
\*(SN Translation of X Events to Program/Widget functionality
.XE
.LP
Except under unusual circumstances, widgets do not hardwire the mapping of
user events into widget behavior by using the Event Manager.  Instead, they
provide a user-overridable default mapping of events into behavior.
.LP
The translation manager provides an interface to specify and manage the
mapping of X Event sequences into widget-supplied functionality. 
The simplest example would be to call procedure Foo when key ``y'' is pressed.
.\" Beta release
.\"
.\".LP
.\"[[ Should mention that actions may be NULL.  DefineTranslation looks up 
.\"superclass chain?  If all NULL DefineTranslation should issue a warning. ]]
.LP
The translation manager uses two tables to perform translations.  The
``action table'', which is in the widget class structure, specifies the mapping
of externally available procedure name strings to the corresponding procedure
implemented by the widget class.  The ``translation table'', which is in the widget
instance structure, specifies the mapping of event sequence to procedure names.
.LP
For example, the action table for the Command widget class is defined as:
.LP
.IN "Action Table"
.DS 0
.TA .5i 1.5i
.ta .5i 1.5i
XtActionsRec actionTable[] = {
	{"Set",	(caddr_t) Set},
	{"Unset",	(caddr_t) Unset},
	{"Highlight",	(caddr_t) Highlight},
	{"Unhighlight",	(caddr_t) Unhighlight}
	{"Notify",	(caddr_t) Notify},
};
.DE
.LP
The default behavior of Command is:
.IP \(bu 5
Higlighted on enter window
.IP \(bu 5
Unhighlighted on exit window
.IP \(bu 5
Invert on left button down
.IP \(bu 5
Call callbacks and reinvert on left button up
.LP
Command's default translation table is:
.LP
.IN "Translation Table"
.DS 0
.TA .5i 1.5i
.ta .5i 1.5i
static char *defaultTranslations[] = {
	"<EnterWindow>:	Highlight()",
	"<LeaveWindow>:	Unhighlight()",
	"<Btn1Down>:	Set()",
	"<Btn1Up>:	Notify() Unset()",
	NULL
};
.DE
.LP
For details on the syntax of translation tables, see Appendix B. 
.LP
.IN "XtCreateWidget"
.PN XtCreateWidget
calls an internal routine to compile the translation specification into a
structure that efficiently maps incoming events into the specified procedure
calls and registers the necessary events with the Event Manager.  
Widgets need do nothing other than specify the action and translation tables.
.\" Beta release
.\"
.\".LP
.\"[[ I've only cleaned up things to this point. ]]
.NH 3
Translation Tables
.XS
\*(SN Translation Tables
.XE
.LP
Mapping the X Event to procedure calls is accomplished by specifying 
a Translation Table.
Translation tables exist in textual (external) and compiled (internal) forms. 
The compiled form is private to the translation manager and contains the
state tables, the current state, and actions to perform for each state.
The textual form's syntax is described in Appendix B.
.NH 3
Function table
.XS
\*(SN Function table
.XE
.LP
Clients of the translation manager must provide a table (array) of procedure
names to procedure implementations using the following format. 
.LP
.IN "XtActionsRec"
.IN "XtActionList"
.DS 0
.TA .5i 3i
.ta .5i 3i
typedef struct _XtActionsRec {
	char *string;
	caddr_t value;
} XtActionsRec, *XtActionList;
.DE
The string field is the name of the exported function. 
The value field is a pointer to any client supplied data.
The most common use of this is to supply a procedure adress for the
name, but Actions can map onto strings, chars, procedures, atoms, or numbers.
.LP
Each widget class has a table of name-to-procedure bindings for that class.
In addition, 
the translation manager provides a global name to function table containing the
definition of standard utility procedures for setting timers, and the current
values of global values like the double-click time.
.\" Beta release
.\"
.\".NH 2
.\"Translation management issues
.\".XS
.\"\*(SN Translation management issues
.\".XE
.\".LP
.\"How does the application register it's function names?
.\".LP
.\"How do you override specific productions in the translation table?
.\".LP
.\"How are duplicate or conflicting productions handled?
.NH 1
Graphics Contexts
.XS
\*(SN Graphics Contexts
.XE
.LP
The \*(tk provides a mechanism whereby cooperating clients can share
Graphics Contexts, thus, reducing both the number of Graphics Contexts created
and the total number of server calls in any give application. 
The mechanism implemented is a simple caching scheme and all Graphics Contexts
obtained by means of this mechanism must be treated as read-only. 
If a changeable Graphics Context is needed, 
the
.IN "XCreateGC"
.PN XCreateGC 
Xlib function should be used instead. 
.LP
To obtain shared GCs, use 
.IN "XtGetGC"
.PN XtGetGC .
The definition of this function is:
.FD 0
GC XtGetGC(\fIw\fP, \fIvalue_mask\fP, \fIvalues\fP)
.br
      Widget \fIw\fP;
.br
      XtGCMask \fIvalue_mask\fP;
.br
      XGCValues *\fIvalues\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.IP \fIvalue_mask\fP 1i
Specifies which fields of the values are specified. (See 
.IN "XCreateGC"
.PN XCreateGC .)
.IP \fIvalues\fP 1i
Specifies the actual values for this GC. (See 
.PN XCreateGC .)
.LP
.IN "XtGetGC"
.PN XtGetGC 
returns a Graphics Context. 
The parameters to this function are the same as those for 
.PN XCreateGC , 
except that a widget is passed instead of a Display.
.LP
.PN XtGetGC
shares only GCs in which all values in the GC returned by
.PN XCreateGC
are the same. 
In particular, it does not use the value_mask provided to
determine which fields of the GC a widget considers relevant.  The
value_mask is used only to tell the server which fields should be filled in
with widget data and which it should fill in with default values.
.LP
When a Graphics Context is no longer needed it should be deallocated using the
.IN "XtDestroyGC"
.PN XtDestroyGC
procedure. The definition for this procedure is:
.FD 0
void XtDestroyGC(\fIgc\fP)
.br
      GC \fIgc\fP;
.FN
.IP \fIgc\fP 1i
Specifies the gc to be deallocated.
.LP
References to sharable GCs are counted and a free request is generated to the
server when the last user of a GC destroys it.
.\" Beta release
.\"
.\".NH 1
.\"Pixmaps
.\".XS
.\"\*(SN Pixmaps
.\".XE
.\".LP
.\"[[ Needs to be filled in with Mike's stuff. ]]
.NH 1
Errors
.XS
\*(SN Errors
.XE
.\" Beta release
.\"
.\".LP
.\"[[ This section needs updating per new Xlib. ]]
.\".LP
.\"[[ Also support for detecting errors when ``debugging'' on: XtMalloc/malloc?;
.\"XtCheckSubclassOf/null; XtCheckIsWidget/null; etc. ]]
.LP
The \*(tk uses the Xlib error handling interface. 
This facility allows a client to register a procedure to be called 
whenever an error occurs. 
This facility is intended for error logging 
but not for error correction or recovery. 
.\" Beta release
.\"
.\".NH 2 
.\"Error Handling Issues
.\".XS
.\"\*(SN Error Handling Issues
.\".XE
.\".LP
.\"A warning error handling facility is needed for non-fatal errors. Work is
.\"underway to merge the toolkit error handling with Xlib. If this succeeds this
.\"section will be merged with the Xlib manual.
.bp
.SH
Appendix A: \.Xdefaults file format
.XS
\*(SN Appendix A: \.Xdefaults file format
.XE
.LP
The .Xdefaults file is an ASCII text file that consists of a number of lines
with the following EBNF syntax:
.TS
l l .
Xdefault	= {line '\\\\n'}.
line	= (comment | include | production).
comment	= "!" string.
include	= "#INCLUDE" filename.
production	= [hostspec] resourcename ":" string.
resourcename	= ["*"] name {("." | "*") name}.
string	= {<any character not including eol>}.
filename	= <operating system specific>.
hostspec	= <operating system specific, same as X host spec>.
name	= {"A"-"Z" | "a"-"z" | "0"-"9"}.
.TE
The filename is an operating system specific name of a file to 
include textually in place of the include. The hostspec is a system dependent host
specification. 
The intent is to omit any lines containing a hostspec not
matching the host the application is running on. This is determined by
parsing the display_name field of the display variable. Because hostspecs
are likely to include colon characters (``:'') to avoid ambiguity, the hostspec
must not be followed by whitespace. 
However, the colon that separates the resource
name from the resource value string must be followed by whitespace.
.bp
.\" Beta release
.\"
.\".SH
.\"Issues
.\".XS
.\"\*(SN Issues
.\".XE
.\".LP
.\"There is no way to put multi-line strings into the resource database.
.\".NH 1
.\"Appendix B: Binary resource database file format
.\".XS
.\"\*(SN Appendix B: Binary resource database file format
.\".XE
.\".LP
.\".TS
.\"box;
.\"c .
.\"Database File
.\"=
.\"Header
.\"_
.\"Database Entries
.\"\.
.\"\.
.\"\.
.\"_
.\"Quark Table Entries
.\"\.
.\"\.
.\"\.
.\"_
.\"Strings
.\"\.
.\"\.
.\"\.
.\"_
.\"Values
.\"\.
.\"\.
.\"\.
.\".TE
.\".TS
.\"box;
.\"c s s
.\"l l | l .
.\"Header
.\"=
.\"MagicNumber	4 bytes	2393018510
.\"_
.\"DatabaseStart	4 bytes	byte offset in file of start of Database section
.\"_
.\"DatabaseSize	4 bytes	size in bytes of Database section
.\"_
.\"QuarkTblStart	4 bytes	byte offset in file of start of Quark table
.\"_
.\"QuarkTblSize	4 bytes	size in bytes of Quark table
.\"_
.\"StringTblStart	4 bytes	byte offset in file of start of String table
.\"_
.\"StringTblSize	4 bytes	size in bytes of String table
.\"_
.\"ValueTblStart	4 bytes	byte offset in file of start of Value table
.\"_
.\"ValueTblSize	4 bytes	size in bytes of Value table
.\"_
.\"Database	<DatabaseSize> bytes	Resource database records
.\"_
.\"QuarkTbl	<QuarkTblSize> bytes	Quark to string mapping
.\"_
.\"StringTbl	<StringTblSize> bytes	String bodies
.\"_
.\"ValueTbl	<ValueTblSize> bytes	Values
.\".TE
.\"All ``pointers'' are relative to the start of the table they are pointing into
.\"(that is, they are byte indices into the table). Quarks are 4-byte indices into
.\"the Quark table. Value pointers are 4-byte indices into the Value table.
.\"String pointers are 4-byte indices into the string table, and so on.
.\".LP
.\"Each database section entry has the following format:
.\".TS
.\"box;
.\"c s
.\"l | l .
.\"Database
.\"=
.\"Representation	Quark pointer
.\"Value	Value pointer
.\"HashTable	64*HashEntry
.\".TE
.\".LP
.\"Each HashEntry has the following format:
.\".TS
.\"box;
.\"c s
.\"l | l .
.\"Hash Entry
.\"=
.\"NextHash	HashEntryPointer
.\"name	Quark pointer
.\"database	DatabasePointer
.\".TE
.\".LP
.\"HashEntryPointers and DatabasePointers are into the Database section. A
.\"HashEntryPointer is the index of a HashEntry, and a DatabasePointer is the index
.\"of a database entry.
.\" Beta release
.\"
.\".LP
.\"[[ What is the hashing scheme? ]]
.\".LP
.\"The Quark table consists of a series of entries of the form:
.\".TS
.\"box;
.\"c s
.\"l | l .
.\"Quark Table
.\"=
.\"Next	Quark pointer
.\"Signature	4 bytes
.\"QuarkVal	4 bytes
.\"Name	String pointer
.\".TE
.\" Beta release
.\"
.\".LP
.\"[[ How is the quark table organized/implemented. ]]
.\".LP
.\"The String table consists of a series of entries of the form:
.\".TS
.\"box;
.\"c s
.\"l | l .
.\"String Table
.\"=
.\"Length	4 bytes
.\"Body	<Length> bytes
.\".TE
.\".LP
.\"The Value table consists of a mixture of entries of the forms:
.\".TS
.\"box;
.\"c s
.\"l | l .
.\"Value Table
.\"=
.\"Size	4 bytes
.\"Address	Value pointer
.\".TE
.\".LP
.\"and unstructured data.
.bp
.SH
Appendix B: Translation table file syntax
.XS
\*(SN Appendix B: Translation table file syntax
.XE
.LP
A translation table file is an ASCII text file.
.SH
Notation
.XS
\*(SN Notation
.XE
.LP
Syntax is specified in an extended BNF notation with the following
abbreviations:
.LP
	l ::= [ a ] .
.LP
is equivalent to
.LP
	l ::= a | NIL .
.LP
	l ::= { a } .
.LP
is equivalent to
.LP
	l ::= a l | NIL .
.LP
All terminals are enclosed in 'single' quotation marks. Informal descriptions are
enclosed in <angle> brackets.
.SH
Syntax
.XS
\*(SN Syntax
.XE
.LP
The syntax of the translation table file is:
.TS
l l .
translationTable	::= { production '\\\\n' }
production	::= lhs':' rhs
lhs	::= ( event | keyseq ) [ifstate] [setstate]
keyseq	::= '"' keychar {keychar} '"'
keychar	::= [ '^' | '$' ] <ascii character>
event	::= mode'<'eventtype'>'detail
ifstate	::= ',' 'IF' state
setstate	::= ',' 'SET' state
mode	::= <see ``Modes''>
eventtype	::= <see ``Event Types''>
detail	::= <eventtype specific>
rhs	::= { action '(' params ')' }
action	::=  atom
params	::= { atom | "string" | `char' | number }
atom	::= atomchar { atomchar }
atomchar	::= { alpha | digit | '$' | '_' }
alpha	::= <alphabetic character>
digit	::= <decimal digit 0-9>
number	::= digit { digit }
.TE
Informally, the productions are an event specifier on the left (terminated
with a colon) and a list of
action specifications on the right (terminated with a newline).
.LP
The information on the left specifies the X Event, complete with modifiers and
detail fields, while that on
the right specifies what to do when that event is detected. An action
is the name of an exported function. The atoms, strings, chars, and
numbers are parameters to the function.
.SH
Modes
.XS
\*(SN Modes
.XE
.LP
The Mode field is used to specify normal X keyboard and button modifier mask
bits:
.TS H
box;
l l.
_
.sp 6p
.TB
Mode	Meaning
.sp 6p
_
.sp 6p
.TH
.R
c	Control Key
Ctrl	Control Key
s	Shift Key
Shift	Shift Key
m	Meta Key
Meta	Meta Key
l	Lock Key
Lock	Lock Key
1	Modifier 1
Mod1	Modifier 1
2	Modifier 2
Mod2	Modifier 2
3	Modifier 3
Mod3	Modifier 3
4	Modifier 4
Mod4	Modifier 4
5	Modifier 5
Mod5	Modifier 5
.sp 6p
_
.TE
.LP
The character \~ when used as a prefix to the Mode specifies that the
modifier key must be up.  If a modifier key is omitted from a mode field
specification, then it is assumed that the user does not care whether the
key is up or down.
.SH
Event Types
.XS
\*(SN Event Types
.XE
.LP
The EventType field describes XEvent types. The following are the currently
defined EventType values:
.TS H
box;
l l.
_
.sp 6p
.TB
Type	Meaning
.sp 6p
_
.sp 6p
.TH
.R
Key	KeyPress
KeyDown	KeyPress
KeyUp	KeyRelease
BtnDown	ButtonPress
BtnUp	ButtonRelease
Motion	MotionNotify
Enter	EnterNotify
Leave	LeaveNotify
FocusIn	FocusIn
FocusOut	FocusOut
Keymap	KeymapNotify
Expose	Expose
GrExp	GraphicsExpose
NoExp	NoExpose
Visible	VisibilityNotify
Create	CreateNotify
Destroy	DestroyNotify
Unmap	UnmapNotify
Map	MapNotify
MapReq	MapRequest
Reparent	ReparentNotify
Configure	ConfigureNotify
ConfReq	ConfigureRequest
Grav	GravityNotify
ResReq	ResizeRequest
Circ	CirculateNotify
CircReq	CirculateRequest
Prop	PropertyNotify
SelClr	SelectionClear
SelReq	SelectionRequest
Select	SelectionNotify
Clrmap	ColormapNotify
Message	ClientMessage
Mapping	MappingNotify
Timer	Toolkit Timer Event
EventTimer	Toolkit ``Event Timer'' event
.sp 6p
_
.TE
Supported Abbreviations:
.TS H
box;
l l.
_
.sp 6p
.TB
Abbreviation	Meaning
.sp 6p
_
.sp 6p
.TH
.R
Ctrl	KeyPressed with control modifier.
Meta	KeyPressed with meta modifier.
Shift	KeyPressed with shift modifier.
Btn1Down	ButtonPress with Btn1 detail
Btn1Up	ButtonRelease with Btn1 detail
Btn2Down	ButtonPress with Btn2 detail
Btn2Up	ButtonRelease with Btn2 detail
Btn3Down	ButtonPress with Btn3 detail
Btn3Up	ButtonRelease with Btn3 detail
Btn4Down	ButtonPress with Btn4 detail
Btn4Up	ButtonRelease with Btn4 detail
Btn5Down	ButtonPress with Btn5 detail
Btn5Up	ButtonRelease with Btn5 detail
.sp 6p
_
.TE
.LP
The Detail field is event specific and normally corresponds to the 
detail field of an X Event, for example, <Key>A.
In the event that no event bindings are specified externally,
the widget class specifies the default bindings in textual form.
.\" Beta release
.\"
.\".NH 2
.\"Issues
.\".XS
.\"\*(SN Issues
.\".XE
.\".LP
.\"Need to specify exact syntax of detail for each event.
.\".LP
.\"States are not implemented for Version 1.0.
.\".LP
.\"The current syntax is awkward for complex descriptions, such as commonly arise 
.\"in text. What is the best way to specify the state machine?
.\".LP
.\"How is detail for keyboard events specified? Is detail of ``a'' different from
.\"``A''
.\".LP
.\"Need a convenient abbreviation for ``escape'' character.
.\".LP
.\"Mouse motion should \fIalways\fP be an epsilon transition.
.\".LP
.\"Need an ``else'' syntax especially for keyboard events.
.\".LP
.\"Are mouse, buttons, and keyboard completely independent? Is click-down,
.\"keyboard event, click-up, keyboard event, click-down, a double-click or not?
.\".LP
.\"A mechanism for providing variables to procedure calls is needed.
.\".LP
.\"The selection heirarchy (circular multi-click semantics) is not well supported.
.\".LP
.bp
.SH
Appendix C: Intrinsic.h
.XS
\*(SN Appendix C: Intrinsic.h
.XE
.LP
.C{
.so Intrinsic.h
.C}

.TC
