.na
.de FD
.LP
.KS
.TA 1.0i 3i
.ta 1.0i 3i
.nf
..
.de FN
.fi
.KE
.LP
..
.de IN		\" send an index entry to the stderr
..
.de C{
.KS
.nf
.D
.\"
.\"	choose appropriate monospace font
.\"	the imagen conditional, 480,
.\"	may be changed to L if LB is too
.\"	heavy for your eyes...
.\"
.ie "\\*(.T"480" .ft L
.el .ie "\\*(.T"300" .ft L
.el .ie "\\*(.T"202" .ft PO
.el .ie "\\*(.T"aps" .ft CW
.el .ft R
.ps \\n(PS
.ie \\n(VS>40 .vs \\n(VSu
.el .vs \\n(VSp
..
.de C}
.DE
.R
..
.de PN
.ie t \f(H\|\\$1\|\fR\\$2
.el \fI\|\\$1\|\fP\\$2
..
.de NT
.ne 7
.ds NO Note
.if \\n(.$>$1 .if !'\\$2'C' .ds NO \\$2
.if \\n(.$ .if !'\\$1'C' .ds NO \\$1
.ie n .sp
.el .sp 10p
.TB
.ce
\\*(NO
.ie n .sp
.el .sp 5p
.if '\\$1'C' .ce 99
.if '\\$2'C' .ce 99
.in +5n
.ll -5n
.R
..
.		\" Note End -- doug kraft 3/85
.de NE
.ce 0
.in -5n
.ll +5n
.ie n .sp
.el .sp 10p
..
.ny0
.TH XSetErrorHandler 3X 
.SH NAME
XSetErrorHandler, XGetErrorText, XGetErrorDatabaseText, XDisplayName, XSetIOErrorHandler \- default error handlers
.SH SYNTAX
.\" $Header: XErrHndlr.f,v 11.4 87/08/15 12:12:22 mento Exp $
XSetErrorHandler\^(\^\fIhandler\fP\^)
.br
      int (\^*\^\fIhandler\fP\^)\^(Display *, XErrorEvent *)
.LP
.\" $Header: XErrDescrip.f,v 11.7 87/08/15 12:12:21 mento Exp $
XGetErrorText\^(\^\fIdisplay\fP, \fIcode\fP, \fIbuffer_return\fP, \fIlength\fP\^)
.br
      Display *\fIdisplay\fP\^;
.br
      int \fIcode\fP\^;
.br
      char *\fIbuffer_return\fP\^;
.br
      int \fIlength\fP\^;
.LP
char *XDisplayName\^(\^\fIstring\fP\^)
.br
      char *\fIstring\fP\^;
.LP
.\" $Header: XIOErrHnd.f,v 11.4 87/08/15 12:13:53 mento Exp $
XSetIOErrorHandler\^(\^\fIhandler\fP\^)
.br
      int (\^*\^\fIhandler\fP\^)\^(Display *);
.LP
XGetErrorDatabaseText\^(\^\fIdisplay\fP, \fIname\fP, \fImessage\fP, \fIdefault_string\fP, \fIbuffer_return\fP, \fIlength\fP\^)
.br
      Display \fIdisplay\fP\^;
.br
      char *\fIname\fP, *\fImessage\fP\^;
.br
      char *\fIdefault_string\fP\^;
.br
      char *\fIbuffer_return\fP\^;
.br
      int \fIlength\fP\^;
.SH ARGUMENTS
.IP \fIbuffer\fP 1i
Specifies the buffer that you want the error message stored in.
.\" $Header: code.a,v 11.2 87/03/28 10:54:44 mento Exp $
.IP \fIcode\fP 1i
Specifies the error code for which you want to obtain a description.
.IP \fIdefault_string\fP 1i
Specifies the default error message.
.\" $Header: display.a,v 11.8 87/09/03 11:02:24 mento Exp $
.IP \fIdisplay\fP 1i
Specifies the connection to the X server.
.\" $Header: handler.a,v 11.2 87/03/28 10:56:42 mento Exp $
.IP \fIhandler\fP 1i
Specifies the program's supplied error handler.
.IP \fIlength\fP 1i
Specifies the size of the buffer.
.\" $Header: type_err.a,v 1.3 87/09/04 22:22:00 mento Exp $
.IP \fImessage\fP 1i
Specifies the type of the error message.
.\" $Header: name_err.a,v 1.2 87/09/04 22:20:09 mento Exp $
.IP \fIname\fP 1i
Specifies the name of the application.
.IP \fInbytes\fP 1i
Specifies the number of bytes available in the buffer.
.\" $Header: string.a,v 11.3 87/04/15 12:24:39 jg Exp $
.IP \fIstring\fP 1i
Specifies the character string.
.SH DESCRIPTION
.\" $Header: XErrHndlr.d,v 1.1 87/08/27 14:18:52 mento Exp $
The
.PN XSetErrorHandler
function handles error events.
.LP
.\" $Header: XErrDescrip.d,v 1.2 87/09/03 09:47:45 mento Exp $
The
.PN XGetErrorText
function copies a null-terminated string describing the specified error code
into the specified buffer.
.LP
.\" $Header: XDispName.d,v 1.2 87/09/10 14:57:19 mento Exp $
The
.PN XDisplayName
function returns the name of the display that you are currently using.
.LP
.\" $Header: XIOErrHnd.d,v 1.2 87/09/10 14:59:40 mento Exp $
The
.PN XSetIOErrorHandler
sets the fatal IO error handler.
.LP
The
.PN XGetErrorDatabaseText
function returns a message (or the default masssage) from the error message
database.
.SH "SEE ALSO"
XSynchronize(3X)
.br
\fIXlib \- C Language X Interface, Protocol Version 11\fP
