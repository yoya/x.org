.na
.de FD
.LP
.KS
.TA 1.0i 3i
.ta 1.0i 3i
.nf
..
.de FN
.fi
.KE
.LP
..
.de IN		\" send an index entry to the stderr
..
.de C{
.KS
.nf
.D
.\"
.\"	choose appropriate monospace font
.\"	the imagen conditional, 480,
.\"	may be changed to L if LB is too
.\"	heavy for your eyes...
.\"
.ie "\\*(.T"480" .ft L
.el .ie "\\*(.T"300" .ft L
.el .ie "\\*(.T"202" .ft PO
.el .ie "\\*(.T"aps" .ft CW
.el .ft R
.ps \\n(PS
.ie \\n(VS>40 .vs \\n(VSu
.el .vs \\n(VSp
..
.de C}
.DE
.R
..
.de PN
.ie t \f(H\|\\$1\|\fR\\$2
.el \fI\|\\$1\|\fP\\$2
..
.de NT
.ne 7
.ds NO Note
.if \\n(.$>$1 .if !'\\$2'C' .ds NO \\$2
.if \\n(.$ .if !'\\$1'C' .ds NO \\$1
.ie n .sp
.el .sp 10p
.TB
.ce
\\*(NO
.ie n .sp
.el .sp 5p
.if '\\$1'C' .ce 99
.if '\\$2'C' .ce 99
.in +5n
.ll -5n
.R
..
.		\" Note End -- doug kraft 3/85
.de NE
.ce 0
.in -5n
.ll +5n
.ie n .sp
.el .sp 10p
..
.ny0
.TH XStoreBytes 3X 
.SH NAME
XStoreBytes, XStoreBuffer, XFetchBytes, XFetchBuffer, XRotateBuffers 
\- manipulate cut and paste buffers
.SH SYNTAX
.\" $Header: XStoreBytes.f,v 11.6 87/08/15 12:16:52 mento Exp $
XStoreBytes\^(\^\fIdisplay\fP, \fIbytes\fP\^, \fInbytes\fP\^)
.br
      Display *\fIdisplay\fP\^;
.br
      char \fIbytes\fP\^[\^]\^;
.br
      int \^\fInbytes\fP\^;
.br
.LP
.\" $Header: XStoreBuffer.f,v 11.6 87/08/15 12:16:51 mento Exp $
XStoreBuffer\^(\^\fIdisplay\fP, \fIbytes\fP\^, \fInbytes\fP\^, \fIbuffer\fP\^)
.br
      Display *\fIdisplay\fP\^;
.br
      char \fIbytes\fP\^[\^]\^;
.br
      int \^\fInbytes\fP\^;
.br
      int \fIbuffer\fP\^;
.LP
.\" $Header: XFetchBytes.f,v 11.5 87/08/15 12:12:30 mento Exp $
char *XFetchBytes\^(\^\fIdisplay\fP, \fInbytes_return\fP\^)
.br
      Display *\fIdisplay\fP\^;
.br
      int *\fInbytes_return\fP\^;
.LP
.\" $Header: XFetchBuffer.f,v 11.4 87/08/15 12:12:29 mento Exp $
char *XFetchBuffer\^(\^\fIdisplay\fP, \fInbytes_return\fP\^, \fIreturn_buffer\fP\^)
.br
      Display *\fIdisplay\fP\^;
.br
      int *\fInbytes_return\fP\^;
.br
      int \fIreturn_buffer\fP\^;
.LP
.\" $Header: XRotateBufs.f,v 11.3 87/08/15 12:15:36 mento Exp $
XRotateBuffers\^(\^\fIdisplay\fP, \fIrotate\fP\^)
.br
      Display *\fIdisplay\fP\^;
.br
      int \fIrotate\fP\^;
.SH ARGUMENTS
.\" $Header: buffer.a,v 11.2 87/03/28 10:54:14 mento Exp $
.IP \fIbuffer\fP 1i
Specifies the buffer in which you want to store the byte string.
.\" $Header: bytes.a,v 11.2 87/03/28 10:54:20 mento Exp $
.IP \fIbytes\fP 1i
Specifies the string of bytes you want stored.
The byte string is not necessarily ASCII or null-terminated.
.\" $Header: display.a,v 11.8 87/09/03 11:02:24 mento Exp $
.IP \fIdisplay\fP 1i
Specifies the connection to the X server.
.IP \fInbytes\fP 1i
Specifies the number of bytes of the bytes argument that you want stored.
.\" $Header: nbytes.a,v 11.6 87/09/10 16:34:04 mento Exp $
.IP \fInbytes_return\fP 1i
Returns the number of bytes in the string in the buffer.
.IP \fIreturn_buffer\fP 1i
Specifies which buffer you want to stored data to be returned from.
.\" $Header: rotate.a,v 11.2 87/03/28 11:00:26 mento Exp $
.IP \fIrotate\fP 1i
Specifies how much to rotate the cut buffer. 
.SH DESCRIPTION
.\" $Header: XStoreBytes.d,v 1.1 87/08/27 14:21:49 mento Exp $
The
.PN XStoreBytes
function returns
the number of bytes to be stored to the nbytes argument.
.ds fd .PN XStoreBytes
The errors that can be generated by 
\*(fd
are
.PN BadWindow 
and
.PN BadAlloc .
.LP
.\" $Header: XStoreBuffer.d,v 1.1 87/08/27 14:21:48 mento Exp $
The
.PN XStoreBuffer
function stores data in a specified cut buffer.
.ds fd .PN XStoreBuffer
The errors that can be generated by 
\*(fd
are
.PN BadWindow ,
.PN BadAtom ,
and
.PN BadAlloc .
.LP
.\" $Header: XFetchBytes.d,v 1.2 87/09/07 14:47:25 mento Exp $
The
.PN XFetchBytes
function
returns the number of bytes in the nbytes argument,
if the buffer contains data.
Otherwise, the function
returns NULL and sets nbytes to 0.
.ds fd .PN XFetchBytes
The error that can be generated by
\*(fd 
is
.PN BadWindow .
.LP
.\" $Header: XFetchBuffer.d,v 1.2 87/08/28 08:29:09 mento Exp $
The
.PN XFetchBuffer
function
returns the value zero (0) to the nbytes argument
if there is no data in the buffer.
.ds fd .PN XFetchBuffer
The error that can be generated by
\*(fd 
is
.PN BadValue .
.LP
.\" $Header: XRotateBufs.d,v 1.1 87/08/27 14:21:05 mento Exp $
The
.PN XRotateBuffers
function rotates the cut
buffers, such that buffer 0 becomes buffer n, buffer 1 becomes n+1 mod 8, and so on.
This cut buffer numbering is global to the display.
.ds fd .PN XRotateBuffers
The errors that can be generated by 
\*(fd
are
.PN BadWindow ,
.PN BadAtom ,
and
.PN BadMatch .
.SH DIAGNOSTICS
.\" $Header: badalloc.e,v 1.3 87/09/11 11:17:14 mento Exp $
.TP 1i
.PN BadAlloc
The server failed to allocate the requested resource or server memory.
.\" $Header: badatom.e,v 1.1 87/09/04 08:22:55 mento Exp $
.TP 1i
.PN BadAtom
A value for an Atom argument does not name a defined Atom.
.\" $Header: badmatch2.e,v 1.3 87/09/11 11:53:42 mento Exp $
.TP 1i
.PN BadMatch
Some argument or pair of arguments has the correct type and range but fails
to match in some other way required by the request.
.\" $Header: badvalue.e,v 1.1 87/09/04 08:23:19 mento Exp $
.TP 1i
.PN BadValue
Some numeric value falls outside the range of values accepted by the request.
Unless a specific range is specified for an argument, the full range defined
by the argument's type is accepted.  Any argument defined as a set of
alternatives can generate this error.
.\" $Header: badwindow.e,v 1.1 87/09/04 08:23:20 mento Exp $
.TP 1i
.PN BadWindow
A value for a Window argument does not name a defined Window.

.SH "SEE ALSO"
\fIXlib \- C Language X Interface, Protocol Version 11\fP
