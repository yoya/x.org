                      Release 6 Public Patch #02
                             X Consortium

To apply this patch:

cd to the top of the source tree (to the directory containing the "xc"
and "contrib" subdirectories) and do:
        patch -p -s < ThisFile
Patch will work silently unless an error occurs.  You may get warning messages
of the form "mkdir: <dir>: File exists", which can be ignored.  If you want to
watch patch do its thing, leave out the "-s" argument to patch.

Finally, to rebuild after applying this patch, cd to the "xc" subdirectory
and do:
        make Everything >& every.log

This patch creates the following new files:
	xc/programs/Xserver/hw/hp/input/drivers/Imakefile
	xc/programs/Xserver/hw/hp/input/drivers/hp7lc2k.c
	xc/programs/Xserver/hw/hp/input/drivers/hp7lc2m.c
	xc/programs/Xserver/hw/hp/input/drivers/ps2io.h
	xc/programs/Xserver/hw/hp/input/drivers/x_serialdrv.h
If you are using a symbolic link tree, you will need to create new links.

Brief notes on what this patch fixes:

config: AllocateLocalDefines not passed to NCR Xserver
config: IBM AIX 3.2.5 does not imply threads
doc: xhost man page doesn't document R6 features
doc: Xi man pages format incorrectly
doc: Xlib XClientMessageEvent man page typo
doc: Xsun man page does not list which devices are supported
doc: Xt XtGetMultiClickTime man page alias typo
fontlib: matrix transformed names don't conform to XLFD spec
fontlib: Speedo get_font_info calls sp_open_font wrong
fonts: no prototype in scope for atof in PEX/to_wfont
Fresco: bad app-defaults lookup
Fresco: does not compile with HP or Digital native C++ compiler
Fresco: does not compile with K&R preprocessor
Fresco: fix problems compiling with Sun, SGI, IBM compilers
ICElib: cannot call ICE functions from C++
nls: iso8859-1 compose table typos
SMlib: cannot call SM functions from C++
xdm: STREAMSCONN is broken
xdpyinfo: use of QueryExtension can cause dynamic loading of all extensions
XIE: QueryColorList may hang X connection
XIE: the server can accept an illegal photoflo topology
Xlib: XConvertCase should understand Greek
Xlib: XIM protocol packet headers have wrong length field
Xlib: XOpenIM parses "@locale=..." list incorrectly
Xlib: bad XcmsRGBiToRGB conversion using some device profiles
Xlib: cannot specify hex numbers in the Compose table
Xserver: HP ddx update for new hardware
Xserver: STREAMSCONN problem with XDMCP
Xserver: Xsun does not install 8-bit TrueColor visuals correctly
Xserver: Xsun wrong modifier map for type-5 PC keyboard
Xserver: imaging problems on olwm icons
xsmclient: fails to compile with -DX_NOT_POSIX
Xt: Session shell: nits in handling XSMP ShutdownCancelled
Xt: XtOpenDisplay derives appl name incorrectly
Xt: memory leak in XtAppAddActionHook/XtRemoveActionHook
Xt: parsing translation table: "<ButtonPress>Button1" does not work
xtrans: ConvertAddress addr argument must be passed by reference
xtrans: cannot recover from attempt to run second server on same display

Prereq: public-patch-1

*** /tmp/,RCSt1a22195	Mon Jun  6 17:07:17 1994
--- xc/bug-report	Mon Jun  6 17:04:43 1994
***************
*** 3,9
  
       VERSION:
  
! R6, public-patch-1
  [X Consortium public patches edit this line to indicate the patch level]
  
       CLIENT MACHINE and OPERATING SYSTEM:

--- 3,9 -----
  
       VERSION:
  
! R6, public-patch-2
  [X Consortium public patches edit this line to indicate the patch level]
  
       CLIENT MACHINE and OPERATING SYSTEM:
*** /tmp/da16019	Sun Jun  5 18:25:42 1994
--- xc/config/cf/hp.cf	Sun Jun  5 18:25:41 1994
***************
*** 1,4 ****
! XCOMM platform:  $XConsortium: hp.cf,v 1.67 94/04/01 20:00:21 kaleb Exp $
  
  #define OSName                 HP-UX 9.1
  XCOMM operating system:  OSName
--- 1,4 ----
! XCOMM platform:  $XConsortium: hp.cf,v 1.68 94/06/03 21:38:44 matt Exp $
  
  #define OSName                 HP-UX 9.1
  XCOMM operating system:  OSName
***************
*** 5,10 ****
--- 5,52 ----
  #define OSMajorVersion         9
  #define OSMinorVersion         1
  #define OSTeenyVersion         0
+ 
+ 
+ /*
+  * C++ compiler setup.  This file knows what options to use with 
+  * certain compilers, including HP C++ and CenterLine C++.
+  * 
+  * For HP C++, define HasHPCplusplus to YES in site.def.  
+  * For CenterLine C++, define HasCenterLineCplusplus to YES in site.def.
+  * For other compilers, define HasCplusplus to YES in site.def, and 
+  *    check to see if you need to provide values for CplusplusOptions
+  *    and/or DefaultCplusplusOptions.
+  *
+  * In any case, you may also need to set CplusplusDependIncludes.
+  */
+ 
+ #if HasHPCplusplus
+ #ifndef HasCplusplus
+ #define HasCplusplus YES
+ #endif
+ #ifndef DefaultCplusplusOptions
+ #define DefaultCplusplusOptions -Aa
+ #endif
+ #ifndef CplusplusOptions
+ #define CplusplusOptions -Aa
+ #endif
+ #ifndef CplusplusDependIncludes 
+ #define CplusplusDependIncludes -I/usr/include/CC
+ #endif
+ #endif
+ 
+ #if HasCenterLineCplusplus
+ #ifndef HasCplusplus
+ #define HasCplusplus YES
+ #endif
+ #ifndef OptimizedCplusplusDebugFlags
+ #define OptimizedCplusplusDebugFlags -O
+ #endif
+ #ifndef CplusplusDependIncludes 
+ #define CplusplusDependIncludes -I/usr/local/CenterLine/clc++/pa-hpux8/incl
+ #endif
+ #endif
+ 
  
  #define SystemV                YES
  #define Malloc0ReturnsNull     YES
*** /tmp/da16035	Sun Jun  5 18:25:43 1994
--- xc/config/cf/ibm.cf	Sun Jun  5 18:25:43 1994
***************
*** 1,4 ****
! XCOMM platform:  $XConsortium: ibm.cf,v 1.50 94/03/28 20:23:42 matt Exp $
  
  #ifdef RsArchitecture
  #define OSName		AIX 3.2.5
--- 1,4 ----
! XCOMM platform:  $XConsortium: ibm.cf,v 1.52 94/06/04 16:44:25 rws Exp $
  
  #ifdef RsArchitecture
  #define OSName		AIX 3.2.5
***************
*** 27,36 ****
  
  #ifdef RsArchitecture
  
! #if OSMajorVersion >= 3 && OSMinorVersion >= 2
  #define HasBSD44Sockets		YES
! #if OSMajorVersion > 3 || OSMinorVersion > 2 || OSTeenyVersion > 4
  #define HasPosixThreads		YES
  #define SystemMTDefines -D_THREAD_SAFE
  #define ThreadedX		YES
  #define ThreadsLibraries -lpthreads -lc_r
--- 27,43 ----
  
  #ifdef RsArchitecture
  
! #if OSMajorVersion > 3 || (OSMajorVersion == 3 && OSMinorVersion >= 2)
  #define HasBSD44Sockets		YES
! /*
!  * If you do not have threads support installed, put
!  * #define HasPosixThreads NO
!  * in the BeforeVendorCF section of your site.def.
!  */
! #if !defined(HasPosixThreads) && (OSMajorVersion > 3 || (OSMajorVersion == 3 && (OSMinorVersion > 2 || (OSMinorVersion == 2 && OSTeenyVersion > 4))))
  #define HasPosixThreads		YES
+ #endif
+ #if HasPosixThreads
  #define SystemMTDefines -D_THREAD_SAFE
  #define ThreadedX		YES
  #define ThreadsLibraries -lpthreads -lc_r
***************
*** 46,53 ****
--- 53,67 ----
   * C++ shared libraries like libFresco
   */
  
+ #ifndef CplusplusCmd
  #define CplusplusCmd xlC
+ #endif
+ #ifndef CplusplusLibC
  #define CplusplusLibC /usr/lpp/xlC/lib/libC.a
+ #endif
+ #ifndef CplusplusDependIncludes
+ #define CplusplusDependIncludes -I/usr/lpp/xlC/include
+ #endif
  
  /*
   * IBM's xlC refuses to compile files unless their names end in ".C".
*** /tmp/da16051	Sun Jun  5 18:25:45 1994
--- xc/config/cf/ncr.cf	Sun Jun  5 18:25:45 1994
***************
*** 1,4 ****
! XCOMM platform:  $XConsortium: ncr.cf,v 1.10 94/04/15 11:52:14 rws Exp $
  #define OSName			Unix System V Release 4/MP-RAS
  #define OSVendor		NCR
  XCOMM operating system:  OSName
--- 1,4 ----
! XCOMM platform:  $XConsortium: ncr.cf,v 1.11 94/06/04 16:47:47 rws Exp $
  #define OSName			Unix System V Release 4/MP-RAS
  #define OSVendor		NCR
  XCOMM operating system:  OSName
***************
*** 12,18 ****
  #define StandardDefines		-DSVR4 -DNCR -Di386 -DXML -DXI18N
  #define DefaultCCOptions	-Xc -Hnocopyr -W0,-asm
  #define DefaultCDebugFlags	-O3
! #define ServerExtraDefines      -DNO_SECONDARY
  #define ServerOSDefines         -DDDXTIME -DDDXOSINIT
  #define AllocateLocalDefines	-DNO_ALLOCA
  
--- 12,18 ----
  #define StandardDefines		-DSVR4 -DNCR -Di386 -DXML -DXI18N
  #define DefaultCCOptions	-Xc -Hnocopyr -W0,-asm
  #define DefaultCDebugFlags	-O3
! #define ServerExtraDefines      -DNO_SECONDARY AllocateLocalDefines
  #define ServerOSDefines         -DDDXTIME -DDDXOSINIT
  #define AllocateLocalDefines	-DNO_ALLOCA
  
*** /tmp/da16067	Sun Jun  5 18:25:47 1994
--- xc/config/cf/osf1.cf	Sun Jun  5 18:25:47 1994
***************
*** 1,4 ****
! XCOMM platform:  $XConsortium: osf1.cf,v 1.37 94/04/09 20:45:31 rws Exp $
  /* only tested with Digital OSF/1 */
  
  #ifdef AlphaArchitecture
--- 1,4 ----
! XCOMM platform:  $XConsortium: osf1.cf,v 1.38 94/06/03 21:38:48 matt Exp $
  /* only tested with Digital OSF/1 */
  
  #ifdef AlphaArchitecture
***************
*** 34,39 ****
--- 34,56 ----
  
  #if ThreadedX
  #define ThreadsLibraries -lpthreads -lmach -lc_r
+ #endif
+ 
+ /*
+  * For OSF/1 platforms, we must define both the location of the compiler
+  * and the location of its standard C++ library.  The library location
+  * is needed to resolve dependent library symbols when we build our own
+  * C++ shared libraries like libFresco
+  */
+ 
+ #ifndef CplusplusCmd
+ #define CplusplusCmd /usr/bin/cxx
+ #endif
+ #ifndef CplusplusDependIncludes 
+ #define CplusplusDependIncludes -D__DECCXX -I/usr/include
+ #endif
+ #ifndef CplusplusLibC
+ #define CplusplusLibC -L/usr/lib/cmplrs/cxx -lcxx
  #endif
  
  #include <osfLib.rules>
*** /tmp/da16083	Sun Jun  5 18:25:49 1994
--- xc/config/cf/osfLib.tmpl	Sun Jun  5 18:25:48 1994
***************
*** 1,4 ****
! XCOMM $XConsortium: osfLib.tmpl,v 1.17 94/01/29 11:47:36 rws Exp $
  
  /*
   * OSF/1 shared library template
--- 1,4 ----
! XCOMM $XConsortium: osfLib.tmpl,v 1.18 94/06/03 21:38:46 matt Exp $
  
  /*
   * OSF/1 shared library template
***************
*** 22,24 ****
--- 22,33 ----
  #define SharedXtstReqs $(LDPRELIB) $(XLIB)
  #define SharedXieReqs $(LDPRELIB) $(XLIBONLY)
  #define SharedSMReqs $(LDPRELIB) $(ICELIB)
+ 
+ #if ThreadedX && ModernOSF1
+ #define FrescoSysLibs  -lpthreads -lmach CplusplusLibC MathLibrary
+ #else
+ #define FrescoSysLibs  CplusplusLibC MathLibrary
+ #endif
+ 
+ #define SharedFrescoReqs $(LDPRELIB) $(XLIBONLY) FrescoSysLibs
+ #define SharedXtfReqs $(LDPRELIB) $(FRESCOLIB) $(XTOOLLIB) $(XLIB) FrescoSysLibs
*** /tmp/da16099	Sun Jun  5 18:25:50 1994
--- xc/config/cf/sgi.cf	Sun Jun  5 18:25:50 1994
***************
*** 1,4 ****
! XCOMM platform:  $XConsortium: sgi.cf,v 1.42 94/04/01 19:59:12 kaleb Exp $
  
  #define OSName			IRIX 5.2
  XCOMM operating system:  OSName
--- 1,4 ----
! XCOMM platform:  $XConsortium: sgi.cf,v 1.43 94/06/03 21:38:45 matt Exp $
  
  #define OSName			IRIX 5.2
  XCOMM operating system:  OSName
***************
*** 51,56 ****
--- 51,61 ----
  #define DefaultCCOptions sgiCCOptions SymbolTables
  #define PexCCOptions sgiCCOptions PexSymbolTables
  #define ServerCCOptions sgiCCOptions ServerSymbolTables
+ 
+ /* For SGI C++ compiler, need to search extra dirs in make depend */
+ #ifndef CplusplusDependIncludes
+ #define CplusplusDependIncludes -I/usr/include/CC
+ #endif
  
  /* At SGI, we don't need this */
  #define ConstructMFLAGS		NO	/* build MFLAGS from MAKEFLAGS */
*** /tmp/da19513	Mon Jun  6 12:17:27 1994
--- xc/config/cf/site.sample	Mon Jun  6 12:17:26 1994
***************
*** 1,4 ****
! XCOMM site:  $XConsortium: site.sample,v 1.10 94/05/13 16:43:11 matt Exp $
  
  /*****************************************************************************
   *                                                                           *
--- 1,4 ----
! XCOMM site:  $XConsortium: site.sample,v 1.11 94/06/03 19:50:12 matt Exp $
  
  /*****************************************************************************
   *                                                                           *
***************
*** 60,90 ****
  /* #define BuildXKB YES */
  
  /* #define PreIncDir /usr/local/lib/gcc-lib/sparc-sun-sunos4.1.3/2.5.8/include */
- 
- /*
-  * If your C++ compiler has ANSI preprocessor features like token-pasting, 
-  * you may want to turn them on when building Fresco.  If you get compile
-  * time errors about "_" not being a type name or Xf not being a type name,
-  * it means your standard preprocessor converts empty comments to spaces 
-  * instead of doing token pasting.  Use an ANSI preprocessor if you can.
-  *
-  * If your compiler does ANSI token-pasting but does NOT set __STDC__ to 1
-  * you should add -D__ANSI_CPP__ to the command line so Fresco sources 
-  * know they can use ANSI token pasting.  Here's a sample set of values
-  * for HP's C++ compiler, which requires special flags for ANSI features
-  * and which does not assert __STDC__ == 1:
-  */
- 
- /*
- #ifdef HPArchitecture
- #ifndef DefaultCplusplusOptions
- #define DefaultCplusplusOptions -Aa
- #endif
- #ifndef CplusplusExtraDefines
- #define CplusplusExtraDefines -D__ANSI_CPP__
- #endif
- #endif 
- */
  
  /*
  #if defined(SunArchitecture) && defined(SparcArchitecture)
--- 60,65 ----
*** /tmp/da16115	Sun Jun  5 18:25:52 1994
--- xc/config/cf/sun.cf	Sun Jun  5 18:25:51 1994
***************
*** 1,4 ****
! XCOMM platform:  $XConsortium: sun.cf,v 1.130 94/05/13 16:03:10 matt Exp $
  
  #ifdef SVR4
  #ifdef i386Architecture
--- 1,4 ----
! XCOMM platform:  $XConsortium: sun.cf,v 1.131 94/06/03 21:38:47 matt Exp $
  
  #ifdef SVR4
  #ifdef i386Architecture
***************
*** 24,44 ****
  
  /*
   * Compiler setup.  This sun.cf file knows what options to use with 
!  * certain compilers, including Sun C, CenterLine C, and gcc.  If you
!  * don't tell us which compiler you have, we assume you have the 
!  * unbundled Sun C compiler under Solaris 2.x, and the bundled /bin/cc
!  * under SunOS 4.1.x
   *
!  * If you have CenterLine C, you can just define HasCenterLineC to YES
!  * in site.def, or if you have gcc or gcc2, you can just define HasGcc 
!  * or HasGcc2 to YES in site.def
   * 
!  * If you have some other compiler, you must define HasSunC to NO in
!  * site.def, then provide appropriate values for the various compiler
!  * related configuration varibles used here.  If you submit changes to
!  * support other compilers as an X11 request for enhancement, we'll
!  * consider adding them in the future.  It's always easier to add and
!  * support such changes if we have a copy of the compiler in question.
   */
  
  #ifndef HasSunC
--- 24,64 ----
  
  /*
   * Compiler setup.  This sun.cf file knows what options to use with 
!  * certain compilers, including Sun C, CenterLine C, and gcc.  It 
!  * also understands how to set some of the options for various C++
!  * compilers, including Sun C++ and CenterLine C++.
   *
!  * === C Compiler Setup ==========================================
!  *
!  * For SunPro C, define HasSunC to YES in site.def.  
!  * For CenterLine C, define HasCenterLineC to YES in site.def
!  * For gcc or gcc2, define HasGcc or HasGcc2 to YES in site.def
!  * For other compilers, define HasSunC to NO in site.def, then 
!  *    provide appropriate values for the various compiler related
!  *    configuration varibles used here.
   * 
!  * If you say you have the SunPro C compiler, we assume you have 
!  * version 2.0.x of the compiler.  If you have version 3.0.x instead, 
!  * define CCompilerMajorVersion as 3 in site.def
!  *
!  * If you don't tell us which C compiler you have, we assume you have 
!  * the SunPro C compiler under Solaris 2.x, and the bundled /bin/cc 
!  * under SunOS 4.1.x
!  *
!  * === C++ Compiler Setup ==========================================
!  *
!  * For SunPro C++, define HasSunCplusplus to YES in site.def
!  * For CenterLine C++, define HasCenterLineCplusplus to YES in site.def
!  * For other compilers, define HasCplusplus to YES in site.def, and 
!  *    check to see if you need to provide values for CplusplusOptions
!  *    and/or DefaultCplusplusOptions.
!  *
!  * In any case, you may also need to set CplusplusDependIncludes.
!  *
!  * If you say you have the SunPro C++ compiler, we assume you have 
!  * version 3.0.x of the compiler.  If you have version 4.0.x instead, 
!  * define CplusplusCompilerMajorVersion as 4 in site.def.
!  *
   */
  
  #ifndef HasSunC
***************
*** 49,96 ****
  #endif
  #endif
  
- /*
-  * If you say you have the unbundled Sun C compiler, we assume you have
-  * version 2.0.x of the compiler unless you say otherwise.  If you have
-  * version 3.0.x of the C compiler, define CCompilerMajorVersion as 3
-  * in site.def
-  */
- 
  #if HasSunC 
  #ifndef CCompilerMajorVersion
  #define CCompilerMajorVersion 2
  #endif
- #ifndef CcCmd
- #define CcCmd /opt/SUNWspro/bin/cc
  #endif
- #endif
  
- /*
-  * If you say you have the Sun C++ compiler, we assume you have version 
-  * 3.0.x of the compiler (the cfront-based version) unless you say otherwise.
-  * If you have version 4.0.x of the C++ compiler (the one with exceptions)
-  * define CplusplusCompilerMajorVersion as 4 in site.def
-  */
- 
  #if HasSunCplusplus
  #ifndef CplusplusCompilerMajorVersion
  #define CplusplusCompilerMajorVersion 3
  #endif
- #ifndef CplusplusCmd
- #define CplusplusCmd /opt/SUNWspro/bin/CC
  #endif
- #endif
  
- /*
-  * If you say you have the CenterLine C compiler, we assume that clcc
-  * is somewhere in your default path.
-  */
- 
  #if HasCenterLineC
  #ifndef CcCmd
  #define CcCmd clcc
  #endif
  #endif
  
  #if OSMajorVersion < 4 || (OSMajorVersion == 4 && OSMinorVersion < 1)
  /* We do not guarantee this will work */
--- 69,107 ----
  #endif
  #endif
  
  #if HasSunC 
  #ifndef CCompilerMajorVersion
  #define CCompilerMajorVersion 2
  #endif
  #endif
  
  #if HasSunCplusplus
+ #ifndef HasCplusplus
+ #define HasCplusplus YES
+ #endif
  #ifndef CplusplusCompilerMajorVersion
  #define CplusplusCompilerMajorVersion 3
  #endif
  #endif
  
  #if HasCenterLineC
  #ifndef CcCmd
  #define CcCmd clcc
  #endif
  #endif
+ 
+ #if HasCenterLineCplusplus
+ #ifndef HasCplusplus
+ #define HasCplusplus YES
+ #endif
+ #ifndef DefaultCplusplusOptions
+ #define DefaultCplusplusOptions -Xa
+ #endif
+ #ifndef CplusplusOptions
+ #define CplusplusOptions -Xa
+ #endif
+ #endif
+ 
  
  #if OSMajorVersion < 4 || (OSMajorVersion == 4 && OSMinorVersion < 1)
  /* We do not guarantee this will work */
*** /tmp/da16133	Sun Jun  5 18:25:53 1994
--- xc/doc/man/X11/XCMEvent.man	Sat Jun 04 16:22:25 1994
***************
*** 140,146 ****
  .ny0
  .TH XClientMessageEvent 3X11 "Release 6" "X Version 11" "XLIB FUNCTIONS"
  .SH NAME
! XClientMessageEvent \- ColormapNotify event structure
  .SH STRUCTURES
  The structure for
  .ZN ClientMessage
--- 140,146 ----
  .ny0
  .TH XClientMessageEvent 3X11 "Release 6" "X Version 11" "XLIB FUNCTIONS"
  .SH NAME
! XClientMessageEvent \- ClientMessage event structure
  .SH STRUCTURES
  The structure for
  .ZN ClientMessage
*** /tmp/da16157	Sun Jun  5 18:25:56 1994
--- xc/doc/man/Xi/XAllDvEv.man	Sun Jun  5 18:25:55 1994
***************
*** 1,5 ****
  .\"
- $XMCOPY
  .\" Copyright ([\d,\s]*) by Hewlett-Packard Company, Ardent Computer, 
  .\" 
  .\" Permission to use, copy, modify, distribute, and sell this documentation 
--- 1,4 ----
***************
*** 9,15 ****
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XAllDvEv.man,v 1.4 94/04/17 20:07:26 dpw Exp $
  .ds xL Programming With Xlib
  .TH XAllowDeviceEvents 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
--- 8,14 ----
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XAllDvEv.man,v 1.5 94/06/04 17:32:07 rws Exp $
  .ds xL Programming With Xlib
  .TH XAllowDeviceEvents 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
***************
*** 55,61 ****
  It has no effect if the specified time is earlier than the last-grab
  time of the most recent active grab for the client and device, 
  or if the specified time is later than the current X server time.
! .P
  The following describes the processing that occurs depending on what
  constant you pass to the event_mode argument.
  .TP 12
--- 54,60 ----
  It has no effect if the specified time is earlier than the last-grab
  time of the most recent active grab for the client and device, 
  or if the specified time is later than the current X server time.
! .LP
  The following describes the processing that occurs depending on what
  constant you pass to the event_mode argument.
  .TP 12
***************
*** 110,116 ****
  on behalf of multiple separate grabs, \fIAsyncAll\fP thaws for
  all.  \fIAsyncAll\fP has no effect unless all devices are frozen by
  the client.
! .P
  \fIAsyncThisDevice\fP,
  \fISyncThisDevice\fP,
  and
--- 109,115 ----
  on behalf of multiple separate grabs, \fIAsyncAll\fP thaws for
  all.  \fIAsyncAll\fP has no effect unless all devices are frozen by
  the client.
! .LP
  \fIAsyncThisDevice\fP,
  \fISyncThisDevice\fP,
  and
***************
*** 123,129 ****
  or
  \fIAsyncAll\fP,
  the device parameter is ignored.
! .P
  It is possible for several grabs of different devices by the same or
  different clients to be active simultaneously.  If a device is frozen on
  behalf of any grab, no event processing is performed for the device.
--- 122,128 ----
  or
  \fIAsyncAll\fP,
  the device parameter is ignored.
! .LP
  It is possible for several grabs of different devices by the same or
  different clients to be active simultaneously.  If a device is frozen on
  behalf of any grab, no event processing is performed for the device.
***************
*** 130,136 ****
  It is possible for a single device to be frozen because of several grabs.
  In this case, the freeze must be released on behalf of each grab before
  events can again be processed.
! .P
  \fIXAllowDeviceEvents\fP
  can generate a \fIBadDevice\fP or
  \fIBadValue\fP 
--- 129,135 ----
  It is possible for a single device to be frozen because of several grabs.
  In this case, the freeze must be released on behalf of each grab before
  events can again be processed.
! .LP
  \fIXAllowDeviceEvents\fP
  can generate a \fIBadDevice\fP or
  \fIBadValue\fP 
*** /tmp/da16173	Sun Jun  5 18:25:57 1994
--- xc/doc/man/Xi/XChDCtl.man	Sun Jun  5 18:25:57 1994
***************
*** 1,5 ****
  .\"
- $XMCOPY
  .\" Copyright ([\d,\s]*) by Hewlett-Packard Company, Ardent Computer, 
  .\" 
  .\" Permission to use, copy, modify, distribute, and sell this documentation 
--- 1,4 ----
***************
*** 9,15 ****
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XChDCtl.man,v 1.4 94/04/17 20:07:27 dpw Exp $
  .ds xL Programming With Xlib
  .TH XGetDeviceControl 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
--- 8,14 ----
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XChDCtl.man,v 1.5 94/06/04 17:32:14 rws Exp $
  .ds xL Programming With Xlib
  .TH XGetDeviceControl 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
***************
*** 52,85 ****
  These requests are provided to manipulate those input devices that
  support device control.  A \fIBadMatch\fP error will be generated if the
  requested device does not support any device controls.
! .P
  Valid device control types that can be used with these requests include the
  following:
  .TP 20
  DEVICE_RESOLUTION
  Queries or changes the resolution of valuators on input devices.
! .P
  The \fIXGetDeviceControl\fP request returns a pointer to an
  \fIXDeviceControl\fP structure. 
! .P
  \fIXGetDeviceControl\fP can generate a \fIBadDevice\fP or
  \fIBadMatch\fP error.
! .P
  The \fIXChangeDeviceControl\fP request modifies the values of one 
  control on the specified device.  The control is identified by the id
  field of the \fIXDeviceControl\fP structure that is passed with the
  request.
! .P
  \fIXChangeDeviceControl\fP can generate a \fIBadDevice\fP,
  \fIBadMatch\fP, or \fIBadValue\fP  error.
  .SH STRUCTURES
  Each control is described by a structure specific to that control.
  These structures are defined in the file \fIXInput.h\fP.
! .P
  \fIXDeviceControl\fP is a generic 
  structure that contains two fields that are at the beginning of each class
  of control:
! .P
  .DS
  .nf
  typedef struct {
--- 51,84 ----
  These requests are provided to manipulate those input devices that
  support device control.  A \fIBadMatch\fP error will be generated if the
  requested device does not support any device controls.
! .LP
  Valid device control types that can be used with these requests include the
  following:
  .TP 20
  DEVICE_RESOLUTION
  Queries or changes the resolution of valuators on input devices.
! .LP
  The \fIXGetDeviceControl\fP request returns a pointer to an
  \fIXDeviceControl\fP structure. 
! .LP
  \fIXGetDeviceControl\fP can generate a \fIBadDevice\fP or
  \fIBadMatch\fP error.
! .LP
  The \fIXChangeDeviceControl\fP request modifies the values of one 
  control on the specified device.  The control is identified by the id
  field of the \fIXDeviceControl\fP structure that is passed with the
  request.
! .LP
  \fIXChangeDeviceControl\fP can generate a \fIBadDevice\fP,
  \fIBadMatch\fP, or \fIBadValue\fP  error.
  .SH STRUCTURES
  Each control is described by a structure specific to that control.
  These structures are defined in the file \fIXInput.h\fP.
! .LP
  \fIXDeviceControl\fP is a generic 
  structure that contains two fields that are at the beginning of each class
  of control:
! .LP
  .DS
  .nf
  typedef struct {
***************
*** 91,100 ****
  } XDeviceControl;
  .fi
  .DE
! .P
  The \fIXDeviceResolutionState\fP structure defines the information that is
  returned for device resolution for devices with valuators.
! .P
  .DS
  .nf
  typedef struct {
--- 90,99 ----
  } XDeviceControl;
  .fi
  .DE
! .LP
  The \fIXDeviceResolutionState\fP structure defines the information that is
  returned for device resolution for devices with valuators.
! .LP
  .DS
  .nf
  typedef struct {
***************
*** 107,116 ****
  } XDeviceResolutionState;
  .fi
  .DE
! .P
  The \fIXDeviceResolutionControl\fP structure defines the attributes that can be
  controlled for keyboard Devices.
! .P
  .DS
  .nf
  typedef struct {
--- 106,115 ----
  } XDeviceResolutionState;
  .fi
  .DE
! .LP
  The \fIXDeviceResolutionControl\fP structure defines the attributes that can be
  controlled for keyboard Devices.
! .LP
  .DS
  .nf
  typedef struct {
*** /tmp/da16189	Sun Jun  5 18:25:59 1994
--- xc/doc/man/Xi/XChFCtl.man	Sun Jun  5 18:25:59 1994
***************
*** 1,5 ****
  .\"
- $XMCOPY
  .\" Copyright ([\d,\s]*) by Hewlett-Packard Company, Ardent Computer, 
  .\" 
  .\" Permission to use, copy, modify, distribute, and sell this documentation 
--- 1,4 ----
***************
*** 9,15 ****
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XChFCtl.man,v 1.4 94/04/17 20:07:27 dpw Exp $
  .ds xL Programming With Xlib
  .TH XGetFeedbackControl 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
--- 8,14 ----
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XChFCtl.man,v 1.5 94/06/04 17:32:15 rws Exp $
  .ds xL Programming With Xlib
  .TH XGetFeedbackControl 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
***************
*** 62,74 ****
  support feedbacks, \fIXOpenDevice\fP will return an
  \fIXInputClassInfo\fP structure with the input_class field
  equal to the constant \fIFeedbackClass\fP (defined in the file \fIXI.h\fP).
! .P
  The \fIXGetFeedbackControl\fP request returns a pointer to a list of 
  \fIXFeedbackState\fP structures.  Each item in this list describes one
  of the feedbacks supported by the device.  The items are variable length,
  so each contains its length to allow traversal to the next item in the
  list.
! .P
  The feedback classes that are currently defined are:  \fIKbdFeedbackClass\fP,
  \fIPtrFeedbackClass\fP, \fIStringFeedbackClass\fP, \fIIntegerFeedbackClass\fP,
  \fILedFeedbackClass\fP, and \fIBellFeedbackClass\fP.  These constants are
--- 61,73 ----
  support feedbacks, \fIXOpenDevice\fP will return an
  \fIXInputClassInfo\fP structure with the input_class field
  equal to the constant \fIFeedbackClass\fP (defined in the file \fIXI.h\fP).
! .LP
  The \fIXGetFeedbackControl\fP request returns a pointer to a list of 
  \fIXFeedbackState\fP structures.  Each item in this list describes one
  of the feedbacks supported by the device.  The items are variable length,
  so each contains its length to allow traversal to the next item in the
  list.
! .LP
  The feedback classes that are currently defined are:  \fIKbdFeedbackClass\fP,
  \fIPtrFeedbackClass\fP, \fIStringFeedbackClass\fP, \fIIntegerFeedbackClass\fP,
  \fILedFeedbackClass\fP, and \fIBellFeedbackClass\fP.  These constants are
***************
*** 77,92 ****
  of the same class.  Each feedback contains a class identifier and an id
  that is unique within that class for that input device.  The id is used
  to identify the feedback when making an \fIXChangeFeedbackControl\fP request.
! .P
  \fIXGetFeedbackControl\fP can generate a \fIBadDevice\fP or
  \fIBadMatch\fP error.
! .P
  The \fIXChangeFeedbackControl\fP request modifies the values of one 
  feedback on the specified device.  The feedback is identified by the id
  field of the \fIXFeedbackControl\fP structure that is passed with the
  request.  The fields of the feedback that are to be modified are identified
  by the bits of the mask that is passed with the request.
! .P
  \fIXChangeFeedbackControl\fP can generate a \fIBadDevice\fP,
  \fIBadMatch\fP, or \fIBadValue\fP  error.
  .SH STRUCTURES
--- 76,91 ----
  of the same class.  Each feedback contains a class identifier and an id
  that is unique within that class for that input device.  The id is used
  to identify the feedback when making an \fIXChangeFeedbackControl\fP request.
! .LP
  \fIXGetFeedbackControl\fP can generate a \fIBadDevice\fP or
  \fIBadMatch\fP error.
! .LP
  The \fIXChangeFeedbackControl\fP request modifies the values of one 
  feedback on the specified device.  The feedback is identified by the id
  field of the \fIXFeedbackControl\fP structure that is passed with the
  request.  The fields of the feedback that are to be modified are identified
  by the bits of the mask that is passed with the request.
! .LP
  \fIXChangeFeedbackControl\fP can generate a \fIBadDevice\fP,
  \fIBadMatch\fP, or \fIBadValue\fP  error.
  .SH STRUCTURES
***************
*** 95,101 ****
  \fIXFeedbackState\fP and \fIXFeedbackControl\fP are generic 
  structures that contain three fields that are at the beginning of each class
  of feedback:
! .P
  .DS
  typedef struct {
  .br
--- 94,100 ----
  \fIXFeedbackState\fP and \fIXFeedbackControl\fP are generic 
  structures that contain three fields that are at the beginning of each class
  of feedback:
! .LP
  .DS
  typedef struct {
  .br
***************
*** 107,116 ****
  .br
  } XFeedbackState, XFeedbackControl;
  .DE
! .P
  The \fIXKbdFeedbackState\fP structure defines the attributes that are
  returned for feedbacks equivalent to those on the X keyboard.
! .P
  .DS
  .nf
  typedef struct {
--- 106,115 ----
  .br
  } XFeedbackState, XFeedbackControl;
  .DE
! .LP
  The \fIXKbdFeedbackState\fP structure defines the attributes that are
  returned for feedbacks equivalent to those on the X keyboard.
! .LP
  .DS
  .nf
  typedef struct {
***************
*** 127,136 ****
  } XKbdFeedbackState;
  .fi
  .DE
! .P
  The \fIXPtrFeedbackState\fP structure defines the attributes that are
  returned for feedbacks equivalent to those on the the X pointer.
! .P
  .DS
  .nf
  typedef struct {
--- 126,135 ----
  } XKbdFeedbackState;
  .fi
  .DE
! .LP
  The \fIXPtrFeedbackState\fP structure defines the attributes that are
  returned for feedbacks equivalent to those on the the X pointer.
! .LP
  .DS
  .nf
  typedef struct {
***************
*** 143,152 ****
  } XPtrFeedbackState;
  .fi
  .DE
! .P
  The \fIXIntegerFeedbackState\fP structure defines attributes that are 
  returned for integer feedbacks.
! .P
  .DS
  .nf
  typedef struct {
--- 142,151 ----
  } XPtrFeedbackState;
  .fi
  .DE
! .LP
  The \fIXIntegerFeedbackState\fP structure defines attributes that are 
  returned for integer feedbacks.
! .LP
  .DS
  .nf
  typedef struct {
***************
*** 159,168 ****
  } XIntegerFeedbackState;
  .fi
  .DE
! .P
  The \fIXStringFeedbackState\fP structure defines the attributes that are
  returned for string feedbacks.
! .P
  .DS
  .nf
  typedef struct {
--- 158,167 ----
  } XIntegerFeedbackState;
  .fi
  .DE
! .LP
  The \fIXStringFeedbackState\fP structure defines the attributes that are
  returned for string feedbacks.
! .LP
  .DS
  .nf
  typedef struct {
***************
*** 175,184 ****
  } XStringFeedbackState;
  .fi
  .DE
! .P
  The \fIXBellFeedbackState\fP structure defines the attributes that are
  returned for bell feedbacks.
! .P
  .DS
  .nf
  typedef struct {
--- 174,183 ----
  } XStringFeedbackState;
  .fi
  .DE
! .LP
  The \fIXBellFeedbackState\fP structure defines the attributes that are
  returned for bell feedbacks.
! .LP
  .DS
  .nf
  typedef struct {
***************
*** 191,200 ****
  } XBellFeedbackState;
  .fi
  .DE
! .P
  The \fIXLedFeedbackState\fP structure defines the attributes that are
  returned for LED feedbacks.
! .P
  .DS
  .nf
  typedef struct {
--- 190,199 ----
  } XBellFeedbackState;
  .fi
  .DE
! .LP
  The \fIXLedFeedbackState\fP structure defines the attributes that are
  returned for LED feedbacks.
! .LP
  .DS
  .nf
  typedef struct {
***************
*** 205,214 ****
  } XLedFeedbackState;
  .fi
  .DE
! .P
  The \fIXPrtFeedbackControl\fP structure defines the attributes that can be
  controlled for pointer feedbacks.
! .P
  .DS
  .nf
  typedef struct {
--- 204,213 ----
  } XLedFeedbackState;
  .fi
  .DE
! .LP
  The \fIXPrtFeedbackControl\fP structure defines the attributes that can be
  controlled for pointer feedbacks.
! .LP
  .DS
  .nf
  typedef struct {
***************
*** 221,230 ****
  } XPtrFeedbackControl;
  .fi
  .DE
! .P
  The \fIXKbdFeedbackControl\fP structure defines the attributes that can be
  controlled for keyboard feedbacks.
! .P
  .DS
  .nf
  typedef struct {
--- 220,229 ----
  } XPtrFeedbackControl;
  .fi
  .DE
! .LP
  The \fIXKbdFeedbackControl\fP structure defines the attributes that can be
  controlled for keyboard feedbacks.
! .LP
  .DS
  .nf
  typedef struct {
***************
*** 242,251 ****
  } XKbdFeedbackControl;
  .fi
  .DE
! .P
  The \fIXStringFeedbackControl\fP structure defines the attributes that can be
  controlled for string feedbacks.
! .P
  .DS
  .nf
  typedef struct {
--- 241,250 ----
  } XKbdFeedbackControl;
  .fi
  .DE
! .LP
  The \fIXStringFeedbackControl\fP structure defines the attributes that can be
  controlled for string feedbacks.
! .LP
  .DS
  .nf
  typedef struct {
***************
*** 257,266 ****
  } XStringFeedbackControl;
  .fi
  .DE
! .P
  The \fIXIntegerFeedbackControl\fP structure defines the attributes that can
  be controlled for integer feedbacks.
! .P
  .DS
  .nf
  typedef struct {
--- 256,265 ----
  } XStringFeedbackControl;
  .fi
  .DE
! .LP
  The \fIXIntegerFeedbackControl\fP structure defines the attributes that can
  be controlled for integer feedbacks.
! .LP
  .DS
  .nf
  typedef struct {
***************
*** 271,280 ****
  } XIntegerFeedbackControl;
  .fi
  .DE
! .P
  The \fIXBellFeedbackControl\fP structure defines the attributes that can be
  controlled for bell feedbacks.
! .P
  .DS
  .nf
  typedef struct {
--- 270,279 ----
  } XIntegerFeedbackControl;
  .fi
  .DE
! .LP
  The \fIXBellFeedbackControl\fP structure defines the attributes that can be
  controlled for bell feedbacks.
! .LP
  .DS
  .nf
  typedef struct {
***************
*** 287,296 ****
  } XBellFeedbackControl;
  .fi
  .DE
! .P
  The \fIXLedFeedbackControl\fP structure defines the attributes that can be
  controlled for LED feedbacks.
! .P
  .DS
  .nf
  typedef struct {
--- 286,295 ----
  } XBellFeedbackControl;
  .fi
  .DE
! .LP
  The \fIXLedFeedbackControl\fP structure defines the attributes that can be
  controlled for LED feedbacks.
! .LP
  .DS
  .nf
  typedef struct {
*** /tmp/da16205	Sun Jun  5 18:26:01 1994
--- xc/doc/man/Xi/XChKMap.man	Sun Jun  5 18:26:00 1994
***************
*** 1,5 ****
  .\"
- $XMCOPY
  .\" Copyright ([\d,\s]*) by Hewlett-Packard Company, Ardent Computer, 
  .\" 
  .\" Permission to use, copy, modify, distribute, and sell this documentation 
--- 1,4 ----
***************
*** 9,15 ****
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XChKMap.man,v 1.4 94/04/17 20:07:28 dpw Exp $
  .ds xL Programming with Xlib
  .TH XGetDeviceKeyMapping 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
--- 8,14 ----
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XChKMap.man,v 1.5 94/06/04 17:32:17 rws Exp $
  .ds xL Programming with Xlib
  .TH XGetDeviceKeyMapping 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
***************
*** 72,97 ****
  In addition, the following expression must be less than or equal 
  to max_keycode as returned by
  \fIXListInputDevices\fP:
! .P
  .DS 
  first_keycode + keycode_count \- 1
  .DE
! .P
  If this is not the case, a 
  \fIBadValue\fP
  error results. 
  The number of elements in the KeySyms list is:
! .P
  .DS 
  keycode_count * keysyms_per_keycode_return
  .DE
! .P
  KeySym number N, counting from zero, for KeyCode K has the following index
  in the list, counting from zero: 
  .DS
  (K \- first_code) * keysyms_per_code_return + N
  .DE
! .P
  The X server arbitrarily chooses the keysyms_per_keycode_return value 
  to be large enough to report all requested symbols. 
  A special KeySym value of 
--- 71,96 ----
  In addition, the following expression must be less than or equal 
  to max_keycode as returned by
  \fIXListInputDevices\fP:
! .LP
  .DS 
  first_keycode + keycode_count \- 1
  .DE
! .LP
  If this is not the case, a 
  \fIBadValue\fP
  error results. 
  The number of elements in the KeySyms list is:
! .LP
  .DS 
  keycode_count * keysyms_per_keycode_return
  .DE
! .LP
  KeySym number N, counting from zero, for KeyCode K has the following index
  in the list, counting from zero: 
  .DS
  (K \- first_code) * keysyms_per_code_return + N
  .DE
! .LP
  The X server arbitrarily chooses the keysyms_per_keycode_return value 
  to be large enough to report all requested symbols. 
  A special KeySym value of 
***************
*** 102,142 ****
  \fIXGetDeviceKeyMapping\fP,
  use
  \fIXFree\fP.
! .P
  If the specified device does not support input class keys, a \fIBadMatch\fP
  error will result.
! .P
  \fIXGetDeviceKeyMapping\fP
  can generate a \fIBadDevice\fP, \fIBadMatch\fP, or \fIBadValue\fP
  error.
! .P
  For the specified device, the \fIXChangeDeviceKeyMapping\fP
  request defines the symbols for the specified number of KeyCodes
  starting with first_keycode.
  The symbols for KeyCodes outside this range remain unchanged.  
  The number of elements in keysyms must be:
! .P
  .DS
  num_codes * keysyms_per_keycode
  .DE
! .P
  The specified first_keycode must be greater than or equal to min_keycode 
  returned by \fIXListInputDevices\fP, or a \fIBadValue\fP error results.
  In addition, the following expression must be less than or equal to 
  max_keycode as returned by
  \fIXListInputDevices\fP, or a \fIBadValue\fP error results:
! .P
  .DS
  first_keycode + num_codes \- 1
  .DE
! .P
  KeySym number N, counting from zero, for KeyCode K has the following index
  in keysyms, counting from zero: 
! .P
  .DS 
  (K \- first_keycode) * keysyms_per_keycode + N
  .DE
! .P
  The specified keysyms_per_keycode can be chosen arbitrarily by the client
  to be large enough to hold all desired symbols. 
  A special KeySym value of 
--- 101,141 ----
  \fIXGetDeviceKeyMapping\fP,
  use
  \fIXFree\fP.
! .LP
  If the specified device does not support input class keys, a \fIBadMatch\fP
  error will result.
! .LP
  \fIXGetDeviceKeyMapping\fP
  can generate a \fIBadDevice\fP, \fIBadMatch\fP, or \fIBadValue\fP
  error.
! .LP
  For the specified device, the \fIXChangeDeviceKeyMapping\fP
  request defines the symbols for the specified number of KeyCodes
  starting with first_keycode.
  The symbols for KeyCodes outside this range remain unchanged.  
  The number of elements in keysyms must be:
! .LP
  .DS
  num_codes * keysyms_per_keycode
  .DE
! .LP
  The specified first_keycode must be greater than or equal to min_keycode 
  returned by \fIXListInputDevices\fP, or a \fIBadValue\fP error results.
  In addition, the following expression must be less than or equal to 
  max_keycode as returned by
  \fIXListInputDevices\fP, or a \fIBadValue\fP error results:
! .LP
  .DS
  first_keycode + num_codes \- 1
  .DE
! .LP
  KeySym number N, counting from zero, for KeyCode K has the following index
  in keysyms, counting from zero: 
! .LP
  .DS 
  (K \- first_keycode) * keysyms_per_keycode + N
  .DE
! .LP
  The specified keysyms_per_keycode can be chosen arbitrarily by the client
  to be large enough to hold all desired symbols. 
  A special KeySym value of 
***************
*** 149,164 ****
  of the effective list for a KeyCode.
  \fIXChangeDeviceKeyMapping\fP generates a \fIDeviceMappingNotify\fP
  event that is sent to all clients that have selected that type of event.
! .P
  There is no requirement that the X server interpret this mapping. 
  It is merely stored for reading and writing by clients.
! .P
  If the specified device does not support input class keys, a \fIBadMatch\fP
  error results.
! .P
  \fIXChangeDeviceKeyMapping\fP can generate a \fIBadDevice\fP,
  \fIBadMatch\fP, \fIBadAlloc\fP, or \fIBadValue\fP  error.
! .P
  .SH DIAGNOSTICS
  .TP 12
  \fIBadDevice\fP
--- 148,163 ----
  of the effective list for a KeyCode.
  \fIXChangeDeviceKeyMapping\fP generates a \fIDeviceMappingNotify\fP
  event that is sent to all clients that have selected that type of event.
! .LP
  There is no requirement that the X server interpret this mapping. 
  It is merely stored for reading and writing by clients.
! .LP
  If the specified device does not support input class keys, a \fIBadMatch\fP
  error results.
! .LP
  \fIXChangeDeviceKeyMapping\fP can generate a \fIBadDevice\fP,
  \fIBadMatch\fP, \fIBadAlloc\fP, or \fIBadValue\fP  error.
! .LP
  .SH DIAGNOSTICS
  .TP 12
  \fIBadDevice\fP
*** /tmp/da16221	Sun Jun  5 18:26:03 1994
--- xc/doc/man/Xi/XChMMap.man	Sun Jun  5 18:26:02 1994
***************
*** 1,5 ****
  .\"
- $XMCOPY
  .\" Copyright ([\d,\s]*) by Hewlett-Packard Company, Ardent Computer, 
  .\" 
  .\" Permission to use, copy, modify, distribute, and sell this documentation 
--- 1,4 ----
***************
*** 9,15 ****
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XChMMap.man,v 1.4 94/04/17 20:07:29 dpw Exp $
  .ds xL Programming With Xlib
  .TH XGetDeviceModifierMapping 3X11 "Release 6" "X Version 11"  "X FUNCTIONS"
  .SH NAME
--- 8,14 ----
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XChMMap.man,v 1.5 94/06/04 17:32:18 rws Exp $
  .ds xL Programming With Xlib
  .TH XGetDeviceModifierMapping 3X11 "Release 6" "X Version 11"  "X FUNCTIONS"
  .SH NAME
***************
*** 47,53 ****
  If more than eight are specified in the
  \fIXModifierKeymap\fP structure, a \fIBadLength\fP
  error results.
! .P
  The modifiermap member of the \fIXModifierKeymap\fP
  structure contains eight sets of max_keypermod KeyCodes, 
  one for each modifier in the order 
--- 46,52 ----
  If more than eight are specified in the
  \fIXModifierKeymap\fP structure, a \fIBadLength\fP
  error results.
! .LP
  The modifiermap member of the \fIXModifierKeymap\fP
  structure contains eight sets of max_keypermod KeyCodes, 
  one for each modifier in the order 
***************
*** 70,76 ****
  or a
  \fIBadValue\fP
  error results.
! .P
  An X server can impose restrictions on how modifiers can be changed, 
  for example,
  if certain keys do not generate up transitions in hardware,
--- 69,75 ----
  or a
  \fIBadValue\fP
  error results.
! .LP
  An X server can impose restrictions on how modifiers can be changed, 
  for example,
  if certain keys do not generate up transitions in hardware,
***************
*** 86,96 ****
  \fIXSetDeviceModifierMapping\fP
  returns \fIMappingBusy\fP,
  and none of the modifiers is changed.
! .P
  \fIXSetDeviceModifierMapping\fP
  can generate \fIBadLength\P, \fIBadDevice\fP, \fIBadMatch\fP, \fIBadAlloc\fP,
  and \fIBadValue\fP errors.
! .P
  The
  \fIXGetDeviceModifierMapping\fP
  request returns a pointer to a newly created
--- 85,95 ----
  \fIXSetDeviceModifierMapping\fP
  returns \fIMappingBusy\fP,
  and none of the modifiers is changed.
! .LP
  \fIXSetDeviceModifierMapping\fP
  can generate \fIBadLength\P, \fIBadDevice\fP, \fIBadMatch\fP, \fIBadAlloc\fP,
  and \fIBadValue\fP errors.
! .LP
  The
  \fIXGetDeviceModifierMapping\fP
  request returns a pointer to a newly created
***************
*** 100,111 ****
  \fIXFreeModifierMapping \fP.
  If only zero values appear in the set for any modifier, 
  that modifier is disabled.
! .P
  \fIXGetDeviceModifierMapping\fP
  can generate \fIBadDevice\fP and \fIBadMatch\fP errors.
  .SH STRUCTURES
  The \fIXModifierKeymap\fP structure contains:
! .P
  .nf
  typedef struct {
  	int max_keypermod;
--- 99,110 ----
  \fIXFreeModifierMapping \fP.
  If only zero values appear in the set for any modifier, 
  that modifier is disabled.
! .LP
  \fIXGetDeviceModifierMapping\fP
  can generate \fIBadDevice\fP and \fIBadMatch\fP errors.
  .SH STRUCTURES
  The \fIXModifierKeymap\fP structure contains:
! .LP
  .nf
  typedef struct {
  	int max_keypermod;
***************
*** 112,118 ****
  	KeyCode *modifiermap;
  } XModifierKeymap;
  .fi
! .P
  .SH DIAGNOSTICS
  .TP 12
  \fIBadLength\fP
--- 111,117 ----
  	KeyCode *modifiermap;
  } XModifierKeymap;
  .fi
! .LP
  .SH DIAGNOSTICS
  .TP 12
  \fIBadLength\fP
*** /tmp/da16237	Sun Jun  5 18:26:04 1994
--- xc/doc/man/Xi/XChProp.man	Sun Jun  5 18:26:04 1994
***************
*** 1,5 ****
  .\"
- $XMCOPY
  .\" Copyright ([\d,\s]*) by Hewlett-Packard Company, Ardent Computer, 
  .\" 
  .\" Permission to use, copy, modify, distribute, and sell this documentation 
--- 1,4 ----
***************
*** 9,15 ****
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XChProp.man,v 1.5 94/04/17 20:07:30 dpw Exp $
  .ds xL Programming With Xlib
  .TH XChangeDeviceDontPropagateList 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
--- 8,14 ----
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XChProp.man,v 1.6 94/06/04 17:32:19 rws Exp $
  .ds xL Programming With Xlib
  .TH XChangeDeviceDontPropagateList 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
***************
*** 64,70 ****
  Once modified, the list remains modified for the life of the window.
  Events are not removed from the list because the client that added them
  has terminated.
! .P
  Suppression of event propagation is not allowed for all input extension
  events.  If a specified event class is one that cannot be suppressed,
  a \fIBadClass\fP error will result.  Events that can be suppressed
--- 63,69 ----
  Once modified, the list remains modified for the life of the window.
  Events are not removed from the list because the client that added them
  has terminated.
! .LP
  Suppression of event propagation is not allowed for all input extension
  events.  If a specified event class is one that cannot be suppressed,
  a \fIBadClass\fP error will result.  Events that can be suppressed
***************
*** 71,83 ****
  include \fIDeviceKeyPress\fP, \fIDeviceKeyRelease\fP, \fIDeviceButtonPress\fP,
  \fIDeviceButtonRelease\fP, \fIDeviceMotionNotify\fP, \fIProximityIn\fP, 
  and \fIProximityOut\fP.
! .P
  \fIXChangeDeviceDontPropagateList\fP
  can generate a \fIBadDevice\fP, \fIBadClass\fP, or \fIBadValue\fP error.
! .P
  The \fIXGetDeviceDontPropagateList\fP request queries the list
  of events that should not be propagated to ancestors of the event window.
! .P
  \fIXGetDeviceDontPropagateList\fP
  can generate a \fIBadClass\fP  or \fIBadWindow\fP error.
  .SH DIAGNOSTICS
--- 70,82 ----
  include \fIDeviceKeyPress\fP, \fIDeviceKeyRelease\fP, \fIDeviceButtonPress\fP,
  \fIDeviceButtonRelease\fP, \fIDeviceMotionNotify\fP, \fIProximityIn\fP, 
  and \fIProximityOut\fP.
! .LP
  \fIXChangeDeviceDontPropagateList\fP
  can generate a \fIBadDevice\fP, \fIBadClass\fP, or \fIBadValue\fP error.
! .LP
  The \fIXGetDeviceDontPropagateList\fP request queries the list
  of events that should not be propagated to ancestors of the event window.
! .LP
  \fIXGetDeviceDontPropagateList\fP
  can generate a \fIBadClass\fP  or \fIBadWindow\fP error.
  .SH DIAGNOSTICS
*** /tmp/da16253	Sun Jun  5 18:26:06 1994
--- xc/doc/man/Xi/XChgKbd.man	Sun Jun  5 18:26:05 1994
***************
*** 1,5 ****
  .\"
- $XMCOPY
  .\" Copyright ([\d,\s]*) by Hewlett-Packard Company, Ardent Computer, 
  .\" 
  .\" Permission to use, copy, modify, distribute, and sell this documentation 
--- 1,4 ----
***************
*** 9,15 ****
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XChgKbd.man,v 1.4 94/04/17 20:07:31 dpw Exp $
  .ds xL Programming With Xlib
  .TH XChangeKeyboardDevice 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
--- 8,14 ----
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XChgKbd.man,v 1.5 94/06/04 17:32:20 rws Exp $
  .ds xL Programming With Xlib
  .TH XChangeKeyboardDevice 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
***************
*** 35,46 ****
  The device must support input class \fIKeys\fP, or a \fIBadMatch\fP error
  will result.  If the server implementation does not support using the requested
  device as the X keyboard, a \fIBadDevice\fP error will result.
! .P
  If the specified device is grabbed by another client, \fIAlreadyGrabbed\fP
  is returned.  If the specified device is frozen by a grab on another device,
  \fIGrabFrozen\fP is returned.
  If the request is successful, \fISuccess\fP is returned.
! .P
  If the request succeeds,
  a \fIChangeDeviceNotify\fP event is sent to all clients that have selected that
  event.  A \fIMappingNotify\fP event with request = \fIMappingKeyboard\fP
--- 34,45 ----
  The device must support input class \fIKeys\fP, or a \fIBadMatch\fP error
  will result.  If the server implementation does not support using the requested
  device as the X keyboard, a \fIBadDevice\fP error will result.
! .LP
  If the specified device is grabbed by another client, \fIAlreadyGrabbed\fP
  is returned.  If the specified device is frozen by a grab on another device,
  \fIGrabFrozen\fP is returned.
  If the request is successful, \fISuccess\fP is returned.
! .LP
  If the request succeeds,
  a \fIChangeDeviceNotify\fP event is sent to all clients that have selected that
  event.  A \fIMappingNotify\fP event with request = \fIMappingKeyboard\fP
***************
*** 48,54 ****
  The specified device becomes the X keyboard and 
  the old X keyboard becomes accessible through the input extension
  protocol requests.
! .P
  \fIXChangeKeyboardDevice\fP can generate a \fIBadDevice\fP or a \fIBadMatch\fP
  error.
  .SH DIAGNOSTICS
--- 47,53 ----
  The specified device becomes the X keyboard and 
  the old X keyboard becomes accessible through the input extension
  protocol requests.
! .LP
  \fIXChangeKeyboardDevice\fP can generate a \fIBadDevice\fP or a \fIBadMatch\fP
  error.
  .SH DIAGNOSTICS
*** /tmp/da16269	Sun Jun  5 18:26:07 1994
--- xc/doc/man/Xi/XChgPtr.man	Sun Jun  5 18:26:07 1994
***************
*** 1,5 ****
  .\"
- $XMCOPY
  .\" Copyright ([\d,\s]*) by Hewlett-Packard Company, Ardent Computer, 
  .\" 
  .\" Permission to use, copy, modify, distribute, and sell this documentation 
--- 1,4 ----
***************
*** 9,15 ****
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XChgPtr.man,v 1.4 94/04/17 20:07:31 dpw Exp $
  .ds xL Programming With Xlib
  .TH XChangePointerDevice 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
--- 8,14 ----
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XChgPtr.man,v 1.5 94/06/04 17:32:21 rws Exp $
  .ds xL Programming With Xlib
  .TH XChangePointerDevice 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
***************
*** 45,56 ****
  support input class \fIValuators\fP or a \fIBadMatch\fP error will result.
  If the implementation does not support use of the specified device as the
  X pointer, a \fIBadDevice\fP error will result.
! .P
  If the specified device is grabbed by another client, \fIAlreadyGrabbed\fP
  is returned.  If the specified device is frozen by a grab on another device,
  \fIGrabFrozen\fP is returned.
  If the request is successful, \fISuccess\fP is returned.
! .P
  If the request succeeds,
  a \fIChangeDeviceNotify\fP event is sent to all clients that have selected that
  event.  A \fIMappingNotify\fP event with request = \fIMappingPointer\fP is
--- 44,55 ----
  support input class \fIValuators\fP or a \fIBadMatch\fP error will result.
  If the implementation does not support use of the specified device as the
  X pointer, a \fIBadDevice\fP error will result.
! .LP
  If the specified device is grabbed by another client, \fIAlreadyGrabbed\fP
  is returned.  If the specified device is frozen by a grab on another device,
  \fIGrabFrozen\fP is returned.
  If the request is successful, \fISuccess\fP is returned.
! .LP
  If the request succeeds,
  a \fIChangeDeviceNotify\fP event is sent to all clients that have selected that
  event.  A \fIMappingNotify\fP event with request = \fIMappingPointer\fP is
***************
*** 58,64 ****
  The specified device becomes the X pointer, and
  the old X pointer becomes accessible through the input extension
  protocol requests.
! .P
  \fIXChangePointerDevice\fP can generate a \fIBadDevice\fP or a \fIBadMatch\fP
  error.
  .SH DIAGNOSTICS
--- 57,63 ----
  The specified device becomes the X pointer, and
  the old X pointer becomes accessible through the input extension
  protocol requests.
! .LP
  \fIXChangePointerDevice\fP can generate a \fIBadDevice\fP or a \fIBadMatch\fP
  error.
  .SH DIAGNOSTICS
*** /tmp/da16285	Sun Jun  5 18:26:09 1994
--- xc/doc/man/Xi/XDevBell.man	Sun Jun  5 18:26:08 1994
***************
*** 1,5 ****
  .\"
- $XMCOPY
  .\" Copyright ([\d,\s]*) by Hewlett-Packard Company, Ardent Computer, 
  .\" 
  .\" Permission to use, copy, modify, distribute, and sell this documentation 
--- 1,4 ----
***************
*** 9,15 ****
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XDevBell.man,v 1.5 94/04/17 20:07:32 dpw Exp $
  .ds xL Programming With Xlib
  .TH XDeviceBell 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
--- 8,14 ----
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XDevBell.man,v 1.6 94/06/04 17:32:23 rws Exp $
  .ds xL Programming With Xlib
  .TH XDeviceBell 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
***************
*** 54,72 ****
  does not support a bell, or if a nonexistent feedbackid is specified,
  or a percent value is specified that is not in the range -100 to 100,
  a \fIBadValue\fP error will be returned.
! .P
  The volume at which the bell is rung when the percent argument is 
  nonnegative is:
  .IP
  base \- [(base * percent) / 100] + percent
! .P
  The volume at which the bell rings
  when the percent argument is negative is:
  .IP
  base + [(base * percent) / 100]
! .P
  To change the base volume of the bell, use \fIXChangeFeedbackControl\fP.
! .P
  \fIXDeviceBell\fP can generate a \fIBadDevice\fP or a \fIBadValue\fP
  error.
  .SH DIAGNOSTICS
--- 53,71 ----
  does not support a bell, or if a nonexistent feedbackid is specified,
  or a percent value is specified that is not in the range -100 to 100,
  a \fIBadValue\fP error will be returned.
! .LP
  The volume at which the bell is rung when the percent argument is 
  nonnegative is:
  .IP
  base \- [(base * percent) / 100] + percent
! .LP
  The volume at which the bell rings
  when the percent argument is negative is:
  .IP
  base + [(base * percent) / 100]
! .LP
  To change the base volume of the bell, use \fIXChangeFeedbackControl\fP.
! .LP
  \fIXDeviceBell\fP can generate a \fIBadDevice\fP or a \fIBadValue\fP
  error.
  .SH DIAGNOSTICS
*** /tmp/da16301	Sun Jun  5 18:26:11 1994
--- xc/doc/man/Xi/XGetDvMo.man	Sun Jun  5 18:26:10 1994
***************
*** 1,5 ****
  .\"
- $XMCOPY
  .\" Copyright ([\d,\s]*) by Hewlett-Packard Company, Ardent Computer, 
  .\" 
  .\" Permission to use, copy, modify, distribute, and sell this documentation 
--- 1,4 ----
***************
*** 9,15 ****
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XGetDvMo.man,v 1.4 94/04/17 20:07:33 dpw Exp $
  .ds xL Programming with Xlib
  .TH XGetDeviceMotionEvents 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
--- 8,14 ----
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XGetDvMo.man,v 1.5 94/06/04 17:32:24 rws Exp $
  .ds xL Programming with Xlib
  .TH XGetDeviceMotionEvents 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
***************
*** 62,68 ****
  \fIDeviceMotionNotify\fP
  events.
  The \fIXGetDeviceMotionEvents\fP request makes this history available.
! .P
  The
  \fIXGetDeviceMotionEvents\fP
  request returns all events in the motion history buffer that fall between the
--- 61,67 ----
  \fIDeviceMotionNotify\fP
  events.
  The \fIXGetDeviceMotionEvents\fP request makes this history available.
! .LP
  The
  \fIXGetDeviceMotionEvents\fP
  request returns all events in the motion history buffer that fall between the
***************
*** 71,77 ****
  future, no events are returned.
  If the stop time is in the future, it is equivalent to specifying
  \fICurrentTime\fP.
! .P
  The \fImode\fP indicates whether the device is reporting absolute positional
  data (mode=\fIAbsolute\fP) or relative motion data (mode=\fIRelative\fP).
  Some devices allow their mode to be changed via the \fIXSetDeviceMode\fP
--- 70,76 ----
  future, no events are returned.
  If the stop time is in the future, it is equivalent to specifying
  \fICurrentTime\fP.
! .LP
  The \fImode\fP indicates whether the device is reporting absolute positional
  data (mode=\fIAbsolute\fP) or relative motion data (mode=\fIRelative\fP).
  Some devices allow their mode to be changed via the \fIXSetDeviceMode\fP
***************
*** 78,84 ****
  request.
  These constants are defined in the file XI.h.  The \fIaxis_count\fP
  returns the number of axes or valuators being reported by the device.
! .P
  \fIXGetDeviceMotionEvents\fP can generate a \fIBadDevice\fP, or \fIBadMatch\fP
  error.
  .SH STRUCTURES
--- 77,83 ----
  request.
  These constants are defined in the file XI.h.  The \fIaxis_count\fP
  returns the number of axes or valuators being reported by the device.
! .LP
  \fIXGetDeviceMotionEvents\fP can generate a \fIBadDevice\fP, or \fIBadMatch\fP
  error.
  .SH STRUCTURES
***************
*** 85,91 ****
  The
  \fIXDeviceTimeCoord\fP
  structure contains:
! .P
  .nf
  typedef struct {
  	Time time;
--- 84,90 ----
  The
  \fIXDeviceTimeCoord\fP
  structure contains:
! .LP
  .nf
  typedef struct {
  	Time time;
***************
*** 92,98 ****
  	int *data;
  } XDeviceTimeCoord;
  .fi
! .P
  The time member is set to the time, in milliseconds. 
  The data member is a pointer to an array of integers.  
  These integers are set to the values of each valuator or
--- 91,97 ----
  	int *data;
  } XDeviceTimeCoord;
  .fi
! .LP
  The time member is set to the time, in milliseconds. 
  The data member is a pointer to an array of integers.  
  These integers are set to the values of each valuator or
***************
*** 105,114 ****
  field of the \fIXAxisInfo\fP returned by the \fIXListInputDevices\fP 
  request.  If the mode is \fIRelative\fP, the data values are the relative
  values generated by the device.
! .P
  You should use \fIXFreeDeviceMotionEvents\fP to free the data returned by
  this request.
! .P
  Errors returned by this request: \fIBadDevice\fP, \fIBadMatch\fP.
  .SH DIAGNOSTICS
  .TP 12
--- 104,113 ----
  field of the \fIXAxisInfo\fP returned by the \fIXListInputDevices\fP 
  request.  If the mode is \fIRelative\fP, the data values are the relative
  values generated by the device.
! .LP
  You should use \fIXFreeDeviceMotionEvents\fP to free the data returned by
  this request.
! .LP
  Errors returned by this request: \fIBadDevice\fP, \fIBadMatch\fP.
  .SH DIAGNOSTICS
  .TP 12
*** /tmp/da16317	Sun Jun  5 18:26:12 1994
--- xc/doc/man/Xi/XGetExtV.man	Sun Jun  5 18:26:12 1994
***************
*** 1,5 ****
  .\"
- $XMCOPY
  .\" Copyright ([\d,\s]*) by Hewlett-Packard Company, Ardent Computer, 
  .\" 
  .\" Permission to use, copy, modify, distribute, and sell this documentation 
--- 1,4 ----
***************
*** 9,14 ****
--- 8,14 ----
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
+ .\" $XConsortium: XGetExtV.man,v 1.5 94/06/04 17:34:47 rws Exp $
  .ds xL Programming With Xlib
  .TH XGetExtensionVersion 3X "" "X Version 11" 
  .SH NAME
***************
*** 35,41 ****
  requests added to the input extension after its initial release is indicated
  by a version number corresponding to the added requests.  Each version
  contains all the protocol requests contained by previous versions.
! .P
  You should use \fIXFree\fP to free the \fIXExtensionVersion\fP structure.
  .SH STRUCTURES
  This request returns an XExtensionVersion structure.
--- 35,41 ----
  requests added to the input extension after its initial release is indicated
  by a version number corresponding to the added requests.  Each version
  contains all the protocol requests contained by previous versions.
! .LP
  You should use \fIXFree\fP to free the \fIXExtensionVersion\fP structure.
  .SH STRUCTURES
  This request returns an XExtensionVersion structure.
*** /tmp/da16333	Sun Jun  5 18:26:14 1994
--- xc/doc/man/Xi/XGrDvBut.man	Sun Jun  5 18:26:13 1994
***************
*** 1,5 ****
  .\"
- $XMCOPY
  .\" Copyright ([\d,\s]*) by Hewlett-Packard Company, Ardent Computer, 
  .\" 
  .\" Permission to use, copy, modify, distribute, and sell this documentation 
--- 1,4 ----
***************
*** 9,15 ****
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XGrDvBut.man,v 1.5 94/04/17 20:07:35 dpw Exp $
  .ds xL Programming With Xlib
  .TH XGrabDeviceButton 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
--- 8,14 ----
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XGrDvBut.man,v 1.6 94/06/04 17:32:26 rws Exp $
  .ds xL Programming With Xlib
  .TH XGrabDeviceButton 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
***************
*** 106,121 ****
  .IP \(bu 5
  A passive grab on the same button/modifier combination does not exist
  on any ancestor of grab_window.
! .P
  The interpretation of the remaining arguments is as for
  \fIXGrabDevice\fP.
  The active grab is terminated automatically when the logical state of the
  device has all buttons released
  (independent of the logical state of the modifier keys).
! .P
  Note that the logical state of a device (as seen by client applications)
  may lag the physical state if device event processing is frozen.
! .P
  This request overrides all previous grabs by the same client on the same
  button/modifier combinations on the same window.
  A modifiers of 
--- 105,120 ----
  .IP \(bu 5
  A passive grab on the same button/modifier combination does not exist
  on any ancestor of grab_window.
! .LP
  The interpretation of the remaining arguments is as for
  \fIXGrabDevice\fP.
  The active grab is terminated automatically when the logical state of the
  device has all buttons released
  (independent of the logical state of the modifier keys).
! .LP
  Note that the logical state of a device (as seen by client applications)
  may lag the physical state if device event processing is frozen.
! .LP
  This request overrides all previous grabs by the same client on the same
  button/modifier combinations on the same window.
  A modifiers of 
***************
*** 130,139 ****
  issuing the request for all possible buttons.
  Otherwise, it is not required that the specified button currently be assigned
  to a physical button.
! .P
  A modifier_device of NULL indicates that the X keyboard is to be used as the
  modifier_device.
! .P
  If some other client has already issued a 
  \fIXGrabDeviceButton\fP
  with the same button/modifier combination on the same window, a
--- 129,138 ----
  issuing the request for all possible buttons.
  Otherwise, it is not required that the specified button currently be assigned
  to a physical button.
! .LP
  A modifier_device of NULL indicates that the X keyboard is to be used as the
  modifier_device.
! .LP
  If some other client has already issued a 
  \fIXGrabDeviceButton\fP
  with the same button/modifier combination on the same window, a
***************
*** 150,156 ****
  established) if there is a conflicting grab for any combination.
  \fIXGrabDeviceButton\fP
  has no effect on an active grab.
! .P
  \fIXGrabDeviceButton\fP
  can generate
  \fIBadClass\fP,
--- 149,155 ----
  established) if there is a conflicting grab for any combination.
  \fIXGrabDeviceButton\fP
  has no effect on an active grab.
! .LP
  \fIXGrabDeviceButton\fP
  can generate
  \fIBadClass\fP,
***************
*** 175,184 ****
  request for all possible buttons.
  \fIXUngrabDeviceButton\fP
  has no effect on an active grab.
! .P
  A modifier_device of NULL indicates that the X keyboard should be used as
  the modifier_device.
! .P
  \fIXUngrabDeviceButton\fP
  can generate
  \fIBadDevice\fP,
--- 174,183 ----
  request for all possible buttons.
  \fIXUngrabDeviceButton\fP
  has no effect on an active grab.
! .LP
  A modifier_device of NULL indicates that the X keyboard should be used as
  the modifier_device.
! .LP
  \fIXUngrabDeviceButton\fP
  can generate
  \fIBadDevice\fP,
*** /tmp/da16349	Sun Jun  5 18:26:16 1994
--- xc/doc/man/Xi/XGrDvKey.man	Sun Jun  5 18:26:15 1994
***************
*** 1,5 ****
  .\"
- $XMCOPY
  .\" Copyright ([\d,\s]*) by Hewlett-Packard Company, Ardent Computer, 
  .\" 
  .\" Permission to use, copy, modify, distribute, and sell this documentation 
--- 1,4 ----
***************
*** 9,15 ****
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XGrDvKey.man,v 1.4 94/04/17 20:07:36 dpw Exp $
  .ds xL Programming with Xlib
  .TH XGrabDeviceKey 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
--- 8,14 ----
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XGrDvKey.man,v 1.5 94/06/04 17:32:28 rws Exp $
  .ds xL Programming with Xlib
  .TH XGrabDeviceKey 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
***************
*** 126,137 ****
  .IP \(bu 5
  A passive grab on the same key/modifier combination does not exist
  on any ancestor of grab_window.
! .P
  The interpretation of the remaining arguments is as for
  \fIXGrabDevice\fP .
  The active grab is terminated automatically when the logical state of the
  device has the specified key released.
! .P
  Note that the logical state of a device (as seen by means of the X protocol )
  may lag the physical state if device event processing is frozen.
  .LP
--- 125,136 ----
  .IP \(bu 5
  A passive grab on the same key/modifier combination does not exist
  on any ancestor of grab_window.
! .LP
  The interpretation of the remaining arguments is as for
  \fIXGrabDevice\fP .
  The active grab is terminated automatically when the logical state of the
  device has the specified key released.
! .LP
  Note that the logical state of a device (as seen by means of the X protocol )
  may lag the physical state if device event processing is frozen.
  .LP
***************
*** 138,144 ****
  If the key is not \fIAnyKey\fP, it must be in the range specified by
  min_keycode and max_keycode as returned by the \fIXListInputDevices\fP
  request.  Otherwise, a \fIBadValue\fP error results.
! .P
  This request overrides all previous grabs by the same client on the same
  Key/modifier combinations on the same window.
  A modifier of 
--- 137,143 ----
  If the key is not \fIAnyKey\fP, it must be in the range specified by
  min_keycode and max_keycode as returned by the \fIXListInputDevices\fP
  request.  Otherwise, a \fIBadValue\fP error results.
! .LP
  This request overrides all previous grabs by the same client on the same
  Key/modifier combinations on the same window.
  A modifier of 
***************
*** 153,162 ****
  issuing the request for all possible keys.
  Otherwise, it is not required that the specified key currently be assigned
  to a physical Key.
! .P
  If a modifier_device of NULL is specified, the X keyboard will be used as
  the modifier_device.
! .P
  If some other client has already issued a 
  \fIXGrabDeviceKey\fP
  with the same Key/modifier combination on the same window, a
--- 152,161 ----
  issuing the request for all possible keys.
  Otherwise, it is not required that the specified key currently be assigned
  to a physical Key.
! .LP
  If a modifier_device of NULL is specified, the X keyboard will be used as
  the modifier_device.
! .LP
  If some other client has already issued a 
  \fIXGrabDeviceKey\fP
  with the same Key/modifier combination on the same window, a
***************
*** 173,179 ****
  established) if there is a conflicting grab for any combination.
  \fIXGrabDeviceKey\fP
  has no effect on an active grab.
! .P
  \fIXGrabDeviceKey\fP
  can generate
  \fIBadAccess\fP,
--- 172,178 ----
  established) if there is a conflicting grab for any combination.
  \fIXGrabDeviceKey\fP
  has no effect on an active grab.
! .LP
  \fIXGrabDeviceKey\fP
  can generate
  \fIBadAccess\fP,
***************
*** 183,189 ****
  \fIBadValue\fP,
  and
  \fIBadWindow\fP 
! errors.  It returns \fISuccess\fI on successful completion of the request.
  .P 
  The \fIXUngrabDeviceKey\fP
  request releases the passive grab for a key/modifier combination on the 
--- 182,188 ----
  \fIBadValue\fP,
  and
  \fIBadWindow\fP 
! errors.  It returns \fISuccess\fP on successful completion of the request.
  .P 
  The \fIXUngrabDeviceKey\fP
  request releases the passive grab for a key/modifier combination on the 
***************
*** 195,204 ****
  A Key of \fIAnyKey\fP 
  is equivalent to issuing the request for all possible Keys.
  \fIXUngrabDeviceKey\fP has no effect on an active grab.
! .P
  If a modifier_device of NULL is specified, the X keyboard will be used as the
  modifier_device.
! .P
  \fIXUngrabDeviceKey\fP can generate \fIBadDevice\fP, \fIBadMatch\fP,
  \fIBadValue\fP and \fIBadWindow\fP errors.
  .SH DIAGNOSTICS
--- 194,203 ----
  A Key of \fIAnyKey\fP 
  is equivalent to issuing the request for all possible Keys.
  \fIXUngrabDeviceKey\fP has no effect on an active grab.
! .LP
  If a modifier_device of NULL is specified, the X keyboard will be used as the
  modifier_device.
! .LP
  \fIXUngrabDeviceKey\fP can generate \fIBadDevice\fP, \fIBadMatch\fP,
  \fIBadValue\fP and \fIBadWindow\fP errors.
  .SH DIAGNOSTICS
*** /tmp/da16365	Sun Jun  5 18:26:18 1994
--- xc/doc/man/Xi/XGrabDev.man	Sun Jun  5 18:26:17 1994
***************
*** 1,5 ****
  .\"
- $XMCOPY
  .\" Copyright ([\d,\s]*) by Hewlett-Packard Company, Ardent Computer, 
  .\" 
  .\" Permission to use, copy, modify, distribute, and sell this documentation 
--- 1,4 ----
***************
*** 9,15 ****
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XGrabDev.man,v 1.5 94/04/17 20:07:36 dpw Exp $
  .ds xL Programming With Xlib
  .TH XGrabDevice 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
--- 8,14 ----
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XGrabDev.man,v 1.6 94/06/04 17:32:29 rws Exp $
  .ds xL Programming With Xlib
  .TH XGrabDevice 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
***************
*** 101,107 ****
  device event would normally be reported to this client, it is reported
  normally; otherwise, the event is reported with respect to the
  grab_window, and is only reported if specified in the event_list.
! .P
  If the this_device_mode argument is 
  \fIGrabModeAsync\fP ,
  device event processing continues
--- 100,106 ----
  device event would normally be reported to this client, it is reported
  normally; otherwise, the event is reported with respect to the
  grab_window, and is only reported if specified in the event_list.
! .LP
  If the this_device_mode argument is 
  \fIGrabModeAsync\fP ,
  device event processing continues
***************
*** 117,123 ****
  call or until the device grab is released.
  Actual device changes are not lost while the device is frozen; 
  they are simply queued in the server for later processing.
! .P
  If other_devices_mode is 
  \fIGrabModeAsync\fP ,
  processing of events from other devices is unaffected
--- 116,122 ----
  call or until the device grab is released.
  Actual device changes are not lost while the device is frozen; 
  they are simply queued in the server for later processing.
! .LP
  If other_devices_mode is 
  \fIGrabModeAsync\fP ,
  processing of events from other devices is unaffected
***************
*** 132,138 ****
  call or until the device grab is released.
  Actual events are not lost while the devices are frozen; 
  they are simply queued in the server for later processing.
! .P
  If the device is actively grabbed by some other client,
  \fIXGrabDevice\fP
  fails and returns
--- 131,137 ----
  call or until the device grab is released.
  Actual events are not lost while the devices are frozen; 
  they are simply queued in the server for later processing.
! .LP
  If the device is actively grabbed by some other client,
  \fIXGrabDevice\fP
  fails and returns
***************
*** 154,165 ****
  If a grabbed device is closed by a client while an active grab by that
  client is in effect, the active grab is released.  If the device is
  frozen only by an active grab of the requesting client, it is thawed.
! .P
  \fIXGrabDevice\fP
  can generate
  \fIBadClass\fP, \fIBadDevice\fP, \fIBadValue\fP, and \fIBadWindow\fP 
  errors.
! .P
  The
  \fIXUngrabDevice\fP
  request
--- 153,164 ----
  If a grabbed device is closed by a client while an active grab by that
  client is in effect, the active grab is released.  If the device is
  frozen only by an active grab of the requesting client, it is thawed.
! .LP
  \fIXGrabDevice\fP
  can generate
  \fIBadClass\fP, \fIBadDevice\fP, \fIBadValue\fP, and \fIBadWindow\fP 
  errors.
! .LP
  The
  \fIXUngrabDevice\fP
  request
*** /tmp/da16381	Sun Jun  5 18:26:19 1994
--- xc/doc/man/Xi/XListDev.man	Sun Jun  5 18:26:19 1994
***************
*** 1,5 ****
  .\"
- $XMCOPY
  .\" Copyright ([\d,\s]*) by Hewlett-Packard Company, Ardent Computer, 
  .\" 
  .\" Permission to use, copy, modify, distribute, and sell this documentation 
--- 1,4 ----
***************
*** 9,15 ****
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XListDev.man,v 1.5 94/04/17 20:07:37 dpw Exp $
  .ds xL Programming with Xlib
  .TH XListInputDevices 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
--- 8,14 ----
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XListDev.man,v 1.6 94/06/04 17:31:20 rws Exp $
  .ds xL Programming with Xlib
  .TH XListInputDevices 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
***************
*** 42,53 ****
  X pointer and X keyboard, any other input devices that are currently accessible
  through the X server, and any input devices that are not currently accessible
  through the X server but could be accessed if requested.
! .P
  Some server implementations may make all input devices available at the time
  the server is initialized.  Others may wait until requested by a client to
  access an input device.  In the latter case, it is possible that an input 
  device will be listed as available at one time but not at another.
! .P
  For each input device available to the server, the XListInputDevices
  request returns an XDeviceInfo structure.  That structure contains a
  pointer to a list of structures, each of which contains information about 
--- 41,52 ----
  X pointer and X keyboard, any other input devices that are currently accessible
  through the X server, and any input devices that are not currently accessible
  through the X server but could be accessed if requested.
! .LP
  Some server implementations may make all input devices available at the time
  the server is initialized.  Others may wait until requested by a client to
  access an input device.  In the latter case, it is possible that an input 
  device will be listed as available at one time but not at another.
! .LP
  For each input device available to the server, the XListInputDevices
  request returns an XDeviceInfo structure.  That structure contains a
  pointer to a list of structures, each of which contains information about 
***************
*** 68,85 ****
  } XDeviceInfo;
  .fi
  .DE
! .P
  The id is a number in the range 0-128 that uniquely identifies 
  the device.  It is assigned to the device when it is initialized by the server.
! .P
  The type field is of type Atom and indicates the nature
  of the device.
! .P
  The name field contains a pointer to a null-terminated
  string that corresponds to one of the defined device
  types.  The name will correspond to one of the following
  strings (defined in the header file \fIXI.h\fP:
! .P
  .DS
  XI_MOUSE
  XI_TABLET
--- 67,84 ----
  } XDeviceInfo;
  .fi
  .DE
! .LP
  The id is a number in the range 0-128 that uniquely identifies 
  the device.  It is assigned to the device when it is initialized by the server.
! .LP
  The type field is of type Atom and indicates the nature
  of the device.
! .LP
  The name field contains a pointer to a null-terminated
  string that corresponds to one of the defined device
  types.  The name will correspond to one of the following
  strings (defined in the header file \fIXI.h\fP:
! .LP
  .DS
  XI_MOUSE
  XI_TABLET
***************
*** 100,111 ****
  XI_CURSORKEYS
  XI_FOOTMOUSE
  .DE
! .P
  These names may be directly compared with the name field of the
  XDeviceInfo structure, or used in an XInternAtom request to return
  an atom that can be compared with the type field of the XDeviceInfo
  structure.
! .P
  The num_classes field is a number in the
  range 0-255 that specifies the number of input classes
  supported by the device for which information is
--- 99,110 ----
  XI_CURSORKEYS
  XI_FOOTMOUSE
  .DE
! .LP
  These names may be directly compared with the name field of the
  XDeviceInfo structure, or used in an XInternAtom request to return
  an atom that can be compared with the type field of the XDeviceInfo
  structure.
! .LP
  The num_classes field is a number in the
  range 0-255 that specifies the number of input classes
  supported by the device for which information is
***************
*** 112,142 ****
  returned by ListInputDevices.  Some input classes, such
  as class Focus and class Proximity do not have any
  information to be returned by ListInputDevices.
! .P
  The use field specifies how the device is currently
  being used.  If the value is \fIIsXKeyboard\fP, the device is
  currently being used as the X keyboard.  If the value
! is \fIIsXPointer\rP, the device is currently being used as
  the X pointer.  If the value is \fIIsXExtensionDevice\fP, the
  device is available for use as an extension device.
! .P
  The inputclassinfo field contains a pointer to the first input-class
  specific data.  The first two fields are common to all
  classes.
! .P
  The class field is a number in the range 0-255.
  It uniquely identifies the class of input for which
  information is returned.  Currently defined classes
  are KeyClass, ButtonClass, and ValuatorClass.
! .P
  The length field is a number in the range 0- 255.  
  It specifies the number of bytes of data that are
  contained in this input class.  The length includes the
  class and length fields.
! .P
  The XKeyInfo structure describes the characteristics of the keys on the
  device.  It is defined as follows:
! .P
  .DS
  .nf
  typedef struct _XKeyInfo {
--- 111,141 ----
  returned by ListInputDevices.  Some input classes, such
  as class Focus and class Proximity do not have any
  information to be returned by ListInputDevices.
! .LP
  The use field specifies how the device is currently
  being used.  If the value is \fIIsXKeyboard\fP, the device is
  currently being used as the X keyboard.  If the value
! is \fIIsXPointer\fP, the device is currently being used as
  the X pointer.  If the value is \fIIsXExtensionDevice\fP, the
  device is available for use as an extension device.
! .LP
  The inputclassinfo field contains a pointer to the first input-class
  specific data.  The first two fields are common to all
  classes.
! .LP
  The class field is a number in the range 0-255.
  It uniquely identifies the class of input for which
  information is returned.  Currently defined classes
  are KeyClass, ButtonClass, and ValuatorClass.
! .LP
  The length field is a number in the range 0- 255.  
  It specifies the number of bytes of data that are
  contained in this input class.  The length includes the
  class and length fields.
! .LP
  The XKeyInfo structure describes the characteristics of the keys on the
  device.  It is defined as follows:
! .LP
  .DS
  .nf
  typedef struct _XKeyInfo {
***************
*** 148,167 ****
  } XKeyInfo;
  .fi
  .DE
! .P
  min_keycode is of type KEYCODE.  It specifies the
  minimum keycode that the device will report.  The
  minimum keycode will not be smaller than 8.
! .P
  max_keycode is of type KEYCODE.  It specifies the
  maximum keycode that the device will report.  The
  maximum keycode will not be larger than 255.
! .P
  num_keys specifies the number of keys that the device has.
! .P
  The XButtonInfo structure defines the characteristics of the buttons
  on the device.  It is defined as follows:
! .P
  .DS
  .nf
  typedef struct _XButtonInfo {
--- 147,166 ----
  } XKeyInfo;
  .fi
  .DE
! .LP
  min_keycode is of type KEYCODE.  It specifies the
  minimum keycode that the device will report.  The
  minimum keycode will not be smaller than 8.
! .LP
  max_keycode is of type KEYCODE.  It specifies the
  maximum keycode that the device will report.  The
  maximum keycode will not be larger than 255.
! .LP
  num_keys specifies the number of keys that the device has.
! .LP
  The XButtonInfo structure defines the characteristics of the buttons
  on the device.  It is defined as follows:
! .LP
  .DS
  .nf
  typedef struct _XButtonInfo {
***************
*** 171,182 ****
  } XButtonInfo;
  .fi
  .DE
! .P
  num_buttons specifies the number of buttons that the device has.
! .P
  The XValuatorInfo structure defines the characteristics of the valuators
  on the device.  It is defined as follows:
! .P
  .DE
  .nf
  typedef struct	_XValuatorInfo {
--- 170,181 ----
  } XButtonInfo;
  .fi
  .DE
! .LP
  num_buttons specifies the number of buttons that the device has.
! .LP
  The XValuatorInfo structure defines the characteristics of the valuators
  on the device.  It is defined as follows:
! .LP
  .DE
  .nf
  typedef struct	_XValuatorInfo {
***************
*** 190,209 ****
  .fi
  .DS
  num_axes contains the number of axes the device supports.
! .P
  mode is a constant that has one of the following
  values: Absolute or Relative.  Some devices allow the
  mode to be changed dynamically via the SetDeviceMode
  request.
! .P
  motion_buffer_size is a cardinal number that specifies
  the number of elements that can be contained in the
  motion history buffer for the device.
! .P
  The axes field contains a pointer to an XAxisInfo structure.
! .P
  The XAxisInfo structure is defined as follows:
! .P
  .DS
  .nf
  typedef struct _XAxisInfo {
--- 189,208 ----
  .fi
  .DS
  num_axes contains the number of axes the device supports.
! .LP
  mode is a constant that has one of the following
  values: Absolute or Relative.  Some devices allow the
  mode to be changed dynamically via the SetDeviceMode
  request.
! .LP
  motion_buffer_size is a cardinal number that specifies
  the number of elements that can be contained in the
  motion history buffer for the device.
! .LP
  The axes field contains a pointer to an XAxisInfo structure.
! .LP
  The XAxisInfo structure is defined as follows:
! .LP
  .DS
  .nf
  typedef struct _XAxisInfo {
***************
*** 213,231 ****
  } XAxisInfo;
  .fi
  .DE
! .P
  The resolution contains a number in counts/meter.
! .P
  The min_val field contains a number that specifies
  the minimum value the device reports for this axis.
  For devices whose mode is Relative, the min_val field
  will contain 0.
! .P
  The max_val field contains a number that specifies
  the maximum value the device reports for this axis.
  For devices whose mode is Relative, the max_val field
  will contain 0.
! .P
  To free the \fIXDeviceInfo\fP array created by \fIXListInputDevices\fP,
  use \fIXFreeDeviceList\fP.
  .SH DIAGNOSTICS
--- 212,230 ----
  } XAxisInfo;
  .fi
  .DE
! .LP
  The resolution contains a number in counts/meter.
! .LP
  The min_val field contains a number that specifies
  the minimum value the device reports for this axis.
  For devices whose mode is Relative, the min_val field
  will contain 0.
! .LP
  The max_val field contains a number that specifies
  the maximum value the device reports for this axis.
  For devices whose mode is Relative, the max_val field
  will contain 0.
! .LP
  To free the \fIXDeviceInfo\fP array created by \fIXListInputDevices\fP,
  use \fIXFreeDeviceList\fP.
  .SH DIAGNOSTICS
*** /tmp/da16397	Sun Jun  5 18:26:21 1994
--- xc/doc/man/Xi/XOpenDev.man	Sun Jun  5 18:26:21 1994
***************
*** 1,5 ****
  .\"
- $XMCOPY
  .\" Copyright ([\d,\s]*) by Hewlett-Packard Company, Ardent Computer, 
  .\" 
  .\" Permission to use, copy, modify, distribute, and sell this documentation 
--- 1,4 ----
***************
*** 9,15 ****
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XOpenDev.man,v 1.4 94/04/17 20:07:38 dpw Exp $
  .ds xL Programming with Xlib
  .TH XOpenDevice 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
--- 8,14 ----
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XOpenDev.man,v 1.5 94/06/04 17:32:31 rws Exp $
  .ds xL Programming with Xlib
  .TH XOpenDevice 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
***************
*** 41,58 ****
  request makes an input device accessible to a client through input extension
  protocol requests.  If successful, it returns a pointer to an \fBXDevice\fP
  structure.
! .P
  The \fIXCloseDevice\fP request makes an input device inaccessible to a 
  client through input extension protocol requests.  Before terminating,
  and client that has opened input devices through the input extension
  should close them via \fICloseDevice\fP.
! .P
  When a client makes an \fIXCloseDevice\fP request,
  any active grabs that the client has on the device are 
  released.  Any event selections that the client has are deleted, as well as
  any passive grabs.  If the requesting client is the last client accessing
  the device, the server may disable all access by X to the device.
! .P
  \fIXOpenDevice\fP and \fIXCloseDevice\fP can generate a \fIBadDevice\fP 
  error.
  .SH STRUCTURES
--- 40,57 ----
  request makes an input device accessible to a client through input extension
  protocol requests.  If successful, it returns a pointer to an \fBXDevice\fP
  structure.
! .LP
  The \fIXCloseDevice\fP request makes an input device inaccessible to a 
  client through input extension protocol requests.  Before terminating,
  and client that has opened input devices through the input extension
  should close them via \fICloseDevice\fP.
! .LP
  When a client makes an \fIXCloseDevice\fP request,
  any active grabs that the client has on the device are 
  released.  Any event selections that the client has are deleted, as well as
  any passive grabs.  If the requesting client is the last client accessing
  the device, the server may disable all access by X to the device.
! .LP
  \fIXOpenDevice\fP and \fIXCloseDevice\fP can generate a \fIBadDevice\fP 
  error.
  .SH STRUCTURES
***************
*** 65,80 ****
  	XInputClassInfo *classes;
  } XDevice;
  .fi
! .P
  The classes field is a pointer to an array of XInputClassInfo structures.
  Each element of this array contains an event type base for a class of input
  supported by the specified device.  The num_classes field indicates the
  number of elements in the classes array.
! .P
  The
  \fIXInputClassInfo\fP
  structure contains:
! .P
  .nf
  typedef struct {
  	unsigned char input_class;
--- 64,79 ----
  	XInputClassInfo *classes;
  } XDevice;
  .fi
! .LP
  The classes field is a pointer to an array of XInputClassInfo structures.
  Each element of this array contains an event type base for a class of input
  supported by the specified device.  The num_classes field indicates the
  number of elements in the classes array.
! .LP
  The
  \fIXInputClassInfo\fP
  structure contains:
! .LP
  .nf
  typedef struct {
  	unsigned char input_class;
***************
*** 81,93 ****
  	unsigned char event_type_base;
  } XInputClassInfo;
  .fi
! .P
  The input_class field identifies one class of input
  supported by the device.  Defined types include \fIKeyClass\fP,
  \fIButtonClass\fP, \fIValuatorClass\fP, \fIProximityClass\fP,
  \fIFeedbackClass\fP, \fIFocusClass\fP, and \fIOtherClass\fP.
  The event_type_base identifies the event type of the first event in that class.
! .P
  The information contained in the \fIXInputClassInfo\fP structure is used
  by macros to obtain the event classes that clients use in making
  \fIXSelectExtensionEvent\fP requests.  Currently defined macros include
--- 80,92 ----
  	unsigned char event_type_base;
  } XInputClassInfo;
  .fi
! .LP
  The input_class field identifies one class of input
  supported by the device.  Defined types include \fIKeyClass\fP,
  \fIButtonClass\fP, \fIValuatorClass\fP, \fIProximityClass\fP,
  \fIFeedbackClass\fP, \fIFocusClass\fP, and \fIOtherClass\fP.
  The event_type_base identifies the event type of the first event in that class.
! .LP
  The information contained in the \fIXInputClassInfo\fP structure is used
  by macros to obtain the event classes that clients use in making
  \fIXSelectExtensionEvent\fP requests.  Currently defined macros include
***************
*** 100,117 ****
  \fIDeviceButton4Motion\fP, \fIDeviceButton5Motion\fP, \fIDeviceButtonMotion\fP,
  \fIDeviceOwnerGrabButton\fP, \fIDeviceButtonPressGrab\fP, and
  \fINoExtensionEvent\fP.
! .P
  To obtain the proper event class for a particular device, one of the above
  macros is invoked using the \fIXDevice\fP structure for that device.  For
  example, 
! .P
  .nf
  DeviceKeyPress (*device, type, eventclass);
  .fi
! .P
  returns the \fIDeviceKeyPress\fP event type and the eventclass for 
  \fIDeviceKeyPress\fP events from the specified device.
! .P
  This \fIeventclass\fP can then be used in an \fIXSelectExtensionEvent\fP 
  request to ask the server to send \fIDeviceKeyPress\fP events from this device. 
  When a selected event is received via \fIXNextEvent\fP, the \fItype\fP can be 
--- 99,116 ----
  \fIDeviceButton4Motion\fP, \fIDeviceButton5Motion\fP, \fIDeviceButtonMotion\fP,
  \fIDeviceOwnerGrabButton\fP, \fIDeviceButtonPressGrab\fP, and
  \fINoExtensionEvent\fP.
! .LP
  To obtain the proper event class for a particular device, one of the above
  macros is invoked using the \fIXDevice\fP structure for that device.  For
  example, 
! .LP
  .nf
  DeviceKeyPress (*device, type, eventclass);
  .fi
! .LP
  returns the \fIDeviceKeyPress\fP event type and the eventclass for 
  \fIDeviceKeyPress\fP events from the specified device.
! .LP
  This \fIeventclass\fP can then be used in an \fIXSelectExtensionEvent\fP 
  request to ask the server to send \fIDeviceKeyPress\fP events from this device. 
  When a selected event is received via \fIXNextEvent\fP, the \fItype\fP can be 
*** /tmp/da16413	Sun Jun  5 18:26:23 1994
--- xc/doc/man/Xi/XQueryDv.man	Sun Jun  5 18:26:22 1994
***************
*** 1,5 ****
  .\"
- $XMCOPY
  .\" Copyright ([\d,\s]*) by Hewlett-Packard Company, Ardent Computer, 
  .\" 
  .\" Permission to use, copy, modify, distribute, and sell this documentation 
--- 1,4 ----
***************
*** 9,15 ****
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XQueryDv.man,v 1.4 94/04/17 20:07:39 dpw Exp $
  .ds xL Programming with Xlib
  .TH XQueryDeviceState 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
--- 8,14 ----
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XQueryDv.man,v 1.5 94/06/04 17:32:32 rws Exp $
  .ds xL Programming with Xlib
  .TH XQueryDeviceState 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
***************
*** 36,42 ****
  in the \fIXDeviceState\fP structure that is returned.  Valuators on the 
  device report 0 if they are reporting relative information, and the
  current value if they are reporting absolute information.
! .P
  \fIXQueryDeviceState\fP
  can generate a \fIBadDevice\fP error.
  .SH STRUCTURES
--- 35,41 ----
  in the \fIXDeviceState\fP structure that is returned.  Valuators on the 
  device report 0 if they are reporting relative information, and the
  current value if they are reporting absolute information.
! .LP
  \fIXQueryDeviceState\fP
  can generate a \fIBadDevice\fP error.
  .SH STRUCTURES
***************
*** 43,49 ****
  The
  \fIXDeviceState\fP
  structure contains:
! .P
  .nf
  typedef struct {
  	XID device_id;
--- 42,48 ----
  The
  \fIXDeviceState\fP
  structure contains:
! .LP
  .nf
  typedef struct {
  	XID device_id;
***************
*** 51,61 ****
  	XInputClass *data;
  } XDeviceState;
  .fi
! .P
  The
  \fIXValuatorState\fP
  structure contains:
! .P
  .nf
  typedef struct {
  	unsigned char class;
--- 50,60 ----
  	XInputClass *data;
  } XDeviceState;
  .fi
! .LP
  The
  \fIXValuatorState\fP
  structure contains:
! .LP
  .nf
  typedef struct {
  	unsigned char class;
***************
*** 65,73 ****
  	int *valuators;
  } XValuatorState;
  .fi
! .P
  The \fIXKeyState\fP structure contains:
! .P
  .nf
  typedef struct {
  	unsigned char class;
--- 64,72 ----
  	int *valuators;
  } XValuatorState;
  .fi
! .LP
  The \fIXKeyState\fP structure contains:
! .LP
  .nf
  typedef struct {
  	unsigned char class;
***************
*** 76,84 ****
  	char keys[32];
  } XKeyState;
  .fi
! .P
  The \fIXButtonState\fP structure contains:
! .P
  .nf
  typedef struct {
  	unsigned char class;
--- 75,83 ----
  	char keys[32];
  } XKeyState;
  .fi
! .LP
  The \fIXButtonState\fP structure contains:
! .LP
  .nf
  typedef struct {
  	unsigned char class;
*** /tmp/da16429	Sun Jun  5 18:26:24 1994
--- xc/doc/man/Xi/XSExEvnt.man	Sun Jun  5 18:26:24 1994
***************
*** 1,5 ****
  .\"
- $XMCOPY
  .\" Copyright ([\d,\s]*) by Hewlett-Packard Company, Ardent Computer, 
  .\" 
  .\" Permission to use, copy, modify, distribute, and sell this documentation 
--- 1,4 ----
***************
*** 9,15 ****
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XSExEvnt.man,v 1.4 94/04/17 20:07:39 dpw Exp $
  .ds xL Programming with Xlib
  .TH XSendExtensionEvent 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
--- 8,14 ----
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XSExEvnt.man,v 1.5 94/06/04 17:32:33 rws Exp $
  .ds xL Programming with Xlib
  .TH XSendExtensionEvent 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
***************
*** 76,82 ****
  and if the focus window contains the pointer, 
  the destination window is the window that contains the pointer; 
  otherwise, the destination window is the focus window.
! .P
  To determine which clients should receive the specified events,
  \fIXSendExtensionEvent\fP
  uses the propagate argument as follows:
--- 75,81 ----
  and if the focus window contains the pointer, 
  the destination window is the window that contains the pointer; 
  otherwise, the destination window is the focus window.
! .LP
  To determine which clients should receive the specified events,
  \fIXSendExtensionEvent\fP
  uses the propagate argument as follows:
***************
*** 107,113 ****
  as the destination, the event is not sent to any clients.
  Otherwise, the event is reported to every client selecting on the final
  destination any of the events specified in the event_list array.
! .P
  The event in the
  \fIXEvent\fP
  structure must be one of the events defined by the input extension (or a 
--- 106,112 ----
  as the destination, the event is not sent to any clients.
  Otherwise, the event is reported to every client selecting on the final
  destination any of the events specified in the event_list array.
! .LP
  The event in the
  \fIXEvent\fP
  structure must be one of the events defined by the input extension (or a 
***************
*** 118,124 ****
  otherwise unaltered and unchecked by the X server except to force send_event to
  \fITrue\fP
  in the forwarded event and to set the serial number in the event correctly.
! .P
  \fIXSendExtensionEvent\fP
  returns zero if the conversion to wire protocol format failed
  and returns nonzero otherwise.
--- 117,123 ----
  otherwise unaltered and unchecked by the X server except to force send_event to
  \fITrue\fP
  in the forwarded event and to set the serial number in the event correctly.
! .LP
  \fIXSendExtensionEvent\fP
  returns zero if the conversion to wire protocol format failed
  and returns nonzero otherwise.
*** /tmp/da16445	Sun Jun  5 18:26:26 1994
--- xc/doc/man/Xi/XSeBMap.man	Sun Jun  5 18:26:25 1994
***************
*** 1,5 ****
  .\"
- $XMCOPY
  .\" Copyright ([\d,\s]*) by Hewlett-Packard Company, Ardent Computer, 
  .\" 
  .\" Permission to use, copy, modify, distribute, and sell this documentation 
--- 1,4 ----
***************
*** 9,15 ****
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XSeBMap.man,v 1.4 94/04/17 20:07:40 dpw Exp $
  .ds xL Programming With Xlib
  .TH XSetDeviceButtonMapping 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
--- 8,14 ----
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XSeBMap.man,v 1.5 94/06/04 17:32:34 rws Exp $
  .ds xL Programming With Xlib
  .TH XSetDeviceButtonMapping 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
***************
*** 70,79 ****
  If any of the buttons to be altered are logically in the down state,
  \fIXSetDeviceButtonMapping\fP returns \fIMappingBusy\fP,
  and the mapping is not changed.
! .P
  \fIXSetDeviceButtonMapping\fP
  can generate \fIBadDevice\fP, \fIBadMatch\fP, and  \fIBadValue\fP errors.
! .P
  The \fIXGetDeviceButtonMapping\fP
  request returns the current mapping of the specified device.
  Buttons are numbered starting from one.
--- 69,78 ----
  If any of the buttons to be altered are logically in the down state,
  \fIXSetDeviceButtonMapping\fP returns \fIMappingBusy\fP,
  and the mapping is not changed.
! .LP
  \fIXSetDeviceButtonMapping\fP
  can generate \fIBadDevice\fP, \fIBadMatch\fP, and  \fIBadValue\fP errors.
! .LP
  The \fIXGetDeviceButtonMapping\fP
  request returns the current mapping of the specified device.
  Buttons are numbered starting from one.
***************
*** 83,89 ****
  The nmap argument specifies the length of the array where the device
  mapping is returned, and only the first nmap elements are returned 
  in map_return.
! .P
  \fIXGetDeviceButtonMapping\fP
  can generate \fIBadDevice\fP or \fIBadMatch\fP errors.
  .SH DIAGNOSTICS
--- 82,88 ----
  The nmap argument specifies the length of the array where the device
  mapping is returned, and only the first nmap elements are returned 
  in map_return.
! .LP
  \fIXGetDeviceButtonMapping\fP
  can generate \fIBadDevice\fP or \fIBadMatch\fP errors.
  .SH DIAGNOSTICS
*** /tmp/da16461	Sun Jun  5 18:26:28 1994
--- xc/doc/man/Xi/XSeDvFoc.man	Sun Jun  5 18:26:27 1994
***************
*** 1,5 ****
  .\"
- $XMCOPY
  .\" Copyright ([\d,\s]*) by Hewlett-Packard Company, Ardent Computer, 
  .\" 
  .\" Permission to use, copy, modify, distribute, and sell this documentation 
--- 1,4 ----
***************
*** 9,15 ****
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XSeDvFoc.man,v 1.4 94/04/17 20:07:40 dpw Exp $
  .ds xL Programming with Xlib
  .TH XSetDeviceFocus 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
--- 8,14 ----
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XSeDvFoc.man,v 1.5 94/06/04 17:32:36 rws Exp $
  .ds xL Programming with Xlib
  .TH XSetDeviceFocus 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
***************
*** 101,107 ****
  and 
  \fIDeviceFocusOut\fP
  events.
! .P
  Depending on the focus argument,
  the following occurs: 
  .IP \(bu 5
--- 100,106 ----
  and 
  \fIDeviceFocusOut\fP
  events.
! .LP
  Depending on the focus argument,
  the following occurs: 
  .IP \(bu 5
***************
*** 126,132 ****
  \fIFollowKeyboard\fP,
  the focus window is dynamically taken to be the window to which the X keyboard
  focus is set at each input event.
! .P
  The specified focus window must be viewable at the time 
  \fIXSetDeviceFocus\fP
  is called,
--- 125,131 ----
  \fIFollowKeyboard\fP,
  the focus window is dynamically taken to be the window to which the X keyboard
  focus is set at each input event.
! .LP
  The specified focus window must be viewable at the time 
  \fIXSetDeviceFocus\fP
  is called,
***************
*** 154,160 ****
  or
  \fINone\fP,
  respectively.
! .P
  When the focus reverts,
  the X server generates
  \fIDeviceFocusIn\fP
--- 153,159 ----
  or
  \fINone\fP,
  respectively.
! .LP
  When the focus reverts,
  the X server generates
  \fIDeviceFocusIn\fP
***************
*** 161,167 ****
  and
  \fIDeviceFocusOut\fP
  events, but the last-focus-change time is not affected.
! .P
  Input extension devices are not required to support the ability to be focused.
  Attempting to set the focus of a device that does not support this request
  will result in a \fIBadMatch\fP error.  Whether or not given device can
--- 160,166 ----
  and
  \fIDeviceFocusOut\fP
  events, but the last-focus-change time is not affected.
! .LP
  Input extension devices are not required to support the ability to be focused.
  Attempting to set the focus of a device that does not support this request
  will result in a \fIBadMatch\fP error.  Whether or not given device can
***************
*** 171,177 ****
  support focus, \fIXOpenDevice\fP will return an
  \fIXInputClassInfo\fP structure with the input_class field
  equal to the constant \fIFocusClass\fP (defined in the file \fIXI.h\fP).
! .P
  \fIXSetDeviceFocus\fP
  can generate
  \fIBadDevice\fP,
--- 170,176 ----
  support focus, \fIXOpenDevice\fP will return an
  \fIXInputClassInfo\fP structure with the input_class field
  equal to the constant \fIFocusClass\fP (defined in the file \fIXI.h\fP).
! .LP
  \fIXSetDeviceFocus\fP
  can generate
  \fIBadDevice\fP,
***************
*** 180,195 ****
  and
  \fIBadWindow\fP
  errors.
! .P
  The
  \fIXGetDeviceFocus\fP
  request returns the focus window and the current focus state.
! .P
  Not all input extension devices can be focused.  Attempting to query the
  focus state of a device that can't be focused results in a \fIBadMatch\fP
  error.  A device that can be focused returns information for input Class
  Focus when an \fIXOpenDevice\fP request is made.
! .P
  \fIXGetDeviceFocus\fP can generate \fIBadDevice\fP,
  and \fIBadMatch\fP errors.
  .SH DIAGNOSTICS
--- 179,194 ----
  and
  \fIBadWindow\fP
  errors.
! .LP
  The
  \fIXGetDeviceFocus\fP
  request returns the focus window and the current focus state.
! .LP
  Not all input extension devices can be focused.  Attempting to query the
  focus state of a device that can't be focused results in a \fIBadMatch\fP
  error.  A device that can be focused returns information for input Class
  Focus when an \fIXOpenDevice\fP request is made.
! .LP
  \fIXGetDeviceFocus\fP can generate \fIBadDevice\fP,
  and \fIBadMatch\fP errors.
  .SH DIAGNOSTICS
*** /tmp/da16477	Sun Jun  5 18:26:29 1994
--- xc/doc/man/Xi/XSelExtEv.man	Sun Jun  5 18:26:29 1994
***************
*** 1,5 ****
  .\"
- $XMCOPY
  .\" Copyright ([\d,\s]*) by Hewlett-Packard Company, Ardent Computer, 
  .\" 
  .\" Permission to use, copy, modify, distribute, and sell this documentation 
--- 1,4 ----
***************
*** 9,15 ****
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XSelExtEv.man,v 1.5 94/04/17 20:07:41 dpw Exp $
  .ds xL Programming with Xlib
  .TH XSelectExtensionEvent 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
--- 8,14 ----
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XSelExtEv.man,v 1.6 94/06/04 17:32:37 rws Exp $
  .ds xL Programming with Xlib
  .TH XSelectExtensionEvent 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
***************
*** 77,83 ****
  If a window is not interested in a device event, it usually propagates to
  the closest ancestor that is interested,
  unless the do_not_propagate mask prohibits it.
! .P
  Multiple clients can select for the same events on the same window
  with the following restrictions:
  .IP \(bu 5
--- 76,82 ----
  If a window is not interested in a device event, it usually propagates to
  the closest ancestor that is interested,
  unless the do_not_propagate mask prohibits it.
! .LP
  Multiple clients can select for the same events on the same window
  with the following restrictions:
  .IP \(bu 5
***************
*** 93,101 ****
  To receive \fIDeviceButtonPress\fP events without automatic passive
  grabbing, use event class \fIDeviceButtonPress\fP but do not specify
  event class \fIDeviceButtonPressGrab\fP.
! .P
  The server reports the event to all interested clients.
! .P
  Information contained in the \fIXDevice\fP structure returned by
  \fIXOpenDevice\fP is used
  by macros to obtain the event classes that clients use in making
--- 92,100 ----
  To receive \fIDeviceButtonPress\fP events without automatic passive
  grabbing, use event class \fIDeviceButtonPress\fP but do not specify
  event class \fIDeviceButtonPressGrab\fP.
! .LP
  The server reports the event to all interested clients.
! .LP
  Information contained in the \fIXDevice\fP structure returned by
  \fIXOpenDevice\fP is used
  by macros to obtain the event classes that clients use in making
***************
*** 109,128 ****
  \fIDeviceButton4Motion\fP, \fIDeviceButton5Motion\fP, \fIDeviceButtonMotion\fP,
  \fIDeviceOwnerGrabButton\fP, \fIDeviceButtonPressGrab\fP, and
  \fINoExtensionEvent\fP.
! .P
  To obtain the proper event class for a particular device, one of the above
  macros is invoked using the \fIXDevice\fP structure for that device.  For
  example, 
! .P
  .DS 0
  .TA .5i
  .ta .5i
  DeviceKeyPress (*device, type, eventclass);
  .DE
! .P
  returns the \fIDeviceKeyPress\fP event type and the eventclass for selecting
  \fIDeviceKeyPress\fP events from this device.
! .P
  \fIXSelectExtensionEvent\fP
  can generate a \fIBadWindow\fP or \fIBadClass\fP error.
  The
--- 108,127 ----
  \fIDeviceButton4Motion\fP, \fIDeviceButton5Motion\fP, \fIDeviceButtonMotion\fP,
  \fIDeviceOwnerGrabButton\fP, \fIDeviceButtonPressGrab\fP, and
  \fINoExtensionEvent\fP.
! .LP
  To obtain the proper event class for a particular device, one of the above
  macros is invoked using the \fIXDevice\fP structure for that device.  For
  example, 
! .LP
  .DS 0
  .TA .5i
  .ta .5i
  DeviceKeyPress (*device, type, eventclass);
  .DE
! .LP
  returns the \fIDeviceKeyPress\fP event type and the eventclass for selecting
  \fIDeviceKeyPress\fP events from this device.
! .LP
  \fIXSelectExtensionEvent\fP
  can generate a \fIBadWindow\fP or \fIBadClass\fP error.
  The
***************
*** 134,140 ****
  the specified window.  The other lists the event classes selected by all
  clients from the specified window.  You should use \fIXFree\fP to free these
  two arrays.
! .P
  \fIXGetSelectedExtensionEvents\fP
  can generate a \fIBadWindow\fP error.
  .SH DIAGNOSTICS
--- 133,139 ----
  the specified window.  The other lists the event classes selected by all
  clients from the specified window.  You should use \fIXFree\fP to free these
  two arrays.
! .LP
  \fIXGetSelectedExtensionEvents\fP
  can generate a \fIBadWindow\fP error.
  .SH DIAGNOSTICS
*** /tmp/da16493	Sun Jun  5 18:26:31 1994
--- xc/doc/man/Xi/XSetDVal.man	Sun Jun  5 18:26:30 1994
***************
*** 1,5 ****
  .\"
- $XMCOPY
  .\" Copyright ([\d,\s]*) by Hewlett-Packard Company, Ardent Computer, 
  .\" 
  .\" Permission to use, copy, modify, distribute, and sell this documentation 
--- 1,4 ----
***************
*** 9,15 ****
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XSetDVal.man,v 1.5 94/04/17 20:07:43 dpw Exp $
  .ds xL Programming with Xlib
  .TH XSetDeviceValuators 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
--- 8,14 ----
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XSetDVal.man,v 1.6 94/06/04 17:32:38 rws Exp $
  .ds xL Programming with Xlib
  .TH XSetDeviceValuators 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
***************
*** 54,63 ****
  Not all input devices support initialization of valuator values.  If this
  request is made to a device that does not support valuators initialization,
  a \fIBadMatch\fP error will occur.
! .P
  If the request succeeds, a status of Success is returned.  If another
  client has the device grabbed, a status of AlreadyGrabbed is returned.
! .P
  \fIXSetDeviceValuators\fP
  can generate a \fIBadLength\fP, \fIBadDevice\fP , \fIBadMatch\fP, or 
  \fIBadValue\fP error.
--- 53,62 ----
  Not all input devices support initialization of valuator values.  If this
  request is made to a device that does not support valuators initialization,
  a \fIBadMatch\fP error will occur.
! .LP
  If the request succeeds, a status of Success is returned.  If another
  client has the device grabbed, a status of AlreadyGrabbed is returned.
! .LP
  \fIXSetDeviceValuators\fP
  can generate a \fIBadLength\fP, \fIBadDevice\fP , \fIBadMatch\fP, or 
  \fIBadValue\fP error.
*** /tmp/da16509	Sun Jun  5 18:26:32 1994
--- xc/doc/man/Xi/XSetMode.man	Sun Jun  5 18:26:32 1994
***************
*** 1,5 ****
  .\"
- $XMCOPY
  .\" Copyright ([\d,\s]*) by Hewlett-Packard Company, Ardent Computer, 
  .\" 
  .\" Permission to use, copy, modify, distribute, and sell this documentation 
--- 1,4 ----
***************
*** 9,15 ****
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XSetMode.man,v 1.5 94/04/17 20:07:44 dpw Exp $
  .ds xL Programming with Xlib
  .TH XSetDeviceMode 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
--- 8,14 ----
  .\" suitability for any purpose of the information in this document.  It is 
  .\" provided \`\`as is'' without express or implied warranty.
  .\" 
! .\" $XConsortium: XSetMode.man,v 1.6 94/06/04 17:32:39 rws Exp $
  .ds xL Programming with Xlib
  .TH XSetDeviceMode 3X11 "Release 6" "X Version 11" "X FUNCTIONS"
  .SH NAME
***************
*** 43,49 ****
  either absolute positional information or relative motion information.  
  Not all input devices are capable of reporting motion data, and not
  all are capable of changing modes from \fIAbsolute\fP to \fIRelative\fP.
! .P
  \fIXSetDeviceMode\fP
  can generate a \fIBadDevice\fP or
  \fIBadMode\fP 
--- 42,48 ----
  either absolute positional information or relative motion information.  
  Not all input devices are capable of reporting motion data, and not
  all are capable of changing modes from \fIAbsolute\fP to \fIRelative\fP.
! .LP
  \fIXSetDeviceMode\fP
  can generate a \fIBadDevice\fP or
  \fIBadMode\fP 
*** /tmp/da21657	Mon Jun  6 16:27:03 1994
--- xc/doc/man/Xt/Imakefile	Mon Jun  6 16:27:02 1994
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile,v 1.13 94/05/11 16:20:22 kaleb Exp $
  
  MANDIR = $(LIBMANDIR)
  MANSUFFIX = $(LIBMANSUFFIX)
--- 1,4 ----
! XCOMM $XConsortium: Imakefile,v 1.14 94/06/01 15:57:45 kaleb Exp $
  
  MANDIR = $(LIBMANDIR)
  MANSUFFIX = $(LIBMANSUFFIX)
***************
*** 117,123 ****
  InstallManPageLong(XtCallActP,$(MANDIR),XtCallActionProc)
  InstallManPageLong(XtRegGA,$(MANDIR),XtRegisterGrabAction)
  InstallManPageLong(XtClickT,$(MANDIR),XtSetMultiClickTime)
! InstallManPageAliases(XtSetMultiClickTime,$(MANDIR),$XtGetMultiClickTime)
  InstallManPageLong(XtGetActK,$(MANDIR),XtGetActionKeysym)
  InstallManPageLong(XtExtEvDis,$(MANDIR),XtInsertEventTypeHandler)
  InstallManPageAliases(XtInsertEventTypeHandler,$(MANDIR),XtRemoveEventTypeHandler XtRegisterExtensionSelector XtSetEventDispatcher XtDispatchEventToWidget)
--- 117,123 ----
  InstallManPageLong(XtCallActP,$(MANDIR),XtCallActionProc)
  InstallManPageLong(XtRegGA,$(MANDIR),XtRegisterGrabAction)
  InstallManPageLong(XtClickT,$(MANDIR),XtSetMultiClickTime)
! InstallManPageAliases(XtSetMultiClickTime,$(MANDIR),XtGetMultiClickTime)
  InstallManPageLong(XtGetActK,$(MANDIR),XtGetActionKeysym)
  InstallManPageLong(XtExtEvDis,$(MANDIR),XtInsertEventTypeHandler)
  InstallManPageAliases(XtInsertEventTypeHandler,$(MANDIR),XtRemoveEventTypeHandler XtRegisterExtensionSelector XtSetEventDispatcher XtDispatchEventToWidget)
*** /tmp/da16531	Sun Jun  5 18:26:34 1994
--- xc/fonts/PEX/lex.l	Sun Jun  5 18:26:34 1994
***************
*** 1,5 ****
  %{
! /* $XConsortium: lex.l,v 5.6 94/04/17 20:10:07 rws Exp $ */
  
  /*****************************************************************
  
--- 1,5 ----
  %{
! /* $XConsortium: lex.l,v 5.7 94/06/04 17:03:52 rws Exp $ */
  
  /*****************************************************************
  
***************
*** 53,61 ****
  #include <ctype.h>
  #include <math.h>
  #include "to_wfont.h"
! 
  #if defined(ISC) && defined(SYSV) && defined(SYSV386) && __STDC__
  extern double atof(char *);
  #endif
  
  %}
--- 53,65 ----
  #include <ctype.h>
  #include <math.h>
  #include "to_wfont.h"
! #include <X11/Xosdefs.h>
! #ifndef X_NOT_STDC_ENV
! #include <stdlib.h>
! #else
  #if defined(ISC) && defined(SYSV) && defined(SYSV386) && __STDC__
  extern double atof(char *);
+ #endif
  #endif
  
  %}
*** /tmp/da16552	Sun Jun  5 18:26:36 1994
--- xc/lib/ICE/ICElib.h	Sun Jun  5 18:26:36 1994
***************
*** 1,4 ****
! /* $XConsortium: ICElib.h,v 1.39 94/04/17 20:15:25 mor Exp $ */
  /******************************************************************************
  
  
--- 1,4 ----
! /* $XConsortium: ICElib.h,v 1.40 94/06/01 10:48:43 mor Exp $ */
  /******************************************************************************
  
  
***************
*** 233,238 ****
--- 233,240 ----
   * Function prototypes
   */
  
+ _XFUNCPROTOBEGIN
+ 
  extern int IceRegisterForProtocolSetup (
  #if NeedFunctionPrototypes
      char *			/* protocolName */,
***************
*** 520,524 ****
--- 522,528 ----
      IceConn		/* iceConn */
  #endif
  );
+ 
+ _XFUNCPROTOEND
  
  #endif /* _ICELIB_H_ */
*** /tmp/da16574	Sun Jun  5 18:26:38 1994
--- xc/lib/SM/SMlib.h	Sun Jun  5 18:26:38 1994
***************
*** 1,4 ****
! /* $XConsortium: SMlib.h,v 1.22 94/04/17 20:16:50 mor Exp $ */
  
  /*
  
--- 1,4 ----
! /* $XConsortium: SMlib.h,v 1.23 94/06/01 10:49:13 mor Exp $ */
  
  /*
  
***************
*** 386,391 ****
--- 386,393 ----
   * Function Prototypes
   */
  
+ _XFUNCPROTOBEGIN
+ 
  extern SmcConn SmcOpenConnection (
  #if NeedFunctionPrototypes
      char *		/* networkIdsList */,
***************
*** 652,656 ****
--- 654,660 ----
      char **		/* reasonMsgs */
  #endif
  );
+ 
+ _XFUNCPROTOEND
  
  #endif /* _SMLIB_H_ */
*** /tmp/da16595	Sun Jun  5 18:26:41 1994
--- xc/lib/X11/ConnDis.c	Sun Jun  5 18:26:40 1994
***************
*** 1,4 ****
! /* $XConsortium: ConnDis.c,v 11.122 94/05/05 13:13:24 mor Exp $ */
  /*
   
  Copyright (c) 1989  X Consortium
--- 1,4 ----
! /* $XConsortium: ConnDis.c,v 11.123 94/05/19 11:00:27 mor Exp $ */
  /*
   
  Copyright (c) 1989  X Consortium
***************
*** 312,318 ****
  	 * X protocol (ie FamilyInternet).
  	 */
  
! 	if( _X11TransConvertAddress(&family, &saddrlen, saddr) < 0 )
  	    {
  	    _X11TransClose(trans_conn);
  	    trans_conn = NULL;
--- 312,318 ----
  	 * X protocol (ie FamilyInternet).
  	 */
  
! 	if( _X11TransConvertAddress(&family, &saddrlen, &saddr) < 0 )
  	    {
  	    _X11TransClose(trans_conn);
  	    trans_conn = NULL;
*** /tmp/da16611	Sun Jun  5 18:26:43 1994
--- xc/lib/X11/KeyBind.c	Sun Jun  5 18:26:42 1994
***************
*** 1,4 ****
! /* $XConsortium: KeyBind.c,v 11.79 94/04/17 20:20:03 erik Exp $ */
  /* 
  
  Copyright (c) 1985, 1987,  X Consortium
--- 1,4 ----
! /* $XConsortium: KeyBind.c,v 11.80 94/06/05 17:02:01 rws Exp $ */
  /* 
  
  Copyright (c) 1985, 1987,  X Consortium
***************
*** 37,42 ****
--- 37,43 ----
  #define XK_LATIN3
  #define XK_LATIN4
  #define XK_CYRILLIC
+ #define XK_GREEK
  #define XK_XKB_KEYS
  #include <X11/keysymdef.h>
  #include <stdio.h>
***************
*** 177,188 ****
  	    } else if (sym == XK_Shift_Lock) {
  		dpy->lock_meaning = XK_Shift_Lock;
  	    }
- #ifdef	XK_ISO_Lock
  	    else if (sym == XK_ISO_Lock) {
  		dpy->lock_meaning = XK_Caps_Lock;
  		break;
  	    }
- #endif
  	}
      }
      /* Now find any Mod<n> modifier acting as the Group or Numlock modifier */
--- 178,187 ----
***************
*** 289,295 ****
      *lower = sym;
      *upper = sym;
      switch(sym >> 8) {
!     case 0:
  	if ((sym >= XK_A) && (sym <= XK_Z))
  	    *lower += (XK_a - XK_A);
  	else if ((sym >= XK_a) && (sym <= XK_z))
--- 288,294 ----
      *lower = sym;
      *upper = sym;
      switch(sym >> 8) {
!     case 0: /* Latin 1 */
  	if ((sym >= XK_A) && (sym <= XK_Z))
  	    *lower += (XK_a - XK_A);
  	else if ((sym >= XK_a) && (sym <= XK_z))
***************
*** 303,310 ****
  	else if ((sym >= XK_oslash) && (sym <= XK_thorn))
  	    *upper -= (XK_oslash - XK_Ooblique);
  	break;
! #ifdef XK_LATIN2
!     case 1:
  	/* Assume the KeySym is a legal value (ignore discontinuities) */
  	if (sym == XK_Aogonek)
  	    *lower = XK_aogonek;
--- 302,308 ----
  	else if ((sym >= XK_oslash) && (sym <= XK_thorn))
  	    *upper -= (XK_oslash - XK_Ooblique);
  	break;
!     case 1: /* Latin 2 */
  	/* Assume the KeySym is a legal value (ignore discontinuities) */
  	if (sym == XK_Aogonek)
  	    *lower = XK_aogonek;
***************
*** 327,335 ****
  	else if (sym >= XK_racute && sym <= XK_tcedilla)
  	    *upper -= (XK_racute - XK_Racute);
  	break;
! #endif
! #ifdef XK_LATIN3
!     case 2:
  	/* Assume the KeySym is a legal value (ignore discontinuities) */
  	if (sym >= XK_Hstroke && sym <= XK_Hcircumflex)
  	    *lower += (XK_hstroke - XK_Hstroke);
--- 325,331 ----
  	else if (sym >= XK_racute && sym <= XK_tcedilla)
  	    *upper -= (XK_racute - XK_Racute);
  	break;
!     case 2: /* Latin 3 */
  	/* Assume the KeySym is a legal value (ignore discontinuities) */
  	if (sym >= XK_Hstroke && sym <= XK_Hcircumflex)
  	    *lower += (XK_hstroke - XK_Hstroke);
***************
*** 344,352 ****
  	else if (sym >= XK_cabovedot && sym <= XK_scircumflex)
  	    *upper -= (XK_cabovedot - XK_Cabovedot);
  	break;
! #endif
! #ifdef XK_LATIN4
!     case 3:
  	/* Assume the KeySym is a legal value (ignore discontinuities) */
  	if (sym >= XK_Rcedilla && sym <= XK_Tslash)
  	    *lower += (XK_rcedilla - XK_Rcedilla);
--- 340,346 ----
  	else if (sym >= XK_cabovedot && sym <= XK_scircumflex)
  	    *upper -= (XK_cabovedot - XK_Cabovedot);
  	break;
!     case 3: /* Latin 4 */
  	/* Assume the KeySym is a legal value (ignore discontinuities) */
  	if (sym >= XK_Rcedilla && sym <= XK_Tslash)
  	    *lower += (XK_rcedilla - XK_Rcedilla);
***************
*** 361,369 ****
  	else if (sym >= XK_amacron && sym <= XK_umacron)
  	    *upper -= (XK_amacron - XK_Amacron);
  	break;
! #endif
! #ifdef XK_CYRILLIC
!     case 6:
  	/* Assume the KeySym is a legal value (ignore discontinuities) */
  	if (sym >= XK_Serbian_DJE && sym <= XK_Serbian_DZE)
  	    *lower -= (XK_Serbian_DJE - XK_Serbian_dje);
--- 355,361 ----
  	else if (sym >= XK_amacron && sym <= XK_umacron)
  	    *upper -= (XK_amacron - XK_Amacron);
  	break;
!     case 6: /* Cyrillic */
  	/* Assume the KeySym is a legal value (ignore discontinuities) */
  	if (sym >= XK_Serbian_DJE && sym <= XK_Serbian_DZE)
  	    *lower -= (XK_Serbian_DJE - XK_Serbian_dje);
***************
*** 374,380 ****
  	else if (sym >= XK_Cyrillic_yu && sym <= XK_Cyrillic_hardsign)
  	    *upper += (XK_Cyrillic_YU - XK_Cyrillic_yu);
          break;
! #endif
      }
  }
  
--- 366,385 ----
  	else if (sym >= XK_Cyrillic_yu && sym <= XK_Cyrillic_hardsign)
  	    *upper += (XK_Cyrillic_YU - XK_Cyrillic_yu);
          break;
!     case 7: /* Greek */
! 	/* Assume the KeySym is a legal value (ignore discontinuities) */
! 	if (sym >= XK_Greek_ALPHAaccent && sym <= XK_Greek_OMEGAaccent)
! 	    *lower += (XK_Greek_alphaaccent - XK_Greek_ALPHAaccent);
! 	else if (sym >= XK_Greek_alphaaccent && sym <= XK_Greek_omegaaccent &&
! 		 sym != XK_Greek_iotaaccentdieresis &&
! 		 sym != XK_Greek_upsilonaccentdieresis)
! 	    *upper -= (XK_Greek_alphaaccent - XK_Greek_ALPHAaccent);
! 	else if (sym >= XK_Greek_ALPHA && sym <= XK_Greek_OMEGA)
! 	    *lower += (XK_Greek_alpha - XK_Greek_ALPHA);
! 	else if (sym >= XK_Greek_alpha && sym <= XK_Greek_omega &&
! 		 sym != XK_Greek_finalsmallsigma)
! 	    *upper -= (XK_Greek_alpha - XK_Greek_ALPHA);
!         break;
      }
  }
  
*** /tmp/da16627	Sun Jun  5 18:26:45 1994
--- xc/lib/X11/LRGB.c	Sun Jun  5 18:26:44 1994
***************
*** 1,4 ****
! /* $XConsortium: LRGB.c,v 1.29 93/10/07 18:49:28 rws Exp $" */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
--- 1,4 ----
! /* $XConsortium: LRGB.c,v 1.30 94/06/03 17:51:49 rws Exp $" */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
***************
*** 1183,1189 ****
  	    / ((1 << bitsPerRGB) - 1);
  
      /* Special case so that zero intensity always maps to zero value */
!     if ((*compar) (key,lo) == 0) {
  	memcpy (answer, lo, nKeyPtrSize);
  	((IntensityRec *)answer)->value &= MASK[bitsPerRGB];
  	return XcmsSuccess;
--- 1183,1189 ----
  	    / ((1 << bitsPerRGB) - 1);
  
      /* Special case so that zero intensity always maps to zero value */
!     if ((*compar) (key,lo) <= 0) {
  	memcpy (answer, lo, nKeyPtrSize);
  	((IntensityRec *)answer)->value &= MASK[bitsPerRGB];
  	return XcmsSuccess;
*** /tmp/da16643	Sun Jun  5 18:26:47 1994
--- xc/lib/X11/imDefIm.c	Sun Jun  5 18:26:46 1994
***************
*** 1,4 ****
! /* $XConsortium: imDefIm.c,v 1.9 94/03/30 09:09:37 rws Exp $ */
  /******************************************************************
           Copyright 1990, 1991, 1992 by Sun Microsystems, Inc.
           Copyright 1992, 1993, 1994 by FUJITSU LIMITED
--- 1,4 ----
! /* $XConsortium: imDefIm.c,v 1.11 94/06/03 18:35:30 rws Exp $ */
  /******************************************************************
           Copyright 1990, 1991, 1992 by Sun Microsystems, Inc.
           Copyright 1992, 1993, 1994 by FUJITSU LIMITED
***************
*** 73,79 ****
  
      buf_b[0] = major_opcode;
      buf_b[1] = minor_opcode;
!     buf_s[1] = *len;
      *len += XIM_HEADER_SIZE;
      return;
  }
--- 73,79 ----
  
      buf_b[0] = major_opcode;
      buf_b[1] = minor_opcode;
!     buf_s[1] = ((*len) / 4);
      *len += XIM_HEADER_SIZE;
      return;
  }
***************
*** 150,156 ****
--- 150,160 ----
      pp = &address[category_len];
  
      for(;;) {
+ 	Bool finish = False;
+ 
  	for (p = pp; (*p != ',') && (*p); p++);
+ 	if (!*p)
+ 	    finish = True;
  	*p = '\0';
  	address_len = (int)(p - pp);
  
***************
*** 157,163 ****
  	for( n = 0; n < len; n++ )
  	    if( locale_name[n]  &&  !strcmp( pp, locale_name[n] ) )
  		return locale_name[n];
! 	if (!(*p))
  	    break;
  	pp = p + 1;
      }
--- 161,167 ----
  	for( n = 0; n < len; n++ )
  	    if( locale_name[n]  &&  !strcmp( pp, locale_name[n] ) )
  		return locale_name[n];
! 	if (finish)
  	    break;
  	pp = p + 1;
      }
*** /tmp/da16659	Sun Jun  5 18:26:49 1994
--- xc/lib/X11/imLcPrs.c	Sun Jun  5 18:26:49 1994
***************
*** 1,4 ****
! /* $XConsortium: imLcPrs.c,v 1.5 94/03/26 17:00:38 rws Exp $ */
  /******************************************************************
  
                Copyright 1992 by Oki Technosystems Laboratory, Inc.
--- 1,4 ----
! /* $XConsortium: imLcPrs.c,v 1.6 94/06/03 17:48:24 rws Exp $ */
  /******************************************************************
  
                Copyright 1992 by Oki Technosystems Laboratory, Inc.
***************
*** 211,216 ****
--- 211,217 ----
  		        goto string_error;
  		    }
  		    putbackch(c);
+ 		    *p++ = (char)i;
  #undef ishexch
  		    break;
  		  case '\n':
*** /tmp/da16675	Sun Jun  5 18:26:51 1994
--- xc/lib/X11/imTransR.c	Sun Jun  5 18:26:50 1994
***************
*** 1,4 ****
! /* $XConsortium: imTransR.c,v 1.6 94/03/26 20:07:12 rws Exp $ */
  /******************************************************************
  
                Copyright 1992 by Sun Microsystems, Inc.
--- 1,4 ----
! /* $XConsortium: imTransR.c,v 1.7 94/06/03 17:34:28 rws Exp $ */
  /******************************************************************
  
                Copyright 1992 by Sun Microsystems, Inc.
***************
*** 86,92 ****
  {
      int		 data_len;
  
!     data_len = (int)(*((CARD16 *)recv_buf + 1) + XIM_HEADER_SIZE);
      return data_len;
  }
  
--- 86,92 ----
  {
      int		 data_len;
  
!     data_len = (int)(((*((CARD16 *)recv_buf + 1)) * 4) + XIM_HEADER_SIZE);
      return data_len;
  }
  
*** /tmp/da16696	Sun Jun  5 18:26:53 1994
--- xc/lib/Xt/ActionHook.c	Sun Jun  5 18:26:52 1994
***************
*** 1,4 ****
! /* $XConsortium: ActionHook.c,v 1.7 94/04/17 20:13:35 kaleb Exp $ */
  
  /*LINTLIBRARY*/
  
--- 1,4 ----
! /* $XConsortium: ActionHook.c,v 1.8 94/06/01 15:38:29 converse Exp $ */
  
  /*LINTLIBRARY*/
  
***************
*** 114,129 ****
      XtAppContext app = hook->app;
      LOCK_APP(app);
      for (p = &app->action_hook_list; p != NULL && *p != hook; p = &(*p)->next);
!     if (p == NULL) {
  #ifdef DEBUG
  	XtAppWarningMsg(app, "badId", "xtRemoveActionHook", XtCXtToolkitError,
  			"XtRemoveActionHook called with bad or old hook id",
  			(String*)NULL, (Cardinal*)NULL);
- #endif /*DEBUG*/	
- 	UNLOCK_APP(app);
- 	return;
      }
!     *p = hook->next;
!     XtFree( (XtPointer)hook );
      UNLOCK_APP(app);
  }
--- 114,132 ----
      XtAppContext app = hook->app;
      LOCK_APP(app);
      for (p = &app->action_hook_list; p != NULL && *p != hook; p = &(*p)->next);
!     if (p) {
! 	*p = hook->next;
! 	XtFree( (XtPointer)hook );
! 	if (app->action_hook_list == NULL)
! 	    _XtRemoveCallback(&app->destroy_callbacks, FreeActionHookList,
! 			      (XtPointer) &app->action_hook_list);
!     }
  #ifdef DEBUG
+     else {
  	XtAppWarningMsg(app, "badId", "xtRemoveActionHook", XtCXtToolkitError,
  			"XtRemoveActionHook called with bad or old hook id",
  			(String*)NULL, (Cardinal*)NULL);
      }
! #endif /*DEBUG*/
      UNLOCK_APP(app);
  }
*** /tmp/da16712	Sun Jun  5 18:26:55 1994
--- xc/lib/Xt/Display.c	Sun Jun  5 18:26:54 1994
***************
*** 1,4 ****
! /* $XConsortium: Display.c,v 1.115 94/04/17 20:13:58 kaleb Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $XConsortium: Display.c,v 1.116 94/06/01 15:34:15 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 261,269 ****
  	if (! applName && !(applName = getenv("RESOURCE_NAME"))) {
  	    if (*argc > 0 && argv[0] && *argv[0]) {
  #ifdef WIN32
! 		char *ptr = strchr(argv[0], '\\');
  #else
! 		char *ptr = strchr(argv[0], '/');
  #endif
  		if (ptr) applName = ++ptr;
  		else applName = argv[0];
--- 261,269 ----
  	if (! applName && !(applName = getenv("RESOURCE_NAME"))) {
  	    if (*argc > 0 && argv[0] && *argv[0]) {
  #ifdef WIN32
! 		char *ptr = strrchr(argv[0], '\\');
  #else
! 		char *ptr = strrchr(argv[0], '/');
  #endif
  		if (ptr) applName = ++ptr;
  		else applName = argv[0];
*** /tmp/da16728	Sun Jun  5 18:26:57 1994
--- xc/lib/Xt/Shell.c	Sun Jun  5 18:26:56 1994
***************
*** 1,4 ****
! /* $XConsortium: Shell.c,v 1.165 94/04/17 20:14:47 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts
--- 1,4 ----
! /* $XConsortium: Shell.c,v 1.166 94/06/01 15:33:25 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts
***************
*** 3003,3009 ****
  
      if (w->session.checkpoint_state != XtSaveInactive) {
  	w->session.save->cancel_shutdown = True;
! 	call_interacts = (w->session.save->interact_style != None);
      }
  
      XtCallCallbackList((Widget)w, w->session.cancel_callbacks,
--- 3003,3010 ----
  
      if (w->session.checkpoint_state != XtSaveInactive) {
  	w->session.save->cancel_shutdown = True;
! 	call_interacts = (w->session.save->interact_style !=
! 			  SmInteractStyleNone);
      }
  
      XtCallCallbackList((Widget)w, w->session.cancel_callbacks,
***************
*** 3010,3016 ****
  		       (XtPointer) NULL);
  
      if (call_interacts) {
! 	w->session.save->interact_style = None;
  	XtInteractPermission(w->session.connection, (SmPointer) w);
      }
  
--- 3011,3017 ----
  		       (XtPointer) NULL);
  
      if (call_interacts) {
! 	w->session.save->interact_style = SmInteractStyleNone;
  	XtInteractPermission(w->session.connection, (SmPointer) w);
      }
  
***************
*** 3018,3024 ****
  	if (w->session.save->save_tokens == 0 &&
  	    w->session.checkpoint_state == XtSaveActive) {
  	    w->session.checkpoint_state = XtSaveInactive;
! 	    SmcSaveYourselfDone(w->session.connection, False);
  	    CleanUpSave(w);
  	}
      }
--- 3019,3026 ----
  	if (w->session.save->save_tokens == 0 &&
  	    w->session.checkpoint_state == XtSaveActive) {
  	    w->session.checkpoint_state = XtSaveInactive;
! 	    SmcSaveYourselfDone(w->session.connection,
! 				w->session.save->save_success);
  	    CleanUpSave(w);
  	}
      }
*** /tmp/da16744	Sun Jun  5 18:27:01 1994
--- xc/lib/Xt/TMparse.c	Sun Jun  5 18:27:00 1994
***************
*** 1,4 ****
! /* $XConsortium: TMparse.c,v 1.140 94/04/17 20:14:53 kaleb Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $XConsortium: TMparse.c,v 1.142 94/06/03 16:27:01 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 521,554 ****
      return (Cardinal) i;
  }
  
- /***********************************************************************
-  * _XtLookupTableSym
-  * Given a table and string, it fills in the value if found and returns
-  * status
-  ***********************************************************************/
- 
- static Boolean _XtLookupTableSym(table, name, valueP)
-     NameValueTable	table;
-     String name;
-     Value *valueP;
- {
- /* ||| should implement via hash or something else faster than linear search */
- 
-     register int i;
-     register XrmQuark signature = StringToQuark(name);
- 
-     for (i=0; table[i].name != NULL; i++)
- 	if (table[i].signature == signature) {
- 	    *valueP = table[i].value;
- 	    return TRUE;
- 	}
- 
-     return FALSE;
- }
- 
- 
- 
- 
  static void StoreLateBindings(keysymL,notL,keysymR,notR,lateBindings)
  
      KeySym  keysymL;
--- 521,526 ----
***************
*** 1025,1030 ****
--- 997,1004 ----
      Boolean* error;
  {
      register String start = str;
+     register XrmQuark signature;
+     NameValueTable table = (NameValueTable) closure;
      char tableSymName[100];
  
      event->event.eventCode = 0L;
***************
*** 1037,1051 ****
      }
      (void) memmove(tableSymName, start, str-start);
      tableSymName[str-start] = '\0';
!     if (! _XtLookupTableSym((NameValueTable)closure, tableSymName, 
!             (Value *)&event->event.eventCode)) {
! 	Syntax("Unknown Detail Type:  ",tableSymName);
!         *error = TRUE;
!         return PanicModeRecovery(str);
!     }
!     event->event.eventCodeMask = ~0L;
  
!     return str;
  }
  
  /*ARGSUSED*/
--- 1011,1027 ----
      }
      (void) memmove(tableSymName, start, str-start);
      tableSymName[str-start] = '\0';
!     signature = StringToQuark(tableSymName);
!     for (; table->signature != NULLQUARK; table++)
! 	if (table->signature == signature) {
! 	    event->event.eventCode = table->value;
! 	    event->event.eventCodeMask = ~0L;
! 	    return str;
! 	}
  
!     Syntax("Unknown Detail Type:  ", tableSymName);
!     *error = TRUE;
!     return PanicModeRecovery(str);
  }
  
  /*ARGSUSED*/
*** /tmp/da22644	Mon Jun  6 17:48:57 1994
--- xc/lib/font/Speedo/spfuncs.c	Mon Jun  6 17:48:56 1994
***************
*** 1,4 ****
! /* $XConsortium: spfuncs.c,v 1.12 94/04/17 20:17:49 gildea Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation
--- 1,4 ----
! /* $XConsortium: spfuncs.c,v 1.13 94/06/06 17:42:26 gildea Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation
***************
*** 86,96 ****
   * and to simply save the values without doing the work.
   */
  static int
! get_font_info(pinfo, fontname, filename, entry, spfont)
      FontInfoPtr pinfo;
      char       *fontname;
      char       *filename;
      FontEntryPtr	entry;
      SpeedoFontPtr *spfont;
  {
      SpeedoFontPtr spf;
--- 86,97 ----
   * and to simply save the values without doing the work.
   */
  static int
! get_font_info(pinfo, fontname, filename, entry, vals, spfont)
      FontInfoPtr pinfo;
      char       *fontname;
      char       *filename;
      FontEntryPtr	entry;
+     FontScalablePtr	vals;
      SpeedoFontPtr *spfont;
  {
      SpeedoFontPtr spf;
***************
*** 97,103 ****
      int         err;
      long	sWidth;
  
!     err = sp_open_font(fontname, filename, entry,
  	       (fsBitmapFormat) 0, (fsBitmapFormatMask) 0, (unsigned long) 0,
  		       &spf);
  
--- 98,104 ----
      int         err;
      long	sWidth;
  
!     err = sp_open_font(fontname, filename, entry, vals,
  	       (fsBitmapFormat) 0, (fsBitmapFormatMask) 0, (unsigned long) 0,
  		       &spf);
  
***************
*** 137,143 ****
      strcpy(fullName, entry->name.name);
      FontParseXLFDName(fullName, vals, FONT_XLFD_REPLACE_VALUE);
  
!     err = get_font_info(pFontInfo, fullName, fileName, entry, &spf);
  
      if (spf)
  	sp_close_font(spf);
--- 138,144 ----
      strcpy(fullName, entry->name.name);
      FontParseXLFDName(fullName, vals, FONT_XLFD_REPLACE_VALUE);
  
!     err = get_font_info(pFontInfo, fullName, fileName, entry, vals, &spf);
  
      if (spf)
  	sp_close_font(spf);
*** /tmp/da16765	Sun Jun  5 18:27:03 1994
--- xc/lib/font/util/fontxlfd.c	Sun Jun  5 18:27:03 1994
***************
*** 1,4 ****
! /* $XConsortium: fontxlfd.c,v 1.18 94/04/17 20:17:33 rws Exp $ */
  
  /*
  
--- 1,4 ----
! /* $XConsortium: fontxlfd.c,v 1.19 94/06/05 14:42:48 rws Exp $ */
  
  /*
  
***************
*** 130,139 ****
  }
  
  static char *
! xlfd_double_to_text(value, buffer, sign_required)
  double value;
  char *buffer;
! int sign_required;
  {
      char formatbuf[40];
      register char *p1;
--- 130,139 ----
  }
  
  static char *
! xlfd_double_to_text(value, buffer, space_required)
  double value;
  char *buffer;
! int space_required;
  {
      char formatbuf[40];
      register char *p1;
***************
*** 154,159 ****
--- 154,162 ----
      /* Compute a format to use to render the number */
      sprintf(formatbuf, "%%.%dle", XLFD_NDIGITS);
  
+     if (space_required)
+ 	*buffer++ = ' ';
+ 
      /* Render the number using printf's idea of formatting */
      sprintf(buffer, formatbuf, value);
  
***************
*** 190,203 ****
  	}
      }
  
-     /* If we need a sign at the beginning and don't have one, stuff
-        it in. */
-     if (sign_required && *buffer != *minus)
-     {
- 	memmove(buffer + 1, buffer, strlen(buffer) + 1);
- 	buffer[0] = *plus;
-     }
- 
      /* Last step, convert the locale-specific sign and radix characters
         to our own. */
      for (p1 = buffer; *p1; p1++)
--- 193,198 ----
***************
*** 207,213 ****
  	else if (*p1 == *radix) *p1 = '.';
      }
  
!     return buffer;
  }
  
  double
--- 202,208 ----
  	else if (*p1 == *radix) *p1 = '.';
      }
  
!     return buffer - space_required;
  }
  
  double
***************
*** 415,421 ****
  	ptr = strchr(ptr, '-') + 1;		/* skip setwidth_name */
  	ptr = strchr(ptr, '-') + 1;		/* skip add_style_name */
  
! 	if ((ptr - fname) + spacingLen + strlen(ptr5) + 10 >= 1024)
  	    return FALSE;
  	*ptr++ = replaceChar;
  	*ptr++ = '-';
--- 410,416 ----
  	ptr = strchr(ptr, '-') + 1;		/* skip setwidth_name */
  	ptr = strchr(ptr, '-') + 1;		/* skip add_style_name */
  
! 	if ((ptr - fname) + spacingLen + strlen(ptr5) + 10 >= (unsigned)1024)
  	    return FALSE;
  	*ptr++ = replaceChar;
  	*ptr++ = '-';
*** /tmp/da16786	Sun Jun  5 18:27:06 1994
--- xc/lib/xtrans/Xtrans.c	Sun Jun  5 18:27:05 1994
***************
*** 1,4 ****
! /* $XConsortium: Xtrans.c,v 1.24 94/05/10 11:32:27 mor Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
--- 1,4 ----
! /* $XConsortium: Xtrans.c,v 1.25 94/06/02 10:59:43 mor Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
***************
*** 89,100 ****
      &TRANS(TLIINETFuncs),	TRANS_TLI_INET_INDEX,
      &TRANS(TLITLIFuncs),	TRANS_TLI_TLI_INDEX,
  #endif /* STREAMSCONN */
- #if defined(UNIXCONN)
- #if !defined(LOCALCONN)
-     &TRANS(SocketLocalFuncs),	TRANS_SOCKET_LOCAL_INDEX,
- #endif /* !LOCALCONN */
-     &TRANS(SocketUNIXFuncs),	TRANS_SOCKET_UNIX_INDEX,
- #endif /* UNIXCONN */
  #if defined(TCPCONN)
      &TRANS(SocketTCPFuncs),	TRANS_SOCKET_TCP_INDEX,
      &TRANS(SocketINETFuncs),	TRANS_SOCKET_INET_INDEX,
--- 89,94 ----
***************
*** 102,107 ****
--- 96,107 ----
  #if defined(DNETCONN)
      &TRANS(DNETFuncs),		TRANS_DNET_INDEX,
  #endif /* DNETCONN */
+ #if defined(UNIXCONN)
+ #if !defined(LOCALCONN)
+     &TRANS(SocketLocalFuncs),	TRANS_SOCKET_LOCAL_INDEX,
+ #endif /* !LOCALCONN */
+     &TRANS(SocketUNIXFuncs),	TRANS_SOCKET_UNIX_INDEX,
+ #endif /* UNIXCONN */
  #if defined(LOCALCONN)
      &TRANS(LocalFuncs),		TRANS_LOCAL_LOCAL_INDEX,
      &TRANS(PTSFuncs),		TRANS_LOCAL_PTS_INDEX,
***************
*** 1026,1032 ****
  {
      char		buffer[256]; /* ??? What size ?? */
      XtransConnInfo	ciptr, temp_ciptrs[NUMTRANS];
!     int			i;
  
      PRMSG (2,"TRANS(MakeAllCOTSServerListeners) (%s,%x)\n",
  	   port ? port : "NULL", ciptrs_ret, 0);
--- 1026,1032 ----
  {
      char		buffer[256]; /* ??? What size ?? */
      XtransConnInfo	ciptr, temp_ciptrs[NUMTRANS];
!     int			status, i, j;
  
      PRMSG (2,"TRANS(MakeAllCOTSServerListeners) (%s,%x)\n",
  	   port ? port : "NULL", ciptrs_ret, 0);
***************
*** 1053,1064 ****
  	    continue;
  	}
  
! 	if (TRANS(CreateListener (ciptr, port)) < 0)
  	{
! 	    PRMSG (1,
  	"TRANS(MakeAllCOTSServerListeners) failed to create listener for %s\n",
  		  trans->TransName, 0, 0);
! 	    continue;
  	}
  
  	PRMSG (5,
--- 1053,1088 ----
  	    continue;
  	}
  
! 	if ((status = TRANS(CreateListener (ciptr, port))) < 0)
  	{
! 	    if (status == TRANS_ADDR_IN_USE)
! 	    {
! 		/*
! 		 * We failed to bind to the specified address because the
! 		 * address is in use.  It must be that a server is already
! 		 * running at this address, and this function should fail.
! 		 */
! 
! 		PRMSG (1,
! 		"TRANS(MakeAllCOTSServerListeners) server already running\n",
! 		  0, 0, 0);
! 
! 		for (j = 0; j < *count_ret; j++)
! 		    TRANS(Close) (temp_ciptrs[j]);
! 
! 		*count_ret = 0;
! 		*ciptrs_ret = NULL;
! 		*partial = 0;
! 		return -1;
! 	    }
! 	    else
! 	    {
! 		PRMSG (1,
  	"TRANS(MakeAllCOTSServerListeners) failed to create listener for %s\n",
  		  trans->TransName, 0, 0);
! 
! 		continue;
! 	    }
  	}
  
  	PRMSG (5,
***************
*** 1105,1111 ****
  {
      char		buffer[256]; /* ??? What size ?? */
      XtransConnInfo	ciptr, temp_ciptrs[NUMTRANS];
!     int			i;
  
      PRMSG (2,"TRANS(MakeAllCLTSServerListeners) (%s,%x)\n",
  	port ? port : "NULL", ciptrs_ret, 0);
--- 1129,1135 ----
  {
      char		buffer[256]; /* ??? What size ?? */
      XtransConnInfo	ciptr, temp_ciptrs[NUMTRANS];
!     int			status, i, j;
  
      PRMSG (2,"TRANS(MakeAllCLTSServerListeners) (%s,%x)\n",
  	port ? port : "NULL", ciptrs_ret, 0);
***************
*** 1132,1143 ****
  	    continue;
  	}
  
! 	if (TRANS(CreateListener (ciptr, port)) < 0)
  	{
! 	    PRMSG (1,
  	"TRANS(MakeAllCLTSServerListeners) failed to create listener for %s\n",
  		  trans->TransName, 0, 0);
! 	    continue;
  	}
  
  	PRMSG (5,
--- 1156,1191 ----
  	    continue;
  	}
  
! 	if ((status = TRANS(CreateListener (ciptr, port))) < 0)
  	{
! 	    if (status == TRANS_ADDR_IN_USE)
! 	    {
! 		/*
! 		 * We failed to bind to the specified address because the
! 		 * address is in use.  It must be that a server is already
! 		 * running at this address, and this function should fail.
! 		 */
! 
! 		PRMSG (1,
! 		"TRANS(MakeAllCLTSServerListeners) server already running\n",
! 		  0, 0, 0);
! 
! 		for (j = 0; j < *count_ret; j++)
! 		    TRANS(Close) (temp_ciptrs[j]);
! 
! 		*count_ret = 0;
! 		*ciptrs_ret = NULL;
! 		*partial = 0;
! 		return -1;
! 	    }
! 	    else
! 	    {
! 		PRMSG (1,
  	"TRANS(MakeAllCLTSServerListeners) failed to create listener for %s\n",
  		  trans->TransName, 0, 0);
! 
! 		continue;
! 	    }
  	}
  
  	PRMSG (5,
*** /tmp/da16802	Sun Jun  5 18:27:08 1994
--- xc/lib/xtrans/Xtrans.h	Sun Jun  5 18:27:07 1994
***************
*** 1,4 ****
! /* $XConsortium: Xtrans.h,v 1.24 94/05/02 10:45:32 mor Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
--- 1,4 ----
! /* $XConsortium: Xtrans.h,v 1.27 94/06/02 10:49:08 mor Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
***************
*** 189,194 ****
--- 189,202 ----
  
  
  /*
+  * Return values of CreateListener (0 is success)
+  */
+ 
+ #define TRANS_CREATE_LISTENER_FAILED 	-1
+ #define TRANS_ADDR_IN_USE		-2
+ 
+ 
+ /*
   * Return values of Accept (0 is success)
   */
  
***************
*** 443,449 ****
  #if NeedFunctionPrototypes
      int *,		/* familyp */
      int *,		/* addrlenp */
!     Xtransaddr *	/* addrp */
  #endif
  );
  
--- 451,457 ----
  #if NeedFunctionPrototypes
      int *,		/* familyp */
      int *,		/* addrlenp */
!     Xtransaddr **	/* addrp */
  #endif
  );
  
*** /tmp/da16818	Sun Jun  5 18:27:10 1994
--- xc/lib/xtrans/Xtranssock.c	Sun Jun  5 18:27:09 1994
***************
*** 1,4 ****
! /* $XConsortium: Xtranssock.c,v 1.27 94/05/02 11:44:22 mor Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
--- 1,4 ----
! /* $XConsortium: Xtranssock.c,v 1.29 94/06/02 10:51:53 mor Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
***************
*** 113,118 ****
--- 113,119 ----
  #undef close
  #define close closesocket
  #define ECONNREFUSED WSAECONNREFUSED
+ #define EADDRINUSE WSAEADDRINUSE
  #define EPROTOTYPE WSAEPROTOTYPE
  #undef EWOULDBLOCK
  #define EWOULDBLOCK WSAEWOULDBLOCK
***************
*** 716,726 ****
  
      while (bind (fd, (struct sockaddr *) sockname, namelen) < 0)
      {
  	if (retry-- == 0) {
  	    PRMSG (1, "TRANS(SocketCreateListener): failed to bind listener\n",
  		0, 0, 0);
  	    close (fd);
! 	    return -1;
  	}
  #ifdef SO_REUSEADDR
  	sleep (1);
--- 717,730 ----
  
      while (bind (fd, (struct sockaddr *) sockname, namelen) < 0)
      {
+ 	if (errno == EADDRINUSE)
+ 	    return TRANS_ADDR_IN_USE;
+ 
  	if (retry-- == 0) {
  	    PRMSG (1, "TRANS(SocketCreateListener): failed to bind listener\n",
  		0, 0, 0);
  	    close (fd);
! 	    return TRANS_CREATE_LISTENER_FAILED;
  	}
  #ifdef SO_REUSEADDR
  	sleep (1);
***************
*** 747,753 ****
      {
  	PRMSG (1, "TRANS(SocketCreateListener): listen() failed\n", 0, 0, 0);
  	close (fd);
! 	return -1;
      }
  	
      /* Set a flag to indicate that this connection is a listener */
--- 751,757 ----
      {
  	PRMSG (1, "TRANS(SocketCreateListener): listen() failed\n", 0, 0, 0);
  	close (fd);
! 	return TRANS_CREATE_LISTENER_FAILED;
      }
  	
      /* Set a flag to indicate that this connection is a listener */
***************
*** 768,774 ****
  {
      struct sockaddr_in	sockname;
      int		namelen = sizeof(sockname);
!     int		ret;
      short	tmpport;
      struct	servent	*servp;
  
--- 772,778 ----
  {
      struct sockaddr_in	sockname;
      int		namelen = sizeof(sockname);
!     int		status;
      short	tmpport;
      struct	servent	*servp;
  
***************
*** 811,817 ****
  		PRMSG (1,
  	     "TRANS(SocketINETCreateListener): Unable to get service for %s\n",
  		      port, 0, 0);
! 		return -1;
  	    }
  	    
  	    sockname.sin_port = servp->s_port;
--- 815,821 ----
  		PRMSG (1,
  	     "TRANS(SocketINETCreateListener): Unable to get service for %s\n",
  		      port, 0, 0);
! 		return TRANS_CREATE_LISTENER_FAILED;
  	    }
  	    
  	    sockname.sin_port = servp->s_port;
***************
*** 831,843 ****
      sockname.sin_family = AF_INET;
      sockname.sin_addr.s_addr = htonl (INADDR_ANY);
  
!     if (TRANS(SocketCreateListener) (ciptr,
! 	(struct sockaddr *) &sockname, namelen) < 0)
      {
  	PRMSG (1,
      "TRANS(SocketINETCreateListener): TRANS(SocketCreateListener) () failed\n",
  	    0, 0, 0);
! 	return -1;
      }
  
      if (TRANS(SocketINETGetAddr) (ciptr) < 0)
--- 835,847 ----
      sockname.sin_family = AF_INET;
      sockname.sin_addr.s_addr = htonl (INADDR_ANY);
  
!     if ((status = TRANS(SocketCreateListener) (ciptr,
! 	(struct sockaddr *) &sockname, namelen)) < 0)
      {
  	PRMSG (1,
      "TRANS(SocketINETCreateListener): TRANS(SocketCreateListener) () failed\n",
  	    0, 0, 0);
! 	return status;
      }
  
      if (TRANS(SocketINETGetAddr) (ciptr) < 0)
***************
*** 845,851 ****
  	PRMSG (1,
         "TRANS(SocketINETCreateListener): TRANS(SocketINETGetAddr) () failed\n",
  	    0, 0, 0);
! 	return -1;
      }
  
      return 0;
--- 849,855 ----
  	PRMSG (1,
         "TRANS(SocketINETCreateListener): TRANS(SocketINETGetAddr) () failed\n",
  	    0, 0, 0);
! 	return TRANS_CREATE_LISTENER_FAILED;
      }
  
      return 0;
***************
*** 866,871 ****
--- 870,876 ----
      struct sockaddr_un	sockname;
      int			namelen;
      int			oldUmask;
+     int			status;
  
      PRMSG (2, "TRANS(SocketUNIXCreateListener) (%s)\n",
  	port ? port : "NULL", 0, 0);
***************
*** 900,912 ****
  
      unlink (sockname.sun_path);
  
!     if (TRANS(SocketCreateListener) (ciptr,
! 	(struct sockaddr *) &sockname, namelen) < 0)
      {
  	PRMSG (1,
      "TRANS(SocketUNIXCreateListener): TRANS(SocketCreateListener) () failed\n",
  	    0, 0, 0);
! 	return -1;
      }
  
      /*
--- 905,917 ----
  
      unlink (sockname.sun_path);
  
!     if ((status = TRANS(SocketCreateListener) (ciptr,
! 	(struct sockaddr *) &sockname, namelen)) < 0)
      {
  	PRMSG (1,
      "TRANS(SocketUNIXCreateListener): TRANS(SocketCreateListener) () failed\n",
  	    0, 0, 0);
! 	return status;
      }
  
      /*
***************
*** 923,929 ****
          PRMSG (1,
          "TRANS(SocketUNIXCreateListener): Can't allocate space for the addr\n",
  	    0, 0, 0);
!         return -1;
      }
  
      ciptr->family = sockname.sun_family;
--- 928,934 ----
          PRMSG (1,
          "TRANS(SocketUNIXCreateListener): Can't allocate space for the addr\n",
  	    0, 0, 0);
!         return TRANS_CREATE_LISTENER_FAILED;
      }
  
      ciptr->family = sockname.sun_family;
*** /tmp/da16834	Sun Jun  5 18:27:12 1994
--- xc/lib/xtrans/Xtranstli.c	Sun Jun  5 18:27:12 1994
***************
*** 1,4 ****
! /* $XConsortium: Xtranstli.c,v 1.19 94/05/05 11:44:11 mor Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
--- 1,4 ----
! /* $XConsortium: Xtranstli.c,v 1.21 94/06/02 10:54:50 mor Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
***************
*** 735,741 ****
      {
  	PRMSG(1, "TRANS(TLICreateListener): failed to allocate a t_bind\n",
  	      0,0,0 );
! 	return -1;
      }
      
      if( t_bind(ciptr->fd, req, ret) < 0 )
--- 735,741 ----
      {
  	PRMSG(1, "TRANS(TLICreateListener): failed to allocate a t_bind\n",
  	      0,0,0 );
! 	return TRANS_CREATE_LISTENER_FAILED;
      }
      
      if( t_bind(ciptr->fd, req, ret) < 0 )
***************
*** 743,749 ****
  	PRMSG(1, "TRANS(TLICreateListener): t_bind failed\n", 0,0,0 );
  	t_free((char *)req,T_BIND);
  	t_free((char *)ret,T_BIND);
! 	return -1;
      }
      
      if( memcmp(req->addr.buf,ret->addr.buf,req->addr.len) != 0 )
--- 743,749 ----
  	PRMSG(1, "TRANS(TLICreateListener): t_bind failed\n", 0,0,0 );
  	t_free((char *)req,T_BIND);
  	t_free((char *)ret,T_BIND);
! 	return TRANS_CREATE_LISTENER_FAILED;
      }
      
      if( memcmp(req->addr.buf,ret->addr.buf,req->addr.len) != 0 )
***************
*** 752,758 ****
  	      req, 0,0 );
  	t_free((char *)req,T_BIND);
  	t_free((char *)ret,T_BIND);
! 	return -1;
      }
      
      /*
--- 752,758 ----
  	      req, 0,0 );
  	t_free((char *)req,T_BIND);
  	t_free((char *)ret,T_BIND);
! 	return TRANS_ADDR_IN_USE;
      }
      
      /*
***************
*** 766,772 ****
  	      0,0,0 );
  	t_free((char *)req,T_BIND);
  	t_free((char *)ret, T_BIND);
! 	return -1;
      }
      
      ciptr->addrlen=ret->addr.len;
--- 766,772 ----
  	      0,0,0 );
  	t_free((char *)req,T_BIND);
  	t_free((char *)ret, T_BIND);
! 	return TRANS_CREATE_LISTENER_FAILED;
      }
      
      ciptr->addrlen=ret->addr.len;
***************
*** 820,826 ****
  	PRMSG(1,
  	    "TRANS(TLIINETCreateListener): failed to allocate a t_bind\n",
  	    0,0,0 );
! 	return -1;
      }
  
      if( port && *port ) {
--- 820,826 ----
  	PRMSG(1,
  	    "TRANS(TLIINETCreateListener): failed to allocate a t_bind\n",
  	    0,0,0 );
! 	return TRANS_CREATE_LISTENER_FAILED;
      }
  
      if( port && *port ) {
***************
*** 830,836 ****
  		  "TRANS(TLIINETCreateListener): can't resolve name:HOST_SELF.%s\n",
  		  port, 0,0 );
  	    t_free((char *)req,T_BIND);
! 	    return -1;
  	}
      } else {
  	sinaddr=(struct sockaddr_in *)req->addr.buf;
--- 830,836 ----
  		  "TRANS(TLIINETCreateListener): can't resolve name:HOST_SELF.%s\n",
  		  port, 0,0 );
  	    t_free((char *)req,T_BIND);
! 	    return TRANS_CREATE_LISTENER_FAILED;
  	}
      } else {
  	sinaddr=(struct sockaddr_in *)req->addr.buf;
***************
*** 865,871 ****
  	PRMSG(1,
  	      "TRANS(TLITLICreateListener): failed to allocate a t_bind\n",
  	      0,0,0 );
! 	return -1;
      }
      
      if( (sunaddr=(struct sockaddr_un *)
--- 865,871 ----
  	PRMSG(1,
  	      "TRANS(TLITLICreateListener): failed to allocate a t_bind\n",
  	      0,0,0 );
! 	return TRANS_CREATE_LISTENER_FAILED;
      }
      
      if( (sunaddr=(struct sockaddr_un *)
***************
*** 875,881 ****
  	      "TRANS(TLITLICreateListener): failed to allocate a sockaddr_un\n",
  	      0,0,0 );
  	t_free((char *)req,T_BIND);
! 	return -1;
      }
      
      sunaddr->sun_family=AF_UNIX;
--- 875,881 ----
  	      "TRANS(TLITLICreateListener): failed to allocate a sockaddr_un\n",
  	      0,0,0 );
  	t_free((char *)req,T_BIND);
! 	return TRANS_CREATE_LISTENER_FAILED;
      }
      
      sunaddr->sun_family=AF_UNIX;
*** /tmp/da16850	Sun Jun  5 18:27:14 1994
--- xc/lib/xtrans/Xtransutil.c	Sun Jun  5 18:27:14 1994
***************
*** 1,4 ****
! /* $XConsortium: Xtransutil.c,v 1.16 94/05/02 11:13:42 mor Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
--- 1,4 ----
! /* $XConsortium: Xtransutil.c,v 1.17 94/05/19 11:00:07 mor Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
***************
*** 86,95 ****
  TRANS(ConvertAddress)(familyp,addrlenp,addrp)
  int	*familyp;
  int	*addrlenp;
! Xtransaddr	*addrp;
  {
  
!     PRMSG(2,"TRANS(ConvertAddress)(%d,%d,%x)\n",*familyp,*addrlenp,addrp);
  
      switch( *familyp )
      {
--- 86,95 ----
  TRANS(ConvertAddress)(familyp,addrlenp,addrp)
  int	*familyp;
  int	*addrlenp;
! Xtransaddr	**addrp;
  {
  
!     PRMSG(2,"TRANS(ConvertAddress)(%d,%d,%x)\n",*familyp,*addrlenp,*addrp);
  
      switch( *familyp )
      {
***************
*** 114,120 ****
  	char *cp = (char *) &saddr.sin_addr.s_addr;
  #endif /* CRAY */
  
! 	memcpy (&saddr, addrp, sizeof (struct sockaddr_in));
  
  	if ((len == 4) && (cp[0] == 127) && (cp[1] == 0) &&
  	    (cp[2] == 0) && (cp[3] == 1))
--- 114,120 ----
  	char *cp = (char *) &saddr.sin_addr.s_addr;
  #endif /* CRAY */
  
! 	memcpy (&saddr, *addrp, sizeof (struct sockaddr_in));
  
  	if ((len == 4) && (cp[0] == 127) && (cp[1] == 0) &&
  	    (cp[2] == 0) && (cp[3] == 1))
***************
*** 125,131 ****
  	{
  	    *familyp=FamilyInternet;
  	    *addrlenp=len;
! 	    memcpy(addrp,&saddr.sin_addr,len);
  	}
  	break;
      }
--- 125,131 ----
  	{
  	    *familyp=FamilyInternet;
  	    *addrlenp=len;
! 	    memcpy(*addrp,&saddr.sin_addr,len);
  	}
  	break;
      }
***************
*** 136,146 ****
      {
  	struct sockaddr_dn saddr;
  
! 	memcpy (&saddr, addrp, sizeof (struct sockaddr_dn));
  
  	*familyp=FamilyDECnet;
  	*addrlenp=sizeof(struct dn_naddr);
! 	memcpy(addrp,&saddr.sdn_add,*addrlenp);
  
  	break;
      }
--- 136,146 ----
      {
  	struct sockaddr_dn saddr;
  
! 	memcpy (&saddr, *addrp, sizeof (struct sockaddr_dn));
  
  	*familyp=FamilyDECnet;
  	*addrlenp=sizeof(struct dn_naddr);
! 	memcpy(*addrp,&saddr.sdn_add,*addrlenp);
  
  	break;
      }
***************
*** 187,201 ****
  	int len = TRANS(GetHostname) (hostnamebuf, sizeof hostnamebuf);
  
  	if (len > 0) {
! 	    if (addrp && *addrlenp < (len + 1))
  	    {
! 		free ((char *) addrp);
! 		addrp = NULL;
  	    }
! 	    if (!addrp)
! 		addrp = (Xtransaddr *) malloc (len + 1);
! 	    if (addrp) {
! 		strcpy ((char *) addrp, hostnamebuf);
  		*addrlenp = len;
  	    } else {
  		*addrlenp = 0;
--- 187,201 ----
  	int len = TRANS(GetHostname) (hostnamebuf, sizeof hostnamebuf);
  
  	if (len > 0) {
! 	    if (*addrp && *addrlenp < (len + 1))
  	    {
! 		free ((char *) *addrp);
! 		*addrp = NULL;
  	    }
! 	    if (!*addrp)
! 		*addrp = (Xtransaddr *) malloc (len + 1);
! 	    if (*addrp) {
! 		strcpy ((char *) *addrp, hostnamebuf);
  		*addrlenp = len;
  	    } else {
  		*addrlenp = 0;
***************
*** 203,211 ****
  	}
  	else
  	{
! 	    if (addrp)
! 		free ((char *) addrp);
! 	    addrp = NULL;
  	    *addrlenp = 0;
  	}
      }
--- 203,211 ----
  	}
  	else
  	{
! 	    if (*addrp)
! 		free ((char *) *addrp);
! 	    *addrp = NULL;
  	    *addrlenp = 0;
  	}
      }
*** /tmp/da16871	Sun Jun  5 18:27:16 1994
--- xc/nls/X11/locale/Compose/iso8859-1	Sun Jun  5 18:27:16 1994
***************
*** 1,4 ****
! # $XConsortium: iso8859-1,v 1.2 93/09/17 16:02:48 rws Exp $
  #
  # ISO 8859-1 (Latin1) Compose Sequence
  #
--- 1,4 ----
! # $XConsortium: iso8859-1,v 1.3 94/06/04 17:14:22 rws Exp $
  #
  # ISO 8859-1 (Latin1) Compose Sequence
  #
***************
*** 101,107 ****
  # Accented Alphabet
  <Multi_key> <A> <grave>			: "\300"	# A Grave
  <Multi_key> <A> <acute>			: "\301"	# A Acute
! <Multi_key> <A> <asciicircumflex>	: "\302"	# A Circumflex
  <Multi_key> <A> <greater>		: "\302"	# A Circumflex
  <Multi_key> <A> <asciitilde>		: "\303"	# A Tilde
  <Multi_key> <A> <minus>			: "\303"	# A Tilde
--- 101,107 ----
  # Accented Alphabet
  <Multi_key> <A> <grave>			: "\300"	# A Grave
  <Multi_key> <A> <acute>			: "\301"	# A Acute
! <Multi_key> <A> <asciicircum>		: "\302"	# A Circumflex
  <Multi_key> <A> <greater>		: "\302"	# A Circumflex
  <Multi_key> <A> <asciitilde>		: "\303"	# A Tilde
  <Multi_key> <A> <minus>			: "\303"	# A Tilde
***************
*** 110,116 ****
  <Multi_key> <A> <E>			: "\306"	# A E Diphthong
  <Multi_key> <a> <grave>			: "\340"	# a Grave
  <Multi_key> <a> <acute>			: "\341"	# a Acute
! <Multi_key> <a> <asciicircumflex>	: "\342"	# a Circumflex
  <Multi_key> <a> <greater>		: "\342"	# a Circumflex
  <Multi_key> <a> <asciitilde>		: "\343"	# a Tilde
  <Multi_key> <a> <minus>			: "\343"	# a Tilde
--- 110,116 ----
  <Multi_key> <A> <E>			: "\306"	# A E Diphthong
  <Multi_key> <a> <grave>			: "\340"	# a Grave
  <Multi_key> <a> <acute>			: "\341"	# a Acute
! <Multi_key> <a> <asciicircum>		: "\342"	# a Circumflex
  <Multi_key> <a> <greater>		: "\342"	# a Circumflex
  <Multi_key> <a> <asciitilde>		: "\343"	# a Tilde
  <Multi_key> <a> <minus>			: "\343"	# a Tilde
***************
*** 123,144 ****
  <Multi_key> <minus> <d>			: "\360"	# Small Icelandic Eth
  <Multi_key> <E> <grave>			: "\310"	# E Grave
  <Multi_key> <E> <acute>			: "\311"	# E Acute
! <Multi_key> <E> <asciicircumflex>	: "\312"	# E Circumflex
  <Multi_key> <E> <greater>		: "\312"	# E Circumflex
  <Multi_key> <E> <quotedbl>		: "\313"	# E Umlaut
  <Multi_key> <e> <grave>			: "\350"	# e Grave
  <Multi_key> <e> <acute>			: "\351"	# e Acute
! <Multi_key> <e> <asciicircumflex>	: "\352"	# e Circumflex
  <Multi_key> <e> <greater>		: "\352"	# e Circumflex
  <Multi_key> <e> <quotedbl>		: "\353"	# e Umlaut
  <Multi_key> <I> <grave>			: "\314"	# I Grave
  <Multi_key> <I> <acute>			: "\315"	# I Acute
! <Multi_key> <I> <asciicircumflex>	: "\316"	# I Circumflex
  <Multi_key> <I> <greater>		: "\316"	# I Circumflex
  <Multi_key> <I> <quotedbl>		: "\317"	# I Umlaut
  <Multi_key> <i> <grave>			: "\354"	# i Grave
  <Multi_key> <i> <acute>			: "\355"	# i Acute
! <Multi_key> <i> <asciicircumflex>	: "\356"	# i Circumflex
  <Multi_key> <i> <greater>		: "\356"	# i Circumflex
  <Multi_key> <i> <quotedbl>		: "\357"	# i Umlaut
  <Multi_key> <N> <asciitilde>		: "\321"	# N Tilde
--- 123,144 ----
  <Multi_key> <minus> <d>			: "\360"	# Small Icelandic Eth
  <Multi_key> <E> <grave>			: "\310"	# E Grave
  <Multi_key> <E> <acute>			: "\311"	# E Acute
! <Multi_key> <E> <asciicircum>		: "\312"	# E Circumflex
  <Multi_key> <E> <greater>		: "\312"	# E Circumflex
  <Multi_key> <E> <quotedbl>		: "\313"	# E Umlaut
  <Multi_key> <e> <grave>			: "\350"	# e Grave
  <Multi_key> <e> <acute>			: "\351"	# e Acute
! <Multi_key> <e> <asciicircum>		: "\352"	# e Circumflex
  <Multi_key> <e> <greater>		: "\352"	# e Circumflex
  <Multi_key> <e> <quotedbl>		: "\353"	# e Umlaut
  <Multi_key> <I> <grave>			: "\314"	# I Grave
  <Multi_key> <I> <acute>			: "\315"	# I Acute
! <Multi_key> <I> <asciicircum>		: "\316"	# I Circumflex
  <Multi_key> <I> <greater>		: "\316"	# I Circumflex
  <Multi_key> <I> <quotedbl>		: "\317"	# I Umlaut
  <Multi_key> <i> <grave>			: "\354"	# i Grave
  <Multi_key> <i> <acute>			: "\355"	# i Acute
! <Multi_key> <i> <asciicircum>		: "\356"	# i Circumflex
  <Multi_key> <i> <greater>		: "\356"	# i Circumflex
  <Multi_key> <i> <quotedbl>		: "\357"	# i Umlaut
  <Multi_key> <N> <asciitilde>		: "\321"	# N Tilde
***************
*** 147,153 ****
  <Multi_key> <n> <minus>			: "\361"	# n Tilde
  <Multi_key> <O> <grave>			: "\322"	# O Grave
  <Multi_key> <O> <acute>			: "\323"	# O Acute
! <Multi_key> <O> <asciicircumflex>	: "\324"	# O Circumflex
  <Multi_key> <O> <greater>		: "\324"	# O Circumflex
  <Multi_key> <O> <asciitilde>		: "\325"	# O Tilde
  <Multi_key> <O> <minus>			: "\325"	# O Tilde
--- 147,153 ----
  <Multi_key> <n> <minus>			: "\361"	# n Tilde
  <Multi_key> <O> <grave>			: "\322"	# O Grave
  <Multi_key> <O> <acute>			: "\323"	# O Acute
! <Multi_key> <O> <asciicircum>		: "\324"	# O Circumflex
  <Multi_key> <O> <greater>		: "\324"	# O Circumflex
  <Multi_key> <O> <asciitilde>		: "\325"	# O Tilde
  <Multi_key> <O> <minus>			: "\325"	# O Tilde
***************
*** 155,161 ****
  <Multi_key> <O> <slash>			: "\330"	# O Slash
  <Multi_key> <o> <grave>			: "\362"	# o Grave
  <Multi_key> <o> <acute>			: "\363"	# o Acute
! <Multi_key> <o> <asciicircumflex>	: "\364"	# o Circumflex
  <Multi_key> <o> <greater>		: "\364"	# o Circumflex
  <Multi_key> <o> <asciitilde>		: "\365"	# o Tilde
  <Multi_key> <o> <minus>			: "\365"	# o Tilde
--- 155,161 ----
  <Multi_key> <O> <slash>			: "\330"	# O Slash
  <Multi_key> <o> <grave>			: "\362"	# o Grave
  <Multi_key> <o> <acute>			: "\363"	# o Acute
! <Multi_key> <o> <asciicircum>		: "\364"	# o Circumflex
  <Multi_key> <o> <greater>		: "\364"	# o Circumflex
  <Multi_key> <o> <asciitilde>		: "\365"	# o Tilde
  <Multi_key> <o> <minus>			: "\365"	# o Tilde
***************
*** 163,174 ****
  <Multi_key> <o> <slash>			: "\370"	# o Slash
  <Multi_key> <U> <grave>			: "\331"	# U Grave
  <Multi_key> <U> <acute>			: "\332"	# U Acute
! <Multi_key> <U> <asciicircumflex>	: "\333"	# U Circumflex
  <Multi_key> <U> <greater>		: "\333"	# U Circumflex
  <Multi_key> <U> <quotedbl>		: "\334"	# U Umlaut
  <Multi_key> <u> <grave>			: "\371"	# u Grave
  <Multi_key> <u> <acute>			: "\372"	# u Acute
! <Multi_key> <u> <asciicircumflex>	: "\373"	# u Circumflex
  <Multi_key> <u> <greater>		: "\373"	# u Circumflex
  <Multi_key> <u> <quotedbl>		: "\374"	# u Umlaut
  <Multi_key> <s> <s>			: "\337"	# German Small Sharp s
--- 163,174 ----
  <Multi_key> <o> <slash>			: "\370"	# o Slash
  <Multi_key> <U> <grave>			: "\331"	# U Grave
  <Multi_key> <U> <acute>			: "\332"	# U Acute
! <Multi_key> <U> <asciicircum>		: "\333"	# U Circumflex
  <Multi_key> <U> <greater>		: "\333"	# U Circumflex
  <Multi_key> <U> <quotedbl>		: "\334"	# U Umlaut
  <Multi_key> <u> <grave>			: "\371"	# u Grave
  <Multi_key> <u> <acute>			: "\372"	# u Acute
! <Multi_key> <u> <asciicircum>		: "\373"	# u Circumflex
  <Multi_key> <u> <greater>		: "\373"	# u Circumflex
  <Multi_key> <u> <quotedbl>		: "\374"	# u Umlaut
  <Multi_key> <s> <s>			: "\337"	# German Small Sharp s
***************
*** 275,281 ****
  
  Ctrl<T> <A> <grave>			: "\300"	# A Grave
  Ctrl<T> <A> <acute>			: "\301"	# A Acute
! Ctrl<T> <A> <asciicircumflex>		: "\302"	# A Circumflex
  Ctrl<T> <A> <greater>			: "\302"	# A Circumflex
  Ctrl<T> <A> <asciitilde>		: "\303"	# A Tilde
  Ctrl<T> <A> <minus>			: "\303"	# A Tilde
--- 275,281 ----
  
  Ctrl<T> <A> <grave>			: "\300"	# A Grave
  Ctrl<T> <A> <acute>			: "\301"	# A Acute
! Ctrl<T> <A> <asciicircum>		: "\302"	# A Circumflex
  Ctrl<T> <A> <greater>			: "\302"	# A Circumflex
  Ctrl<T> <A> <asciitilde>		: "\303"	# A Tilde
  Ctrl<T> <A> <minus>			: "\303"	# A Tilde
***************
*** 284,290 ****
  Ctrl<T> <A> <E>				: "\306"	# A E Diphthong
  Ctrl<T> <a> <grave>			: "\340"	# a Grave
  Ctrl<T> <a> <acute>			: "\341"	# a Acute
! Ctrl<T> <a> <asciicircumflex>		: "\342"	# a Circumflex
  Ctrl<T> <a> <greater>			: "\342"	# a Circumflex
  Ctrl<T> <a> <asciitilde>		: "\343"	# a Tilde
  Ctrl<T> <a> <minus>			: "\343"	# a Tilde
--- 284,290 ----
  Ctrl<T> <A> <E>				: "\306"	# A E Diphthong
  Ctrl<T> <a> <grave>			: "\340"	# a Grave
  Ctrl<T> <a> <acute>			: "\341"	# a Acute
! Ctrl<T> <a> <asciicircum>		: "\342"	# a Circumflex
  Ctrl<T> <a> <greater>			: "\342"	# a Circumflex
  Ctrl<T> <a> <asciitilde>		: "\343"	# a Tilde
  Ctrl<T> <a> <minus>			: "\343"	# a Tilde
***************
*** 297,318 ****
  Ctrl<T> <minus> <d>			: "\360"	# Small Icelandic Eth
  Ctrl<T> <E> <grave>			: "\310"	# E Grave
  Ctrl<T> <E> <acute>			: "\311"	# E Acute
! Ctrl<T> <E> <asciicircumflex>		: "\312"	# E Circumflex
  Ctrl<T> <E> <greater>			: "\312"	# E Circumflex
  Ctrl<T> <E> <quotedbl>			: "\313"	# E Umlaut
  Ctrl<T> <e> <grave>			: "\350"	# e Grave
  Ctrl<T> <e> <acute>			: "\351"	# e Acute
! Ctrl<T> <e> <asciicircumflex>		: "\352"	# e Circumflex
  Ctrl<T> <e> <greater>			: "\352"	# e Circumflex
  Ctrl<T> <e> <quotedbl>			: "\353"	# e Umlaut
  Ctrl<T> <I> <grave>			: "\314"	# I Grave
  Ctrl<T> <I> <acute>			: "\315"	# I Acute
! Ctrl<T> <I> <asciicircumflex>		: "\316"	# I Circumflex
  Ctrl<T> <I> <greater>			: "\316"	# I Circumflex
  Ctrl<T> <I> <quotedbl>			: "\317"	# I Umlaut
  Ctrl<T> <i> <grave>			: "\354"	# i Grave
  Ctrl<T> <i> <acute>			: "\355"	# i Acute
! Ctrl<T> <i> <asciicircumflex>		: "\356"	# i Circumflex
  Ctrl<T> <i> <greater>			: "\356"	# i Circumflex
  Ctrl<T> <i> <quotedbl>			: "\357"	# i Umlaut
  Ctrl<T> <N> <asciitilde>		: "\321"	# N Tilde
--- 297,318 ----
  Ctrl<T> <minus> <d>			: "\360"	# Small Icelandic Eth
  Ctrl<T> <E> <grave>			: "\310"	# E Grave
  Ctrl<T> <E> <acute>			: "\311"	# E Acute
! Ctrl<T> <E> <asciicircum>		: "\312"	# E Circumflex
  Ctrl<T> <E> <greater>			: "\312"	# E Circumflex
  Ctrl<T> <E> <quotedbl>			: "\313"	# E Umlaut
  Ctrl<T> <e> <grave>			: "\350"	# e Grave
  Ctrl<T> <e> <acute>			: "\351"	# e Acute
! Ctrl<T> <e> <asciicircum>		: "\352"	# e Circumflex
  Ctrl<T> <e> <greater>			: "\352"	# e Circumflex
  Ctrl<T> <e> <quotedbl>			: "\353"	# e Umlaut
  Ctrl<T> <I> <grave>			: "\314"	# I Grave
  Ctrl<T> <I> <acute>			: "\315"	# I Acute
! Ctrl<T> <I> <asciicircum>		: "\316"	# I Circumflex
  Ctrl<T> <I> <greater>			: "\316"	# I Circumflex
  Ctrl<T> <I> <quotedbl>			: "\317"	# I Umlaut
  Ctrl<T> <i> <grave>			: "\354"	# i Grave
  Ctrl<T> <i> <acute>			: "\355"	# i Acute
! Ctrl<T> <i> <asciicircum>		: "\356"	# i Circumflex
  Ctrl<T> <i> <greater>			: "\356"	# i Circumflex
  Ctrl<T> <i> <quotedbl>			: "\357"	# i Umlaut
  Ctrl<T> <N> <asciitilde>		: "\321"	# N Tilde
***************
*** 321,327 ****
  Ctrl<T> <n> <minus>			: "\361"	# n Tilde
  Ctrl<T> <O> <grave>			: "\322"	# O Grave
  Ctrl<T> <O> <acute>			: "\323"	# O Acute
! Ctrl<T> <O> <asciicircumflex>		: "\324"	# O Circumflex
  Ctrl<T> <O> <greater>			: "\324"	# O Circumflex
  Ctrl<T> <O> <asciitilde>		: "\325"	# O Tilde
  Ctrl<T> <O> <minus>			: "\325"	# O Tilde
--- 321,327 ----
  Ctrl<T> <n> <minus>			: "\361"	# n Tilde
  Ctrl<T> <O> <grave>			: "\322"	# O Grave
  Ctrl<T> <O> <acute>			: "\323"	# O Acute
! Ctrl<T> <O> <asciicircum>		: "\324"	# O Circumflex
  Ctrl<T> <O> <greater>			: "\324"	# O Circumflex
  Ctrl<T> <O> <asciitilde>		: "\325"	# O Tilde
  Ctrl<T> <O> <minus>			: "\325"	# O Tilde
***************
*** 329,335 ****
  Ctrl<T> <O> <slash>			: "\330"	# O Slash
  Ctrl<T> <o> <grave>			: "\362"	# o Grave
  Ctrl<T> <o> <acute>			: "\363"	# o Acute
! Ctrl<T> <o> <asciicircumflex>		: "\364"	# o Circumflex
  Ctrl<T> <o> <greater>			: "\364"	# o Circumflex
  Ctrl<T> <o> <asciitilde>		: "\365"	# o Tilde
  Ctrl<T> <o> <minus>			: "\365"	# o Tilde
--- 329,335 ----
  Ctrl<T> <O> <slash>			: "\330"	# O Slash
  Ctrl<T> <o> <grave>			: "\362"	# o Grave
  Ctrl<T> <o> <acute>			: "\363"	# o Acute
! Ctrl<T> <o> <asciicircum>		: "\364"	# o Circumflex
  Ctrl<T> <o> <greater>			: "\364"	# o Circumflex
  Ctrl<T> <o> <asciitilde>		: "\365"	# o Tilde
  Ctrl<T> <o> <minus>			: "\365"	# o Tilde
***************
*** 337,348 ****
  Ctrl<T> <o> <slash>			: "\370"	# o Slash
  Ctrl<T> <U> <grave>			: "\331"	# U Grave
  Ctrl<T> <U> <acute>			: "\332"	# U Acute
! Ctrl<T> <U> <asciicircumflex>		: "\333"	# U Circumflex
  Ctrl<T> <U> <greater>			: "\333"	# U Circumflex
  Ctrl<T> <U> <quotedbl>			: "\334"	# U Umlaut
  Ctrl<T> <u> <grave>			: "\371"	# u Grave
  Ctrl<T> <u> <acute>			: "\372"	# u Acute
! Ctrl<T> <u> <asciicircumflex>		: "\373"	# u Circumflex
  Ctrl<T> <u> <greater>			: "\373"	# u Circumflex
  Ctrl<T> <u> <quotedbl>			: "\374"	# u Umlaut
  Ctrl<T> <s> <s>				: "\337"	# German Small Sharp s
--- 337,348 ----
  Ctrl<T> <o> <slash>			: "\370"	# o Slash
  Ctrl<T> <U> <grave>			: "\331"	# U Grave
  Ctrl<T> <U> <acute>			: "\332"	# U Acute
! Ctrl<T> <U> <asciicircum>		: "\333"	# U Circumflex
  Ctrl<T> <U> <greater>			: "\333"	# U Circumflex
  Ctrl<T> <U> <quotedbl>			: "\334"	# U Umlaut
  Ctrl<T> <u> <grave>			: "\371"	# u Grave
  Ctrl<T> <u> <acute>			: "\372"	# u Acute
! Ctrl<T> <u> <asciicircum>		: "\373"	# u Circumflex
  Ctrl<T> <u> <greater>			: "\373"	# u Circumflex
  Ctrl<T> <u> <quotedbl>			: "\374"	# u Umlaut
  Ctrl<T> <s> <s>				: "\337"	# German Small Sharp s
*** /tmp/da16892	Sun Jun  5 18:27:19 1994
--- xc/programs/Xserver/XIE/dixie/request/colorlst.c	Sun Jun  5 18:27:18 1994
***************
*** 1,4 ****
! /* $XConsortium: colorlst.c,v 1.5 94/04/17 20:33:52 rws Exp $ */
  /**** module colorlst.c ****/
  /****************************************************************************
  
--- 1,4 ----
! /* $XConsortium: colorlst.c,v 1.6 94/06/03 15:59:07 dpw Exp $ */
  /**** module colorlst.c ****/
  /****************************************************************************
  
***************
*** 237,245 ****
       *       (anyone care to donate an Alpha?)
       */
      if( client->swapped )
!       CopySwap32Write(client, clst->cellCnt, clst->cellPtr);
      else
!       WriteToClient(client, clst->cellCnt, (char *)clst->cellPtr);
    
    return(Success);
  }                               /* end ProcQueryColorList */
--- 237,245 ----
       *       (anyone care to donate an Alpha?)
       */
      if( client->swapped )
!       CopySwap32Write(client, clst->cellCnt << 2, clst->cellPtr);
      else
!       WriteToClient(client, clst->cellCnt << 2, (char *)clst->cellPtr);
    
    return(Success);
  }                               /* end ProcQueryColorList */
*** /tmp/da16908	Sun Jun  5 18:27:21 1994
--- xc/programs/Xserver/XIE/dixie/request/flo.c	Sun Jun  5 18:27:20 1994
***************
*** 1,4 ****
! /* $XConsortium: flo.c,v 1.6 94/04/17 20:33:55 rws Exp $ */
  /**** module flo.c ****/
  /******************************************************************************
  
--- 1,4 ----
! /* $XConsortium: flo.c,v 1.7 94/06/03 15:58:13 dpw Exp $ */
  /**** module flo.c ****/
  /******************************************************************************
  
***************
*** 460,466 ****
        inFlo->ownDef = ped;
        src = inFlo->srcDef = flo->peArray[tag];
        
!       if(src->flags.loop)
  	SourceError(flo,ped, break);	/* oops, we've stumbled over a loop */
  
        /* insert this inFlo into the source element's outFlo list */
--- 460,466 ----
        inFlo->ownDef = ped;
        src = inFlo->srcDef = flo->peArray[tag];
        
!       if(src->flags.loop || src->flags.export)
  	SourceError(flo,ped, break);	/* oops, we've stumbled over a loop */
  
        /* insert this inFlo into the source element's outFlo list */
***************
*** 472,479 ****
      }        
    }
    if(!ferrCode(flo)) {
!     /* clear the loop-detector (unless this is an export element) */
!     ped->flags.loop = ped->flags.export;
      
      if(ped->flags.import && !ListEmpty(&flo->defDAG)) {
        /* find the end of the import list, then append this element */
--- 472,479 ----
      }        
    }
    if(!ferrCode(flo)) {
!     /* clear the loop-detector */
!     ped->flags.loop = FALSE;
      
      if(ped->flags.import && !ListEmpty(&flo->defDAG)) {
        /* find the end of the import list, then append this element */
*** /tmp/da16929	Sun Jun  5 18:27:23 1994
--- xc/programs/Xserver/cfb/cfbbitblt.c	Sun Jun  5 18:27:22 1994
***************
*** 30,36 ****
  Author: Keith Packard
  
  */
! /* $XConsortium: cfbbitblt.c,v 5.50 94/04/17 20:28:43 dpw Exp $ */
  
  #include	"X.h"
  #include	"Xmd.h"
--- 30,36 ----
  Author: Keith Packard
  
  */
! /* $XConsortium: cfbbitblt.c,v 5.51 94/05/27 11:00:56 dpw Exp $ */
  
  #include	"X.h"
  #include	"Xmd.h"
***************
*** 451,457 ****
  	leftShift = xoffSrc;
  	rightShift = MFB_PPW - leftShift;
  
! 	pixelsRemainingOnRightEdge = (nlMiddle & 7) + ((dstx + width) & PIM);
  
  	/* setup is done; now let's move some bits */
  
--- 451,458 ----
  	leftShift = xoffSrc;
  	rightShift = MFB_PPW - leftShift;
  
! 	pixelsRemainingOnRightEdge = (nlMiddle & 7) * PPW +
! 	    				((dstx + width) & PIM);
  
  	/* setup is done; now let's move some bits */
  
*** /tmp/da16950	Sun Jun  5 18:27:25 1994
--- xc/programs/Xserver/hw/hp/Imakefile	Sun Jun  5 18:27:24 1994
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile,v 3.6 93/10/12 11:25:38 dpw Exp $
  #include <Server.tmpl>
  
  #define IHaveSubdirs
--- 1,4 ----
! XCOMM $XConsortium: Imakefile,v 3.7 94/05/28 15:39:04 dpw Exp $
  #include <Server.tmpl>
  
  #define IHaveSubdirs
***************
*** 22,28 ****
  	hpCursorUtils.ln \
  	hpInit.ln
  
! DEFINES = $(ANSI_DEFINES)
  
  LIB_DEFINES = -DLIBDIR=\"$(LIBDIR)\"
  
--- 22,28 ----
  	hpCursorUtils.ln \
  	hpInit.ln
  
! DEFINES = $(ANSI_DEFINES) -DOSMAJORVERSION=OSMajorVersion
  
  LIB_DEFINES = -DLIBDIR=\"$(LIBDIR)\"
  
*** /tmp/da16966	Sun Jun  5 18:27:26 1994
--- xc/programs/Xserver/hw/hp/README	Sun Jun  5 18:27:26 1994
***************
*** 1,3 ****
--- 1,4 ----
+ $XConsortium: README,v 1.4 94/06/03 10:47:07 dpw Exp $
  
  			README
  
***************
*** 56,61 ****
--- 57,65 ----
  
  	HP710L    710 SPU   1024x768 Color, 8 planes
  
+ 	HP712     712 SPU   1024x768 Color, 8 planes or 
+ 	                    1280x1024 Color, 8 planes
+ 
  	
  	=======================
  	MULTIPLE SCREEN SUPPORT
***************
*** 63,73 ****
  
  	The HP X11 sample server supports multiple physical screens
  	connected to a single server program.  The file
! 	/usr/lib/X11/X*screens is read by the X11 server to determine
  	information about the system screen configuration.
  
  	For a complete description of the X*screens file, refer to the
! 	HP-UX manuals, or view the sample file in /usr/lib/X11.
  	
  	==========================
  	24 PLANE SUPPORT FOR CRX24
--- 67,78 ----
  
  	The HP X11 sample server supports multiple physical screens
  	connected to a single server program.  The file
! 	$(LIBDIR)/X*screens is read by the X11 server to determine
  	information about the system screen configuration.
+ 	$(LIBDIR) is /usr/X11R6/lib/X11 by default.
  
  	For a complete description of the X*screens file, refer to the
! 	HP-UX manuals, or view the sample file in $(LIBDIR)
  	
  	==========================
  	24 PLANE SUPPORT FOR CRX24
*** /tmp/da16982	Sun Jun  5 18:27:28 1994
--- xc/programs/Xserver/hw/hp/ddx_info.c	Sun Jun  5 18:27:28 1994
***************
*** 1,4 ****
! /* $XConsortium: ddx_info.c,v 1.1 93/08/08 13:00:29 rws Exp $ */
  
  /*************************************************************************
   * 
--- 1,4 ----
! /* $XConsortium: ddx_info.c,v 1.2 94/05/28 15:39:13 dpw Exp $ */
  
  /*************************************************************************
   * 
***************
*** 61,66 ****
--- 61,69 ----
  #   ifndef S9000_ID_TOMCAT          /* 2-headed ELK; sorry, no P/N yet */
  #       define S9000_ID_TOMCAT          0x27FCCB6D
  #   endif
+ #   ifndef S9000_ID_ARTIST          /* Artist 712 mother board graphics */
+ #       define S9000_ID_ARTIST          0x2B4DED6D
+ #   endif
  #endif
  
  /* Declare the external initialization functions */
***************
*** 132,137 ****
--- 135,141 ----
  	case S9000_ID_TOMCAT:	    /* 2-Headed CRX */
  	case S9000_ID_TIMBER:	    /* Bushmaster (710) Graphics */
  	case S9000_ID_A1439A:	    /* CRX24 (24-plane Color) */
+ 	case S9000_ID_ARTIST:	    /* 712 (8-plane Color) Graphics */
  
  	    return_value = ngleScreenInit;
  	    break;
*** /tmp/da16998	Sun Jun  5 18:27:30 1994
--- xc/programs/Xserver/hw/hp/hpInit.c	Sun Jun  5 18:27:29 1994
***************
*** 1,4 ****
! /* $XConsortium: hpInit.c,v 1.3 93/10/07 10:21:22 rws Exp $ */
  /*************************************************************************
   * 
   * (c)Copyright 1992 Hewlett-Packard Co.,  All Rights Reserved.
--- 1,4 ----
! /* $XConsortium: hpInit.c,v 1.4 94/05/28 15:39:14 dpw Exp $ */
  /*************************************************************************
   * 
   * (c)Copyright 1992 Hewlett-Packard Co.,  All Rights Reserved.
***************
*** 43,49 ****
--- 43,53 ----
  #include "XHPproto.h"
  
  #ifndef LIBDIR
+ #if OSMAJORVERSION >= 10
+ #define LIBDIR "/etc/X11"
+ #else
  #define LIBDIR "/usr/lib/X11"
+ #endif
  #endif
  
  extern char    		*display;	/* display number as a string */
*** /tmp/da17019	Sun Jun  5 18:27:32 1994
--- xc/programs/Xserver/hw/hp/input/Imakefile	Sun Jun  5 18:27:31 1994
***************
*** 1,6 ****
! XCOMM $XConsortium: Imakefile,v 1.4 93/09/06 15:25:54 rws Exp $
  #include <Server.tmpl>
  
  #if defined(HPArchitecture) || defined(HPOSFArchitecture)
  
  SRCS1 =	\
--- 1,10 ----
! XCOMM $XConsortium: Imakefile,v 1.5 94/05/28 15:50:16 dpw Exp $
  #include <Server.tmpl>
  
+ #define IHaveSubdirs
+ 
+ SUBDIRS=drivers
+ 
  #if defined(HPArchitecture) || defined(HPOSFArchitecture)
  
  SRCS1 =	\
***************
*** 80,91 ****
  	xtest1imp.ln	\
  	getkeysym.ln
  
!    DEFINES = ExtensionOSDefines
     INCLUDES = -I. -I.. -I../include -I../../../include -I./X11 \
  	      -I../../../cfb -I../../../mfb -I../../../mi \
! 	      -I$(INCLUDESRC) -I$(EXTINCSRC)
     LINTLIBS = ../../../dix/llib-ldix.ln ../../../os/hpux/llib-los.ln
  
  NormalLibraryObjectRule()
  NormalLibraryTarget(hp,$(OBJS))
  
--- 84,101 ----
  	xtest1imp.ln	\
  	getkeysym.ln
  
!    DEFINES = ExtensionOSDefines -DOSMAJORVERSION=OSMajorVersion
!    LIB_DEFINES = -DLIBDIR=\"$(LIBDIR)\"
     INCLUDES = -I. -I.. -I../include -I../../../include -I./X11 \
  	      -I../../../cfb -I../../../mfb -I../../../mi \
! 	      -I$(INCLUDESRC) -I$(EXTINCSRC) -I./drivers
     LINTLIBS = ../../../dix/llib-ldix.ln ../../../os/hpux/llib-los.ln
  
+ all::
+ 
+ MakeSubdirs($(SUBDIRS))
+ DependSubdirs($(SUBDIRS))
+ 
  NormalLibraryObjectRule()
  NormalLibraryTarget(hp,$(OBJS))
  
***************
*** 98,103 ****
--- 108,115 ----
  NormalLibraryTarget(hp800,$(OBJS800))
  #endif
  
+ SpecialCObjectRule(x_hilinit,$(ICONFIGFILES),$(LIB_DEFINES))
+ SpecialCObjectRule(getkeysym,$(ICONFIGFILES),$(LIB_DEFINES))
  DependTarget()
  
  LintLibraryTarget(hp,$(SRCS1))
*** /dev/null	Sun Jun  5 17:11:28 1994
--- xc/programs/Xserver/hw/hp/input/drivers/Imakefile	Sun Jun  5 18:27:33 1994
***************
*** 0 ****
--- 1,31 ----
+ XCOMM $XConsortium: Imakefile,v 1.3 94/05/30 17:18:11 rws Exp $
+ 
+ #include <Server.tmpl>
+ 
+ .c.o:
+ 	$(RM) $@
+ 	$(CC) -c $(CFLAGS) $(PICFLAGS) $*.c
+ 
+ DRVRLIBDIR = $(LIBDIR)/extensions
+ PICFLAGS = +z
+ SRCS = hp7lc2k.c hp7lc2m.c
+ 
+ #define DriverTarget(name)						@@\
+ AllTarget(name.sl)							@@\
+ 									@@\
+ name.sl:  name.o							@@\
+ 	$(RM) $@~							@@\
+ 	$(LD) -o $@~ -b name.o						@@\
+ 	chmod a-w $@~							@@\
+ 	$(RM) $@ 							@@\
+ 	$(MV) $@~ $@							@@\
+ 									@@\
+ InstallTarget(install,name.sl,$(INSTPGMFLAGS),$(DRVRLIBDIR))		@@\
+ 									@@\
+ clean::									@@\
+ 	$(RM) name.sl
+ 
+ DriverTarget(hp7lc2k)
+ DriverTarget(hp7lc2m)
+ 
+ DependTarget()
*** /dev/null	Sun Jun  5 17:11:28 1994
--- xc/programs/Xserver/hw/hp/input/drivers/hp7lc2k.c	Sun Jun  5 18:27:35 1994
***************
*** 0 ****
--- 1,450 ----
+ /* $XConsortium: hp7lc2k.c,v 1.1 94/05/28 14:32:42 dpw Exp $ */
+ /************************************************************
+ 
+ Copyright (c) 1993 by Hewlett-Packard Company, Palo Alto, California
+ 
+ 			All Rights Reserved
+ 
+ Permission to use, copy, modify, and distribute this software and its
+ documentation for any purpose and without fee is hereby granted,
+ provided that the above copyright notice appear in all copies and that
+ both that copyright notice and this permission notice appear in
+ supporting documentation, and that the name of Hewlett-Packard not be
+ used in advertising or publicity pertaining to distribution of the
+ software without specific, written prior permission.
+ 
+ HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+ HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+ WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ SOFTWARE.
+ 
+ ********************************************************/
+ 
+ #include <stdio.h>
+ #include <errno.h>
+ #include <fcntl.h>
+ #include "ps2io.h"
+ #include <X11/X.h>
+ #include <X11/extensions/XI.h>
+ #include "x_serialdrv.h"
+ 
+ /**************************************************************************
+  *
+  * hp7lc2k.c - X server input device driver.
+  *
+  * This driver provides support for PS2 keyboards attached to an HP9000700LC2
+  * via the internal mini-DIN interface.
+  *
+  * The HP-UX 9.03 operating system is required by this driver.
+  *
+  * If another device is used as the X keyboard, the PS2 keyboard attached to
+  * the mini-DIN interface can be accessed via the X input device extension
+  * by adding the following lines to the /usr/lib/X11/X0devices file:
+  *
+  * Begin_Device_Description
+  * Name	hp7lc2k.sl     		# PS2 DIN keyboard via mini-DIN interface
+  * Use	Extension		# access via input extension
+  * Path	/dev/ps2kbd		# use device special file /dev/ps2kbd
+  * End_Device_Description
+  *
+  * For documentation on using serial input devices with X, please refer
+  * to the manual "Using the X Window System", Chapter 3 "Preliminary
+  * Configuration", in the section titled "Using Special Input Devices".
+  *
+  * Sample entries for the /usr/lib/X11/X*devices file can be found in 
+  * /etc/newconfig/X0devices.
+  *
+  */ 
+ 
+ #define	BUFRSIZ	2048
+ #define READSIZ 2000
+ 
+ static int hp7lc2k_left=READSIZ, hp7lc2k_datacnt=0;
+ static unsigned char hp7lc2k_buf[BUFRSIZ];
+ static unsigned char *hp7lc2k_data_ptr = hp7lc2k_buf;
+ typedef struct ps2_4  ps2_buffer_t;
+ 
+ /**************************************************************************
+  *
+  * Configure the PS/2 keyboard. Use scancode set 3, Turn indicator LEDs
+  * off, set all keys to typematic make/break, and set autorepeat to ~30/sec
+  * and delay to 250 mSec.
+  */
+ 
+ #ifdef _NO_PROTO
+ static int
+ keybd_configure (fd)
+     int fd;
+ #else
+ static int
+ keybd_configure (
+     int fd)
+ #endif
+     {
+     ps2_buffer_t kbdbuf;
+ 
+     /* use scancode set 3 */
+ 
+     kbdbuf.b[0] = SCANCODE_3;
+     ioctl (fd, PS2_SCANCODE, &kbdbuf);
+ 
+     /* turn LEDs off */
+ 
+     kbdbuf.b[0] = 0;
+     ioctl (fd, PS2_INDICATORS, &kbdbuf);
+ 
+     /* set all keys to typematic and make/break  */
+ 
+     ioctl (fd, PS2_ALL_TMAT_MKBRK, &kbdbuf);
+ 
+     /* set the autorepeat rate to the maximum (~30/sec) and the delay to the
+        minimum (250ms) */
+ 
+     kbdbuf.b[0] = 0x00;
+     ioctl (fd, PS2_RATEDELAY, &kbdbuf);
+ 
+     } /* end keybd_configure() */
+ 
+ /**************************************************************************
+  *
+  * This routine is called by the X server to open and configure the device.
+  * It is passed a pointer to an HPDeviceHeader struct (defined in 
+  * x_serialdrv.h).  That struct points to the path name of the device file
+  * to which the input device is connected.  The path is specified in the
+  * X*devices configuration file described above.
+  *
+  * This routine must open the device file and configure the serial port.
+  * It must initialize fields in the HPInputDeviceHeader struct including
+  * the device file descriptor, name by which the device will be known to
+  * X, the number of keys, buttons, and axes on the device, the keymap name
+  * and file, if the device has keys, and a flags field that specifies the
+  * size of the data returned by the device.  See the serial input device
+  * specification described above for more details.
+  *
+  */
+ 
+ #ifdef _NO_PROTO
+ static int
+ hp7lc2kconfigure (d)
+     HPInputDeviceHeader *d;
+ #else
+ static int
+ hp7lc2kconfigure (
+     HPInputDeviceHeader *d)
+ #endif
+     {
+     int ret;
+     ps2_buffer_t kbdbuf;
+     static unsigned char num_leds=3;
+     static char hp7lc2k_namebuf[128];
+     FILE *fp;
+ 
+     d->file_ds = open (d->path, O_RDWR | O_NDELAY);/* non-block read */
+     if (d->file_ds < 0) 
+ 	return(INIT_FAILURE);
+ 
+     keybd_configure (d->file_ds);
+ 
+     /* get the keyboard nationality, or default to US_English */
+ 
+     d->keymap_name = "PS2_DIN_US_English"; /* default keymap name     */
+     fp = fopen (X_KEYMAP_NAME, "r");	 /* defined by x_serialdrv.h  */
+     if (fp && fscanf (fp, "%s", hp7lc2k_namebuf))
+ 	d->keymap_name = hp7lc2k_namebuf;/* international keymap name */
+     fclose(fp);
+ 
+     d->x_name = "PS2_DIN_KEYBOARD";  	 /* device name for X server*/
+     d->keymap_file = "";	 	 /* keymap file for X server*/
+     d->flags = DATA_IS_16_BITS;          /* size of data for device */
+     d->num_keys = 101;	                 /* tell server we have keys*/
+     d->min_kcode = 0;	                 /* server gets from keymap */
+     d->max_kcode = 0;	                 /* server gets from keymap */
+     d->num_ledf = 1;	                 /* number of led feedbacks */
+     d->ledf = &num_leds;	         /* number of leds          */
+     d->reset = 107;			 /* X server reset keycode  */
+     d->reset_mods = ShiftMask | ControlMask; /* X server reset modifiers*/
+ 
+     return (INIT_SUCCESS);
+     }
+ 
+ /**************************************************************************
+  *
+  * Get more data and crunch the buffer if we're getting near the end.
+  *
+  */
+ 
+ #ifdef _NO_PROTO
+ static int get_more_data(fd)
+     int fd;
+ #else
+ static int get_more_data(
+     int fd)
+ #endif
+     {
+     int count;
+ 
+     /* If we don't already have at least 1 byte of data, 
+      * we need to read some.  If we're getting near the end
+      * of the buffer, copy the leftover data to the beginning
+      * of the buffer.
+      */
+ 
+     if (hp7lc2k_data_ptr - hp7lc2k_buf > hp7lc2k_datacnt)
+ 	{
+ 	bcopy (hp7lc2k_data_ptr, hp7lc2k_buf, hp7lc2k_datacnt);
+ 	hp7lc2k_data_ptr = hp7lc2k_buf;
+ 	hp7lc2k_left = READSIZ - hp7lc2k_datacnt;
+ 	}
+     count = read (fd, hp7lc2k_data_ptr + hp7lc2k_datacnt, hp7lc2k_left);
+ 
+     if (count >0)
+ 	{
+         hp7lc2k_datacnt += count;
+         hp7lc2k_left -= count;
+ 	}
+ 
+     if (hp7lc2k_datacnt < 1)
+ 	return(READ_FAILURE);
+ 
+     return(READ_SUCCESS);
+     }
+ 
+ /**************************************************************************
+  *
+  * This entry point is called when the X server detects that there is data
+  * available to be read from the device.  This routine will be called
+  * repeatedly until it returns READ_FAILURE.  It is expected to return
+  * one "event" for each successful call.  An "event" is one key press or
+  * release, one button press or release, one change in axis data, or one
+  * change of proximity state.  One change in axis data can be reported
+  * along with a button or proximity change.
+  *
+  */
+ 
+ #ifdef _NO_PROTO
+ static int
+ hp7lc2kread (fd, data, data_type, pending)
+     int fd;
+     unsigned char *data, *data_type;
+     int *pending;
+ #else
+ static int
+ hp7lc2kread (
+     int fd, unsigned char *data, unsigned char *data_type, int *pending)
+ #endif
+     {
+     struct timeval timeout;
+     unsigned short code, keycode;
+     int count;
+ 
+     get_more_data(fd);
+     if (hp7lc2k_datacnt < 1)
+ 	 return(READ_FAILURE);
+ 
+     /* PS2 keyboards return 1-byte scancode for keypresses, and a 1 byte
+      * constant followed by that same scancode for keyreleases.
+      * The X server expects key releases to have the value of the 
+      * key press + 1, so we must multiply key codes by 2, and add 1 to the
+      * key releases.  
+      *
+      * The minimum key code returned by the kernel is 7, but the minimum
+      * expected by the keymap is 16.  Since the X server will also add 8 to 
+      * the keycode after dividing by 2, to avoid the codes reserved by X for 
+      * mouse buttons, we must add 1 before multiplying.
+      */
+     
+     if (*hp7lc2k_data_ptr == 0xF0) {	/* this is a key release */
+ 	if (hp7lc2k_datacnt == 1){	/* code hasn't arrived   */
+ 	    timeout.tv_sec = 0;
+ 	    timeout.tv_usec = 25000; 	/* wait interval */
+ 	    select(0, (int *)NULL, (int *)NULL, (int *)NULL, &timeout);
+ 	    get_more_data(fd);
+ 	    if (hp7lc2k_datacnt < 1)
+ 		return(READ_FAILURE);
+ 	    }
+ 	code = *(hp7lc2k_data_ptr+1);  /* keycode is second byte  */
+ 	keycode = (code + 1) * 2 + 1;  /* add 1, double it, add 1 */
+ 	hp7lc2k_datacnt-=2;
+ 	hp7lc2k_data_ptr+=2;
+     }
+     else {
+ 	code = *hp7lc2k_data_ptr;
+ 	keycode = (code + 1) * 2; 	/* add 1, double it   */
+ 	hp7lc2k_datacnt-=1;
+ 	hp7lc2k_data_ptr+=1;
+     }
+     
+     if (code == 0xAA) {			/* keyboard has reset itself */
+ 	keybd_configure (fd);		/* reconfigure the keyboard  */
+ 	hp7lc2k_datacnt=0;		/* reset the data count      */
+ 	hp7lc2k_data_ptr = hp7lc2k_buf; /* reset the data pointer    */
+         return(READ_FAILURE);
+     }
+     *data++ = keycode;
+     *data = keycode >> 8;
+     *data_type = KEY_DATA;                /* tell X it's key data */
+     *pending = 2;                        /* two bytes are returned */
+     return(READ_SUCCESS);
+     }
+ 
+ /**************************************************************************
+  *
+  * This routine is called by the X server to write to the keyboard.
+  * It is called when an X request is made that causes a write to an input 
+  * device.
+  *
+  * See the file x_serialdrv.h for the format of the data for each request.
+  *
+  * The only one we will support is _XChangeFeedbackControl, which is used
+  * to turn on LEDs.
+  *
+  */
+ 
+ #ifdef _NO_PROTO
+ static int
+ hp7lc2kwrite (fd, request, data)
+     int fd, request;
+     char *data;
+ #else
+ static int
+ hp7lc2kwrite (
+     int fd, int request, char *data)
+ #endif
+     {
+     int i;
+     HPKeyboardFeedbackControl *ctrl;
+     ps2_buffer_t kbdbuf;
+ 
+     switch (request)
+ 	{
+ 	case _XChangeFeedbackControl:
+ 	    ctrl = (HPKeyboardFeedbackControl *) data;
+ 
+ 	    if (ctrl->class != KbdFeedbackClass)
+ 		return(WRITE_FAILURE);
+ 	    kbdbuf.b[0] = 0;
+ 	    if (ctrl->leds & SCROLLLOCK_LED) {
+ 		kbdbuf.b[0] |= SCROLL_LED;
+ 		}
+ 	    if (ctrl->leds & NUMLOCK_LED) {
+ 		kbdbuf.b[0] |= NUM_LED;
+ 		}
+ 	    if (ctrl->leds & CAPSLOCK_LED) { 
+ 		kbdbuf.b[0] |= CAPS_LED;
+ 		}
+ 	    ioctl (fd, PS2_INDICATORS, &kbdbuf);
+ 
+ 	    if (ctrl->autoRepeat == AutoRepeatModeOff)
+ 		ioctl (fd, PS2_ALL_MKBRK, &kbdbuf);
+ 	    else
+ 		ioctl (fd, PS2_ALL_TMAT_MKBRK, &kbdbuf);
+ 	    break;
+ 	case _XSetDeviceValuators:
+ 	case _XChangeDeviceControl:
+ 	case _XSetDeviceMode:
+ 	default:
+ 		return(WRITE_FAILURE);
+ 	    break;
+ 	}
+     return(WRITE_SUCCESS);
+     }
+ 
+ /**************************************************************************
+  *
+  * This routine is called by the X server to close an input device.
+  *
+  */
+ 
+ #ifdef _NO_PROTO
+ static int
+ hp7lc2kclose (fd)
+     int fd;
+ #else
+ static int
+ hp7lc2kclose (
+     int fd)
+ #endif
+     {
+     close (fd);
+     return (CLOSE_SUCCESS);
+     }
+ 
+ /**************************************************************************
+  *
+  * This routine is called to initialize the entry point vector for this
+  * serial input device driver.
+  *
+  */
+ 
+ #ifdef _NO_PROTO
+ int
+ hp7lc2k_Init(serialproc)                     /* default entry point name */
+     SerialProcs *serialproc;
+ #else
+ int
+ hp7lc2k_Init(
+     SerialProcs *serialproc)
+ #endif
+     {
+     serialproc->configure = hp7lc2kconfigure;/* routine to init device   */
+     serialproc->read = hp7lc2kread;          /* routine to read from dev */
+     serialproc->write = hp7lc2kwrite;        /* routine to write to dev  */
+     serialproc->close = hp7lc2kclose;        /* routine to close device  */
+     return INIT_SUCCESS;                  /* indicate success         */
+     }
+ 
+ #ifdef DEBUG
+ main()
+     {
+     int fd;
+ 
+     makedata();				/* make the test data	*/
+     fd = open ("data", O_RDWR);
+     process_test_data(fd);
+     close(fd);
+     }
+ 
+ /* The PS2 keyboard returns one byte per key press and two bytes per key release.
+  * The keycode is the same in each case.
+  *
+  * Byte 0:
+  *		scancode for key press, 0xF0 for key release.
+  * Byte 1:
+  *		scancode for key release.
+  */
+ 
+ makedata ()
+     {
+     int i, fd;
+     unsigned char buf[3];
+ 
+     fd = creat("data", 0777);
+     for (i=7; i<256; i++)
+ 	{
+ 	buf[0]=i;
+ 	buf[1]=0xF0;
+ 	buf[2]=i;
+ 	write (fd,buf,3);
+ 	}
+     close(fd);
+     }
+ 
+ process_test_data(fd)
+     {
+     unsigned char data[32], data_type;
+     int pending;
+ 
+     hp7lc2kread (fd, data, &data_type, &pending);
+     while (pending > 0)
+ 	{
+ 	printf ("%d bytes returned, type is %x, data is %x %x\n", pending, data_type, 
+ 	    data[0], data[1]);
+ 	pending = 0;
+ 	data[0] = data[1] = 0;
+         hp7lc2kread (fd, data, &data_type, &pending);
+ 	}
+     }
+ #endif /* DEBUG */
*** /dev/null	Sun Jun  5 17:11:28 1994
--- xc/programs/Xserver/hw/hp/input/drivers/hp7lc2m.c	Sun Jun  5 18:27:37 1994
***************
*** 0 ****
--- 1,987 ----
+ /* $XConsortium: hp7lc2m.c,v 1.1 94/05/28 14:32:48 dpw Exp $ */
+ /************************************************************
+ 
+ Copyright (c) 1992 by Hewlett-Packard Company, Palo Alto, California
+ 
+ 			All Rights Reserved
+ 
+ Permission to use, copy, modify, and distribute this software and its
+ documentation for any purpose and without fee is hereby granted,
+ provided that the above copyright notice appear in all copies and that
+ both that copyright notice and this permission notice appear in
+ supporting documentation, and that the name of Hewlett-Packard not be
+ used in advertising or publicity pertaining to distribution of the
+ software without specific, written prior permission.
+ 
+ HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+ HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+ WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ SOFTWARE.
+ 
+ ********************************************************/
+ 
+ #include <stdio.h>
+ #include <errno.h>
+ #include <fcntl.h>
+ #include "ps2io.h"
+ #include <X11/extensions/XI.h>
+ #include "x_serialdrv.h"
+ 
+ /**************************************************************************
+  *
+  * hp7lc2m.c - X server input device driver.
+  *
+  * This driver provides support for PS2 mice attached to an HP9000700LC2
+  * via the internal mini-DIN interface.
+  *
+  * The HP-UX 9.03 operating system is required by this driver.
+  *
+  * If another device is used as the X pointer, the PS2 mouse attached to
+  * the mini-DIN interface can be accessed via the X input device extension
+  * by adding the following lines to the /usr/lib/X11/X0devices file:
+  *
+  * Begin_Device_Description
+  * Name	hp7lc2m.sl     		# PS2 DIN keyboard via mini-DIN interface
+  * Use	Extension		# access via input extension
+  * Path	/dev/ps2mouse		# use device special file /dev/ps2mouse
+  * End_Device_Description
+  *
+  * For documentation on using serial input devices with X, please refer
+  * to the manual "Using the X Window System", Chapter 3 "Preliminary
+  * Configuration", in the section titled "Using Special Input Devices".
+  *
+  * Sample entries for the /usr/lib/X11/X*devices file can be found in 
+  * /etc/newconfig/X0devices.
+  *
+  */ 
+ 
+ #define	BUFRSIZ	2048
+ #define READSIZ 2000
+ #define PKT_SIZ 3
+ #define BUTTON1_AND_2	0x05
+ #define BUTTON2_AND_3	0x06
+ #define BUTTON1_AND_3	0x03
+ #define BUTTON_BITS	0x07
+ #define ONE_BUTTON_DOWN	 -1
+ #define ILLEGAL_COMBO  	 -2
+ 
+ static int hp7lc2m_left=READSIZ, hp7lc2m_datacnt=0;
+ static unsigned char hp7lc2m_buf[BUFRSIZ];
+ static unsigned char *hp7lc2m_data_ptr = hp7lc2m_buf;
+ static unsigned int hp7lc2m_buttonmask;
+ static unsigned int hp7lc2m_chording_button = 0;
+ static unsigned int hp7lc2m_chording_interval = 0;
+ static int process_button(), do_button_chording(), get_more_data(), check_combo ();
+ typedef struct ps2_4 ps2_buffer_t;
+ 
+ /**************************************************************************
+  *
+  * This routine is called by the X server to open and configure the device.
+  * It is passed a pointer to an HPDeviceHeader struct (defined in 
+  * x_serialdrv.h).  That struct points to the path name of the device file
+  * to which the input device is connected.  The path is specified in the
+  * X*devices configuration file described above.
+  *
+  * This routine must open the device file and configure the serial port.
+  * It must initialize fields in the HPInputDeviceHeader struct including
+  * the device file descriptor, name by which the device will be known to
+  * X, the number of keys, buttons, and axes on the device, the keymap name
+  * and file, if the device has keys, and a flags field that specifies the
+  * size of the data returned by the device.  See the serial input device
+  * specification described above for more details.
+  *
+  */
+ 
+ #ifdef _NO_PROTO
+ static int
+ hp7lc2mconfigure (d)
+     HPInputDeviceHeader *d;
+ #else
+ static int
+ hp7lc2mconfigure (
+     HPInputDeviceHeader *d)
+ #endif
+     {
+     int ret;
+     ps2_buffer_t mousebuf;
+ 
+     d->file_ds = open (d->path, O_RDWR | O_NDELAY);/* non-block read */
+     if (d->file_ds < 0) 
+ 	return(INIT_FAILURE);
+ 
+     if (d->button_chording)
+ 	hp7lc2m_chording_interval = d->button_chording;
+ 
+     /* set the sample rate to 100 reports/second max */
+ 
+     ioctl (d->file_ds, PS2_DISABLE);
+     ioctl (d->file_ds, PS2_RESET);
+     mousebuf.b[0] = SAMPLE_60;
+     ioctl (d->file_ds, PS2_SAMPLERATE, &mousebuf);
+ 
+     /* put the mouse into stream mode  */
+ 
+     mousebuf.b[0] = 0;
+     ioctl (d->file_ds, PS2_STREAMMODE, &mousebuf);
+ 
+     /* set the mouse resolution to 8 counts/mm */
+ 
+     mousebuf.b[0] = RES_4;
+     ioctl (d->file_ds, PS2_RESOLUTION, &mousebuf);
+     ioctl (d->file_ds, PS2_ENABLE);
+ 
+     d->x_name = "PS2_DIN_MOUSE";  	/* device name for X server*/
+     d->flags = DATA_IS_8_BITS;         	/* size of data for device */
+     d->ax_num = 2;			/* two axes of motion      */
+     if (d->button_chording)
+ 	d->num_buttons = 5;		/* emulate 5 buttons       */
+     else
+ 	d->num_buttons = 3;		/* support 3 buttons       */
+     d->num_keys =0;     		/* no keys                 */
+     d->resolution = 80;			/* resolution in counts/cm */
+     d->max_x = 255;        		/* maximum x value in counts */
+     d->max_y = 255;			/* maximum y value in counts */
+ 
+     return (INIT_SUCCESS);
+     }
+ 
+ /**************************************************************************
+  *
+  * This entry point is called when the X server detects that there is data
+  * available to be read from the device.  This routine will be called
+  * repeatedly until it returns READ_FAILURE.  It is expected to return
+  * one "event" for each successful call.  An "event" is one key press or
+  * release, one button press or release, one change in axis data, or one
+  * change of proximity state.  One change in axis data can be reported
+  * along with a button or proximity change.
+  *
+  */
+ 
+ #ifdef _NO_PROTO
+ static int
+ hp7lc2mread (fd, data, data_type, pending)
+     int fd, *pending;
+     unsigned char *data, *data_type;
+ #else
+ static int
+ hp7lc2mread (
+     int fd, unsigned char *data, unsigned char *data_type, int *pending)
+ #endif
+     {
+     int button, data_read=0;
+     unsigned int buttonmask;
+     int count, x, y;
+ 
+     /* If we don't already have at least PKT_SIZ bytes of data, 
+      * we need to read some.  If we're getting near the end
+      * of the buffer, copy the leftover data to the beginning
+      * of the buffer.
+      */
+ 
+     if (hp7lc2m_datacnt < PKT_SIZ && (get_more_data (fd) == READ_FAILURE))
+ 	 return(READ_FAILURE);
+ 
+     /* The PS2 mouse returns PKT_SIZ bytes for each movement of the mouse or
+      * button press or release.  The format of the bytes is as follows:
+      *
+      * Byte 0:
+      * 		Bit 7	Y data overflow		(1 = overflow)
+      * 		Bit 6	X data overflow		(1 = overflow)
+      * 		Bit 5	Y data sign		(1 = negative)
+      * 		Bit 4	X data sign		(1 = negative)
+      * 		Bit 3	Not used		(always 1)
+      * 		Bit 2	Center button		(1 = depressed)
+      * 		Bit 1	Right button		(1 = depressed)
+      * 		Bit 0	Left button		(1 = depressed)
+      * Byte 1:
+      *		X coordinate data byte		(2's compliment)
+      * Byte 2:
+      *		Y coordinate data byte		(2's compliment)
+      */
+     
+     x = (int) hp7lc2m_data_ptr[1];
+     y = -((int) hp7lc2m_data_ptr[2]);
+ 
+     if (x!=0 || y != 0) {
+ 	*data_type |= MOTION_DATA;
+ 	data[0] = x;
+ 	data[1] = y;
+ 	data_read = 2;
+         hp7lc2m_data_ptr[1] = 0;	/* clear motion for reprocessing case */
+         hp7lc2m_data_ptr[2] = 0;	/* clear data for reprocessing case */
+ 	}
+ 
+     /* Check to see if a button has changed state */
+ 	buttonmask = (u_char) (hp7lc2m_data_ptr[0] & BUTTON_BITS);
+ 	if (buttonmask != hp7lc2m_buttonmask) {
+ 	    if (hp7lc2m_chording_interval) {
+ 		if ((button = do_button_chording(fd, &buttonmask))>=0) {
+ 		    *data_type |= BUTTON_DATA;
+ 		    data[data_read++] = button;
+ 		}
+ 	    }
+ 	    else {
+ 		button = process_button(buttonmask);
+ 		*data_type |= BUTTON_DATA;
+ 		data[data_read++] = button;
+ 	    }
+ 	}
+     if (hp7lc2m_buttonmask == buttonmask)  /* no leftover buttons */
+ 	{
+         hp7lc2m_datacnt -= PKT_SIZ;
+         hp7lc2m_data_ptr += PKT_SIZ;
+ 	}
+     *pending += data_read;
+     return(READ_SUCCESS);
+     }
+ 
+ /**************************************************************************
+  *
+  * Process a button from the current data packet.
+  *
+  */
+ 
+ #define hp7lc2_BUTTON1	0x01
+ #define hp7lc2_BUTTON2	0x04
+ #define hp7lc2_BUTTON3	0x02
+ #define NUM_BUTTONS	3
+ 
+ #ifdef _NO_PROTO
+ static int process_button(buttonmask)
+     unsigned int buttonmask;
+ #else
+ static int process_button(
+     unsigned int buttonmask)
+ #endif
+     {
+     int i, button, bit, down, up;
+ 
+     button = 1;
+     up = ~buttonmask & hp7lc2m_buttonmask;
+     for (i=0; i<NUM_BUTTONS; i++)
+ 	{
+ 	bit = (1 << i);
+ 	if (bit & up)
+ 	    {
+ 	    switch (bit)
+ 		{
+ 	        case hp7lc2_BUTTON3:
+ 		    button += 2;
+ 	        case hp7lc2_BUTTON2:
+ 		    button += 2;
+ 		    break;
+ 		}
+ 	    hp7lc2m_buttonmask = (hp7lc2m_buttonmask & ~bit);
+             return(button);
+ 	    }
+ 	}
+ 
+     down = buttonmask & ~hp7lc2m_buttonmask;
+     button = 0;
+     for (i=0; i<NUM_BUTTONS; i++)
+ 	{
+ 	bit = (1 << i);
+ 	if (bit & down)
+ 	    {
+ 	    switch (bit)
+ 		{
+ 	        case hp7lc2_BUTTON3:
+ 		    button += 2;
+ 	        case hp7lc2_BUTTON2:
+ 		    button += 2;
+ 		    break;
+ 		}
+ 	    hp7lc2m_buttonmask = (hp7lc2m_buttonmask | bit);
+             return(button);
+ 	    }
+ 	}
+     }
+ 
+ /**************************************************************************
+  *
+  * Get more data and crunch the buffer if we're getting near the end.
+  *
+  */
+ 
+ #ifdef _NO_PROTO
+ static int get_more_data(fd)
+     int fd;
+ #else
+ static int get_more_data(
+     int fd)
+ #endif
+     {
+     int count;
+ 
+     if (hp7lc2m_data_ptr - hp7lc2m_buf > hp7lc2m_datacnt)
+ 	{
+ 	bcopy (hp7lc2m_data_ptr, hp7lc2m_buf, hp7lc2m_datacnt);
+ 	hp7lc2m_data_ptr = hp7lc2m_buf;
+ 	hp7lc2m_left = READSIZ - hp7lc2m_datacnt;
+ 	}
+     count = read (fd, hp7lc2m_data_ptr + hp7lc2m_datacnt, hp7lc2m_left);
+ 
+     if (count >0)
+ 	{
+         hp7lc2m_datacnt += count;
+         hp7lc2m_left -= count;
+ 	}
+ 
+     if (hp7lc2m_datacnt < PKT_SIZ)
+ 	return(READ_FAILURE);
+ 
+     return(READ_SUCCESS);
+     }
+ 
+ /**************************************************************************
+  *
+  * Handle button chording.
+  *
+  */
+ 
+ #define BUTTON1_DOWN 0
+ #define BUTTON1_UP   1
+ #define BUTTON2_DOWN 2
+ #define BUTTON2_UP   3
+ #define BUTTON3_DOWN 4
+ #define BUTTON3_UP   5
+ #define BUTTON4_DOWN 6
+ #define BUTTON4_UP   7
+ #define BUTTON5_DOWN 8
+ #define BUTTON5_UP   9
+ 
+ int ignore1, ignore2, ignorecnt;
+ 
+ #ifdef _NO_PROTO
+ static int  do_button_chording(fd, buttonmask)
+     int fd;
+     unsigned int *buttonmask;
+ #else
+ static int  do_button_chording(
+     int fd,
+     unsigned int *buttonmask)
+ #endif
+     {
+     int button, ret;
+     unsigned char *tptr;
+     unsigned int tmask;
+     struct timeval timeout;
+ 
+     if (hp7lc2m_chording_button)	/* waiting for chorded button up */
+ 	{
+         button = process_button(*buttonmask); /* process one button       */
+ 	if (button % 2)			/* odd number means  button up   */
+ 	    if (button == ignore1)      /* up transition of chorded pair */
+ 		{
+ 		ignore1= -1; ignorecnt--; /* dont ignore it next time    */
+ 		if (ignorecnt == 0)		/* done ignoring buttons */
+ 	    	    {
+ 	    	    button = hp7lc2m_chording_button; /* send chorded up */
+ 	    	    hp7lc2m_chording_button = 0; /* clear saved button   */
+ 	    	    return(button);      /* return chorded button        */
+ 	    	    }
+ 		else
+ 		    return(-1);		 /* we ignored this one          */
+ 		}
+ 	    else if (button == ignore2)  /* other button of chorded pair */
+ 		{
+ 		ignore2= -1; ignorecnt--;/* dont ignore it next time     */
+ 		if (ignorecnt == 0)	 /* done ignoring buttons        */
+ 	    	    {
+ 	    	    button = hp7lc2m_chording_button; /* send chorded up */
+ 	    	    hp7lc2m_chording_button = 0; /* clear saved button   */
+ 	    	    return(button);      /* return chorded button        */
+ 	    	    }
+ 		else
+ 		    return(-1);		 /* we ignored this one          */
+ 		}
+ 	    else
+ 		return(button);		/* not a button to ignore        */
+ 	else
+ 	    return(button);		/* button down - dont ignore     */
+ 	}
+     else if (hp7lc2m_buttonmask==0)	/* check if chording necessary   */
+ 	{
+ 	ret = check_combo (*buttonmask);
+ 	if (ret == ILLEGAL_COMBO)	/* illegal combination		 */
+ 	    return (process_button(*buttonmask)); /* process a button    */
+ 	else if (ret != ONE_BUTTON_DOWN)/* we already chorded 		 */
+ 	    return (ret); 		/* return chorded button 	 */
+ 
+ 	timeout.tv_sec = 0;
+ 	timeout.tv_usec = hp7lc2m_chording_interval * 1000; /* wait interval */
+ 	select(0, (int *)NULL, (int *)NULL, (int *)NULL, &timeout);
+ 	get_more_data(fd);
+ 
+ 	for (tptr=hp7lc2m_data_ptr+PKT_SIZ; 
+ 	     tptr<hp7lc2m_data_ptr+hp7lc2m_datacnt;
+ 	     tptr +=PKT_SIZ)
+ 	    {
+ #ifdef DEBUG
+ 	    if (tptr > (hp7lc2m_data_ptr + (3 * PKT_SIZ)))
+ 		break;
+ #endif
+ 	    tmask = (u_char) (*tptr & BUTTON_BITS);
+ 	    if (tmask != *buttonmask)		/* a button changed    */
+ 		{
+ 		if (!(tmask & *buttonmask))	/* a button went up    */
+ 	    	    return (process_button(*buttonmask));
+ 		if ((ret = check_combo (tmask)) > 0)
+ 		    {
+ 		    if (tmask == hp7lc2m_buttonmask)
+ 			*buttonmask = hp7lc2m_buttonmask;
+ 	     	    hp7lc2m_datacnt -= (tptr - hp7lc2m_data_ptr);
+ 		    hp7lc2m_data_ptr = tptr;
+ 	    	    return (ret);
+ 		    }
+ 		else
+ 	    	    return (process_button(*buttonmask));
+ 		}
+ 	    }
+ 	return (process_button(*buttonmask));
+ 	}
+     else			/* can't chord - button already down   */
+ 	{
+ 	return (process_button(*buttonmask));
+ 	}
+     }
+ 
+ /**************************************************************************
+  *
+  * Check to see if the current data packet indicates more than one button
+  * is down.  If so, it is either a valid chording combingation or an
+  * illegal chording combination.  If valid, remember which buttons we
+  * need to ignore the first time they go up.  If invalid, we won't do
+  * button chording.  If only one button is down, we need more data.
+  */
+ 
+ #ifdef _NO_PROTO
+ static int check_combo (buttonmask)
+     int buttonmask;
+ #else
+ static int check_combo (
+     int buttonmask)
+ #endif
+     {				
+     if ((buttonmask & BUTTON1_AND_3) == BUTTON1_AND_3) /* illegal combo   */
+ 	return (ILLEGAL_COMBO);
+     else if ((buttonmask & BUTTON1_AND_2) == BUTTON1_AND_2)
+ 	{
+ 	process_button(buttonmask);		/* eat one button         */
+ 	process_button(buttonmask);		/* eat the other button   */
+         hp7lc2m_chording_button = BUTTON4_UP;   /* save for up transition */
+ 	ignore1 = BUTTON1_UP;			/* ignore each button up  */
+ 	ignore2 = BUTTON2_UP;
+ 	ignorecnt = 2;
+         return (BUTTON4_DOWN); 			/* send the chorded down  */
+ 	}
+     else if ((buttonmask & BUTTON2_AND_3) == BUTTON2_AND_3)
+ 	{
+ 	process_button(buttonmask);
+ 	process_button(buttonmask);
+         hp7lc2m_chording_button = BUTTON5_UP; 
+ 	ignore2 = BUTTON2_UP;
+ 	ignore1 = BUTTON3_UP;
+ 	ignorecnt = 2;
+         return (BUTTON5_DOWN); 
+ 	}
+     else
+         return (ONE_BUTTON_DOWN);	/* only one button - need more data */
+     }
+ 
+ /**************************************************************************
+  *
+  * This routine is called by the X server to write to the mouse.
+  * It is called when an X request is made that causes a write to an 
+  * input device.  No requests are supported here.
+  *
+  * See the file x_serialdrv.h for the format of the data for each request.
+  *
+  */
+ 
+ #ifdef _NO_PROTO
+ static int
+ hp7lc2mwrite (fd, request, data)
+     int fd, request;
+     char *data;
+ #else
+ static int
+ hp7lc2mwrite (
+     int fd, int request, char *data)
+ #endif
+     {
+     int i;
+     HPPointerFeedbackControl *ctrl;
+     ps2_buffer_t mousebuf;
+ 
+     switch (request)
+ 	{
+ 	case _XChangeFeedbackControl:
+ 	    ctrl = (HPPointerFeedbackControl *) data;
+ 
+ 	    if (ctrl->class != PtrFeedbackClass)
+ 		return(WRITE_FAILURE);
+ 	    break;
+ 	case _XSetDeviceValuators:
+ 	case _XChangeDeviceControl:
+ 	case _XSetDeviceMode:
+ 	default:
+ 		return(WRITE_FAILURE);
+ 	    break;
+ 	}
+     return(WRITE_SUCCESS);
+     }
+ 
+ /**************************************************************************
+  *
+  * This routine is called by the X server to close an input device.
+  *
+  */
+ 
+ #ifdef _NO_PROTO
+ static int
+ hp7lc2mclose (fd)
+     int fd;
+ #else
+ static int
+ hp7lc2mclose (
+     int fd)
+ #endif
+     {
+     close (fd);
+     return (CLOSE_SUCCESS);
+     }
+ 
+ /**************************************************************************
+  *
+  * This routine is called to initialize the entry point vector for this
+  * serial input device driver.
+  *
+  */
+ 
+ #ifdef _NO_PROTO
+ int
+ hp7lc2m_Init(serialproc)                     /* default entry point name */
+     SerialProcs *serialproc;
+ #else
+ int
+ hp7lc2m_Init(
+     SerialProcs *serialproc)
+ #endif
+     {
+     serialproc->configure = hp7lc2mconfigure;/* routine to init device   */
+     serialproc->read = hp7lc2mread;          /* routine to read from dev */
+     serialproc->write = hp7lc2mwrite;        /* routine to write to dev  */
+     serialproc->close = hp7lc2mclose;        /* routine to close device  */
+     return INIT_SUCCESS;                  /* indicate success         */
+     }
+ 
+ #ifdef DEBUG
+ char expected_button1[]= {
+ 0,1,0,2,1,3,0,2,3,1,0,2,1,3,0,4,5,1,0,4,1,5,0,4,2,1,5,3, /* test case 1 */
+ 4,5,4,2,5,3,4,2,3,5,4,2,5,3,4,2,3,5,4,0,2,5,1,3,         /* test case 2 */
+ 2,3,2,0,1,0,1,0,1,4,5,4,5,3,0,4,1,5,                     /* test case 3 */
+ 0,4,1,5,0,4,1,5,2,3,0,4,1,5,                             /* test case 4 */
+ 0,2,1,3,0,2,1,3,4,5,                                     /* test case 5 */
+ 4,2,5,3,4,2,5,3,                                         /* test case 6 */
+ 0,4,2,1,5,3,0,4,2,5,1,4,3,0,2,5,1,4,3,0,2,1,5,3,0,4,1,5, /* test case 7 */
+ 2,3,0,1,4,2,5,3,0,1,4,2,5,3,
+ 
+ 0,2,3,1,4,2,3,5,0,4,5,1,0,4,2,3,5,1,0,2,1,3,4,2,5,3,0,4, /* miscellaneous */
+ 2,1,5,3,0,2,1,4,3,0,1,5,2,3,4,2,0,1,0,1,0,1,5,3,0,1,4,2,
+ 5,3,0,1,4,2,5,3,2,3,0,4,1,5,4,5,0,2,1,3,4,5,0,1,2,3};
+ 
+ char expected_button2[]= {
+ 0,1,6,7,6,7,6,7,0,4,5,1,0,4,1,5,0,4,2,1,5,3,		 /* test case 1 */
+ 4,5,8,9,8,9,8,9,8,9,4,0,2,5,1,3,		         /* test case 2 */
+ 2,3,6,0,1,0,1,4,5,4,5,7,0,4,1,5,                         /* test case 3 */
+ 0,4,1,5,0,4,1,5,2,3,0,4,1,5,                             /* test case 4 */
+ 6,7,6,7,4,5,                                             /* test case 5 */
+ 8,9,8,9,                                                 /* test case 6 */
+ 0,4,2,1,5,3,0,4,2,5,1,4,3,0,2,5,1,4,3,0,2,1,5,3,0,4,1,5, /* test case 7 */
+ 2,3,0,1,8,9,0,1,8,9,
+ 
+ 6,7,8,9,0,4,5,1,0,4,2,3,5,1,6,7,8,9,0,4,2,1,5,3,6,4,7,0,/* miscellaneous */
+ 1,5,2,3,8,0,1,0,1,0,1,9,0,1,8,9,0,1,8,9,2,3,0,4,1,5,4,5,6,7,4,5,0,1,2,3};
+ 
+ char testdata[][3] = {
+ 			/* Case 1: left button goes down        */
+ 			/*              remains down            */
+ 			/*              goes up                 */
+ 			/*              becomes chorded         */
+ 			/*              becomes non-chordable   */
+ {0x08,1,1},		/* no buttons down    		        */
+ {0x08,1,1},		/* no buttons down    		        */
+ {0x09,1,1},		/* left button down	0	0       */
+ {0x09,1,1},		/* left button down		        */
+ {0x08,1,1},		/* no buttons down	1	1       */
+ 
+ {0x09,1,1},		/* left button down	0	        */
+ {0x09,1,1},		/* left button down	 	        */
+ {0x0d,1,1},		/* left and center    	2	6       */
+ {0x0d,1,1},		/* left and center    	 	        */
+ {0x08,1,1},		/* no buttons down	1	        */
+ 			/*                      3       7       */
+ {0x09,1,1},		/* left button down	0	        */
+ {0x0d,1,1},		/* left and center    	2	6       */
+ {0x09,1,1},		/* left button down	3	        */
+ {0x08,1,1},		/* no buttons down	1	7       */
+ {0x09,1,1},		/* left button down	0	        */
+ {0x0d,1,1},		/* left and center    	2	6       */
+ {0x0c,1,1},		/* center button down	1               */
+ {0x08,1,1},		/* no buttons down	3	7       */
+ {0x09,1,1},		/* left button down	0	        */
+ {0x0b,1,1},		/* left and right     	4	0       */
+ 			/*                              4       */
+ {0x09,1,1},		/* left button down	5	5       */
+ {0x08,1,1},		/* no buttons down	1	1       */
+ {0x09,1,1},		/* left button down	0	        */
+ {0x0b,1,1},		/* left and right     	4	0       */
+ 			/*                              4       */
+ {0x0a,1,1},		/* right button down 	1       1       */
+ {0x08,1,1},		/* no buttons down	5	5       */
+ {0x09,1,1},		/* left button down	0	        */
+ {0x0f,1,1},		/* all buttons        	4	0       */
+ 			/*                      2       4       */
+ 			/*                              2       */
+ {0x0e,1,1},		/* right and center   	1	1       */
+ {0x08,1,1},		/* no buttons down	5	5       */
+ 			/*                      3       3       */
+ 
+ 
+ 			/* Case 2: right button goes down       */
+ 			/*              remains down            */
+ 			/*              goes up                 */
+ 			/*              becomes chorded         */
+ 			/*              becomes non-chordable   */
+ {0x08,1,1},		/* no buttons down	 	        */
+ {0x08,1,1},		/* no buttons down	 	        */
+ {0x0a,1,1},		/* right button down	4	4       */
+ {0x0a,1,1},		/* right button down	 	        */
+ {0x08,1,1},		/* no buttons down	5	5       */
+ {0x0a,1,1},		/* right button down	4	        */
+ {0x0e,1,1},		/* right and center   	2	8       */
+ {0x0e,1,1},		/* right and center   	 	        */
+ {0x08,1,1},		/* no buttons down	5	        */
+ 			/*                      3       9       */
+ {0x0a,1,1},		/* right button down	4	        */
+ {0x0e,1,1},		/* right and center   	2	8       */
+ {0x0a,1,1},		/* right button down	3	        */
+ {0x08,1,1},		/* no buttons down	5	9       */
+ {0x0a,1,1},		/* right button down	4	        */
+ {0x0e,1,1},		/* right and center   	2	8       */
+ {0x0c,1,1},		/* center button down   5 	        */
+ {0x08,1,1},		/* no buttons down	3	9       */
+ {0x0a,1,1},		/* right button down	4	        */
+ {0x0e,1,1},		/* right and center   	2	8       */
+ {0x0a,1,1},		/* right button down	3	        */
+ {0x08,1,1},		/* no buttons down	5	9       */
+ {0x0a,1,1},		/* right button down	4	        */
+ {0x0f,1,1},		/* all buttons        	0	4       */
+ 			/*                      2       0       */
+ 			/*                              2       */
+ {0x0d,1,1},		/* left and center   	5	5       */
+ {0x08,1,1},		/* no buttons down	1	1       */
+ 			/*                      3       3       */
+ 
+ 
+ 			/* Case 3: center button goes down      */
+ 			/*              remains down            */
+ 			/*              goes up                 */
+ 			/*              becomes chorded         */
+ 			/*              becomes non-chordable   */
+ {0x0c,1,1},		/* center button down 	2	2       */
+ {0x0c,1,1},		/* center button down 		        */
+ {0x08,1,1},		/* no buttons down    	3	3       */
+ {0x0c,1,1},		/* center button down 	2	        */
+ {0x0d,1,1},		/* left and center    	0	6       */
+ {0x0d,1,1},		/* left and center    	 	        */
+ {0x0c,1,1},		/* center button down 	1	        */
+ {0x0d,1,1},		/* left and center    	0	0       */
+ {0x0c,1,1},		/* center button down 	1	1       */
+ {0x0d,1,1},		/* left and center    	0	0       */
+ {0x0e,1,1},		/* right and center   	1	1       */
+                         /*                      4       4       */
+ {0x0c,1,1},		/* center button down 	5	5       */
+ {0x0e,1,1},		/* right and center   	4	4       */
+ {0x08,1,1},		/* no buttons down    	5	5       */
+                         /*                      3       3       */
+ {0x0b,1,1},		/* left and right     	4	4       */
+                         /*                      0       0       */
+ {0x08,1,1},		/* no buttons down    	5	5       */
+                         /*                      1       1       */
+ 
+ 			/* Case 4: left and right go down       */
+ {0x0b,1,1},		/* left and right     	0	0       */
+                         /*                      4       4       */
+ {0x08,1,1},		/* no buttons down    	1	1       */
+                         /*                      5       5       */
+ {0x0b,1,1},		/* left and right     	0	0       */
+                         /*                      4       4       */
+ {0x0c,1,1},		/* center button down 	1	1       */
+                         /*                      5       5       */
+                         /*                      2       2       */
+ {0x0b,1,1},		/* left and right     	3	3       */
+                         /*                      0       0       */
+                         /*                      4       4       */
+ {0x08,1,1},		/* no buttons down    	1	1       */
+                         /*                      5       5       */
+ 
+ 			/* Case 5: left and center go down      */
+ {0x08,1,1},		/* no buttons down    	 	        */
+ {0x0d,1,1},		/* left and center    	0	        */
+                         /*                      2       6       */
+ {0x08,1,1},		/* no buttons down    	1	7       */
+                         /*                      3               */
+ {0x0d,1,1},		/* left and center    	0	6       */
+                         /*                      2               */
+ {0x0a,1,1},		/* right button down	1	7       */
+                         /*                      3       4       */
+                         /*                      4               */
+ {0x08,1,1},		/* no buttons down    	5	5       */
+ 
+ 
+ 
+ 			/* Case 6: right and center go down     */
+ {0x0e,1,1},		/* right and center   	4	        */
+                         /*                      2       8       */
+ {0x08,1,1},		/* no buttons down    	5	9       */
+                         /*                      3               */
+ {0x0e,1,1},		/* right and center   	4	8       */
+                         /*                      2               */
+ {0x08,1,1},		/* no buttons down    	5	9       */
+                         /*                      3               */
+ {0x08,1,1},		/* no buttons down    	 	        */
+ 
+ 
+ 			/* Case 7: all buttons go down          */
+ {0x0f,1,1},		/* all buttons        	0	0   	*/
+              		/*                    	4	4   	*/
+              		/*                    	2	2   	*/
+ {0x0f,1,1},		/* all buttons                          */ 
+ {0x08,1,1},		/* no buttons down    	1	1       */
+              		/*                    	5	5   	*/
+              		/*                    	3	3   	*/
+ {0x0f,1,1},		/* all buttons        	0	0   	*/
+              		/*                    	4	4   	*/
+              		/*                    	2	2   	*/
+ {0x0d,1,1},		/* left and center    	5	5   	*/
+ {0x0e,1,1},		/* right and center   	1	1   	*/
+                         /*                      4	4   	*/
+ {0x0b,1,1},		/* left and right     	3	3   	*/
+                         /*                      0	0   	*/
+ {0x0f,1,1},		/* all buttons        	2	2   	*/
+ {0x0d,1,1},		/* left and center    	5	5   	*/
+ {0x0e,1,1},		/* right and center   	1	1   	*/
+                         /*                      4	4   	*/
+ {0x0b,1,1},		/* left and right     	3	3   	*/
+                         /*                      0	0   	*/
+ {0x0f,1,1},		/* all buttons        	2	2   	*/
+ {0x0c,1,1},		/* center button down 	1	1   	*/
+                         /*                      5	5   	*/
+ {0x0b,1,1},		/* left and right     	3	3   	*/
+                         /*                      0	0   	*/
+                         /*                      4	4   	*/
+ {0x0c,1,1},		/* center button down 	1	1   	*/
+                         /*                      5	5   	*/
+                         /*                      2	2   	*/
+ {0x08,1,1},		/* no buttons down    	3	3   	*/
+ {0x09,1,1},		/* left button down   	0	    	*/
+ {0x0e,1,1},		/* right and center   	1	0   	*/
+                         /*                      4	1   	*/
+                         /*                      2	8   	*/
+ {0x09,1,1},		/* left button down   	5	    	*/
+                         /*                      3	9   	*/
+                         /*                      0	0   	*/
+ {0x0e,1,1},		/* right and center   	1	1   	*/
+                         /*                      4	    	*/
+                         /*                      2	8   	*/
+ {0x08,1,1},		/* no buttons down    	5	    	*/
+                         /*                      3	9   	*/
+ 
+ 
+ 			/* Case 8: miscellaneous tests          */
+ {0x09,1,1},		/* left button down   	0	    	*/
+ {0x0d,1,1},		/* left and center    	2	6   	*/
+ {0x09,1,1},		/* left button down   	3	    	*/
+ {0x08,1,1},		/* no buttons down    	1	7   	*/
+ 
+ {0x0a,1,1},		/* right button down  	4	    	*/
+ {0x0a,1,1},		/* right button down  		    	*/
+ {0x0e,1,1},		/* right and center   	2	8   	*/
+ {0x0a,1,1},		/* right button down    3	    	*/
+ {0x08,1,1},		/* no buttons down    	5	9   	*/
+ 
+ {0x09,1,1},		/* left button down   	0	0   	*/
+ {0x0b,1,1},		/* left and right     	4	4   	*/
+ {0x09,1,1},		/* left button down   	5	5   	*/
+ {0x08,1,1},		/* no buttons down    	1	1   	*/
+ 
+ {0x09,1,1},		/* left button down   	0	0   	*/
+ {0x0b,1,1},		/* left and right     	4	4   	*/
+ {0x0f,1,1},		/* all buttons        	2	2   	*/
+ {0x0b,1,1},		/* left and right     	3	3   	*/
+ {0x09,1,1},		/* left button down   	5	5   	*/
+ {0x08,1,1},		/* no buttons down    	1	1   	*/
+ 
+ {0x09,1,1},		/* left button down   	0	    	*/
+ {0x09,1,1},		/* left button down   		    	*/
+ {0x09,1,1},		/* left button down   		    	*/
+ {0x0d,1,1},		/* left and center    	2	6   	*/
+ {0x0d,1,1},		/* left and center    		    	*/
+ {0x08,1,1},		/* no buttons down    	1	7   	*/
+                         /*                      3	    	*/
+ 
+ {0x0e,1,1},		/* right and center   	4	8   	*/
+                         /*                      2	    	*/
+ {0x08,1,1},		/* no buttons down    	5	9   	*/
+                         /*                      3	    	*/
+ 
+ {0x0f,1,1},		/* all buttons        	0	0   	*/
+                         /*                      4	4   	*/
+                         /*                      2	2   	*/
+ {0x08,1,1},		/* no buttons down    	1	1   	*/
+                         /*                      5	5   	*/
+                         /*                      3	3   	*/
+ 
+ {0x0d,1,1},		/* left and center    	0	    	*/
+                         /*                      2	6   	*/
+ {0x0e,1,1},		/* right and center   	1	    	*/
+                         /*                      4	4   	*/
+ {0x0b,1,1},		/* left and right     	3	7   	*/
+                         /*                      0	0   	*/
+ {0x08,1,1},		/* no buttons down    	1	1   	*/
+                         /*                      5	5   	*/
+ {0x0c,1,1},		/* center button down 	2	2   	*/
+ {0x08,1,1},		/* no buttons down    	3	3   	*/
+ 
+ {0x0e,1,1},		/* right and center   	4	8   	*/
+                         /*                      2	    	*/
+ {0x0f,1,1},		/* all buttons        	0	0   	*/
+ {0x0e,1,1},		/* right and center   	1	1   	*/
+ {0x0f,1,1},		/* all buttons        	0	0   	*/
+ {0x0e,1,1},		/* right and center   	1	1   	*/
+ {0x0f,1,1},		/* all buttons        	0	0   	*/
+ {0x08,1,1},		/* no buttons down    	1	1   	*/
+                         /*                      5	9   	*/
+                         /*                      3	    	*/
+ 
+ {0x09,1,1},		/* left button down   	0	0   	*/
+ {0x0e,1,1},		/* center, right down 	1	1   	*/
+                         /*                      4	8   	*/
+                         /*                      2	    	*/
+ {0x09,1,1},		/* left button down   	5	9   	*/
+                         /*                      3	0   	*/
+                         /*                      0	    	*/
+ {0x0e,1,1},		/* center, right down 	1	1   	*/
+                         /*                      4	8   	*/
+                         /*                      2	    	*/
+ {0x08,1,1},		/* no buttons down    	5	9   	*/
+                         /*                      3	    	*/
+ 
+ {0x0c,1,1},		/* center button down 	2	2   	*/
+ {0x0b,1,1},		/* left and right     	3	0   	*/
+                         /*                      0	4   	*/
+                         /*                      4	3   	*/
+ {0x08,1,1},		/* no buttons down    	1	1   	*/
+                         /*                      5	5   	*/
+ {0x0a,1,1},		/* right button down  	4	    	*/
+ {0x0d,1,1},		/* left and center    	5	6   	*/
+                         /*                      0	    	*/
+                         /*                      2	    	*/
+ {0x08,1,1},		/* no buttons down    	1	7   	*/
+                         /*                      3	    	*/
+ {0x0a,1,1},		/* right button down  	4	    	*/
+ {0x0a,1,1},		/* right button down  	 	    	*/
+ {0x0a,1,1},		/* right button down  	 	    	*/
+ {0x0a,1,1},		/* right button down  	 	 4  	*/
+ {0x0a,1,1},		/* right button down  	 	    	*/
+ {0x08,1,1},		/* no buttons down    	5	 5  	*/
+ {0x09,1,1},		/* left button down   	0	    	*/
+ {0x09,1,1},		/* left button down   	 	    	*/
+ {0x09,1,1},		/* left button down   	 	    	*/
+ {0x09,1,1},		/* left button down   	 	 0  	*/
+ {0x09,1,1},		/* left button down   	 	    	*/
+ {0x08,1,1},		/* no buttons down    	1	 1  	*/
+ {0x0c,1,1},		/* center button down 	2	    	*/
+ {0x0c,1,1},		/* center button down 	 	    	*/
+ {0x0c,1,1},		/* center button down 	 	    	*/
+ {0x0c,1,1},		/* center button down 	 	 2  	*/
+ {0x0c,1,1},		/* center button down 	 	    	*/
+ {0x08,1,1},		/* no buttons down    	3	 3  	*/
+ 
+ {0x00,1,1}};		/* terminate data     			*/
+ 
+ main ()
+     {
+     int fd;
+ 
+     makedata();				/* make the test data	*/
+     fd = open ("data", O_RDWR);
+     printf("Test case 1: no button chording\n");
+     process_test_data(fd, expected_button1);
+     close(fd);
+     fd = open ("data", O_RDWR);
+     hp7lc2m_chording_interval = 100;
+     printf("Test case 2: button chording enabled\n");
+     process_test_data(fd, expected_button2);
+     close(fd);
+     }
+ 
+ process_test_data (fd, expected)
+     int fd;
+     char *expected;
+     {
+     int pending=0, ndx=0;
+     unsigned char buf[128], data_type=0;
+ 
+     buf[2] = 0;
+     while (hp7lc2mread (fd, buf, &data_type, &pending) == READ_SUCCESS)
+ 	{
+ 	if (data_type & MOTION_DATA)
+ 	    ndx = 2;
+ 	if (data_type & BUTTON_DATA)
+ 	    {
+ 	    if (buf[ndx] != *expected)
+ 	        printf ("Expected button %d received %d.\n",
+ 		    *expected,buf[ndx]);
+ 	    expected++;
+ 	    }
+ 	data_type = 0;
+ 	buf[2]=0;
+ 	pending=0;
+ 	ndx = 0;
+ 	};
+     }
+ 
+ /* The PS2 mouse returns PKT_SIZ bytes for each movement of the mouse or
+  * button press or release.  The format of the bytes is as follows:
+  *
+  * Byte 0:
+  * 		Bit 7	Y data overflow		(1 = overflow)
+  * 		Bit 6	X data overflow		(1 = overflow)
+  * 		Bit 5	Y data sign		(1 = negative)
+  * 		Bit 4	X data sign		(1 = negative)
+  * 		Bit 3	Not used		(always 1)
+  * 		Bit 2	Center button		(1 = depressed)
+  * 		Bit 1	Right button		(1 = depressed)
+  * 		Bit 0	Left button		(1 = depressed)
+  * Byte 1:
+  *		X coordinate data byte		(2's compliment)
+  * Byte 2:
+  *		Y coordinate data byte		(2's compliment)
+  */
+ 
+ makedata ()
+     {
+     int i, fd;
+ 
+     fd = creat("data", 0777);
+     while (testdata[i][0] != 0)
+ 	write (fd, testdata[i++], 3);
+     close(fd);
+     }
+ #endif /* DEBUG */
*** /dev/null	Sun Jun  5 17:11:28 1994
--- xc/programs/Xserver/hw/hp/input/drivers/ps2io.h	Sun Jun  5 18:27:39 1994
***************
*** 0 ****
--- 1,117 ----
+ /* $XConsortium: ps2io.h,v 1.1 94/05/28 14:32:49 dpw Exp $ */
+ /*
+  * @(#)ps2io.h: $Revision: 1.1 $ $Date: 94/05/28 14:32:49 $
+  * $Locker:  $
+  */
+ 
+ #ifndef _SYS_PS2IO_INCLUDED /* allows multiple inclusion */
+ #define _SYS_PS2IO_INCLUDED
+ 
+ #ifndef _SYS_STDSYMS_INCLUDED
+ #ifdef _KERNEL_BUILD
+ #    include "../h/stdsyms.h"
+ #else  /* ! _KERNEL_BUILD */
+ #    include <sys/stdsyms.h>
+ #endif /* _KERNEL_BUILD */
+ #endif   /* _SYS_STDSYMS_INCLUDED  */
+ 
+ #ifdef _KERNEL_BUILD
+ #  include "../h/ioctl.h"
+ #else  /* ! _KERNEL_BUILD */
+ #  include <sys/ioctl.h>
+ #endif /* _KERNEL_BUILD */
+ 
+ struct ps2_4 {
+    unsigned char b[4];
+ };
+ 
+ /*
+  * Device ioctl() command defines
+  */
+ 
+ #define PS2_INDICATORS 	_IOW('P', 0x01, struct ps2_4)
+ #define PS2_IDENT	_IOR('P', 0x02, struct ps2_4)
+ #define PS2_SCANCODE	_IOWR('P', 0x03, struct ps2_4)
+ #define PS2_ENABLE	_IO('P', 0x04)
+ #define PS2_DISABLE	_IO('P', 0x05)
+ #define PS2_STREAMMODE	_IO('P', 0x06)
+ #define PS2_SAMPLERATE  _IOW('P', 0x07, struct ps2_4)
+ #define PS2_RESET	_IOR('P', 0x08, struct ps2_4)
+ #define PS2_RESOLUTION	_IOW('P', 0x09, struct ps2_4)
+ #define PS2_ALL_TMAT 		_IO('P', 0x0A)
+ #define PS2_ALL_MKBRK 		_IO('P', 0x0B)
+ #define PS2_ALL_TMAT_MKBRK 	_IO('P', 0x0C)
+ #define PS2_ALL_MK 		_IO('P', 0x0D)
+ #define PS2_KEY_MKBRK		_IOW('P', 0x0E, struct ps2_4)
+ #define PS2_KEY_MAKE		_IOW('P', 0x0F, struct ps2_4)
+ #define PS2_KEY_TMAT		_IOW('P', 0x10, struct ps2_4)
+ #define PS2_RATEDELAY		_IOW('P', 0x11, struct ps2_4)
+ 
+ #define PS2_PORTSTAT	_IOR('P', 0x12, struct ps2_4)
+ #define PS2_TEST	_IOW('P', 0x13, char)
+ #define PS2_SETDEFAULT	_IO('P', 0x14)
+ #define PS2_PROMPTMODE	_IO('P', 0x15)
+ #define PS2_REPORT	_IOR('P', 0x16, struct ps2_4)
+ #define PS2_STATUS	_IOR('P', 0x17, struct ps2_4)
+ #define PS2_2TO1_SCALING	_IO('P', 0x18)
+ #define PS2_1TO1_SCALING	_IO('P', 0x19)
+ 
+ #define PS2FAKE _IOW('P',0x0F,char)     /* fake a character */
+ 
+ /*
+ #define _IOR('P',0x ,)
+  */
+ 
+ /* Values for PS2_PORTSTAT first return byte */
+ 
+ #define PS2_NONE        0
+ #define PS2_MOUSE       1
+ #define PS2_KEYBD       2
+ #define PS2_UNKNOWN     3
+ 
+ /* Bit mask values for ps2 devices */
+ 
+ #define PS2_NONE_BIT    0x0001
+ #define PS2_MOUSE_BIT   0x0002
+ #define PS2_KEYBD_BIT   0x0004
+ #define PS2_UNKNOWN_BIT 0x0008
+ 
+ /* Bit mask values for PS2_PORTSTAT second return byte */
+ 
+ #define INTERFACE_HAS_ITE	0x01
+ #define PORT_HAS_FIRST_KEYBD	0x02
+ #define PORT_HAS_FIRST_MOUSE	0x04
+ 
+ /* values for PS2_SCANCODE */
+ 
+ #define GET_SCANCODE	0x00
+ #define SCANCODE_1	0x01
+ #define SCANCODE_2	0x02
+ #define SCANCODE_3	0x03
+ 
+ /* values for PS2_SAMPLERATE */
+ 
+ #define SAMPLE_10	0x0A
+ #define SAMPLE_20	0x14
+ #define SAMPLE_40	0x28
+ #define SAMPLE_60	0x3C
+ #define SAMPLE_80	0x50
+ #define SAMPLE_100	0x64
+ #define SAMPLE_200	0xC8
+ 
+ /* values for PS2_INDICATORS */
+ 
+ #define  CAPS_LED	0x04
+ #define  NUM_LED	0x02
+ #define  SCROLL_LED	0x01
+ 
+ /* values for PS2_RESOLUTION */
+ /*  (RES_3 is te default)             Resolution in counts/mm */
+                                /*  200 DPI          320 DPI   */
+ 			       /*---------          -------   */
+ #define	RES_1		0x00   /*        1                1   */
+ #define	RES_2		0x01   /*        2                3   */
+ #define	RES_3		0x02   /*        4                6   */
+ #define	RES_4		0x03   /*        8               12   */
+ 
+ #endif /* _SYS_PS2IO_INCLUDED */
*** /dev/null	Sun Jun  5 17:11:28 1994
--- xc/programs/Xserver/hw/hp/input/drivers/x_serialdrv.h	Sun Jun  5 18:27:40 1994
***************
*** 0 ****
--- 1,188 ----
+ /* $XConsortium: x_serialdrv.h,v 1.1 94/05/28 14:32:51 dpw Exp $ */
+ /************************************************************
+ Copyright (c) 1992 by Hewlett-Packard Company, Palo Alto, California.
+ 
+ 			All Rights Reserved
+ 
+ Permission to use, copy, modify, and distribute this software and its
+ documentation for any purpose and without fee is hereby granted,
+ provided that the above copyright notice appear in all copies and that
+ both that copyright notice and this permission notice appear in
+ supporting documentation, and that the name of Hewlett-Packard not be
+ used in advertising or publicity pertaining to distribution of the
+ software without specific, written prior permission.
+ 
+ HEWLETT-PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+ HEWLETT-PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+ WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ SOFTWARE.
+ 
+ ********************************************************/
+ 
+ /***************************************************************************
+  *
+  * Constants and structs for dynamically loaded serial input device drivers.
+  *
+  */
+ 
+ #ifndef _X_SERIALDRV_H_
+ #include <dl.h>
+ 
+ #define X_KEYMAP_NAME		"/etc/kbdlang"
+ #define MIN_KEYCODE		8
+ #define MAX_NM			64
+ #define DATA_IS_8_BITS		0x01
+ #define DATA_IS_16_BITS		0x02
+ #define DATA_IS_32_BITS		0x04
+ #define REPORTS_PROXIMITY	0x08
+ #define	ABSOLUTE_DATA		0x040
+ #define NON_CONTIGUOUS_DATA	0x080
+ #define FALSE			0
+ #define TRUE 			1
+ #define KEY_DATA 		0x01
+ #define BUTTON_DATA 		0x02
+ #define PROXIMITY_DATA 		0x04
+ #define MOTION_DATA 		0x08
+ #define INIT_SUCCESS		0
+ #define INIT_FAILURE		1
+ #define READ_SUCCESS		0
+ #define READ_FAILURE		1
+ #define WRITE_SUCCESS		0
+ #define WRITE_FAILURE		1
+ #define CLOSE_SUCCESS		0
+ #define IN_PROXIMITY		0
+ #define OUT_OF_PROXIMITY	1
+ 
+ #define SCROLLLOCK_LED		(1 << 0)
+ #define NUMLOCK_LED		(1 << 1) 
+ #define CAPSLOCK_LED		(1 << 2)
+ 
+ #define _XSetDeviceMode		0
+ #define _XSetDeviceValuators	1
+ #define _XChangeDeviceControl	2
+ #define _XChangeFeedbackControl	3
+ #define _XChangeKeyboardControl	4
+ #define _XChangePointerControl	5
+ 
+ typedef struct {
+ 	int	class;
+ 	int	led_mask;
+ 	int	led_values;
+ } HPLedFeedbackControl;
+ 
+ typedef struct {
+ 	int	class;
+ 	int	click;
+ 	int	bell_percent;
+ 	int	bell_pitch;
+ 	int	bell_duration;
+ 	int 	autoRepeat;
+ 	unsigned char	autoRepeats[32];
+ 	int 	leds;
+ } HPKeyboardFeedbackControl;
+ 
+ typedef struct {
+ 	int	class;
+ 	int	num;
+ 	int	den;
+ 	int	threshold;
+ } HPPointerFeedbackControl;
+ 
+ typedef struct {
+ 	int	class;
+ 	int	resolution;
+ 	int	min_value;
+ 	int	max_value;
+ 	int	integer_displayed;
+ } HPIntegerFeedbackControl;
+ 
+ typedef struct {
+ 	int	max_symbols;
+ 	int	num_symbols_supported;
+ 	int  	*symbols_supported;
+ } HPStrF;
+ 
+ typedef struct {
+ 	int	class;
+ 	int	max_symbols;
+ 	int	num_symbols_supported;
+ 	int	num_symbols_displayed;
+ 	int  	*symbols_supported;
+ 	int  	*symbols_displayed;
+ } HPStringFeedbackControl;
+ 
+ typedef struct {
+ 	int	class;
+ 	int	percent;
+ 	int	pitch;
+ 	int	duration;
+ } HPBellFeedbackControl;
+ 
+ typedef struct {
+ 	int	*valuators;
+ 	int	first_valuator;
+ 	int	num_valuators;
+ } HPValuatorControl;
+ 
+ typedef struct {
+ 	int	*resolutions;
+ 	int	first_valuator;
+ 	int	num_valuators;
+ } HPResolutionControl;
+ 
+ typedef int (*pfrb)();
+ typedef int (*ConfigureProc)();
+ typedef int (*InitProc)();
+ typedef int (*ReadProc)();
+ typedef int (*WriteProc)();
+ typedef int (*CloseProc)();
+ 
+ typedef struct _SerialProcs
+     {
+     ConfigureProc	configure;	/* filled in by driver		*/
+     ReadProc		read;		/* filled in by driver		*/
+     WriteProc		write;		/* filled in by driver		*/
+     CloseProc		close;		/* filled in by driver		*/
+     shl_t		ldr_module_id;	/* filled in by X server	*/
+     int			fd;		/* filled in by X server	*/
+     char		driver_name[MAX_NM];   /* filled in by X server	*/
+     char		*keymap_name;   /* filled in by X server	*/
+     char		*keymap_file;   /* filled in by X server	*/
+     int         	num_fdbk;       /* filled in by X server       	*/
+     u_char		*feedbacks;	/* filled in by X server        */
+     int         	num_ledf;       /* filled in by X server       	*/
+     u_char		*ledf; 		/* filled in by X server        */
+     int         	num_strf;       /* filled in by X server      	*/
+     HPStrF		*strf;          /* filled in by X server        */
+     } SerialProcs; 
+ 
+ typedef struct _HPInputDeviceHeader
+     {
+     char	path[MAX_NM];	/* device path - filled in by X server  */
+     char	*x_name;     	/* device name                          */
+     char	*keymap_name;  	/* keymap name, if device has keys      */
+     char	*keymap_file;  	/* keymap file, if device has keys      */
+     int		resolution;	/* resolution in counts/cm         	*/
+     int         max_x;        	/* maximum x value in counts    	*/
+     int         max_y;          /* maximum y value in counts    	*/
+     int         file_ds;        /* file descriptor              	*/
+     int         num_fdbk;       /* length of list that follows  	*/
+     u_char	*feedbacks;	/* kbd, ptr, bell, and integer feedbacks*/
+     int         num_ledf;       /* length of list that follows  	*/
+     u_char	*ledf; 		/* led feedbacks                        */
+     int         num_strf;       /* length of list that follows  	*/
+     HPStrF	*strf;          /* string feedbacks                     */
+     u_char	flags; 		/* device characteristics		*/
+     u_char	ax_num;		/* number of axes			*/
+     u_char	num_buttons;   	/* number of buttons         		*/
+     u_char 	num_keys; 	/* number of keys            		*/
+     u_char 	min_kcode;	/* minimum keycode           		*/
+     u_char 	max_kcode;	/* maximum keycode           		*/
+     u_char	reset;		/* keycode to cause X server reset      */
+     u_char	reset_mods;	/* mask of modifiers for server reset   */
+     u_char	button_chording;/* interval (ms) if chording enabled    */
+     }HPInputDeviceHeader;
+ #endif /* _X_SERIALDRV_H_ */
*** /tmp/da17136	Sun Jun  5 18:27:43 1994
--- xc/programs/Xserver/hw/hp/input/getkeysym.c	Sun Jun  5 18:27:42 1994
***************
*** 1,4 ****
! /* $XConsortium: getkeysym.c,v 1.5 93/08/08 12:58:54 rws Exp $ */
  /*
  
  Copyright (c) 1986, 1987 by Hewlett-Packard Company
--- 1,4 ----
! /* $XConsortium: getkeysym.c,v 1.6 94/05/28 15:50:21 dpw Exp $ */
  /*
  
  Copyright (c) 1986, 1987 by Hewlett-Packard Company
***************
*** 26,31 ****
--- 26,38 ----
  
  */
  
+ #ifndef LIBDIR
+ #if OSMAJORVERSION >= 10
+ #define LIBDIR "/etc/X11"
+ #else
+ #define LIBDIR "/usr/lib/X11"
+ #endif
+ #endif
  #include <stdio.h>
  #include <X11/XHPlib.h>
  
***************
*** 90,97 ****
  
      if (name[0] != '/')
      {
! 	strcpy(filename, DEF_DIRECTORY);
! 	strcat(filename, name);
      }
      else
  	strcpy(filename, name);
--- 97,103 ----
  
      if (name[0] != '/')
      {
! 	sprintf(filename, "%s/%s",LIBDIR,name);
      }
      else
  	strcpy(filename, name);
***************
*** 190,199 ****
  
      if (name[0] != '/')
      {
!       strcpy(filename, DEF_DIRECTORY);
!       strcat(filename, name);
      }
!     else strcpy(filename, name);
  
      if (NULL == (keysym_file = fopen(filename,"r")))
  	return False;
--- 196,205 ----
  
      if (name[0] != '/')
      {
! 	sprintf(filename, "%s/%s",LIBDIR,name);
      }
!     else
! 	strcpy(filename, name);
  
      if (NULL == (keysym_file = fopen(filename,"r")))
  	return False;
*** /tmp/da17152	Sun Jun  5 18:27:45 1994
--- xc/programs/Xserver/hw/hp/input/x_hil.c	Sun Jun  5 18:27:44 1994
***************
*** 1,4 ****
! /* $XConsortium: x_hil.c,v 8.142 94/04/17 20:30:15 dpw Exp $ */
  
  /*******************************************************************
  **
--- 1,4 ----
! /* $XConsortium: x_hil.c,v 8.143 94/05/28 15:50:23 dpw Exp $ */
  
  /*******************************************************************
  **
***************
*** 615,621 ****
  		    }
  		else
  		    {
! 		    if (dev==inputInfo.keyboard)
  			if (bcode & UP_MASK) 
  			    type = KeyRelease;
  			else
--- 615,621 ----
  		    }
  		else
  		    {
! 		    if (dev==inputInfo.keyboard || dev==inputInfo.pointer)
  			if (bcode & UP_MASK) 
  			    type = KeyRelease;
  			else
***************
*** 692,698 ****
  	    kcode += MIN_KEYCODE;		        /* avoid mouse codes. */
  
  	    if (*hil_code & UP_MASK) 
! 		if (dev==inputInfo.keyboard)
  		    type = KeyRelease;
  		else
  		    type = DeviceKeyRelease;
--- 692,698 ----
  	    kcode += MIN_KEYCODE;		        /* avoid mouse codes. */
  
  	    if (*hil_code & UP_MASK) 
! 		if (dev==inputInfo.keyboard || dev==inputInfo.pointer)
  		    type = KeyRelease;
  		else
  		    type = DeviceKeyRelease;
***************
*** 700,706 ****
  		{
  		if (KeyIsDown(dev,kcode) && !KeyIsRepeating(dev,kcode))
  		    return;
! 		if (dev==inputInfo.keyboard)
  		    type = KeyPress;
  		else
  		    type = DeviceKeyPress;
--- 700,706 ----
  		{
  		if (KeyIsDown(dev,kcode) && !KeyIsRepeating(dev,kcode))
  		    return;
! 		if (dev==inputInfo.keyboard || dev==inputInfo.pointer)
  		    type = KeyPress;
  		else
  		    type = DeviceKeyPress;
***************
*** 1008,1015 ****
  	    dev->key->modifierKeyCount[LockMapIndex] <= 1)
  	    if (phys->hpflags & IS_SERIAL_DEVICE){
  		HPKeyboardFeedbackControl	d;
! 		d.class = KbdFeedbackClass;
! 		d.leds = 0;
  		SERIAL_DRIVER_WRITE(phys->file_ds, _XChangeFeedbackControl, &d);
  	    }
  	    else
--- 1008,1015 ----
  	    dev->key->modifierKeyCount[LockMapIndex] <= 1)
  	    if (phys->hpflags & IS_SERIAL_DEVICE){
  		HPKeyboardFeedbackControl	d;
! 		copy_kbd_ctrl_params (&d, &dev->kbdfeed->ctrl);
! 		d.leds &= ~CAPSLOCK_LED;
  		SERIAL_DRIVER_WRITE(phys->file_ds, _XChangeFeedbackControl, &d);
  	    }
  	    else
***************
*** 1017,1024 ****
  	else
  	    if (phys->hpflags & IS_SERIAL_DEVICE){
  		HPKeyboardFeedbackControl	d;
! 		d.class = KbdFeedbackClass;
! 		d.leds = 4;
  		SERIAL_DRIVER_WRITE(phys->file_ds, _XChangeFeedbackControl, &d);
  	    }
  	    else
--- 1017,1024 ----
  	else
  	    if (phys->hpflags & IS_SERIAL_DEVICE){
  		HPKeyboardFeedbackControl	d;
! 		copy_kbd_ctrl_params (&d, &dev->kbdfeed->ctrl);
! 		d.leds |= CAPSLOCK_LED;
  		SERIAL_DRIVER_WRITE(phys->file_ds, _XChangeFeedbackControl, &d);
  	    }
  	    else
*** /tmp/da17168	Sun Jun  5 18:27:48 1994
--- xc/programs/Xserver/hw/hp/input/x_hilinit.c	Sun Jun  5 18:27:47 1994
***************
*** 1,4 ****
! /* $XConsortium: x_hilinit.c,v 8.201 94/04/17 20:30:17 dpw Exp $ */
  /*
  
  Copyright (c) 1988-1992  X Consortium
--- 1,4 ----
! /* $XConsortium: x_hilinit.c,v 8.202 94/05/28 15:50:24 dpw Exp $ */
  /*
  
  Copyright (c) 1988-1992  X Consortium
***************
*** 57,68 ****
  		if ((*(serialprocs[i].write)) (f, type, ptr)==WRITE_SUCCESS) \
  		    return Success; } }
  
! #define SERIAL_DRIVER_WRITE_VOID(f, type, ptr) \
! 	{ int i; \
! 	for (i=0; i<num_serial_devices; i++) \
! 	    if (f==serialprocs[i].fd) { \
! 		if ((*(serialprocs[i].write)) (f, type, ptr)==WRITE_SUCCESS) \
! 		    return; } }
  
  #define	 MAXNAMLEN	255
  #define  spare  	MAX_LOGICAL_DEVS - 2
--- 57,70 ----
  		if ((*(serialprocs[i].write)) (f, type, ptr)==WRITE_SUCCESS) \
  		    return Success; } }
  
! #ifndef LIBDIR
! #if OSMAJORVERSION >= 10
! #define LIBDIR "/etc/X11"
! #else
! #define LIBDIR "/usr/lib/X11"
! #endif
! #endif
! #define DRVRLIBDIR LIBDIR/**/"/extensions/"
  
  #define	 MAXNAMLEN	255
  #define  spare  	MAX_LOGICAL_DEVS - 2
***************
*** 83,88 ****
--- 85,91 ----
  #include <fcntl.h>
  #include <dl.h>
  #include <sys/utsname.h>
+ #include "ps2io.h"
  #endif /* __hpux */
  
  #include "X.h"
***************
*** 143,148 ****
--- 146,152 ----
  extern	int	DeviceButtonPress;
  extern	int	DeviceButtonRelease;
  extern	int	DeviceMotionNotify; 
+ XID	hp_device_ids[MAX_DEVICES];
  XID		x_device_ids[MAX_DEVICES];
  #endif  /* XINPUT */
  
***************
*** 188,193 ****
--- 192,199 ----
   *
   */
  
+ static Bool din_mouse_present();
+ static Bool din_kbd_present();
  static int init_hil_devs ();
  static int get_device_details();
  static int get_device_type();
***************
*** 271,282 ****
   * could use them.
   */
  
! static void hpChangeIntegerControl(pDevice, ctrl)
!     DeviceIntPtr pDevice;
      IntegerCtrl *ctrl;
      {
      HPIntegerFeedbackControl	dctrl;
!     HPInputDevice *d = GET_HPINPUTDEVICE (pDevice);
  
      if (d->hpflags & IS_SERIAL_DEVICE)
  	{
--- 277,288 ----
   * could use them.
   */
  
! static hpChangeIntegerControl(pDevice, ctrl)
!     DevicePtr pDevice;
      IntegerCtrl *ctrl;
      {
      HPIntegerFeedbackControl	dctrl;
!     HPInputDevice *d = GET_HPINPUTDEVICE ((DeviceIntPtr) pDevice);
  
      if (d->hpflags & IS_SERIAL_DEVICE)
  	{
***************
*** 284,299 ****
  	dctrl.resolution = ctrl->resolution;
  	dctrl.max_value = ctrl->max_value;
  	dctrl.integer_displayed = ctrl->integer_displayed;
! 	SERIAL_DRIVER_WRITE_VOID(d->file_ds, _XChangeFeedbackControl, &dctrl);
  	}
      }
  
! static void hpChangeStringControl(pDevice, ctrl)
!     DeviceIntPtr pDevice;
      StringCtrl *ctrl;
      {
      HPStringFeedbackControl	dctrl;
!     HPInputDevice *d = GET_HPINPUTDEVICE (pDevice);
  
      if (d->hpflags & IS_SERIAL_DEVICE)
  	{
--- 290,305 ----
  	dctrl.resolution = ctrl->resolution;
  	dctrl.max_value = ctrl->max_value;
  	dctrl.integer_displayed = ctrl->integer_displayed;
! 	SERIAL_DRIVER_WRITE(d->file_ds, _XChangeFeedbackControl, &dctrl);
  	}
      }
  
! static StringCtrlProcPtr hpChangeStringControl(pDevice, ctrl)
!     DevicePtr pDevice;
      StringCtrl *ctrl;
      {
      HPStringFeedbackControl	dctrl;
!     HPInputDevice *d = GET_HPINPUTDEVICE ((DeviceIntPtr) pDevice);
  
      if (d->hpflags & IS_SERIAL_DEVICE)
  	{
***************
*** 303,318 ****
  	dctrl.num_symbols_displayed = ctrl->num_symbols_displayed;
  	dctrl.symbols_supported = (int *) ctrl->symbols_supported;
  	dctrl.symbols_displayed = (int *) ctrl->symbols_displayed;
! 	SERIAL_DRIVER_WRITE_VOID(d->file_ds, _XChangeFeedbackControl, &dctrl);
  	}
      }
  
! static void hpChangeBellControl(pDevice, ctrl)
!     DeviceIntPtr pDevice;
      BellCtrl *ctrl;
      {
      HPBellFeedbackControl	dctrl;
!     HPInputDevice *d = GET_HPINPUTDEVICE (pDevice);
  
      if (d->hpflags & IS_SERIAL_DEVICE)
  	{
--- 309,324 ----
  	dctrl.num_symbols_displayed = ctrl->num_symbols_displayed;
  	dctrl.symbols_supported = (int *) ctrl->symbols_supported;
  	dctrl.symbols_displayed = (int *) ctrl->symbols_displayed;
! 	SERIAL_DRIVER_WRITE(d->file_ds, _XChangeFeedbackControl, &dctrl);
  	}
      }
  
! static BellCtrlProcPtr hpChangeBellControl(pDevice, ctrl)
!     DevicePtr pDevice;
      BellCtrl *ctrl;
      {
      HPBellFeedbackControl	dctrl;
!     HPInputDevice *d = GET_HPINPUTDEVICE ((DeviceIntPtr) pDevice);
  
      if (d->hpflags & IS_SERIAL_DEVICE)
  	{
***************
*** 320,326 ****
  	dctrl.percent = ctrl->percent;
  	dctrl.pitch = ctrl->pitch;
  	dctrl.duration = ctrl->duration;
! 	SERIAL_DRIVER_WRITE_VOID(d->file_ds, _XChangeFeedbackControl, &dctrl);
  	}
      }
  
--- 326,332 ----
  	dctrl.percent = ctrl->percent;
  	dctrl.pitch = ctrl->pitch;
  	dctrl.duration = ctrl->duration;
! 	SERIAL_DRIVER_WRITE(d->file_ds, _XChangeFeedbackControl, &dctrl);
  	}
      }
  
***************
*** 334,341 ****
   *
   */
  
! static void hpChangePointerControl(pDevice, ctrl)
!     DeviceIntPtr pDevice;
      PtrCtrl *ctrl;
      {
      HPInputDevice *d;
--- 340,347 ----
   *
   */
  
! static hpChangePointerControl(pDevice, ctrl)
!     DevicePtr pDevice;
      PtrCtrl *ctrl;
      {
      HPInputDevice *d;
***************
*** 343,349 ****
  #ifdef XINPUT
      PtrFeedbackPtr b;
  
!     b = pDevice->ptrfeed;
  
      b->ctrl = *ctrl;
  #else
--- 349,355 ----
  #ifdef XINPUT
      PtrFeedbackPtr b;
  
!     b = ((DeviceIntPtr) pDevice)->ptrfeed;
  
      b->ctrl = *ctrl;
  #else
***************
*** 356,368 ****
  	acceleration = 1;
  #endif /* XINPUT */
  
!     d = GET_HPINPUTDEVICE (pDevice);
  #ifdef __apollo
      {
      smd_$pos_t pos;
      extern smd_unit_event_data_t olddata;
  
!     if (pDevice == inputInfo.pointer)
  	{
  	pos.column = d->coords[0];
  	pos.line = d->coords[1];
--- 362,374 ----
  	acceleration = 1;
  #endif /* XINPUT */
  
!     d = GET_HPINPUTDEVICE ((DeviceIntPtr) pDevice);
  #ifdef __apollo
      {
      smd_$pos_t pos;
      extern smd_unit_event_data_t olddata;
  
!     if ((DeviceIntPtr) pDevice == inputInfo.pointer)
  	{
  	pos.column = d->coords[0];
  	pos.line = d->coords[1];
***************
*** 377,383 ****
  	dctrl.num = ctrl->num;
  	dctrl.den = ctrl->den;
  	dctrl.threshold = ctrl->threshold;
! 	SERIAL_DRIVER_WRITE_VOID(d->file_ds, _XChangeFeedbackControl, &dctrl);
  	}
      }
  
--- 383,389 ----
  	dctrl.num = ctrl->num;
  	dctrl.den = ctrl->den;
  	dctrl.threshold = ctrl->threshold;
! 	SERIAL_DRIVER_WRITE(d->file_ds, _XChangeFeedbackControl, &dctrl);
  	}
      }
  
***************
*** 427,440 ****
   *
   */
  
! static void hpChangeLedControl(pDevice, ctrl)
!     DeviceIntPtr pDevice;
      LedCtrl *ctrl;
      {
      HPInputDevice	*d;
      HPLedFeedbackControl	dctrl;
  
!     d = GET_HPINPUTDEVICE (pDevice);
      SetLeds(d, ctrl->led_values, ctrl->led_mask);
      if (d->hpflags & IS_SERIAL_DEVICE)
  	{
--- 433,446 ----
   *
   */
  
! static hpChangeLedControl(pDevice, ctrl)
!     DevicePtr pDevice;
      LedCtrl *ctrl;
      {
      HPInputDevice	*d;
      HPLedFeedbackControl	dctrl;
  
!     d = GET_HPINPUTDEVICE ((DeviceIntPtr) pDevice);
      SetLeds(d, ctrl->led_values, ctrl->led_mask);
      if (d->hpflags & IS_SERIAL_DEVICE)
  	{
***************
*** 441,447 ****
  	dctrl.class = LedFeedbackClass;
  	dctrl.led_values = ctrl->led_values;
  	dctrl.led_mask = ctrl->led_mask;
! 	SERIAL_DRIVER_WRITE_VOID(d->file_ds, _XChangeFeedbackControl, &dctrl);
  	}
      }
  
--- 447,453 ----
  	dctrl.class = LedFeedbackClass;
  	dctrl.led_values = ctrl->led_values;
  	dctrl.led_mask = ctrl->led_mask;
! 	SERIAL_DRIVER_WRITE(d->file_ds, _XChangeFeedbackControl, &dctrl);
  	}
      }
  
***************
*** 457,490 ****
   * keyboard_click is checked whenever a key is pressed, in x_hil.c.
   */
  
! static void hpChangeKeyboardControl(pDevice, ctrl)
!     DeviceIntPtr pDevice;
      KeybdCtrl *ctrl;
      {
      HPInputDevice	*d;
      HPKeyboardFeedbackControl	dctrl;
  
!     if (inputInfo.keyboard && pDevice->id==inputInfo.keyboard->id)
          keyboard_click = (int)((double)(ctrl->click) * 15.0 / 100.0);
  
!     d = GET_HPINPUTDEVICE (pDevice);
      SetAutoRepeat(d, ctrl->autoRepeat);
      SetBellAttributes(d, ctrl);
      SetLeds(d, ctrl->leds, 0xffffffff);
      if (d->hpflags & IS_SERIAL_DEVICE)
  	{
! 	dctrl.class = KbdFeedbackClass;
! 	dctrl.click = ctrl->click;
! 	dctrl.bell_percent = ctrl->bell;
! 	dctrl.bell_pitch = ctrl->bell_pitch;
! 	dctrl.bell_duration = ctrl->bell_duration;
! 	dctrl.autoRepeat = ctrl->autoRepeat;
! 	memmove(dctrl.autoRepeats, ctrl->autoRepeats, 32);
! 	dctrl.leds = ctrl->leds;
! 	SERIAL_DRIVER_WRITE_VOID(d->file_ds, _XChangeFeedbackControl, &dctrl);
  	}
      }
  
  /****************************************************************************
   *
   * hpGetDeviceMotionEvents.
--- 463,504 ----
   * keyboard_click is checked whenever a key is pressed, in x_hil.c.
   */
  
! static hpChangeKeyboardControl(pDevice, ctrl)
!     DevicePtr pDevice;
      KeybdCtrl *ctrl;
      {
      HPInputDevice	*d;
      HPKeyboardFeedbackControl	dctrl;
  
!     if (inputInfo.keyboard &&
!         ((DeviceIntPtr) pDevice)->id==inputInfo.keyboard->id)
          keyboard_click = (int)((double)(ctrl->click) * 15.0 / 100.0);
  
!     d = GET_HPINPUTDEVICE ((DeviceIntPtr) pDevice);
      SetAutoRepeat(d, ctrl->autoRepeat);
      SetBellAttributes(d, ctrl);
      SetLeds(d, ctrl->leds, 0xffffffff);
      if (d->hpflags & IS_SERIAL_DEVICE)
  	{
! 	copy_kbd_ctrl_params (&dctrl, ctrl);
! 	SERIAL_DRIVER_WRITE(d->file_ds, _XChangeFeedbackControl, &dctrl);
  	}
      }
  
+ copy_kbd_ctrl_params (dctrl, ctrl)
+     HPKeyboardFeedbackControl	*dctrl;
+     KeybdCtrl *ctrl;
+     {
+     dctrl->class = KbdFeedbackClass;
+     dctrl->click = ctrl->click;
+     dctrl->bell_percent = ctrl->bell;
+     dctrl->bell_pitch = ctrl->bell_pitch;
+     dctrl->bell_duration = ctrl->bell_duration;
+     dctrl->autoRepeat = ctrl->autoRepeat;
+     memmove(dctrl->autoRepeats, ctrl->autoRepeats, 32);
+     dctrl->leds = ctrl->leds;
+     }
+ 
  /****************************************************************************
   *
   * hpGetDeviceMotionEvents.
***************
*** 491,510 ****
   *
   */
  
- 
  static int hpGetDeviceMotionEvents (dev, coords, start, stop, pScreen)
      DeviceIntPtr  dev;
!     xTimecoord * coords;
!     unsigned long start, stop;
      ScreenPtr pScreen;
      {
-     char *buff;
      HPInputDevice 	*pHPDev = (HPInputDevice *) dev->public.devicePrivate;
      int			i;
      int			evcount = 0;
      int			size = pHPDev->hil_header.ax_num + 1;
      int 		*first, *last, 	*curr;
!     int 		*buffp = (int *) buff;
      int 		*pmBuf = dpmotionBuf[dev->id];
      int 		*hmBuf = dheadmotionBuf[dev->id];
  
--- 505,522 ----
   *
   */
  
  static int hpGetDeviceMotionEvents (dev, coords, start, stop, pScreen)
      DeviceIntPtr  dev;
!     CARD32 start, stop;
!     xTimecoord  *coords;
      ScreenPtr pScreen;
      {
      HPInputDevice 	*pHPDev = (HPInputDevice *) dev->public.devicePrivate;
      int			i;
      int			evcount = 0;
      int			size = pHPDev->hil_header.ax_num + 1;
      int 		*first, *last, 	*curr;
!     int 		*buffp = (int *) coords;
      int 		*pmBuf = dpmotionBuf[dev->id];
      int 		*hmBuf = dheadmotionBuf[dev->id];
  
***************
*** 569,574 ****
--- 581,587 ----
      DevicePtr pDev;
      int onoff;
      {
+     char 		*x_basename ();
      int			keyId;
      unsigned int	mask;
      KeySymsRec		*key_syms, keysym_rec;
***************
*** 589,595 ****
  				   MOTION_BUFFER_SIZE;
  #ifdef XINPUT
      char		*strchr();
-     char		*nptr;
  #endif /* XINPUT */
  
      switch (onoff)
--- 602,607 ----
***************
*** 597,604 ****
  	case DEVICE_INIT: 
  	    pDev->on = FALSE;
  	    pHPDev->pScreen = screenInfo.screens[0];
!     	    nptr = strchr (pHPDev->x_name, '_');
!     	    AssignTypeAndName (pDev, pHPDev->x_atom, ++nptr);
  
  	    if (h->num_keys)
  		{
--- 609,615 ----
  	case DEVICE_INIT: 
  	    pDev->on = FALSE;
  	    pHPDev->pScreen = screenInfo.screens[0];
!     	    AssignTypeAndName (pDev, pHPDev->x_atom, x_basename(pHPDev->x_name));
  
  	    if (h->num_keys)
  		{
***************
*** 647,653 ****
  		    i = pHPDev->sndx;
  		    if (!HPKget_kb_info_by_name(serialprocs[i].keymap_file, 
  			serialprocs[i].keymap_name, &keysym_rec, &the_modmap))
! 			FatalError ("Can't find a keymap in the /usr/lib/X11/XHPKeymaps file for device %s.\n", pHPDev->x_name);
  		    h->keymap_name = serialprocs[i].keymap_name;
  		    }
  		else
--- 658,664 ----
  		    i = pHPDev->sndx;
  		    if (!HPKget_kb_info_by_name(serialprocs[i].keymap_file, 
  			serialprocs[i].keymap_name, &keysym_rec, &the_modmap))
! 			FatalError ("Can't find a keymap in the %s/XHPKeymaps file for device %s.\n", LIBDIR, pHPDev->x_name);
  		    h->keymap_name = serialprocs[i].keymap_name;
  		    }
  		else
***************
*** 655,666 ****
  		key_syms = &keysym_rec;
  		h->min_kcode = key_syms->minKeyCode;
  		h->max_kcode = key_syms->maxKeyCode;
! 		h->num_keys = key_syms->maxKeyCode - key_syms->minKeyCode;
  		pHPDev->x_type = KEYBOARD;
  		if (dev->id == inputInfo.keyboard->id)
  		    {
! 		    InitKeyboardDeviceStruct(pDev, key_syms,
! 		 	the_modmap, hpBell, hpChangeKeyboardControl);
  		    get_pointerkeys();
  		    fix_modifierkeys();
  		    }
--- 666,677 ----
  		key_syms = &keysym_rec;
  		h->min_kcode = key_syms->minKeyCode;
  		h->max_kcode = key_syms->maxKeyCode;
! 		h->num_keys = key_syms->maxKeyCode - key_syms->minKeyCode + 1;
  		pHPDev->x_type = KEYBOARD;
  		if (dev->id == inputInfo.keyboard->id)
  		    {
! 		    InitKeyboardDeviceStruct(pDev, key_syms, the_modmap, hpBell,
! 			(KbdCtrlProcPtr) hpChangeKeyboardControl);
  		    get_pointerkeys();
  		    fix_modifierkeys();
  		    }
***************
*** 669,675 ****
  		    {
  		    InitKeyClassDeviceStruct (dev, key_syms, the_modmap);
  		    InitKbdFeedbackClassDeviceStruct (dev, hpBell,
! 			hpChangeKeyboardControl);
  		    InitFocusClassDeviceStruct (dev);
  		    }
  		}
--- 680,686 ----
  		    {
  		    InitKeyClassDeviceStruct (dev, key_syms, the_modmap);
  		    InitKbdFeedbackClassDeviceStruct (dev, hpBell,
! 			(KbdCtrlProcPtr) hpChangeKeyboardControl);
  		    InitFocusClassDeviceStruct (dev);
  		    }
  		}
***************
*** 678,684 ****
  		dev->id != inputInfo.keyboard->id)
  		{
  		LedFeedbackPtr led;
! 		InitLedFeedbackClassDeviceStruct(dev,hpChangeLedControl);
  		mask=0;
  		for (i=0; i<h->num_leds; i++)
  		    mask |= (1 << i);
--- 689,695 ----
  		dev->id != inputInfo.keyboard->id)
  		{
  		LedFeedbackPtr led;
! 		InitLedFeedbackClassDeviceStruct(dev,(LedCtrlProcPtr) hpChangeLedControl);
  		mask=0;
  		for (i=0; i<h->num_leds; i++)
  		    mask |= (1 << i);
***************
*** 697,721 ****
  		    j<serialprocs[i].num_fdbk; j++,ptrf++)
  		    if (*ptrf == IntegerFeedbackClass)
  			InitIntegerFeedbackClassDeviceStruct (
! 			    dev, hpChangeIntegerControl);
  		    else if (*ptrf == BellFeedbackClass)
  			InitBellFeedbackClassDeviceStruct (
! 			    dev, hpBell, hpChangeBellControl);
  		    else if (*ptrf == KbdFeedbackClass)
! 			InitKbdFeedbackClassDeviceStruct(
! 			    dev, hpBell, hpChangeKeyboardControl);
  		    else if (*ptrf == PtrFeedbackClass)
  			InitPtrFeedbackClassDeviceStruct(
! 			    dev, hpChangePointerControl);
  		for (j=0, ptrf=serialprocs[i].ledf; 
  		     j<serialprocs[i].num_ledf; j++,ptrf++)
! 		    InitLedFeedbackClassDeviceStruct ( dev, hpChangeLedControl);
  		for (j=0, ptrs=serialprocs[i].strf; 
  		     j<serialprocs[i].num_strf; j++, ptrs++)
  		    InitStringFeedbackClassDeviceStruct ( dev, 
! 			hpChangeStringControl, ptrs->max_symbols,
  			ptrs->num_symbols_supported,
! 			ptrs->symbols_supported);
  		}
  
  #endif /* XINPUT */
--- 708,733 ----
  		    j<serialprocs[i].num_fdbk; j++,ptrf++)
  		    if (*ptrf == IntegerFeedbackClass)
  			InitIntegerFeedbackClassDeviceStruct (
! 			    dev, (IntegerCtrlProcPtr) hpChangeIntegerControl);
  		    else if (*ptrf == BellFeedbackClass)
  			InitBellFeedbackClassDeviceStruct (
! 			    dev, hpBell, (BellCtrlProcPtr) hpChangeBellControl);
  		    else if (*ptrf == KbdFeedbackClass)
! 			InitKbdFeedbackClassDeviceStruct( dev, hpBell, 
! 			    (KbdCtrlProcPtr) hpChangeKeyboardControl);
  		    else if (*ptrf == PtrFeedbackClass)
  			InitPtrFeedbackClassDeviceStruct(
! 			    dev, (PtrCtrlProcPtr) hpChangePointerControl);
  		for (j=0, ptrf=serialprocs[i].ledf; 
  		     j<serialprocs[i].num_ledf; j++,ptrf++)
! 		    InitLedFeedbackClassDeviceStruct ( dev, (LedCtrlProcPtr) hpChangeLedControl);
  		for (j=0, ptrs=serialprocs[i].strf; 
  		     j<serialprocs[i].num_strf; j++, ptrs++)
  		    InitStringFeedbackClassDeviceStruct ( dev, 
! 			(StringCtrlProcPtr) hpChangeStringControl, 
! 			ptrs->max_symbols,
  			ptrs->num_symbols_supported,
! 			(KeySym *) ptrs->symbols_supported);
  		}
  
  #endif /* XINPUT */
***************
*** 744,750 ****
  		    smd_$set_unit_cursor_pos (1, pos, &status);
  #endif /* __apollo */
  		    InitPointerDeviceStruct (pDev, ptr_button_map, button_count,
! 			hpGetDeviceMotionEvents, hpChangePointerControl, 
  			    MOTION_BUFFER_SIZE);
  		    }
  #ifdef XINPUT
--- 756,762 ----
  		    smd_$set_unit_cursor_pos (1, pos, &status);
  #endif /* __apollo */
  		    InitPointerDeviceStruct (pDev, ptr_button_map, button_count,
! 			hpGetDeviceMotionEvents, (PtrCtrlProcPtr) hpChangePointerControl, 
  			    MOTION_BUFFER_SIZE);
  		    }
  #ifdef XINPUT
***************
*** 759,765 ****
  			hpGetDeviceMotionEvents, 100, 
  			(h->flags & HIL_ABSOLUTE)?1:0);
  		    InitPtrFeedbackClassDeviceStruct (dev, 
! 			hpChangePointerControl);
  		    }
  		InitValuatorAxisStruct (dev, 0, 0, (unsigned int) h->size_x, 
  		    (unsigned int) h->resx, 0, (unsigned int) h->resx);
--- 771,777 ----
  			hpGetDeviceMotionEvents, 100, 
  			(h->flags & HIL_ABSOLUTE)?1:0);
  		    InitPtrFeedbackClassDeviceStruct (dev, 
! 			(PtrCtrlProcPtr) hpChangePointerControl);
  		    }
  		InitValuatorAxisStruct (dev, 0, 0, (unsigned int) h->size_x, 
  		    (unsigned int) h->resx, 0, (unsigned int) h->resx);
***************
*** 807,812 ****
--- 819,825 ----
  	    if (dev->key) {
  		memset(dev->key->down, 0, DOWN_LENGTH);
  		dev->key->state = 0;
+ 		dev->key->prev_state = 0;
  	    }
  	    if (dev->id != inputInfo.pointer->id &&
  		pHPDev->file_ds == hpPointer->file_ds)
***************
*** 816,822 ****
  #ifndef __hp_osf
  		RemoveEnabledDevice(pHPDev->file_ds);
  #endif /* __hp_osf */
- 	        SetAutoRepeat(pHPDev, FALSE);
      	        close_device (pHPDev);
  		}
  	    break;
--- 829,834 ----
***************
*** 823,829 ****
  	case DEVICE_CLOSE: 
  	    if ( pHPDev != NULL && pHPDev->file_ds >= 0)
  		{
- 	        SetAutoRepeat(pHPDev, FALSE);
  #ifndef __hp_osf
  		RemoveEnabledDevice( pHPDev->file_ds);
  #endif /* __hp_osf */
--- 835,840 ----
***************
*** 860,866 ****
      {
      int	i, j;
      DeviceIntPtr x_init_device();
!     void CheckInput();
  
      mflg = (char *)getenv("XHPPRINTDEBUGMSG");
      x_axis = 0;
--- 871,877 ----
      {
      int	i, j;
      DeviceIntPtr x_init_device();
!     int CheckInput();
  
      mflg = (char *)getenv("XHPPRINTDEBUGMSG");
      x_axis = 0;
***************
*** 876,881 ****
--- 887,896 ----
  	identity_map[i]=i;
      for (i=0; i<NUM_DEV_TYPES; i++)
  	count[i] = 0;
+     if (din_mouse_present())
+ 	count[MOUSE]++;
+     if (din_kbd_present())
+ 	count[KEYBOARD]++;
      serial[XPOINTER].name[0]='\0';
      serial[XKEYBOARD].name[0]='\0';
      lockcode = 0;
***************
*** 906,913 ****
      AddEnabledDevice (beeper_fd);
  #endif /* __hp_osf */
  
!     RegisterBlockAndWakeupHandlers ((BlockHandlerProcPtr)NoopDDA,
! 				    CheckInput, NULL);
      loopnum = atoi(display);
      hilpath[0] = '\0';
      ldigit = '\0';
--- 921,929 ----
      AddEnabledDevice (beeper_fd);
  #endif /* __hp_osf */
  
!     RegisterBlockAndWakeupHandlers ((BlockHandlerProcPtr) NoopDDA, 
! 				    (WakeupHandlerProcPtr) CheckInput, 
! 				    (pointer) NULL);
      loopnum = atoi(display);
      hilpath[0] = '\0';
      ldigit = '\0';
***************
*** 915,923 ****
      init_l_devs ();
      init_events_queue ( &ev_queue);
  #if defined(__hpux)
!     if ((strcmp(uts_name.machine, "9000/7LC") != 0) &&
!         (strcmp(uts_name.machine, "9000/712") != 0))
! 	init_beeper();			/* beeper_fd = /dev/rhil */
  #endif /* __hpux */
  
      /*
--- 931,937 ----
      init_l_devs ();
      init_events_queue ( &ev_queue);
  #if defined(__hpux)
!     init_beeper();			/* beeper_fd = /dev/rhil */
  #endif /* __hpux */
  
      /*
***************
*** 965,972 ****
  	miRegisterPointerDevice(screenInfo.screens[0], pXDev);
  #endif
  	if (dev->x_type == KEYBOARD)
! 	    InitKbdFeedbackClassDeviceStruct ((DeviceIntPtr)pXDev, hpBell,
! 		hpChangeKeyboardControl);
  	screen_change_dev = (DeviceIntPtr) pXDev;
  	if (screen_change_amt == SCREEN_CHANGE_DEFAULT)
  	    if (dev->hil_header.flags & HIL_ABSOLUTE)
--- 979,986 ----
  	miRegisterPointerDevice(screenInfo.screens[0], pXDev);
  #endif
  	if (dev->x_type == KEYBOARD)
! 	    InitKbdFeedbackClassDeviceStruct ((DeviceIntPtr) pXDev, hpBell,
! 		(KbdCtrlProcPtr) hpChangeKeyboardControl);
  	screen_change_dev = (DeviceIntPtr) pXDev;
  	if (screen_change_amt == SCREEN_CHANGE_DEFAULT)
  	    if (dev->hil_header.flags & HIL_ABSOLUTE)
***************
*** 1027,1033 ****
  #endif /* __hpux */
  	}
  
!     sprintf(fname, "/usr/lib/X11/X%sdevices",display);
      fp = fopen ( fname, "r");
      if (fp) 
  	{
--- 1041,1047 ----
  #endif /* __hpux */
  	}
  
!     sprintf(fname, "%s/X%sdevices",LIBDIR,display);
      fp = fopen ( fname, "r");
      if (fp) 
  	{
***************
*** 1148,1153 ****
--- 1162,1170 ----
   *
   */
  
+ #define DEFAULT_DEV 	0
+ #define EXPLICIT_DEV	1
+ 
  #if defined(__hpux) || defined(__hp_osf)
  static int init_hil_devs (opendevs, numdev)
      struct	opendevs opendevs [];
***************
*** 1185,1200 ****
  	    {
  	    for (j=0; j<numdev; j++)
  		{
! 	        if ((d->dev_type==opendevs[j].type && 
! 		    count[d->dev_type]==opendevs[j].pos) ||
! 		    (opendevs[j].type == -1 &&
  		     strcmp (opendevs[j].path, d->dev_name) == 0))
  		    {
  		    d->hpflags |= OPEN_THIS_DEVICE;
! 		    if (j==XKEYBOARD && hpKeyboard==NULL)
  			hpKeyboard = d;
! 		    else if (j==XPOINTER && hpPointer==NULL)
  			hpPointer = d;
  		    else
  			{
  			d->hpflags |= MERGED_DEVICE;
--- 1202,1221 ----
  	    {
  	    for (j=0; j<numdev; j++)
  		{
! 	        if ((d->dev_type == opendevs[j].type && 
! 		     count[d->dev_type]==opendevs[j].pos) ||
! 		    (opendevs[j].type == -1 && 
  		     strcmp (opendevs[j].path, d->dev_name) == 0))
  		    {
  		    d->hpflags |= OPEN_THIS_DEVICE;
! 		    if (j==XKEYBOARD && hpKeyboard==NULL){
  			hpKeyboard = d;
! 			hpKeyboard->pad2 = EXPLICIT_DEV;
! 			}
! 		    else if (j==XPOINTER && hpPointer==NULL){
  			hpPointer = d;
+ 			hpPointer->pad2 = EXPLICIT_DEV;
+ 			}
  		    else
  			{
  			d->hpflags |= MERGED_DEVICE;
***************
*** 1236,1241 ****
--- 1257,1263 ----
  	    }
  	hpKeyboard->hpflags |= OPEN_THIS_DEVICE;
  	hpKeyboard->hpflags &= ~MERGED_DEVICE;
+ 	hpKeyboard->pad2 = DEFAULT_DEV;
  	}
  
      if (hpPointer==NULL)
***************
*** 1248,1253 ****
--- 1270,1276 ----
  	    hpPointer = hpKeyboard;
  	hpPointer->hpflags |= OPEN_THIS_DEVICE;
  	hpPointer->hpflags &= ~MERGED_DEVICE;
+ 	hpPointer->pad2 = DEFAULT_DEV;
  	}
  
      if (hpPointer == hpKeyboard)
***************
*** 1318,1325 ****
      {
  
  #if defined(__hp9000s300) || defined(__hp9000s700)
!     if ((beeper_fd = open(BEEPER_DEVICE,O_RDWR)) < 0)
!  	ErrorF ("Unable to open beeper device \"%s\".\n",BEEPER_DEVICE);
  #endif /*__hp9000s300 or __hp9000s700 */
  
  #if defined(__hp9000s800) && !defined(__hp9000s700)
--- 1341,1351 ----
      {
  
  #if defined(__hp9000s300) || defined(__hp9000s700)
!     if ((beeper_fd = open(BEEPER_DEVICE,O_RDWR)) < 0 &&
! 	((beeper_fd = open("/dev/beep",O_RDWR)) < 0) &&
! 	((strcmp(uts_name.machine, "9000/7LC") != 0) &&
! 	 (strcmp(uts_name.machine, "9000/712") != 0)))
!  	    ErrorF ("Unable to open beeper device \"%s\".\n",BEEPER_DEVICE);
  #endif /*__hp9000s300 or __hp9000s700 */
  
  #if defined(__hp9000s800) && !defined(__hp9000s700)
***************
*** 1701,1707 ****
  
  /********************************************************************
   *
!  * If the file "/usr/lib/X11/X[display#]devices exists, this routine 
   * processes it.
   * It translates the strings in the file to a device type and relative
   * position on the HIL.
--- 1727,1733 ----
  
  /********************************************************************
   *
!  * If the file LIBDIR/X[display#]devices exists, this routine 
   * processes it.
   * It translates the strings in the file to a device type and relative
   * position on the HIL.
***************
*** 1981,1997 ****
   *
   */
  
! static get_codes (key, code, type)
      char	*key;
      int		*code;
      int		type;
      {
-     char	keybuf[256];
      int		i;
      KeySym	sym;
  
!     for (i=0; i<strlen(key); i++)
! 	keybuf[i] = toupper(key[i]);
  
      if (type == UCHAR_NUMBER || type == USHORT_NUMBER || type == UINT_NUMBER)
  	{
--- 2007,2024 ----
   *
   */
  
! static get_codes (key, code, type, makeupper)
      char	*key;
      int		*code;
      int		type;
+     Bool	makeupper;
      {
      int		i;
      KeySym	sym;
  
!     if (makeupper)
! 	for (i=0; i<strlen(key); i++)
! 	    *(key+i) = toupper(*(key+i));
  
      if (type == UCHAR_NUMBER || type == USHORT_NUMBER || type == UINT_NUMBER)
  	{
***************
*** 2000,2012 ****
  	}
      else if (type == STRING)
  	for (i=0; i<MAX_STRINGS; i++)
! 	    if (strcmp (keybuf, strings[i].string) == 0)
  		{
  		*code = strings[i].value;
  		return (0);
  		}
      for (i=0; keyset1[i].keystr; i++)
!         if (strcmp (keybuf, keyset1[i].keystr) == 0)
  	    break;
      if (!inputInfo.keyboard)
  	return(0);
--- 2027,2039 ----
  	}
      else if (type == STRING)
  	for (i=0; i<MAX_STRINGS; i++)
! 	    if (strcmp (key, strings[i].string) == 0)
  		{
  		*code = strings[i].value;
  		return (0);
  		}
      for (i=0; keyset1[i].keystr; i++)
!         if (strcmp (key, keyset1[i].keystr) == 0)
  	    break;
      if (!inputInfo.keyboard)
  	return(0);
***************
*** 2105,2130 ****
  	} codevar;
  
      if (inputInfo.keyboard) {
! 	get_codes ("keypad_2", &code, KEY);
  	cursor_down = (unsigned char) code;
! 	get_codes ("keypad_5", &code, KEY);
  	cursor_up = (unsigned char) code;
! 	get_codes ("keypad_1", &code, KEY);
  	cursor_left = (unsigned char) code;
! 	get_codes ("keypad_3", &code, KEY);
  	cursor_right = (unsigned char) code;
! 	get_codes ("keypad_*", &code, KEY);
  	button_1 = (unsigned char) code;
! 	get_codes ("keypad_/", &code, KEY);
  	button_2 = (unsigned char) code;
! 	get_codes ("keypad_+", &code, KEY);
  	button_3 = (unsigned char) code;
! 	get_codes ("keypad_-", &code, KEY);
  	button_4 = (unsigned char) code;
! 	get_codes ("keypad_7", &code, KEY);
  	button_5 = (unsigned char) code;
  	}
!     sprintf(fname, "/usr/lib/X11/X%spointerkeys",display);
      fp = fopen ( fname, "r");
      if (fp == NULL)
  	return;
--- 2132,2157 ----
  	} codevar;
  
      if (inputInfo.keyboard) {
! 	get_codes ("KEYPAD_2", &code, KEY, FALSE);
  	cursor_down = (unsigned char) code;
! 	get_codes ("KEYPAD_5", &code, KEY, FALSE);
  	cursor_up = (unsigned char) code;
! 	get_codes ("KEYPAD_1", &code, KEY, FALSE);
  	cursor_left = (unsigned char) code;
! 	get_codes ("KEYPAD_3", &code, KEY, FALSE);
  	cursor_right = (unsigned char) code;
! 	get_codes ("KEYPAD_*", &code, KEY, FALSE);
  	button_1 = (unsigned char) code;
! 	get_codes ("KEYPAD_/", &code, KEY, FALSE);
  	button_2 = (unsigned char) code;
! 	get_codes ("KEYPAD_+", &code, KEY, FALSE);
  	button_3 = (unsigned char) code;
! 	get_codes ("KEYPAD_-", &code, KEY, FALSE);
  	button_4 = (unsigned char) code;
! 	get_codes ("KEYPAD_7", &code, KEY, FALSE);
  	button_5 = (unsigned char) code;
  	}
!     sprintf(fname, "%s/X%spointerkeys",LIBDIR,display);
      fp = fopen ( fname, "r");
      if (fp == NULL)
  	return;
***************
*** 2147,2153 ****
  		    function);
  		continue;		/* error - skip this one*/
  		}
! 	    cret = get_codes (key, &code, pointerfunc[index].type);
  	    if (cret < 0 &&		/* not a key or modifier*/
  	        pointerfunc[index].type == KEY) /* but must be  */
  		{
--- 2174,2180 ----
  		    function);
  		continue;		/* error - skip this one*/
  		}
! 	    cret = get_codes (key, &code, pointerfunc[index].type, TRUE);
  	    if (cret < 0 &&		/* not a key or modifier*/
  	        pointerfunc[index].type == KEY) /* but must be  */
  		{
***************
*** 2198,2211 ****
--- 2225,2241 ----
  #ifdef XINPUT
      if (pHPDev == hpPointer)
  	{
+ 	hp_device_ids[pHPDev->dev_id] = XPOINTER;
  	x_device_ids[XPOINTER] = pHPDev->dev_id;
  	}
      else if (pHPDev == hpKeyboard)
  	{
+ 	hp_device_ids[pHPDev->dev_id] = XKEYBOARD;
  	x_device_ids[XKEYBOARD] = pHPDev->dev_id;
  	}
      else
  	{
+ 	hp_device_ids[pHPDev->dev_id] = otherndx;
  	x_device_ids[otherndx++] = pHPDev->dev_id;
  	}
  #endif /* XINPUT */
***************
*** 2220,2226 ****
   *
   */
  
- Bool
  LegalModifier(key, dev)
      unsigned int key;
      DevicePtr dev;
--- 2250,2255 ----
***************
*** 2336,2348 ****
  
  extern int apLeave_X, apReenter_X;      /*  in hp/apollo/apInit2.c */
  
! void
! CheckInput (data, result, selmask)
      pointer data;
!     int result;
!     pointer selmask;
      {
-     long *LastSelectMask = (long*)selmask;
      long devicesReadable[mskcnt];
      extern long EnabledDevices[];
      extern Bool	display_borrowed;	/* in x_hil.c */
--- 2365,2375 ----
  
  extern int apLeave_X, apReenter_X;      /*  in hp/apollo/apInit2.c */
  
! CheckInput (data, result, LastSelectMask)
      pointer data;
!     unsigned long result;
!     long LastSelectMask[];
      {
      long devicesReadable[mskcnt];
      extern long EnabledDevices[];
      extern Bool	display_borrowed;	/* in x_hil.c */
***************
*** 2414,2419 ****
--- 2441,2449 ----
  
      if (old->hpflags & OPEN_THIS_DEVICE)
  	old->hpflags &= ~OPEN_THIS_DEVICE;
+     tmp = hp_device_ids[new_dev->id];
+     hp_device_ids[new_dev->id] = XKEYBOARD;
+     hp_device_ids[old_dev->id] = tmp;
      x_device_ids[XKEYBOARD] = new_dev->id;
      x_device_ids[tmp] = old->dev_id;
      hpKeyboard = new;
***************
*** 2445,2450 ****
--- 2475,2483 ----
  	old->hpflags &= ~OPEN_THIS_DEVICE;
  
      screen_change_dev = new_dev;
+     tmp = hp_device_ids[new_dev->id];
+     hp_device_ids[new_dev->id] = XPOINTER;
+     hp_device_ids[old_dev->id] = tmp;
      x_device_ids[XPOINTER] = new_dev->id;
      x_device_ids[tmp] = old->dev_id;
      hpPointer = new;
***************
*** 2551,2557 ****
      new_client->count = 1;
      new_client->mode = token;
  
!     AddResource(new_client->resource, HPType, (pointer)id);
      }
  
  
--- 2584,2590 ----
      new_client->count = 1;
      new_client->mode = token;
  
!     AddResource((XID) new_client->resource, (RESTYPE) HPType, (pointer) id);
      }
  
  
***************
*** 2953,2998 ****
      shl_t ldr_module_id;
      long ldr_module_entry;
      int ret_val;
!     char driver_path[255];
!     char driver_init[255];
  
-     if (count[KEYBOARD] == opendevs[XPOINTER].pos && 
- 	opendevs[XPOINTER].use == XPOINTER &&
- 	opendevs[XPOINTER].type == KEYBOARD)
- 	keyboard_is_pointer = TRUE;
     /*
!     * See if this is a hp90007LC.  If so, we need to load a serial driver
!     * for the keyboard and mouse.
      *
      */
  
!     if ((strcmp(uts_name.machine, "9000/7LC") == 0) ||
!         (strcmp(uts_name.machine, "9000/712") == 0)) {
! 	if (!keyboard_is_pointer && serial[XPOINTER].name[0] == '\0') {
! 	    sndx = XPOINTER;
! 	    serial[sndx].use = XPOINTER;
! 	}
! 	else {
! 	    sndx = numdev++;
! 	    serial[sndx].use = XOTHER+1;
! 	}
! 	strcpy (serial[sndx].name, "hp7lc2m.sl");
! 	strcpy (serial[sndx].entry, "hp7lc2m_Init");
! 	strcpy (serial[sndx].path, "/dev/ps2mouse");
  
- 	if (serial[XKEYBOARD].name[0]=='\0') {
- 	    sndx = XKEYBOARD;
- 	    serial[sndx].use = XKEYBOARD;
- 	}
- 	else {
- 	    sndx = numdev++;
- 	    serial[sndx].use = XOTHER+1;
- 	}
- 	strcpy (serial[sndx].name, "hp7lc2k.sl");
- 	strcpy (serial[sndx].entry, "hp7lc2k_Init");
- 	strcpy (serial[sndx].path, "/dev/ps2kbd");
-     }
- 
     /*
      * For each device, 
      *     1). find an available device private struct,
--- 2986,3002 ----
      shl_t ldr_module_id;
      long ldr_module_entry;
      int ret_val;
!     char driver_path[255], driver_init[255];
  
     /*
!     * See if we can access a DIN mouse and keyboard.  If so, we need to load
!     * a driver to support them.
      *
      */
  
!     find_din_kbd_use(opendevs, &keyboard_is_pointer, &numdev, &sndx);
!     find_din_mouse_use(&keyboard_is_pointer, &numdev, &sndx);
  
     /*
      * For each device, 
      *     1). find an available device private struct,
***************
*** 3006,3012 ****
  	if (!serial[i].name[0])
  	    continue;
  
! 	strcpy (driver_path, "/usr/lib/X11/extensions/");
  	strcat (driver_path, serial[i].name);
  #if defined(__hp9000s300)
  	strcpy (driver_init, "_");
--- 3010,3016 ----
  	if (!serial[i].name[0])
  	    continue;
  
! 	strcpy (driver_path, DRVRLIBDIR);
  	strcat (driver_path, serial[i].name);
  #if defined(__hp9000s300)
  	strcpy (driver_init, "_");
***************
*** 3028,3035 ****
  
  	    if ( ldr_module_id == NULL ) 
  		{
! 		ErrorF ("Failed to load serial input device driver %s\n",
! 		    driver_path);
  		ErrorF ("Check spelling and case of device name.\n");
  		continue;
  		}
--- 3032,3039 ----
  
  	    if ( ldr_module_id == NULL ) 
  		{
! 		ErrorF ("Failed to load serial input device driver %s, errno %d\n",
! 		    driver_path, errno);
  		ErrorF ("Check spelling and case of device name.\n");
  		continue;
  		}
***************
*** 3075,3082 ****
  	if ((*(serialprocs[sndx].configure))(&dhdr) == INIT_SUCCESS)
  	    {
  
! 	    for (k=0; l_devs[k].hil_header.id != 1 && k<MAX_DEVICES-1; k++)
  	        ;
  	    serialprocs[sndx].fd = dhdr.file_ds;
  	    serialprocs[sndx].keymap_name = dhdr.keymap_name;
  	    serialprocs[sndx].keymap_file = dhdr.keymap_file;
--- 3079,3089 ----
  	if ((*(serialprocs[sndx].configure))(&dhdr) == INIT_SUCCESS)
  	    {
  
! 	    for (k=MAX_DEVICES-1; l_devs[k].hil_header.id != 1 && k>=0; k--)
  	        ;
+ 	    if (k<0)
+ 	        for (k=MAX_DEVICES-1; (l_devs[k].hpflags & OPEN_THIS_DEVICE) && k>=0; k--)
+ 	        ;
  	    serialprocs[sndx].fd = dhdr.file_ds;
  	    serialprocs[sndx].keymap_name = dhdr.keymap_name;
  	    serialprocs[sndx].keymap_file = dhdr.keymap_file;
***************
*** 3086,3093 ****
  	    serialprocs[sndx].num_strf = dhdr.num_strf;
  	    serialprocs[sndx].ledf = dhdr.ledf;
  	    serialprocs[sndx].num_ledf = dhdr.num_ledf;
! 	    strcpy(l_devs[k].x_name,"FIRST_");
! 	    strcat(l_devs[k].x_name, dhdr.x_name);
  	    l_devs[k].x_atom = MakeAtom (dhdr.x_name, strlen(dhdr.x_name),0);
  	    if (!l_devs[k].x_atom)
  	        l_devs[k].x_atom = MakeAtom(dhdr.x_name, strlen(dhdr.x_name),1);
--- 3093,3099 ----
  	    serialprocs[sndx].num_strf = dhdr.num_strf;
  	    serialprocs[sndx].ledf = dhdr.ledf;
  	    serialprocs[sndx].num_ledf = dhdr.num_ledf;
! 	    strcpy(l_devs[k].x_name, dhdr.x_name);
  	    l_devs[k].x_atom = MakeAtom (dhdr.x_name, strlen(dhdr.x_name),0);
  	    if (!l_devs[k].x_atom)
  	        l_devs[k].x_atom = MakeAtom(dhdr.x_name, strlen(dhdr.x_name),1);
***************
*** 3155,3163 ****
  		serial[i].name);
  	}
      if (!hpPointer)
! 	FatalError ("Couldn't open X pointer device!\n");
      if (!hpKeyboard)
! 	FatalError ("Couldn't open X keyboard!\n");
      }
  
  #define DYNAMIC_DEVICE 	0xffff
--- 3161,3169 ----
  		serial[i].name);
  	}
      if (!hpPointer)
! 	FatalError ("Couldn't open X pointer device!  Is there one attached?\n");
      if (!hpKeyboard)
! 	FatalError ("Couldn't open X keyboard!  Is there one attached?\n");
      }
  
  #define DYNAMIC_DEVICE 	0xffff
***************
*** 3201,3203 ****
--- 3207,3407 ----
   d->hil_header.id = 0;
   d->id_detail &= ~HP_HIL;
  }
+ /******************************************************************************
+  *
+  * shl_driver_load() is passed the path of a shared library to load, and the
+  * name of an entry point to find.  It loads the library and returns the 
+  * entry point address.
+  */
+ 
+ Bool (*shl_driver_load( driver_path, driver_init ))()
+ char *driver_path, *driver_init;
+ {
+    /*
+     * pfrb = pointer to a function returning a Bool
+     */
+    typedef Bool (*pfrb)();
+ 
+    shl_t            ldr_module_id;
+    long             ldr_module_entry=0;
+    int              ret_val;
+    char             *dummy_handle = NULL;
+ #define ALL_SHLIBS_HANDLE &dummy_handle
+ 
+    /**********************************************************************
+     *
+     * If the driver entrypoint is already visible within the current program,
+     * skip the load and return the address of the routine we already have
+     * loaded.
+     *
+     */
+ 
+    ret_val = shl_findsym((shl_t *) PROG_HANDLE, driver_init, 
+        TYPE_PROCEDURE, &ldr_module_entry );
+    if ( ! ret_val ) {
+       return( (pfrb) ldr_module_entry );
+    }
+ 
+    /*
+     * If the driver entrypoint is already visible within a shared library we
+     * are already accessing, skip the load and return the address.
+     */
+    ret_val = shl_findsym((shl_t *) ALL_SHLIBS_HANDLE, driver_init,
+ 	TYPE_PROCEDURE, &ldr_module_entry );
+    if ( ! ret_val ) {
+       return( (pfrb) ldr_module_entry );
+    }
+ 
+ 
+    /**********************************************************************
+     *
+     * Load driver into the current VA space.
+     */
+    ldr_module_id = shl_load( driver_path, (BIND_IMMEDIATE | BIND_VERBOSE), 0L );
+ 
+    if ( ldr_module_id == NULL )
+ 	FatalError ("X server failed to load shared library %s, errno is %d\n", 
+ 	driver_path,errno);
+ 
+ 
+    /**********************************************************************
+     *
+     * Use the module ID to find the address of the requested entry point.
+     */
+ 
+    ret_val = shl_findsym( &ldr_module_id, driver_init, TYPE_PROCEDURE,
+                           &ldr_module_entry );
+    if (ret_val && driver_init != NULL)
+ 	FatalError ("X server couldn't find entry point '%s' in library %s\n",
+ 	    driver_init, driver_path);
+ 
+    return( (pfrb) ldr_module_entry );
+ }
+ 
+ /***********************************************************************
+  *
+  * din_mouse_present
+  *
+  */
+ 
+ static Bool
+ din_mouse_present()
+     {
+     int fd;
+     unsigned char cmdbuf[2];
+ 
+     fd = open("/dev/ps2mouse", O_RDWR);
+     ioctl (fd, PS2_PORTSTAT, &cmdbuf[0]);
+     ioctl (fd, PS2_IDENT, &cmdbuf[1]);
+     close (fd);
+     if (cmdbuf[0] != 1 || cmdbuf[1] != 0)
+ 	return FALSE;
+     return TRUE;
+     }
+ 
+ /***********************************************************************
+  *
+  * find_din_mouse_use
+  *
+  */
+ 
+ find_din_mouse_use(keyboard_is_pointer, numdev, sndx)
+     int *keyboard_is_pointer, *numdev, *sndx;
+     {
+ 
+     if (!din_mouse_present())          		/* no DIN mouse attached */
+ 	{
+ 	if (!hpPointer || 			/* no HIL pointer device */
+ 	     (hpPointer->dev_type != MOUSE &&	/* or it's not a motion device  */
+ 	     hpPointer->pad2 != EXPLICIT_DEV))	/* and not explicitly specified */
+ 	    *keyboard_is_pointer = TRUE;
+ 	return;
+ 	}
+ 
+     if ((serial[XPOINTER].name[0] != '\0') || 	   /* RS232 pointer specified */
+ 	(hpPointer && hpPointer->pad2 == EXPLICIT_DEV)||/* HIL ptr specified  */
+ 	*keyboard_is_pointer)
+ 	{
+ 	*sndx = (*numdev)++;
+ 	serial[*sndx].use = XOTHER+1;
+ 	}
+     else
+ 	{
+ 	*sndx = XPOINTER;
+ 	serial[*sndx].use = XPOINTER;
+ 	}
+     strcpy (serial[*sndx].name, "hp7lc2m.sl");
+     strcpy (serial[*sndx].entry, "hp7lc2m_Init");
+     strcpy (serial[*sndx].path, "/dev/ps2mouse");
+     }
+ 
+ /***********************************************************************
+  *
+  * din_kbd_present
+  *
+  */
+ 
+ static Bool
+ din_kbd_present()
+     {
+     int fd;
+     unsigned char cmdbuf[2];
+ 
+     fd = open("/dev/ps2kbd", O_RDWR);
+     ioctl (fd, PS2_PORTSTAT, &cmdbuf[0]);
+     ioctl (fd, PS2_IDENT, &cmdbuf[1]);
+     close (fd);
+     if (cmdbuf[0]!=2 && cmdbuf[1]!=0xab && cmdbuf[2]!=0x83) /* no DIN kbd  */
+ 	return FALSE;
+     return TRUE;
+     }
+ 
+ /***********************************************************************
+  *
+  * find_din_kbd_use
+  *
+  */
+ 
+ find_din_kbd_use(opendevs, keyboard_is_pointer, numdev, sndx)
+     struct	opendevs opendevs [];
+     int *keyboard_is_pointer, *numdev, *sndx;
+     {
+ 
+     if (!din_kbd_present())				/* no DIN kbd  */
+ 	return;
+ 
+     if ((serial[XKEYBOARD].name[0]!='\0') ||           /* RS232 kbd specified */
+ 	(hpKeyboard && hpKeyboard->pad2 == EXPLICIT_DEV))/* HIL kbd specified */
+ 	{
+ 	*sndx = (*numdev)++;
+ 	serial[*sndx].use = XOTHER+1;
+ 	}
+     else
+ 	{
+ 	*sndx = XKEYBOARD;
+ 	serial[*sndx].use = XKEYBOARD;
+ 	}
+     if (opendevs[XPOINTER].type == KEYBOARD && opendevs[XPOINTER].pos == 0)
+ 	*keyboard_is_pointer = TRUE;
+ 
+     strcpy (serial[*sndx].name, "hp7lc2k.sl");
+     strcpy (serial[*sndx].entry, "hp7lc2k_Init");
+     strcpy (serial[*sndx].path, "/dev/ps2kbd");
+     }
+ 
+ char *x_basename (name)
+     char *name;
+     {
+     int i;
+     char *nptr = strchr (name, '_');
+     char *ordinal[] = {"FIRST", "SECOND", "THIRD", "FOURTH", "FIFTH", "SIXTH", 
+ 	"SEVENTH"};
+ 
+     if (!nptr)
+ 	return (name);
+ 
+     for (i=0; i<7; i++)
+ 	if (!strncmp(name, ordinal[i], strlen(ordinal[i])))
+ 	    return(++nptr);
+     return (name);
+     }
*** /tmp/da17189	Sun Jun  5 18:27:52 1994
--- xc/programs/Xserver/hw/hp/ngle/dregs.h	Sun Jun  5 18:27:51 1994
***************
*** 1,4 ****
! /* $XConsortium: dregs.h,v 1.1 93/08/08 12:56:22 rws Exp $ */
  /*************************************************************************
   * 
   * (c)Copyright 1992 Hewlett-Packard Co.,  All Rights Reserved.
--- 1,4 ----
! /* $XConsortium: dregs.h,v 1.2 94/05/28 15:45:25 dpw Exp $ */
  /*************************************************************************
   * 
   * (c)Copyright 1992 Hewlett-Packard Co.,  All Rights Reserved.
***************
*** 87,96 ****
      long int pad17[62];
      dreg_cplx_t reg17;
      dreg_cplx_t reg18;
!     long int pad19[62];
      dreg_cplx_t reg19;
      long int pad20[1];
      dreg_cplx_t reg20;
      long int pad21[3];
      dreg_cplx_t reg21;
  } ngle_dregs_t;
--- 87,100 ----
      long int pad17[62];
      dreg_cplx_t reg17;
      dreg_cplx_t reg18;
!     long int pad18[4];
!     unsigned long int reg26;
!     long int pad19[57];
      dreg_cplx_t reg19;
      long int pad20[1];
      dreg_cplx_t reg20;
      long int pad21[3];
      dreg_cplx_t reg21;
+     long int pad22[59];
+     dreg_cplx_t reg27;
  } ngle_dregs_t;
*** /tmp/da17205	Sun Jun  5 18:27:53 1994
--- xc/programs/Xserver/hw/hp/ngle/ngle.h	Sun Jun  5 18:27:53 1994
***************
*** 1,4 ****
! /* $XConsortium: ngle.h,v 1.1 93/08/08 12:56:28 rws Exp $ */
  /*************************************************************************
   * 
   * (c)Copyright 1992 Hewlett-Packard Co.,  All Rights Reserved.
--- 1,4 ----
! /* $XConsortium: ngle.h,v 1.2 94/05/28 15:45:30 dpw Exp $ */
  /*************************************************************************
   * 
   * (c)Copyright 1992 Hewlett-Packard Co.,  All Rights Reserved.
***************
*** 94,99 ****
--- 94,103 ----
  
  #   ifndef CRX24_OVERLAY_PLANES		/* Overlay planes on CRX24 */
  #       define CRX24_OVERLAY_PLANES	0x920825AA
+ #   endif
+ 
+ #   ifndef S9000_ID_ARTIST		/* Artist (Gecko) Graphics */
+ #       define S9000_ID_ARTIST          0x2B4DED6D
  #   endif
  
  #define hpGivingUp  (dispatchException & DE_TERMINATE)
*** /tmp/da17221	Sun Jun  5 18:27:55 1994
--- xc/programs/Xserver/hw/hp/ngle/nglecursor.c	Sun Jun  5 18:27:54 1994
***************
*** 1,4 ****
! /* $XConsortium: nglecursor.c,v 1.1 93/08/08 12:57:08 rws Exp $ */
  
  /*************************************************************************
   * 
--- 1,4 ----
! /* $XConsortium: nglecursor.c,v 1.2 94/05/28 15:45:31 dpw Exp $ */
  
  /*************************************************************************
   * 
***************
*** 251,256 ****
--- 251,257 ----
      Card32		cursorXYValue = 0;  
      int 		nTopPadLines = 0;
      int 		nBotPadLines = 0;
+     Int32		hbp_times_vi;
  
  
  
***************
*** 471,480 ****
       * all cursor position information except the number
       * of scanlines hidden.
       */
!     xHi = (x0 / pScreenPriv->sprite.videoInterleave) 
! 	+ pScreenPriv->sprite.horizBackPorch
! 	- pScreenPriv->sprite.pipelineDelay;
!     xLo = x0 % pScreenPriv->sprite.videoInterleave;
  	    
      /* if y0 < 0, y0 has already been set to 0 above */
      cursorXYValue = 
--- 472,492 ----
       * all cursor position information except the number
       * of scanlines hidden.
       */
!     if (pScreenPriv->deviceID != S9000_ID_ARTIST)
!     {
! 	xHi = (x0 / pScreenPriv->sprite.videoInterleave)
! 	    + pScreenPriv->sprite.horizBackPorch
! 	    - pScreenPriv->sprite.pipelineDelay;
! 	xLo = x0 % pScreenPriv->sprite.videoInterleave;
!     }
!     else
!     {
! 	hbp_times_vi = (pScreenPriv->sprite.horizBackPorch *
! 			pScreenPriv->sprite.videoInterleave);
! 	xHi = ((x0 + hbp_times_vi) / pScreenPriv->sprite.videoInterleave)
! 			- pScreenPriv->sprite.pipelineDelay;
! 	xLo = (x0 + hbp_times_vi) % pScreenPriv->sprite.videoInterleave;
!     }
  	    
      /* if y0 < 0, y0 has already been set to 0 above */
      cursorXYValue = 
***************
*** 642,648 ****
  			    pScreenPriv->sprite.videoInterleave);
  	    xHi = ((x0 + hbp_times_vi) / pScreenPriv->sprite.videoInterleave)
  		- pScreenPriv->sprite.pipelineDelay;
! 	    xLo = x0 % pScreenPriv->sprite.videoInterleave;
  
  	    /* if y0 < 0, y0 has already been set to 0 above */
      	    cursorXYValue = 
--- 654,663 ----
  			    pScreenPriv->sprite.videoInterleave);
  	    xHi = ((x0 + hbp_times_vi) / pScreenPriv->sprite.videoInterleave)
  		- pScreenPriv->sprite.pipelineDelay;
! 	    if (pScreenPriv->deviceID != S9000_ID_ARTIST)
! 		xLo = x0 % pScreenPriv->sprite.videoInterleave;
! 	    else
! 		xLo = (x0 + hbp_times_vi) % pScreenPriv->sprite.videoInterleave;
  
  	    /* if y0 < 0, y0 has already been set to 0 above */
      	    cursorXYValue = 
*** /tmp/da17237	Sun Jun  5 18:27:57 1994
--- xc/programs/Xserver/hw/hp/ngle/nglehdw.h	Sun Jun  5 18:27:56 1994
***************
*** 1,4 ****
! /* $XConsortium: nglehdw.h,v 1.1 93/08/08 12:57:34 rws Exp $ */
  
  /*************************************************************************
   * 
--- 1,4 ----
! /* $XConsortium: nglehdw.h,v 1.2 94/05/28 15:45:32 dpw Exp $ */
  
  /*************************************************************************
   * 
***************
*** 44,51 ****
--- 44,53 ----
  #define SETUP_FB(pDregs,ID, depth) {					\
  	    SETUP_HW(pDregs);						\
  	    switch (ID) {						\
+ 		case S9000_ID_ARTIST:					\
  		case S9000_ID_A1659A:					\
      		    (pDregs)->reg10 = 0x13601000;			\
+ 		    break;						\
  		case S9000_ID_A1439A:					\
      		    if (depth == 24)					\
  		        (pDregs)->reg10 = 0xBBA0A000;			\
***************
*** 78,84 ****
  
  #define FINISH_CURSOR_COLORMAP_ACCESS(pDregs,ID,depth) {		\
  	    (pDregs)->reg2 = 0;						\
! 	    (pDregs)->reg1 = 0x80008004;				\
  	    SETUP_FB(pDregs,ID,depth);					\
  	}
  
--- 80,89 ----
  
  #define FINISH_CURSOR_COLORMAP_ACCESS(pDregs,ID,depth) {		\
  	    (pDregs)->reg2 = 0;						\
! 	    if (ID == S9000_ID_ARTIST)					\
! 		(pDregs)->reg26 = 0x80008004;				\
! 	    else							\
! 		(pDregs)->reg1 = 0x80008004;				\
  	    SETUP_FB(pDregs,ID,depth);					\
  	}
  
***************
*** 100,106 ****
  	    if (depth == 24)						\
      		(pDregs)->reg1 = 0x83000100;				\
      	    else  /* depth = 8 */					\
! 	        (pDregs)->reg1 = 0x80000100;				\
  	    SETUP_FB(pDregs,ID,depth);					\
  	}
  
--- 105,116 ----
  	    if (depth == 24)						\
      		(pDregs)->reg1 = 0x83000100;				\
      	    else  /* depth = 8 */					\
! 	    {								\
! 		if (ID == S9000_ID_ARTIST)				\
! 		    (pDregs)->reg26 = 0x80000100;			\
! 		else							\
! 		    (pDregs)->reg1 = 0x80000100;			\
! 	    }								\
  	    SETUP_FB(pDregs,ID,depth);					\
  	}
  
***************
*** 107,113 ****
  #define GET_CURSOR_SPECS(pDregs,pScreenPriv) {				      \
  	    Card32 activeLinesHi, activeLinesLo;			      \
  									      \
! 	    (pScreenPriv)->sprite.horizBackPorch = (pDregs)->reg19.b.b1;      \
  	    activeLinesLo   = (pDregs)->reg20.b.b0;		      	      \
  	    activeLinesHi   = ((pDregs)->reg21.b.b2) & 0xf;		      \
  	    (pScreenPriv)->sprite.maxYLine = ((activeLinesHi << 8)	      \
--- 117,128 ----
  #define GET_CURSOR_SPECS(pDregs,pScreenPriv) {				      \
  	    Card32 activeLinesHi, activeLinesLo;			      \
  									      \
! 	    if ((pScreenPriv)->deviceID != S9000_ID_ARTIST)		      \
! 		(pScreenPriv)->sprite.horizBackPorch = (pDregs)->reg19.b.b1;  \
! 	    else							      \
! 		(pScreenPriv)->sprite.horizBackPorch = (pDregs)->reg19.b.b1 + \
! 						       (pDregs)->reg19.b.b2 + \
! 						       2;		      \
  	    activeLinesLo   = (pDregs)->reg20.b.b0;		      	      \
  	    activeLinesHi   = ((pDregs)->reg21.b.b2) & 0xf;		      \
  	    (pScreenPriv)->sprite.maxYLine = ((activeLinesHi << 8)	      \
***************
*** 155,161 ****
  		    (pScreenPriv)->sprite.enabledCursorXYValue;		\
  									\
  	    SETUP_HW((pScreenPriv)->pDregs);				\
! 	    *pDregsCursorXY = (enabledCursorValue & 0xe007ffff);	\
  	}
  
  #define GET_ROMTABLE_INDEX(romTableIdx) {				\
--- 170,180 ----
  		    (pScreenPriv)->sprite.enabledCursorXYValue;		\
  									\
  	    SETUP_HW((pScreenPriv)->pDregs);				\
! 	    if ((pScreenPriv)->deviceID != S9000_ID_ARTIST)		\
! 		*pDregsCursorXY = (enabledCursorValue & 0xe007ffff);	\
! 	    else							\
! 		(pScreenPriv)->pDregs->reg18.all =			\
! 			(enabledCursorValue & 0x0000003f);		\
  	}
  
  #define GET_ROMTABLE_INDEX(romTableIdx) {				\
***************
*** 233,242 ****
--- 252,284 ----
  	    *(pAuxControlSpace+2) = 0x30000000;				\
  	}
  
+ #define ARTIST_ENABLE_DISPLAY(pDregs) {					\
+ 	    volatile unsigned long *pDregsMiscVideo = 			\
+ 		    &((pDregs)->reg21.all);				\
+ 	    volatile unsigned long *pDregsMiscCtl = 			\
+ 		    &((pDregs)->reg27.all);				\
+ 									\
+ 	    SETUP_HW(pDregs);						\
+ 	    (pDregs)->reg21.all = *pDregsMiscVideo | 0x0A000000;	\
+ 	    (pDregs)->reg27.all = *pDregsMiscCtl   | 0x00800000;	\
+ 	}
  
+ #define ARTIST_DISABLE_DISPLAY(pDregs) {				\
+ 	    volatile unsigned long *pDregsMiscVideo = 			\
+ 		    &((pDregs)->reg21.all);				\
+ 	    volatile unsigned long *pDregsMiscCtl = 			\
+ 		    &((pDregs)->reg27.all);				\
+ 									\
+ 	    SETUP_HW(pDregs);						\
+ 	    (pDregs)->reg21.all = *pDregsMiscVideo & ~0x0A000000;	\
+ 	    (pDregs)->reg27.all = *pDregsMiscCtl   & ~0x00800000;	\
+ 	}
+ 
+ 
  #define BUFF0_CMAP0 0x00001e02
  #define BUFF1_CMAP0 0x02001e02
  #define BUFF1_CMAP3 0x0c001e02
+ #define ARTIST_CMAP0 0x00000102
  
  #define SETUP_ATTR_ACCESS(pDregs,BufferNumber) {			\
  	    SETUP_HW(pDregs);						\
*** /tmp/da17253	Sun Jun  5 18:27:59 1994
--- xc/programs/Xserver/hw/hp/ngle/nglescreen.c	Sun Jun  5 18:27:58 1994
***************
*** 1,4 ****
! /* $XConsortium: nglescreen.c,v 1.1 93/08/08 12:57:53 rws Exp $ */
  /*************************************************************************
   * 
   * (c)Copyright 1992 Hewlett-Packard Co.,  All Rights Reserved.
--- 1,4 ----
! /* $XConsortium: nglescreen.c,v 1.2 94/05/28 15:45:33 dpw Exp $ */
  /*************************************************************************
   * 
   * (c)Copyright 1992 Hewlett-Packard Co.,  All Rights Reserved.
***************
*** 280,323 ****
  	    __FILE__);
      }
  
-     /* Get pointer to unpacked byte/long data in ROM */
-     pBytePerLongDevDepData = (Card32 *)
- 			    gcDescribe.crt_region[NGLEDEVDEPROM_CRT_REGION];
- 
      SETUP_HW(pDregs);
  
!     /* Tomcat supports several resolutions: 1280x1024, 1024x768, 640x480.
!      * This code reads the index into a device dependent ROM array containing
!      * the device's currently selected resolution.
!      */
!     if (pScreenPriv->deviceID == S9000_ID_TOMCAT)
      {
!         /*  jump to the correct ROM table  */
!         GET_ROMTABLE_INDEX(romTableIdx);
!         while  (romTableIdx > 0)
!         {
!             pCard8 = (Card8 *) pPackedDevRomData;
!             pRomTable = pBytePerLongDevDepData;
!             /* Pack every fourth byte from ROM into structure */
!             for (i = 0; i < sizePackedDevRomData; i++)
!             {
! 	        *pCard8++ = (Card8) (*pRomTable++);
!             }
  
!             pBytePerLongDevDepData = (Card32 *)
!                 ((Card8 *) pBytePerLongDevDepData +
!                            pPackedDevRomData->sizeof_ngle_data);
  
!             romTableIdx--;
!         }
!     }
  
!     pCard8 = (Card8 *) pPackedDevRomData;
  
!     /* Pack every fourth byte from ROM into structure */
!     for (i = 0; i < sizePackedDevRomData; i++)
!     {
! 	*pCard8++ = (Card8) (*pBytePerLongDevDepData++);
      }
  
      SETUP_FB(pDregs,pScreenPriv->deviceID,pScreenPriv->devDepth);
--- 280,331 ----
  	    __FILE__);
      }
  
      SETUP_HW(pDregs);
  
!     if (pScreenPriv->deviceID == S9000_ID_ARTIST)
      {
! 	pPackedDevRomData->cursor_pipeline_delay = 4;
! 	pPackedDevRomData->video_interleaves     = 4;
!     }
!     else
!     {
! 	/* Get pointer to unpacked byte/long data in ROM */
! 	pBytePerLongDevDepData = (Card32 *)
! 				gcDescribe.crt_region[NGLEDEVDEPROM_CRT_REGION];
  
! 	/* Tomcat supports several resolutions: 1280x1024, 1024x768, 640x480.
! 	 * This code reads the index into a device dependent ROM array containing
! 	 * the device's currently selected resolution.
! 	 */
! 	if (pScreenPriv->deviceID == S9000_ID_TOMCAT)
! 	{
! 	    /*  jump to the correct ROM table  */
! 	    GET_ROMTABLE_INDEX(romTableIdx);
! 	    while  (romTableIdx > 0)
! 	    {
! 		pCard8 = (Card8 *) pPackedDevRomData;
! 		pRomTable = pBytePerLongDevDepData;
! 		/* Pack every fourth byte from ROM into structure */
! 		for (i = 0; i < sizePackedDevRomData; i++)
! 		{
! 		    *pCard8++ = (Card8) (*pRomTable++);
! 		}
  
! 		pBytePerLongDevDepData = (Card32 *)
! 			((Card8 *) pBytePerLongDevDepData +
! 			       pPackedDevRomData->sizeof_ngle_data);
  
! 		romTableIdx--;
! 	    }
! 	}
  
! 	pCard8 = (Card8 *) pPackedDevRomData;
! 
! 	/* Pack every fourth byte from ROM into structure */
! 	for (i = 0; i < sizePackedDevRomData; i++)
! 	{
! 	    *pCard8++ = (Card8) (*pBytePerLongDevDepData++);
! 	}
      }
  
      SETUP_FB(pDregs,pScreenPriv->deviceID,pScreenPriv->devDepth);
***************
*** 554,559 ****
--- 562,568 ----
  	&&  (gcDescribe.crt_id != S9000_ID_TIMBER)	/* 710 Any */
  	&&  (gcDescribe.crt_id != S9000_ID_TOMCAT)	/* Dual CRX */
  	&&  (gcDescribe.crt_id != S9000_ID_A1439A)	/* CRX24 */
+ 	&&  (gcDescribe.crt_id != S9000_ID_ARTIST)	/* Artist */
  	)
      {
  	ioctl(fildes, GCUNMAP, &mapOrigin);
***************
*** 655,660 ****
--- 664,674 ----
  	pScreenPriv->deviceID   = S9000_ID_A1659A;
  	break;
  
+     case S9000_ID_ARTIST:	/* Artist */
+ 
+ 	pScreenPriv->isGrayScale = FALSE;
+ 	break;
+ 
      case S9000_ID_A1659A:	/* CRX */
  	
  	pScreenPriv->isGrayScale = FALSE;
***************
*** 1032,1046 ****
  	elkSetupPlanes(pScreenPriv);
      }
  
!     /* Clear attribute planes on CRX, CRX24 and GRX devices.
       */
      if ((pScreenPriv->deviceID == S9000_ID_A1659A) ||	/* CRX or GRX */
! 	(pScreenPriv->deviceID == S9000_ID_A1439A))
      {
  	if (pScreenPriv->devDepth == 24)
  	    ngleSetupAttrPlanes(pScreenPriv,BUFF1_CMAP3);
  	else  /* depth = 8 */
! 	    ngleSetupAttrPlanes(pScreenPriv,BUFF1_CMAP0);
  	
      }
  
--- 1046,1065 ----
  	elkSetupPlanes(pScreenPriv);
      }
  
!     /* Clear attribute planes on Artist, CRX, CRX24 and GRX devices.
       */
      if ((pScreenPriv->deviceID == S9000_ID_A1659A) ||	/* CRX or GRX */
! 	(pScreenPriv->deviceID == S9000_ID_A1439A) ||	/* CRX24 */
! 	(pScreenPriv->deviceID == S9000_ID_ARTIST)	/* Artist */
!        )
      {
  	if (pScreenPriv->devDepth == 24)
  	    ngleSetupAttrPlanes(pScreenPriv,BUFF1_CMAP3);
  	else  /* depth = 8 */
! 	    if (pScreenPriv->deviceID == S9000_ID_ARTIST)
! 		ngleSetupAttrPlanes(pScreenPriv,ARTIST_CMAP0);
! 	    else
! 		ngleSetupAttrPlanes(pScreenPriv,BUFF1_CMAP0);
  	
      }
  
***************
*** 1225,1234 ****
          } 
      }
  
!     /* Clear attribute planes on CRX, CRX24 and GRX devices.
       */
      if ((pScreenPriv->deviceID == S9000_ID_A1659A) ||	/* CRX or GRX */
! 	(pScreenPriv->deviceID == S9000_ID_A1439A))     /* CRX24 */
      {
  	ngleSetupAttrPlanes(pScreenPriv,BUFF0_CMAP0);
      }
--- 1244,1255 ----
          } 
      }
  
!     /* Clear attribute planes on Artist, CRX, CRX24 and GRX devices.
       */
      if ((pScreenPriv->deviceID == S9000_ID_A1659A) ||	/* CRX or GRX */
! 	(pScreenPriv->deviceID == S9000_ID_A1439A) ||   /* CRX24 */
! 	(pScreenPriv->deviceID == S9000_ID_ARTIST)      /* Artist */
!        )
      {
  	ngleSetupAttrPlanes(pScreenPriv,BUFF0_CMAP0);
      }
***************
*** 1274,1281 ****
  
  	    CRX24_DISABLE_DISPLAY(pDregs);
  	}
  	else
! 	{   /* CRX and like ilk */
  	    DISABLE_DISPLAY(pDregs);
  	}
      }
--- 1295,1306 ----
  
  	    CRX24_DISABLE_DISPLAY(pDregs);
  	}
+ 	else if (pScreenPriv->deviceID == S9000_ID_ARTIST)
+ 	{
+ 	    ARTIST_DISABLE_DISPLAY(pDregs);
+ 	}
  	else
! 	{   /* CRX and like elk */
  	    DISABLE_DISPLAY(pDregs);
  	}
      }
***************
*** 1300,1307 ****
  	{   /* CRX24 */
  	    CRX24_ENABLE_DISPLAY(pDregs);
  	}
  	else
! 	{   /* CRX and like ilk */
  	    ENABLE_DISPLAY(pDregs);
  	}
      }
--- 1325,1336 ----
  	{   /* CRX24 */
  	    CRX24_ENABLE_DISPLAY(pDregs);
  	}
+ 	else if (pScreenPriv->deviceID == S9000_ID_ARTIST)
+ 	{
+ 	    ARTIST_ENABLE_DISPLAY(pDregs);
+ 	}
  	else
! 	{   /* CRX and like elk */
  	    ENABLE_DISPLAY(pDregs);
  	}
      }
*** /tmp/da21864	Mon Jun  6 16:42:33 1994
--- xc/programs/Xserver/hw/sun/Imakefile	Mon Jun  6 16:42:32 1994
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile,v 5.25 94/02/21 10:20:10 kaleb Exp $
  #include <Server.tmpl>
  
  SRCS1 =	sunInit.c \
--- 1,4 ----
! XCOMM $XConsortium: Imakefile,v 5.26 94/06/06 14:12:06 kaleb Exp $
  #include <Server.tmpl>
  
  SRCS1 =	sunInit.c \
***************
*** 62,67 ****
--- 62,68 ----
  InstallManPage(Xsun,$(MANDIR))
  #ifndef i386Architecture
  InstallManPageAliases(Xsun,$(MANDIR),XsunMono)
+ InstallManPageAliases(Xsun,$(MANDIR),Xsun24)
  #endif
  
  DependTarget()
*** /tmp/da21880	Mon Jun  6 16:42:35 1994
--- xc/programs/Xserver/hw/sun/Xsun.man	Mon Jun  6 16:42:34 1994
***************
*** 1,4 ****
! .\" $XConsortium: Xsun.man,v 1.23 94/04/17 20:29:32 gildea Exp $
  .\" Copyright 1988 Sun Microsystems, Inc.
  .\" Copyright (c) 1993, 1994  X Consortium
  .\" 
--- 1,4 ----
! .\" $XConsortium: Xsun.man,v 1.24 94/06/06 14:13:56 kaleb Exp $
  .\" Copyright 1988 Sun Microsystems, Inc.
  .\" Copyright (c) 1993, 1994  X Consortium
  .\" 
***************
*** 27,33 ****
  .\" from the X Consortium.
  .TH XSUN 1 "Release 6" "X Version 11"
  .SH NAME
! Xsun, XsunMono \- Sun server for X Version 11
  .SH SYNOPSIS
  .B Xsun
  [ option ] ...
--- 27,33 ----
  .\" from the X Consortium.
  .TH XSUN 1 "Release 6" "X Version 11"
  .SH NAME
! Xsun, XsunMono, Xsun24 \- Sun server for X Version 11
  .SH SYNOPSIS
  .B Xsun
  [ option ] ...
***************
*** 39,48 ****
  .SH CONFIGURATIONS
  .PP
  .I Xsun
! supports both color and monochrome screens.
  .I XsunMono
  is configured to support only monochrome screens, for low-end systems 
  with limited memory.
  .PP
  If specific framebuffer device files aren't specified on the command 
  line with the \fI\-dev\fP switch or in the \fIXDEVICE\fP environment
--- 39,52 ----
  .SH CONFIGURATIONS
  .PP
  .I Xsun
! supports 8-bit color and 1-bit monochrome screens.
  .I XsunMono
  is configured to support only monochrome screens, for low-end systems 
  with limited memory.
+ Like Xsun,
+ .I Xsun24
+ supports 8-bit color and 1-bit monochrome screens in addition to the
+ cgeight 24-bit color screen.
  .PP
  If specific framebuffer device files aren't specified on the command 
  line with the \fI\-dev\fP switch or in the \fIXDEVICE\fP environment
***************
*** 50,56 ****
  will use all those that it finds. The following framebuffer types are 
  supported:
  .TP 8
! .B bwtwo, cgtwo, cgthree, cgfour, and cgsix.
  .PP
  Finally, if no specific framebuffers are found, the generic framebuffer 
  interface \fI/dev/fb\fP is used.
--- 54,60 ----
  will use all those that it finds. The following framebuffer types are 
  supported:
  .TP 8
! \fBbwtwo, cgtwo, cgthree, cgfour, cgsix, and cgeight.\fP
  .PP
  Finally, if no specific framebuffers are found, the generic framebuffer 
  interface \fI/dev/fb\fP is used.
***************
*** 57,64 ****
  .PP
  .SH KEYBOARDS
  .PP
! Xsun and XsunMono support the Type-2, Type-3, and many variations of the 
! Type-4 and Type-5 keyboards.
  .PP
  Type-4 and Type-5 keyboards feature a key labeled \fIAltGraph\fP which 
  is a mode-shift key. The mode-shift key is used to generate the symbols 
--- 61,68 ----
  .PP
  .SH KEYBOARDS
  .PP
! Xsun, Xsun24, and XsunMono support the Type-2, Type-3, and many variations 
! of the Type-4 and Type-5 keyboards.
  .PP
  Type-4 and Type-5 keyboards feature a key labeled \fIAltGraph\fP which 
  is a mode-shift key. The mode-shift key is used to generate the symbols 
***************
*** 124,129 ****
--- 128,137 ----
  .B "\-dev \fIfilename[:filename]...\fP"
  This option specifies the colon separated names of the framebuffer device 
  files to be used.
+ .TP 8
+ .B "\-fbinfo
+ This option indicates that the server should enumerate the available
+ frame buffers that it will use.
  .SH ENVIRONMENT
  .TP 8
  \fBXDEVICE\fP
*** /tmp/da17274	Sun Jun  5 18:28:02 1994
--- xc/programs/Xserver/hw/sun/sunCfb.c	Sun Jun  5 18:28:01 1994
***************
*** 1,5 ****
  
! /* $XConsortium: sunCfb.c,v 1.14 94/04/17 20:29:34 kaleb Exp $ */
  
  /*
  Copyright (c) 1990  X Consortium
--- 1,5 ----
  
! /* $XConsortium: sunCfb.c,v 1.15 94/05/18 11:17:56 kaleb Exp $ */
  
  /*
  Copyright (c) 1990  X Consortium
***************
*** 114,119 ****
--- 114,121 ----
      register Entry *pent;
      register VisualPtr pVisual = cmap->pVisual;
      u_char	  rmap[256], gmap[256], bmap[256];
+     unsigned long rMask, gMask, bMask;
+     int	oRed, oGreen, oBlue;
  
      if (cmap == pPrivate->installedMap)
  	return;
***************
*** 121,130 ****
  	WalkTree(pPrivate->installedMap->pScreen, TellLostMap,
  		 (pointer) &(pPrivate->installedMap->mid));
      if ((pVisual->class | DynamicClass) == DirectColor) {
  	for (i = 0; i < 256; i++) {
! 	    rmap[i] = cmap->red[i].co.local.red >> 8;
! 	    gmap[i] = cmap->green[i].co.local.green >> 8;
! 	    bmap[i] = cmap->blue[i].co.local.blue >> 8;
  	}
      } else {
  	for (i = 0, pent = cmap->red;
--- 123,143 ----
  	WalkTree(pPrivate->installedMap->pScreen, TellLostMap,
  		 (pointer) &(pPrivate->installedMap->mid));
      if ((pVisual->class | DynamicClass) == DirectColor) {
+ 	if (pVisual->ColormapEntries < 256) {
+ 	    rMask = pVisual->redMask;
+ 	    gMask = pVisual->greenMask;
+ 	    bMask = pVisual->blueMask;
+ 	    oRed = pVisual->offsetRed;
+ 	    oGreen = pVisual->offsetGreen;
+ 	    oBlue = pVisual->offsetBlue;
+ 	} else {
+ 	    rMask = gMask = bMask = 255;
+ 	    oRed = oGreen = oBlue = 0;
+ 	}
  	for (i = 0; i < 256; i++) {
! 	    rmap[i] = cmap->red[(i & rMask) >> oRed].co.local.red >> 8;
! 	    gmap[i] = cmap->green[(i & gMask) >> oGreen].co.local.green >> 8;
! 	    bmap[i] = cmap->blue[(i & bMask) >> oBlue].co.local.blue >> 8;
  	}
      } else {
  	for (i = 0, pent = cmap->red;
*** /tmp/da17290	Sun Jun  5 18:28:03 1994
--- xc/programs/Xserver/hw/sun/sunIo.c	Sun Jun  5 18:28:03 1994
***************
*** 1,4 ****
! /* $XConsortium: sunIo.c,v 5.25 94/04/17 20:29:40 rws Exp $ */
  /*-
   * sunIo.c --
   *	Functions to handle input from the keyboard and mouse.
--- 1,4 ----
! /* $XConsortium: sunIo.c,v 5.26 94/05/02 17:24:53 mor Exp $ */
  /*-
   * sunIo.c --
   *	Functions to handle input from the keyboard and mouse.
***************
*** 159,164 ****
--- 159,165 ----
  {
      int		i;
      ScreenPtr	pScreen;
+     DevicePtr	devPtr;
  
  #ifdef SVR4
      (void) OsSignal (SIGPOLL, SIG_IGN);
***************
*** 165,171 ****
  #else
      (void) OsSignal (SIGIO, SIG_IGN);
  #endif
!     (void) sunChangeKbdTranslation (((sunKbdPrivPtr)(LookupKeyboardDevice()->devicePrivate))->fd, FALSE);
  #ifdef SVR4
      sunNonBlockConsoleOff ();
  #else
--- 166,174 ----
  #else
      (void) OsSignal (SIGIO, SIG_IGN);
  #endif
!     devPtr = LookupKeyboardDevice();
!     if (devPtr)
! 	(void) sunChangeKbdTranslation (((sunKbdPrivPtr)(devPtr->devicePrivate))->fd, FALSE);
  #ifdef SVR4
      sunNonBlockConsoleOff ();
  #else
*** /tmp/da17306	Sun Jun  5 18:28:07 1994
--- xc/programs/Xserver/hw/sun/sunKeyMap.c	Sun Jun  5 18:28:05 1994
***************
*** 1,4 ****
! /* $XConsortium: sunKeyMap.c,v 4.21 94/05/16 18:28:26 kaleb Exp $ */
  /************************************************************
  Copyright 1987 by Sun Microsystems, Inc. Mountain View, CA.
  
--- 1,4 ----
! /* $XConsortium: sunKeyMap.c,v 4.22 94/05/18 11:16:07 kaleb Exp $ */
  /************************************************************
  Copyright 1987 by Sun Microsystems, Inc. Mountain View, CA.
  
***************
*** 5293,5310 ****
  	XK_KP_Add,	NoSymbol,	NoSymbol,	NoSymbol,	/*125*/
  };
  
! static SunModmapRec US5Modmap[] = {
! 	99,	ShiftMask,
! 	110,	ShiftMask,
! 	76,	LockMask,
! 	119,	ControlMask,
! 	120,	Mod1Mask,
! 	122,	Mod1Mask,
! 	13,	Mod2Mask,
! 	19,	Mod3Mask,
! 	98,	Mod4Mask,
! 	0,	0
! };
  
  #else
  
--- 5293,5299 ----
  	XK_KP_Add,	NoSymbol,	NoSymbol,	NoSymbol,	/*125*/
  };
  
! #define US5Modmap Generic5Modmap
  
  #else
  
*** /tmp/da17327	Sun Jun  5 18:28:11 1994
--- xc/programs/Xserver/os/connection.c	Sun Jun  5 18:28:10 1994
***************
*** 1,4 ****
! /* $XConsortium: connection.c,v 1.187 94/04/17 20:26:56 dpw Exp $ */
  /***********************************************************
  
  Copyright (c) 1987, 1989  X Consortium
--- 1,4 ----
! /* $XConsortium: connection.c,v 1.188 94/06/02 11:36:56 mor Exp $ */
  /***********************************************************
  
  Copyright (c) 1987, 1989  X Consortium
***************
*** 281,287 ****
      }
  
      if (WellKnownConnections == 0)
!         FatalError ("Cannot establish any listening sockets");
  
      OsSignal (SIGPIPE, SIG_IGN);
      OsSignal (SIGHUP, AutoResetServer);
--- 281,287 ----
      }
  
      if (WellKnownConnections == 0)
!         FatalError ("Cannot establish any listening sockets - Make sure an X server isn't already running");
  
      OsSignal (SIGPIPE, SIG_IGN);
      OsSignal (SIGHUP, AutoResetServer);
*** /tmp/da17343	Sun Jun  5 18:28:13 1994
--- xc/programs/Xserver/os/xdmcp.c	Sun Jun  5 18:28:12 1994
***************
*** 1,4 ****
! /* $XConsortium: xdmcp.c,v 1.30 94/03/31 13:56:50 dpw Exp $ */
  /*
   * Copyright 1989 Network Computing Devices, Inc., Mountain View, California.
   *
--- 1,4 ----
! /* $XConsortium: xdmcp.c,v 1.31 94/06/03 17:21:13 mor Exp $ */
  /*
   * Copyright 1989 Network Computing Devices, Inc., Mountain View, California.
   *
***************
*** 28,33 ****
--- 28,37 ----
  #include "dixstruct.h"
  #include "opaque.h"
  
+ #ifdef STREAMSCONN
+ #include <tiuser.h>
+ #endif
+ 
  #ifdef XDMCP
  #undef REQUEST
  #include "Xdmcp.h"
***************
*** 890,895 ****
--- 894,905 ----
  {
      int soopts = 1;
  
+ #ifdef STREAMSCONN
+     if ((xdmcpSocket = t_open("/dev/udp", O_RDWR, 0)) < 0)
+ 	XdmcpWarning("t_open() of /dev/udp failed");
+     if( t_bind(xdmcpSocket,NULL,NULL) < 0 )
+ 	t_error("t_bind(xdmcpSocket) failed" );
+ #else
      if ((xdmcpSocket = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
  	XdmcpWarning("UDP socket creation failed");
  #ifdef SO_BROADCAST
***************
*** 897,902 ****
--- 907,913 ----
  	sizeof(soopts)) < 0)
  	    XdmcpWarning("UDP set broadcast socket-option failed");
  #endif /* SO_BROADCAST */
+ #endif /* STREAMSCONN */
  }
  
  static void
*** /tmp/da17364	Sun Jun  5 18:28:15 1994
--- xc/programs/xdm/auth.c	Sun Jun  5 18:28:15 1994
***************
*** 1,4 ****
! /* $XConsortium: auth.c,v 1.54 94/04/17 20:03:33 gildea Exp $ */
  /*
  
  Copyright (c) 1988  X Consortium
--- 1,4 ----
! /* $XConsortium: auth.c,v 1.55 94/06/03 16:34:12 mor Exp $ */
  /*
  
  Copyright (c) 1988  X Consortium
***************
*** 666,679 ****
  	writeAddr (FamilyLocal, strlen (displayname), displayname, file, auth);
  }
  
- #ifdef STREAMSCONN
  
  #include <tiuser.h>
  
! /* Define this host for access control.  Find all the hosts the OS knows about 
!  * for this fd and add them to the selfhosts list.
!  * TLI version, written without sufficient documentation.
!  */
  static
  DefineSelf (fd, file, auth)
      int fd;
--- 666,685 ----
  	writeAddr (FamilyLocal, strlen (displayname), displayname, file, auth);
  }
  
  
+ #ifdef NCR
+ 
+ #include <sys/un.h>
+ #include <stropts.h>
  #include <tiuser.h>
  
! #include <sys/stream.h>
! #include <net/if.h>
! #include <netinet/ip.h>
! #include <netinet/ip_var.h>
! #include <netinet/in.h>
! #include <netinet/in_var.h>
! 
  static
  DefineSelf (fd, file, auth)
      int fd;
***************
*** 680,697 ****
      FILE	*file;
      Xauth	*auth;
  {
!     struct netbuf	netb;
!     char		addrret[1024]; /* easier than t_alloc */
!     
!     netb.maxlen = sizeof(addrret);
!     netb.buf = addrret;
!     if (t_getname (fd, &netb, LOCALNAME) == -1)
! 	t_error ("t_getname");
!     /* what a kludge */
!     writeAddr (FamilyInternet, 4, netb.buf+4, file, auth);
  }
  
! #else /* STREAMSCONN */
  #ifdef SIOCGIFCONF
  
  /* Define this host for access control.  Find all the hosts the OS knows about 
--- 686,750 ----
      FILE	*file;
      Xauth	*auth;
  {
!     /*
!      * The Wolongong drivers used by NCR SVR4/MP-RAS don't understand the
!      * socket IO calls that most other drivers seem to like. Because of
!      * this, this routine must be special cased for NCR. Eventually,
!      * this will be cleared up.
!      */
! 
!     struct ipb ifnet;
!     struct in_ifaddr ifaddr;
!     struct strioctl str;
!     unsigned char *addr;
!     int	family, len, ipfd;
! 
!     if ((ipfd = open ("/dev/ip", O_RDWR, 0 )) < 0)
!         LogError ("Getting interface configuration");
! 
!     /* Indicate that we want to start at the begining */
!     ifnet.ib_next = (struct ipb *) 1;
! 
!     while (ifnet.ib_next)
!     {
! 	str.ic_cmd = IPIOC_GETIPB;
! 	str.ic_timout = 0;
! 	str.ic_len = sizeof (struct ipb);
! 	str.ic_dp = (char *) &ifnet;
! 
! 	if (ioctl (ipfd, (int) I_STR, (char *) &str) < 0)
! 	{
! 	    close (ipfd);
! 	    LogError ("Getting interface configuration");
! 	}
! 
! 	ifaddr.ia_next = (struct in_ifaddr *) ifnet.if_addrlist;
! 	str.ic_cmd = IPIOC_GETINADDR;
! 	str.ic_timout = 0;
! 	str.ic_len = sizeof (struct in_ifaddr);
! 	str.ic_dp = (char *) &ifaddr;
! 
! 	if (ioctl (ipfd, (int) I_STR, (char *) &str) < 0)
! 	{
! 	    close (ipfd);
! 	    LogError ("Getting interface configuration");
! 	}
! 
! 	/*
! 	 * Ignore the 127.0.0.1 entry.
! 	 */
! 	if (IA_SIN(&ifaddr)->sin_addr.s_addr == htonl(0x7f000001) )
! 		continue;
! 
! 	writeAddr (FamilyInternet, 4, &(IA_SIN(&ifaddr)->sin_addr), file, auth);
!  
!     }
!     close(ipfd);
! 
  }
  
! #else /* NCR */
! 
  #ifdef SIOCGIFCONF
  
  /* Define this host for access control.  Find all the hosts the OS knows about 
***************
*** 811,818 ****
  }
  
  #endif /* SIOCGIFCONF else */
- #endif /* STREAMSCONN else */
  
  static
  setAuthNumber (auth, name)
      Xauth   *auth;
--- 864,873 ----
  }
  
  #endif /* SIOCGIFCONF else */
  
+ #endif /* NCR */
+ 
+ 
  static
  setAuthNumber (auth, name)
      Xauth   *auth;
***************
*** 853,858 ****
--- 908,920 ----
  
      Debug ("writeLocalAuth: %s %.*s\n", name, auth->name_length, auth->name);
      setAuthNumber (auth, name);
+ #ifdef STREAMSCONN
+     fd = t_open ("/dev/tcp", O_RDWR, 0);
+     t_bind(fd, NULL, NULL);
+     DefineSelf (fd, file, auth);
+     t_unbind (fd);
+     t_close (fd);
+ #endif
  #ifdef TCPCONN
      fd = socket (AF_INET, SOCK_STREAM, 0);
      DefineSelf (fd, file, auth);
*** /tmp/da17380	Sun Jun  5 18:28:17 1994
--- xc/programs/xdm/choose.c	Sun Jun  5 18:28:17 1994
***************
*** 1,5 ****
  /*
!  * $XConsortium: choose.c,v 1.15 94/04/17 20:03:34 rws Exp $
   *
  Copyright (c) 1990  X Consortium
  
--- 1,5 ----
  /*
!  * $XConsortium: choose.c,v 1.16 94/06/03 16:34:38 mor Exp $
   *
  Copyright (c) 1990  X Consortium
  
***************
*** 43,48 ****
--- 43,51 ----
  #include <netinet/in.h>
  #include <sys/un.h>
  #include <ctype.h>
+ #if defined(STREAMSCONN)
+ # include       <tiuser.h>
+ #endif
  
  #ifdef X_NOT_STDC_ENV
  #define Time_t long
***************
*** 369,377 ****
--- 372,425 ----
      ARRAY8	clientAddress;
      CARD16	connectionType;
      ARRAY8	choice;
+ #if defined(STREAMSCONN)
+     struct t_call *call;
+     int flags=0;
+ #endif
  
      Debug ("Process chooser socket\n");
      len = sizeof (buf);
+ #if defined(STREAMSCONN)
+     call = (struct t_call *)t_alloc( fd, T_CALL, T_ALL );
+     if( call == NULL )
+     {
+ 	t_error( "ProcessChooserSocket: t_alloc failed" );
+ 	LogError ("Cannot setup to listen on chooser connection\n");
+ 	return;
+     }
+     if( t_listen( fd, call ) < 0 )
+     {
+ 	t_error( "ProcessChooserSocket: t_listen failed" );
+ 	t_free( (char *)call, T_CALL );
+ 	LogError ("Cannot listen on chooser connection\n");
+ 	return;
+     }
+     client_fd = t_open ("/dev/tcp", O_RDWR, NULL);
+     if (client_fd == -1)
+     {
+ 	t_error( "ProcessChooserSocket: t_open failed" );
+ 	t_free( (char *)call, T_CALL );
+ 	LogError ("Cannot open new chooser connection\n");
+ 	return;
+     }
+     if( t_bind( client_fd, NULL, NULL ) < 0 )
+     {
+ 	t_error( "ProcessChooserSocket: t_bind failed" );
+ 	t_free( (char *)call, T_CALL );
+ 	LogError ("Cannot bind new chooser connection\n");
+         t_close (client_fd);
+ 	return;
+     }
+     if( t_accept (fd, client_fd, call) < 0 )
+     {
+ 	t_error( "ProcessChooserSocket: t_accept failed" );
+ 	LogError ("Cannot accept chooser connection\n");
+ 	t_free( (char *)call, T_CALL );
+         t_unbind (client_fd);
+         t_close (client_fd);
+ 	return;
+     }
+ #else
      client_fd = accept (fd, (struct sockaddr *)buf, &len);
      if (client_fd == -1)
      {
***************
*** 378,386 ****
--- 426,439 ----
  	LogError ("Cannot accept chooser connection\n");
  	return;
      }
+ #endif
      Debug ("Accepted %d\n", client_fd);
      
+ #if defined(STREAMSCONN)
+     len = t_rcv (client_fd, buf, sizeof (buf),&flags);
+ #else
      len = read (client_fd, buf, sizeof (buf));
+ #endif
      Debug ("Read returns %d\n", len);
      if (len > 0)
      {
***************
*** 407,413 ****
--- 460,472 ----
  	LogError ("Invalid choice response length %d\n", len);
      }
  
+ #if defined(STREAMSCONN)
+     t_unbind (client_fd);
+     t_free( (char *)call, T_CALL );
+     t_close (client_fd);
+ #else
      close (client_fd);
+ #endif
  }
  
  RunChooser (d)
*** /tmp/da17396	Sun Jun  5 18:28:19 1994
--- xc/programs/xdm/chooser.c	Sun Jun  5 18:28:18 1994
***************
*** 1,5 ****
  /*
!  * $XConsortium: chooser.c,v 1.19 94/04/17 20:03:34 rws Exp $
   *
  Copyright (c) 1990  X Consortium
  
--- 1,5 ----
  /*
!  * $XConsortium: chooser.c,v 1.20 94/06/03 16:34:39 mor Exp $
   *
  Copyright (c) 1990  X Consortium
  
***************
*** 75,80 ****
--- 75,87 ----
  #include    <sys/socket.h>
  #include    <netinet/in.h>
  #include    <sys/ioctl.h>
+ #if defined(STREAMSCONN)
+ #if defined(NCR)
+ #include    <netinet/ip.h>
+ #endif
+ #include    <stropts.h>
+ #include    <tiuser.h>
+ #endif
  
  #define BROADCAST_HOSTNAME  "BROADCAST"
  
***************
*** 472,477 ****
--- 479,516 ----
  
      if (!strcmp (name, BROADCAST_HOSTNAME))
      {
+ #if defined(STREAMSCONN) && defined(NCR)
+     int                 ipfd;
+     struct ifconf       *ifcp;
+     struct strioctl     ioc;
+ 
+ 	ifcp = (struct ifconf *)buf;
+ 	ifcp->ifc_buf = buf+4;
+ 	ifcp->ifc_len = sizeof (buf) - 4;
+ 
+ 	if ((ipfd=open( "/dev/ip", O_RDONLY )) < 0 )
+ 	    {
+ 	    t_error( "RegisterHostname() t_open(/dev/ip) failed" );
+ 	    return;
+ 	    }
+ 
+ 	ioc.ic_cmd = IPIOC_GETIFCONF;
+ 	ioc.ic_timout = 60;
+ 	ioc.ic_len = sizeof( buf );
+ 	ioc.ic_dp = (char *)ifcp;
+ 
+ 	if (ioctl (ipfd, (int) I_STR, (char *) &ioc) < 0)
+ 	    {
+ 	    perror( "RegisterHostname() ioctl(I_STR(IPIOC_GETIFCONF)) failed" );
+ 	    close( ipfd );
+ 	    return;
+ 	    }
+ 
+ 	for (ifr = ifcp->ifc_req,
+ n = ifcp->ifc_len / sizeof (struct ifreq);
+ 	    --n >= 0;
+ 	    ifr++)
+ #else
  	ifc.ifc_len = sizeof (buf);
  	ifc.ifc_buf = buf;
  	if (ioctl (socketFD, (int) SIOCGIFCONF, (char *) &ifc) < 0)
***************
*** 486,491 ****
--- 525,531 ----
  	     , n = ifc.ifc_len / sizeof (struct ifreq); --n >= 0; ifr++
  #endif
  	     )
+ #endif /* STREAMSCONN && NCR */
  	{
  	    if (ifr->ifr_addr.sa_family != AF_INET)
  		continue;
***************
*** 498,510 ****
--- 538,568 ----
  		struct ifreq    broad_req;
      
  		broad_req = *ifr;
+ #if defined(STREAMSCONN) && defined(NCR)
+ 		ioc.ic_cmd = IPIOC_GETIFFLAGS;
+ 		ioc.ic_timout = 0;
+ 		ioc.ic_len = sizeof( broad_req );
+ 		ioc.ic_dp = (char *)&broad_req;
+ 
+ 		if (ioctl (ipfd, I_STR, (char *) &ioc) != -1 &&
+ #else
  		if (ioctl (socketFD, SIOCGIFFLAGS, (char *) &broad_req) != -1 &&
+ #endif
  		    (broad_req.ifr_flags & IFF_BROADCAST) &&
  		    (broad_req.ifr_flags & IFF_UP)
  		    )
  		{
  		    broad_req = *ifr;
+ #if defined(STREAMSCONN) && defined(NCR)
+ 		    ioc.ic_cmd = IPIOC_GETIFBRDADDR;
+ 		    ioc.ic_timout = 0;
+ 		    ioc.ic_len = sizeof( broad_req );
+ 		    ioc.ic_dp = (char *)&broad_req;
+ 
+ 		    if (ioctl (ipfd, I_STR, (char *) &ioc) != -1)
+ #else
  		    if (ioctl (socketFD, SIOCGIFBRDADDR, &broad_req) != -1)
+ #endif
  			broad_addr = broad_req.ifr_addr;
  		    else
  			continue;
***************
*** 592,599 ****
--- 650,663 ----
  	header.length += 2 + AuthenticationNames.data[i].length;
      XdmcpWriteHeader (&directBuffer, &header);
      XdmcpWriteARRAYofARRAY8 (&directBuffer, &AuthenticationNames);
+ #if defined(STREAMSCONN)
+     if ((socketFD = t_open ("/dev/udp", O_RDWR, 0)) < 0)
+         return 0;
+     t_bind( socketFD, NULL, NULL );
+ #else
      if ((socketFD = socket (AF_INET, SOCK_DGRAM, 0)) < 0)
  	return 0;
+ #endif
  #ifdef SO_BROADCAST
      soopts = 1;
      if (setsockopt (socketFD, SOL_SOCKET, SO_BROADCAST, (char *)&soopts, sizeof (soopts)) < 0)
***************
*** 626,631 ****
--- 690,698 ----
  	char		buf[1024];
  	XdmcpBuffer	buffer;
  	char		*xdm;
+ #if defined(STREAMSCONN)
+         struct  t_call  call, rcv;
+ #endif
  
  	xdm = (char *) app_resources.xdmAddress->data;
  	family = (xdm[0] << 8) + xdm[1];
***************
*** 641,646 ****
--- 708,743 ----
  	    len = sizeof (in_addr);
  	    break;
  	}
+ #if defined(STREAMSCONN)
+ 	if ((fd = t_open ("/dev/tcp", O_RDWR, NULL)) == -1)
+ 	{
+ 	    fprintf (stderr, "Cannot create response endpoint\n");
+ 	    fflush(stderr);
+ 	    exit (REMANAGE_DISPLAY);
+ 	}
+ 	if (t_bind (fd, NULL, NULL) == -1)
+ 	{
+ 	    fprintf (stderr, "Cannot bind response endpoint\n");
+ 	    fflush(stderr);
+ 	    t_close (fd);
+ 	    exit (REMANAGE_DISPLAY);
+ 	}
+ 	call.addr.buf=(char *)addr;
+ 	call.addr.len=len;
+ 	call.addr.maxlen=len;
+ 	call.opt.len=0;
+ 	call.opt.maxlen=0;
+ 	call.udata.len=0;
+ 	call.udata.maxlen=0;
+ 	if (t_connect (fd, &call, NULL) == -1)
+ 	{
+ 	    t_error ("Cannot connect to xdm\n");
+ 	    fflush(stderr);
+ 	    t_unbind (fd);
+ 	    t_close (fd);
+ 	    exit (REMANAGE_DISPLAY);
+ 	}
+ #else
  	if ((fd = socket (family, SOCK_STREAM, 0)) == -1)
  	{
  	    fprintf (stderr, "Cannot create response socket\n");
***************
*** 651,656 ****
--- 748,754 ----
  	    fprintf (stderr, "Cannot connect to xdm\n");
  	    exit (REMANAGE_DISPLAY);
  	}
+ #endif
  	buffer.data = (BYTE *) buf;
  	buffer.size = sizeof (buf);
  	buffer.pointer = 0;
***************
*** 658,665 ****
--- 756,779 ----
  	XdmcpWriteARRAY8 (&buffer, app_resources.clientAddress);
  	XdmcpWriteCARD16 (&buffer, (CARD16) app_resources.connectionType);
  	XdmcpWriteARRAY8 (&buffer, &h->hostaddr);
+ #if defined(STREAMSCONN)
+ 	if( t_snd (fd, (char *)buffer.data, buffer.pointer, 0) < 0 )
+ 	{
+ 	    fprintf (stderr, "Cannot send to xdm\n");
+ 	    fflush(stderr);
+ 	    t_unbind (fd);
+ 	    t_close (fd);
+ 	    exit (REMANAGE_DISPLAY);
+ 	}
+ 	sleep(5);	/* Hack because sometimes the connection gets
+ 			   closed before the data arrives on the other end. */
+ 	t_snddis (fd,NULL);
+ 	t_unbind (fd);
+ 	t_close (fd);
+ #else
  	write (fd, (char *)buffer.data, buffer.pointer);
  	close (fd);
+ #endif
      }
      else
      {
*** /tmp/da17412	Sun Jun  5 18:28:21 1994
--- xc/programs/xdm/streams.c	Sun Jun  5 18:28:20 1994
***************
*** 1,4 ****
! /* $XConsortium: streams.c,v 1.4 94/04/17 20:03:47 rws Exp $ */
  /*
  
  Copyright (c) 1988  X Consortium
--- 1,4 ----
! /* $XConsortium: streams.c,v 1.5 94/06/03 16:34:41 mor Exp $ */
  /*
  
  Copyright (c) 1988  X Consortium
***************
*** 75,81 ****
      xdmcpFd = t_open(nconf->nc_device, O_RDWR, NULL);
      if (xdmcpFd == -1) {
  	LogError ("XDMCP stream creation failed\n");
! 	t_error ("t_open");
  	return;
      }
      name = localHostname ();
--- 75,81 ----
      xdmcpFd = t_open(nconf->nc_device, O_RDWR, NULL);
      if (xdmcpFd == -1) {
  	LogError ("XDMCP stream creation failed\n");
! 	t_error ("CreateWellKnownSockets(xdmcpFd): t_open failed");
  	return;
      }
      name = localHostname ();
***************
*** 91,102 ****
      bind_addr.qlen = 5;
      bind_addr.addr.buf = servaddrs->n_addrs[0].buf;
      bind_addr.addr.len = servaddrs->n_addrs[0].len;
      it = t_bind(xdmcpFd, &bind_addr, &bind_addr);
      netdir_free((char *)servaddrs, ND_ADDRLIST);
      if (it < 0)
      {
  	LogError ("error binding STREAMS address %d\n", request_port);
! 	t_error("t_bind");	/* also goes to log file */
  	t_close (xdmcpFd);
  	xdmcpFd = -1;
  	return;
--- 91,103 ----
      bind_addr.qlen = 5;
      bind_addr.addr.buf = servaddrs->n_addrs[0].buf;
      bind_addr.addr.len = servaddrs->n_addrs[0].len;
+     bind_addr.addr.maxlen = servaddrs->n_addrs[0].len;
      it = t_bind(xdmcpFd, &bind_addr, &bind_addr);
      netdir_free((char *)servaddrs, ND_ADDRLIST);
      if (it < 0)
      {
  	LogError ("error binding STREAMS address %d\n", request_port);
! 	t_error("CreateWellKNowSocket(xdmcpFd): t_bind failed");
  	t_close (xdmcpFd);
  	xdmcpFd = -1;
  	return;
***************
*** 109,117 ****
      if (chooserFd == -1)
      {
  	LogError ("chooser stream creation failed\n");
! 	t_error("t_open chooser");
  	return;
      }
      if (chooserFd > WellKnownSocketsMax)
  	WellKnownSocketsMax = chooserFd;
      FD_SET (chooserFd, &WellKnownSocketsMask);
--- 110,126 ----
      if (chooserFd == -1)
      {
  	LogError ("chooser stream creation failed\n");
! 	t_error("CreateWellKnowSockets(chooserFd): t_open failed");
  	return;
      }
+     bind_addr.qlen = 5;
+     bind_addr.addr.len = 0;
+     bind_addr.addr.maxlen = 0;
+     if( t_bind( chooserFd, &bind_addr, NULL ) < 0 )
+     {
+         t_error("CreateWellKnowSockets(chooserFd): t_bind failed");
+     }
+ 
      if (chooserFd > WellKnownSocketsMax)
  	WellKnownSocketsMax = chooserFd;
      FD_SET (chooserFd, &WellKnownSocketsMask);
***************
*** 125,132 ****
      int retval;
  
      nbuf.buf = addr;
      nbuf.maxlen = *lenp;
!     retval = t_getname (chooserFd, nbuf, LOCALNAME);
      if (retval < 0) {
  	if (debugLevel > 0)
  	    t_error("t_getname on chooser fd");
--- 134,142 ----
      int retval;
  
      nbuf.buf = addr;
+     nbuf.len = *lenp;
      nbuf.maxlen = *lenp;
!     retval = t_getname (chooserFd, &nbuf, LOCALNAME);
      if (retval < 0) {
  	if (debugLevel > 0)
  	    t_error("t_getname on chooser fd");
*** /tmp/da19334	Mon Jun  6 11:53:36 1994
--- xc/programs/xdpyinfo/xdpyinfo.man	Mon Jun  6 11:53:35 1994
***************
*** 1,4 ****
! .\" $XConsortium: xdpyinfo.man,v 1.16 94/04/17 20:25:20 dpw Exp $
  .\" Copyright (c) 1988, 1989, 1994  X Consortium
  .\" 
  .\" Permission is hereby granted, free of charge, to any person obtaining
--- 1,4 ----
! .\" $XConsortium: xdpyinfo.man,v 1.17 94/06/06 11:45:00 rws Exp $
  .\" Copyright (c) 1988, 1989, 1994  X Consortium
  .\" 
  .\" Permission is hereby granted, free of charge, to any person obtaining
***************
*** 30,35 ****
--- 30,36 ----
  .SH SYNOPSIS
  .B "xdpyinfo"
  [\-display \fIdisplayname\fP]
+ [\-queryExtensions]
  .SH DESCRIPTION
  .PP
  .I Xdpyinfo
***************
*** 38,43 ****
--- 39,50 ----
  capabilities of a server, the predefined values for various parameters used
  in communicating between clients and the server, and the different types of
  screens and visuals that are available.
+ .PP
+ By default, numeric information (opcode, base event, base error) about
+ protocol extensions is not displayed.  This information can be obtained
+ with the \fB\-queryExtensions\fP option.  Use of this option on servers
+ that dynamically load extensions will likely cause all possible extensions
+ to be loaded, which can be slow and can consume significant server resources.
  .SH ENVIRONMENT
  .PP
  .TP 8
*** /tmp/da19364	Mon Jun  6 11:53:41 1994
--- xc/programs/xdpyinfo/xdpyinfo.c	Mon Jun  6 11:53:40 1994
***************
*** 1,5 ****
  /*
!  * $XConsortium: xdpyinfo.c,v 1.28 94/04/17 20:25:18 rws Exp $
   * 
   * xdpyinfo - print information about X display connecton
   *
--- 1,5 ----
  /*
!  * $XConsortium: xdpyinfo.c,v 1.29 94/06/06 11:39:16 rws Exp $
   * 
   * xdpyinfo - print information about X display connecton
   *
***************
*** 37,47 ****
  #include <stdio.h>
  
  char *ProgramName;
  
- 
  static void usage ()
  {
!     fprintf (stderr, "usage:  %s [-display displayname]\n",
  	     ProgramName);
      exit (1);
  }
--- 37,47 ----
  #include <stdio.h>
  
  char *ProgramName;
+ Bool queryExtensions = False;
  
  static void usage ()
  {
!     fprintf (stderr, "usage:  %s [-display displayname] [-queryExtensions]\n",
  	     ProgramName);
      exit (1);
  }
***************
*** 60,77 ****
  
      for (i = 1; i < argc; i++) {
  	char *arg = argv[i];
! 
! 	if (arg[0] == '-') {
! 	    switch (arg[1]) {
! 	      case 'd':
! 		if (++i >= argc) usage ();
! 		displayname = argv[i];
! 		continue;
! 	      default:
! 		usage ();
! 	    }
  	} else
! 	  usage ();
      }
  
      dpy = XOpenDisplay (displayname);
--- 60,74 ----
  
      for (i = 1; i < argc; i++) {
  	char *arg = argv[i];
! 	int len = strlen(arg);
! 	
! 	if (!strncmp("-display", arg, len)) {
! 	    if (++i >= argc) usage ();
! 	    displayname = argv[i];
! 	} else if (!strncmp("-queryExtensions", arg, len)) {
! 	    queryExtensions = True;
  	} else
! 	    usage ();
      }
  
      dpy = XOpenDisplay (displayname);
***************
*** 211,216 ****
--- 208,217 ----
  
  	qsort(extlist, n, sizeof(char *), StrCmp);
  	for (i = 0; i < n; i++) {
+ 	    if (!queryExtensions) {
+ 		printf ("    %s\n", extlist[i]);
+ 		continue;
+ 	    }
  	    XQueryExtension(dpy, extlist[i], &opcode, &event, &error);
  	    printf ("    %s  (opcode: %d", extlist[i], opcode);
  	    if (event)
*** /tmp/da22154	Mon Jun  6 17:02:27 1994
--- xc/programs/xhost/xhost.man	Mon Jun  6 17:02:26 1994
***************
*** 1,4 ****
! .\" $XConsortium: xhost.man,v 1.17 94/04/18 18:01:36 rws Exp $
  .\" Copyright (c) 1988  X Consortium
  .\" 
  .\" Permission is hereby granted, free of charge, to any person obtaining
--- 1,4 ----
! .\" $XConsortium: xhost.man,v 1.18 94/06/06 16:56:15 gildea Exp $
  .\" Copyright (c) 1988  X Consortium
  .\" 
  .\" Permission is hereby granted, free of charge, to any person obtaining
***************
*** 39,52 ****
  worst abuses.  Environments which require more sophisticated measures should
  implement the user-based mechanism or use the hooks in the
  protocol for passing other authentication data to the server.
- .PP
- Hostnames that are followed by two colons (::) are used in checking DECnet
- connections; all other hostnames are used for TCP/IP connections.
- .PP
- User names contain an at-sign (@).  When Secure RPC is being used, the
- network independent netname (e.g., "unix.\fIuid\fP@\fIdomainname\fP") can
- be specified, or a local user can be specified with just the username
- and a trailing at-sign (e.g., "pat@").
  .SH OPTIONS
  \fIXhost\fP accepts the following command line options described below.  For
  security, the options that effect access control may only be run from the
--- 39,44 ----
***************
*** 85,90 ****
--- 77,107 ----
  is printed, followed by the list of those allowed to connect.
  This is the only option that may be used from machines other than
  the controlling host.
+ .SH NAMES
+ A complete name has the syntax
+ ``family:name'' where the families are
+ as follows:
+ .PP
+ .nf
+ .ta 1i
+ inet	Internet host
+ dnet	DECnet host
+ nis	Secure RPC network name
+ krb	Kerberos V5 principal
+ local	contains only one name, the empty string
+ .fi
+ .PP
+ The family is case insensitive.
+ The format of the name varies with the family.
+ .PP
+ When Secure RPC is being used, the
+ network independent netname (e.g., "nis:unix.\fIuid\fP@\fIdomainname\fP") can
+ be specified, or a local user can be specified with just the username
+ and a trailing at-sign (e.g., "nis:pat@").
+ .PP
+ For backward compatibility with pre-R6 \fIxhost\fP,
+ names that contain an at-sign (@) are assumed to be in the nis family.
+ Otherwise the inet family is assumed.
  .SH DIAGNOSTICS
  For each name added to the access control list,
  a line of the form "\fIname\fP being added to access control list"
***************
*** 95,101 ****
  .SH FILES
  /etc/X*.hosts
  .SH "SEE ALSO"
! X(1), Xserver(1), xdm(1)
  .SH ENVIRONMENT
  .TP 8
  .B DISPLAY
--- 112,118 ----
  .SH FILES
  /etc/X*.hosts
  .SH "SEE ALSO"
! X(1), Xsecurity(1), Xserver(1), xdm(1)
  .SH ENVIRONMENT
  .TP 8
  .B DISPLAY
*** /tmp/da17433	Sun Jun  5 18:28:23 1994
--- xc/workInProgress/Fresco/include/Impls/action.h	Sun Jun  5 18:28:23 1994
***************
*** 1,3 ****
--- 1,5 ----
+ /* $XConsortium: action.h,v 1.5 94/06/03 21:43:41 matt Exp $ */
+ 
  /*
   * Copyright (c) 1992-1993 Silicon Graphics, Inc.
   *
***************
*** 54,60 ****
   * Action denoted by an object and member function to call on the object.
   */
  
! #if defined(__STDC__) || defined(__ANSI_CPP__)
  #define __ActionCallback(T) T##_ActionCallback
  #define ActionCallback(T) __ActionCallback(T)
  #define __ActionMemberFunction(T) T##_ActionMemberFunction
--- 56,62 ----
   * Action denoted by an object and member function to call on the object.
   */
  
! #if !defined(UNIXCPP)
  #define __ActionCallback(T) T##_ActionCallback
  #define ActionCallback(T) __ActionCallback(T)
  #define __ActionMemberFunction(T) T##_ActionMemberFunction
*** /tmp/da17454	Sun Jun  5 18:28:25 1994
--- xc/workInProgress/Fresco/include/OS/list.h	Sun Jun  5 18:28:24 1994
***************
*** 1,3 ****
--- 1,5 ----
+ /* $XConsortium: list.h,v 1.3 94/06/03 21:41:51 matt Exp $ */
+ 
  /*
   * Copyright (c) 1987, 1988, 1989, 1990, 1991 Stanford University
   * Copyright (c) 1991 Silicon Graphics, Inc.
***************
*** 34,40 ****
  extern void ListImpl_range_error(long index);
  extern long ListImpl_best_new_count(long count, unsigned size);
  
! #if defined(__STDC__) || defined(__ANSI_CPP__)
  #define __ListItr(List) List##_Iterator
  #define ListItr(List) __ListItr(List)
  #define __ListUpdater(List) List##_Updater
--- 36,42 ----
  extern void ListImpl_range_error(long index);
  extern long ListImpl_best_new_count(long count, unsigned size);
  
! #if !defined(UNIXCPP)
  #define __ListItr(List) List##_Iterator
  #define ListItr(List) __ListItr(List)
  #define __ListUpdater(List) List##_Updater
*** /tmp/da17470	Sun Jun  5 18:28:27 1994
--- xc/workInProgress/Fresco/include/OS/table.h	Sun Jun  5 18:28:26 1994
***************
*** 1,3 ****
--- 1,5 ----
+ /* $XConsortium: table.h,v 1.3 94/06/03 21:41:56 matt Exp $ */
+ 
  /*
   * Copyright (c) 1987, 1988, 1989, 1990, 1991 Stanford University
   * Copyright (c) 1991 Silicon Graphics, Inc.
***************
*** 31,37 ****
  
  #include <X11/Fresco/_enter.h>
  
! #if defined(__STDC__) || defined(__ANSI_CPP__)
  #define __TableEntry(Table) Table##_Entry
  #define TableEntry(Table) __TableEntry(Table)
  #define __TableIterator(Table) Table##_Iterator
--- 33,39 ----
  
  #include <X11/Fresco/_enter.h>
  
! #if !defined(UNIXCPP)
  #define __TableEntry(Table) Table##_Entry
  #define TableEntry(Table) __TableEntry(Table)
  #define __TableIterator(Table) Table##_Iterator
*** /tmp/da17486	Sun Jun  5 18:28:28 1994
--- xc/workInProgress/Fresco/include/OS/table2.h	Sun Jun  5 18:28:28 1994
***************
*** 1,3 ****
--- 1,5 ----
+ /* $XConsortium: table2.h,v 1.3 94/06/03 21:41:57 matt Exp $ */
+ 
  /*
   * Copyright (c) 1987, 1988, 1989, 1990, 1991 Stanford University
   * Copyright (c) 1991 Silicon Graphics, Inc.
***************
*** 31,37 ****
  
  #include <X11/Fresco/_enter.h>
  
! #if defined(__STDC__) || defined(__ANSI_CPP__)
  #define __Table2Entry(Table2) Table2##_Entry
  #define Table2Entry(Table2) __Table2Entry(Table2)
  #define __Table2Iterator(Table2) Table2##_Iterator
--- 33,39 ----
  
  #include <X11/Fresco/_enter.h>
  
! #if !defined(UNIXCPP)
  #define __Table2Entry(Table2) Table2##_Entry
  #define Table2Entry(Table2) __Table2Entry(Table2)
  #define __Table2Iterator(Table2) Table2##_Iterator
*** /tmp/da17507	Sun Jun  5 18:28:30 1994
--- xc/workInProgress/Fresco/include/Ox/schema.h	Sun Jun  5 18:28:30 1994
***************
*** 1,3 ****
--- 1,5 ----
+ /* $XConsortium: schema.h,v 1.5 94/06/03 21:42:16 matt Exp $ */
+ 
  /*
   * Copyright (c) 1993 Silicon Graphics, Inc.
   * Copyright (c) 1993 Fujitsu, Ltd.
***************
*** 129,135 ****
   * is _<type>_type.
   */
  
! #if defined(__STDC__) || defined(__ANSI_CPP__)
  #define __TypeIdVar(T) _##T##_##tid
  #define TypeIdVar(T) __TypeIdVar(T)
  #define __TypeVar(T) _##T##_##type
--- 131,137 ----
   * is _<type>_type.
   */
  
! #if !defined(UNIXCPP)
  #define __TypeIdVar(T) _##T##_##tid
  #define TypeIdVar(T) __TypeIdVar(T)
  #define __TypeVar(T) _##T##_##type
*** /tmp/da17528	Sun Jun  5 18:28:32 1994
--- xc/workInProgress/Fresco/include/_enter.h	Sun Jun  5 18:28:32 1994
***************
*** 1,3 ****
--- 1,5 ----
+ /* $XConsortium: _enter.h,v 1.3 94/06/03 21:42:38 matt Exp $ */
+ 
  /*
   * Copyright (c) 1987-91 Stanford University
   * Copyright (c) 1991-93 Silicon Graphics, Inc.
***************
*** 25,31 ****
  #ifndef xf__scope_h
  #define xf__scope_h
  
! #if defined(__STDC__) || defined(__ANSI_CPP__)
  #define _lib_fresco(name) Xf##name
  #else
  #define _lib_fresco(name) Xf/**/name
--- 27,33 ----
  #ifndef xf__scope_h
  #define xf__scope_h
  
! #if !defined(UNIXCPP)
  #define _lib_fresco(name) Xf##name
  #else
  #define _lib_fresco(name) Xf/**/name
*** /tmp/da17549	Sun Jun  5 18:28:34 1994
--- xc/workInProgress/Fresco/src/Imakefile	Sun Jun  5 18:28:33 1994
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile,v 1.9 94/03/30 12:07:57 gildea Exp $
  #define DoNormalLib NormalLibFresco
  #define DoSharedLib SharedLibFresco
  #define DoDebugLib DebugLibFresco
--- 1,4 ----
! XCOMM $XConsortium: Imakefile,v 1.10 94/06/03 22:46:06 matt Exp $
  #define DoNormalLib NormalLibFresco
  #define DoSharedLib SharedLibFresco
  #define DoDebugLib DebugLibFresco
***************
*** 14,20 ****
  
        LINTLIBS = $(LINTXLIB)
  DEPEND_DEFINES = CplusplusDependIncludes
! FRESCO_DEFINES = -DFRESCO_LIBALL='"$(XLIBDIR)/X11"' -DX_LIBDIR='"$(XLIBDIR)/X11"'
  
  HEADERS =
  
--- 14,20 ----
  
        LINTLIBS = $(LINTXLIB)
  DEPEND_DEFINES = CplusplusDependIncludes
! FRESCO_DEFINES = -DX_LIBDIR='"$(LIBDIR)"'
  
  HEADERS =
  
*** /tmp/da17565	Sun Jun  5 18:28:36 1994
--- xc/workInProgress/Fresco/src/fresco.cxx	Sun Jun  5 18:28:35 1994
***************
*** 1,5 ****
  /*
!  * $XConsortium: fresco.cxx,v 1.5 94/04/07 11:29:33 matt Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: fresco.cxx,v 1.6 94/06/03 21:38:54 matt Exp $
   */
  
  /*
***************
*** 298,305 ****
  #include <sys/select.h>
  #endif
  
! #if defined(sony)
! /* Sony has select in libsocket, but no prototype in /usr/include */
  extern "C" int select(int, fd_set*, fd_set*, fd_set*, struct timeval*);
  #endif
  
--- 298,305 ----
  #include <sys/select.h>
  #endif
  
! #if defined(sony) || defined(__DECCXX)
! /* Sony and DEC OSF/1 have select, but no prototype in /usr/include */
  extern "C" int select(int, fd_set*, fd_set*, fd_set*, struct timeval*);
  #endif
  
*** /tmp/da17581	Sun Jun  5 18:28:38 1994
--- xc/workInProgress/Fresco/src/os.cxx	Sun Jun  5 18:28:37 1994
***************
*** 1,5 ****
  /*
!  * $XConsortium: os.cxx,v 1.9 94/04/01 16:48:03 matt Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: os.cxx,v 1.10 94/06/03 21:38:55 matt Exp $
   */
  
  /*
***************
*** 57,76 ****
  #include <stdlib.h>
  #include <string.h>
  #include <sys/stat.h>
! #include <sysent.h>
! #include <unistd.h>
! 
! /*
!  * DEC C++ headers don't prototype getpw* functions?
!  */
! 
! #ifdef __DECCXX
! extern "C" {
!     extern struct passwd* getpwent();
!     extern struct passwd* getpwnam(const char*);
!     extern struct passwd* getpwuid(uid_t);
! }
  #endif
  
  #ifndef S_ISDIR
  #define S_ISDIR(mode) (((mode) & S_IFMT) == S_IFDIR)
--- 57,66 ----
  #include <stdlib.h>
  #include <string.h>
  #include <sys/stat.h>
! #if !defined(__DECCXX) && !defined(__hpux)
! #include <sysent.h>		/* DEC and HP don't ahve sysent.h */
  #endif
+ #include <unistd.h>
  
  #ifndef S_ISDIR
  #define S_ISDIR(mode) (((mode) & S_IFMT) == S_IFDIR)
*** /tmp/da17602	Sun Jun  5 18:28:40 1994
--- xc/workInProgress/xsm/xsmclient.c	Sun Jun  5 18:28:39 1994
***************
*** 1,4 ****
! /* $XConsortium: xsmclient.c,v 1.19 94/04/17 21:15:21 mor Exp $ */
  /******************************************************************************
  
  Copyright (c) 1993  X Consortium
--- 1,4 ----
! /* $XConsortium: xsmclient.c,v 1.20 94/05/20 12:25:42 mor Exp $ */
  /******************************************************************************
  
  Copyright (c) 1993  X Consortium
***************
*** 459,465 ****
  #ifndef X_NOT_POSIX
  	getcwd((char *)NULL, PATH_MAX),
  #else
! 	"unknown-cwd"
  #endif
          XtNfromHoriz, cwdLabel,
          XtNfromVert, quitButton,
--- 459,465 ----
  #ifndef X_NOT_POSIX
  	getcwd((char *)NULL, PATH_MAX),
  #else
! 	"unknown-cwd",
  #endif
          XtNfromHoriz, cwdLabel,
          XtNfromVert, quitButton,
