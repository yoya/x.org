                      Release 6 Public Patch #12
                             X Consortium

To apply this patch:

cd to the top of the source tree (to the directory containing the "xc"
and "contrib" subdirectories) and do:
        patch -p -s < ThisFile
Patch will work silently unless an error occurs.  If you want to
watch patch do its thing, leave out the "-s" argument to patch.

Next, from the same top-level directory do:
        rm -f xc/lib/Xt/Shell.h
        rm -f xc/lib/Xt/StringDefs.h
        rm -f xc/lib/Xt/StringDefs.c

To rebuild, do:
	cd xc
        make Everything >& every.log

This patch creates the following new files:
    xc/lib/Xt/util/Shell.ht
    xc/lib/Xt/util/StrDefs.ct
    xc/lib/Xt/util/StrDefs.ht
    xc/config/util/makestrs.c
    xc/config/util/makestrs.man
    xc/workInProgress/Fresco/README
    xc/workInProgress/Xtf/README
If you are using a symbolic link tree, you will need to create new links.

Note: If you're building X for the first time on Solaris x86 and using
    gcc, the binaries for gcc-2.4.5 that have been distributed by the 
    GNU Project have a minor bug.  Later versions of gcc have already 
    fixed this bug.  Two possible solutions:

    1) Build a newer version of gcc using gcc-2.4.5 and then build X
       with the new version of gcc.

    2) Add `-Dsun' (without the quotes) to the predefines in the file
       /usr/local/lib/gcc-lib/i486-sun-solaris2/2.4.5/specs

    Failure to do one or the other will result in the X build failing
    because the imake bootstrap cannot find /usr/lib/cpp.


Brief notes on what fix 12 corrects:

config: SVR4 compilers want -Xa, not -Xc
config: Solaris 2.4 gettimeofday() arguments change
config: typo in NetBSD.cf for NetBSD 1.0/sparc
config: SVR4 malloc 0 returns NULL if linked with libmalloc
config: typo in SentinelProgramTarget
config: use of sysconf defines in early FreeBSD/NetBSD
config: fujitsu.cf missing HasLdRunPath
config: Solaris 2.4 support
nls: fixes and enhancements for iso8859-1 Compose list
Xlib: return missing in _XimRegCommitInfo()
Xlib: CT and extended segments
Xlib: Decnet hostname incorrectly parsed
Xlib: IM callback impl doesn't match spec on text delete
Xlib: Imakefile missing POLL_DEFINES for x11trans
Xlib: Missing field in XIMStringConversionCallbackStruct
Xlib: R6 spec and SI don't agree on XOMOrientation
Xlib: XCMSDB file opened but not closed
Xlib: XGetICValues and XSetICValues function
Xlib: Xfree called on malloc'd memory
Xlib: improper memory allocation in imCallbk.c
Xlib: mishandles unexpected Authenticate from server
Xlib: setlocale return string is implementation depended
Xlib: CMS RGB conversion of invalid "rgb:" spec may cause a divide by zero
Xlib: Correct table init for EUC and SJIS locales.
Xlib: XxxLookupString cuts off last character of buffer in some cases.
Xlib: XCMSDB file opened but not closed
Xlib: Failure to create CmapRec for 24-bit visual colormaps
Xlib: XGetAtomNames can return unterminated strings
Xlib: CMS RGB invalid "rgb:" specification may cause a divide by zero error
Xlib: omGeneric's XCreateOC too expensive
Xlib: X**TextList... adds char 0
Xt: Growth of _XtStrings array in R6 adversely affects binary compat.
Xt: Block hooks might add or remove inputs
Xt: Hooks Object: inappropriate placement of call in XtRealizeWidget
Xt: Return values passed by reference aren't assigned properly.
Xt: Performance degrades when Mode_switch key is assigned a modifier.
Xt: Incomplete mapping of poll() events.
Xt: wanted LeaveNotify events compressed in dispatch
Xt: XtVaOpenApplication compiler warning
Xt: XtManageChildren(children, 0) fails in R6
Xt: Session Shell's XtCvtStringToDirectoryString converter fails
Xt: incremental selection buffer can be too small
Xt: XtVaSetValues, XtVaTypedArg and target size > sizeof(XtArgVal)
Xt: set values with typed args on the hook registration widget
Xt: subtle R5->R6 bug in ApplicationShell argc/argv processing
Xt: XtGetSelectionParameters while processing a MULTIPLE request
Xt: Keyboard.c pathTrace cache may contain bad data
Xt: parameterized selection targets, later crash in destroy callback
Xaw: selection hangs client
Xaw: Use of Xt private APIs is risky
Xaw: MenuButton grabs don't work when Num_Lock key is down.
fontlib: catalogue lists in font server font path entries are broken.
fontlib: FONT_ENTRY_BC code is obsolete
xtrans: TRANS(SocketUNIXConnect) doesn't consider hostname
xtrans: Transport name for DECnet is confused
ICElib: xtrans connection not closed after I/O error
XIElib: Technique errors not fully reported by XIElib
Fresco: Reference more up to date sources.
Xserver: Xext: bad shmat declaration
Xserver: LOCALCONN type connections not recognised as local
Xserver: fix-11 inadvertantly disabled alloca if gcc is used
xfree86: I/O privilege level changes for Unixware 4.2 2.0
xfree86: compiler bug workaround on UnixWare 2.0
fsinfo: fsinfo core dumps printing error message
smproxy: must watch all available screens
twm: use flex #define instead of system specific define
xfs: UnixWare 2.0 changes
xfs: goes into infinite loops because of uninitialized return value
xhost: string not null-terminated
xmh: nit is an error on AIX 3.2.5
xterm: better tty handling, Solaris updates
xterm: AIX 4.1.1 support
xterm: changes for SGI IRIX 5.x
makedepend: imake imakemdep.h needs SGI predefs
makedepend: imakemdep.h support for more systems
makedepend: imakemdep.h missing commas after -traditional
makedepend: evaluates "#if defined(foo )" incorrectly
xsm: Handling of ICE i/o errors needs to be reworked
xsm: User should be able to break lock on crashed session
LBX: GetAtomName reply uses wrong length for atom name
LBX: Motion Delta support
LBX: byte swapping bugs
LBX: compress font metrics for QueryFont
LBX: doesn't work on 64 bit machines
LBX: Motion Delta support
LBX: xlsfonts -ll hangs after running for a while
LBX: various bugs/cleanups



Prereq: public-patch-11

*** -   Thu Feb  9 15:57:10 1995
--- xc/bug-report       Mon Jun 19 19:18:10 1995
***************
*** 3,9 ****
  
       VERSION:
  
! R6, public-patch-11
  [X Consortium public patches edit this line to indicate the patch level]
  
       CLIENT MACHINE and OPERATING SYSTEM:
--- 3,9 ----
  
       VERSION:
  
! R6, public-patch-12
  [X Consortium public patches edit this line to indicate the patch level]
  
       CLIENT MACHINE and OPERATING SYSTEM:
*** -	Fri Jul  7 09:30:32 1995
--- xc/include/Xfuncproto.h	Fri Jul  7 09:30:32 1995
***************
*** 1,4 ****
! /* $XConsortium: Xfuncproto.h,v 1.8 94/04/17 20:10:49 rws Exp $ */
  /* 
   * 
  Copyright (c) 1989, 1991  X Consortium
--- 1,4 ----
! /* $XConsortium: Xfuncproto.h,v 1.9 95/06/08 23:20:39 gildea Exp $ */
  /* 
   * 
  Copyright (c) 1989, 1991  X Consortium
***************
*** 32,38 ****
  #define _XFUNCPROTO_H_
  
  #ifndef NeedFunctionPrototypes
! #if defined(FUNCPROTO) || __STDC__ || defined(__cplusplus) || defined(c_plusplus)
  #define NeedFunctionPrototypes 1
  #else
  #define NeedFunctionPrototypes 0
--- 32,38 ----
  #define _XFUNCPROTO_H_
  
  #ifndef NeedFunctionPrototypes
! #if defined(FUNCPROTO) || defined(__STDC__) || defined(__cplusplus) || defined(c_plusplus)
  #define NeedFunctionPrototypes 1
  #else
  #define NeedFunctionPrototypes 0
***************
*** 40,46 ****
  #endif /* NeedFunctionPrototypes */
  
  #ifndef NeedVarargsPrototypes
! #if __STDC__ || defined(__cplusplus) || defined(c_plusplus) || (FUNCPROTO&2)
  #define NeedVarargsPrototypes 1
  #else
  #define NeedVarargsPrototypes 0
--- 40,46 ----
  #endif /* NeedFunctionPrototypes */
  
  #ifndef NeedVarargsPrototypes
! #if defined(__STDC__) || defined(__cplusplus) || defined(c_plusplus) || (FUNCPROTO&2)
  #define NeedVarargsPrototypes 1
  #else
  #define NeedVarargsPrototypes 0
***************
*** 50,56 ****
  #if NeedFunctionPrototypes
  
  #ifndef NeedNestedPrototypes
! #if __STDC__ || defined(__cplusplus) || defined(c_plusplus) || (FUNCPROTO&8)
  #define NeedNestedPrototypes 1
  #else
  #define NeedNestedPrototypes 0
--- 50,56 ----
  #if NeedFunctionPrototypes
  
  #ifndef NeedNestedPrototypes
! #if defined(__STDC__) || defined(__cplusplus) || defined(c_plusplus) || (FUNCPROTO&8)
  #define NeedNestedPrototypes 1
  #else
  #define NeedNestedPrototypes 0
***************
*** 58,64 ****
  #endif /* NeedNestedPrototypes */
  
  #ifndef _Xconst
! #if __STDC__ || defined(__cplusplus) || defined(c_plusplus) || (FUNCPROTO&4)
  #define _Xconst const
  #else
  #define _Xconst
--- 58,64 ----
  #endif /* NeedNestedPrototypes */
  
  #ifndef _Xconst
! #if defined(__STDC__) || defined(__cplusplus) || defined(c_plusplus) || (FUNCPROTO&4)
  #define _Xconst const
  #else
  #define _Xconst
*** -	Fri Jul  7 09:30:33 1995
--- xc/include/Xmd.h	Fri Jul  7 09:30:33 1995
***************
*** 47,53 ****
  ******************************************************************/
  #ifndef XMD_H
  #define XMD_H 1
! /* $XConsortium: Xmd.h,v 1.47 94/04/17 20:10:50 rws Exp $ */
  /*
   *  Xmd.h: MACHINE DEPENDENT DECLARATIONS.
   */
--- 47,53 ----
  ******************************************************************/
  #ifndef XMD_H
  #define XMD_H 1
! /* $XConsortium: Xmd.h,v 1.49 95/06/08 23:20:39 gildea Exp $ */
  /*
   *  Xmd.h: MACHINE DEPENDENT DECLARATIONS.
   */
***************
*** 61,66 ****
--- 61,71 ----
  #ifdef __alpha
  #define LONG64				/* 32/64-bit architecture */
  #endif
+ #ifdef __sgi
+ #if (_MIPS_SZLONG == 64)
+ #define LONG64
+ #endif
+ #endif
  
  /*
   * Stuff to handle large architecture machines; the constants were generated
***************
*** 85,91 ****
   * The extra indirection in the __STDC__ case is to get macro arguments to
   * expand correctly before the concatenation, rather than afterward.
   */
! #if ((__STDC__ || defined(__cplusplus) || defined(c_plusplus)) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define _SIZEOF(x) sz_##x
  #define SIZEOF(x) _SIZEOF(x)
  #else
--- 90,96 ----
   * The extra indirection in the __STDC__ case is to get macro arguments to
   * expand correctly before the concatenation, rather than afterward.
   */
! #if ((defined(__STDC__) || defined(__cplusplus) || defined(c_plusplus)) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define _SIZEOF(x) sz_##x
  #define SIZEOF(x) _SIZEOF(x)
  #else
***************
*** 106,112 ****
  typedef unsigned int INT32;
  typedef unsigned int INT16;
  #else
! #if __STDC__
  typedef signed int INT32;
  typedef signed int INT16;
  #else
--- 111,117 ----
  typedef unsigned int INT32;
  typedef unsigned int INT16;
  #else
! #ifdef __STDC__
  typedef signed int INT32;
  typedef signed int INT16;
  #else
***************
*** 126,132 ****
  typedef short INT16;
  #endif
  
! #if __STDC__ || defined(sgi) || defined(AIXV3)
  typedef signed char    INT8;
  #else
  typedef char           INT8;
--- 131,137 ----
  typedef short INT16;
  #endif
  
! #if defined(__STDC__) || defined(sgi) || defined(AIXV3)
  typedef signed char    INT8;
  #else
  typedef char           INT8;
*** -	Fri Jul  7 09:30:34 1995
--- xc/include/Xos.h	Fri Jul  7 09:30:34 1995
***************
*** 1,5 ****
  /*
!  * $XConsortium: Xos.h,v 1.67 94/11/30 20:48:05 kaleb Exp $
   * 
   * 
  Copyright (c) 1987  X Consortium
--- 1,5 ----
  /*
!  * $XConsortium: Xos.h,v 1.68 95/06/02 16:51:21 gildea Exp $
   * 
   * 
  Copyright (c) 1987  X Consortium
***************
*** 197,207 ****
--- 197,211 ----
  #endif /* SYSV */
  
  /* define X_GETTIMEOFDAY macro, a portable gettimeofday() */
+ #if defined(_XOPEN_XPG4) || defined(_XOPEN_UNIX) /* _XOPEN_UNIX is XPG4.2 */
+ #define X_GETTIMEOFDAY(t) gettimeofday(t, (struct timezone*)0)
+ #else
  #if defined(SVR4) || defined(VMS) || defined(WIN32)
  #define X_GETTIMEOFDAY(t) gettimeofday(t)
  #else
  #define X_GETTIMEOFDAY(t) gettimeofday(t, (struct timezone*)0)
  #endif
+ #endif /* XPG4 else */
  
  /* use POSIX name for signal */
  #if defined(X_NOT_POSIX) && defined(SYSV) && !defined(SIGCHLD)
*** -	Fri Jul  7 09:30:34 1995
--- xc/include/Xthreads.h	Fri Jul  7 09:30:34 1995
***************
*** 1,5 ****
  /*
!  * $XConsortium: Xthreads.h,v 1.17 94/04/17 20:10:54 gildea Exp $
   *
   * 
  Copyright (c) 1993  X Consortium
--- 1,5 ----
  /*
!  * $XConsortium: Xthreads.h,v 1.19 95/06/30 17:58:05 kaleb Exp $
   *
   * 
  Copyright (c) 1993  X Consortium
***************
*** 63,70 ****
  #define xcondition_broadcast(cv) condition_broadcast(cv)
  #define xcondition_set_name(cv,str) condition_set_name(cv,str)
  #else
! #if defined(sun) || defined(__sun__)
  #include <thread.h>
  typedef thread_t xthread_t;
  typedef cond_t xcondition_rec;
  typedef mutex_t xmutex_rec;
--- 63,71 ----
  #define xcondition_broadcast(cv) condition_broadcast(cv)
  #define xcondition_set_name(cv,str) condition_set_name(cv,str)
  #else
! #ifdef SVR4
  #include <thread.h>
+ #include <synch.h>
  typedef thread_t xthread_t;
  typedef cond_t xcondition_rec;
  typedef mutex_t xmutex_rec;
***************
*** 152,170 ****
  }
  #else
  #include <pthread.h>
  typedef pthread_t xthread_t;
  typedef pthread_cond_t xcondition_rec;
  typedef pthread_mutex_t xmutex_rec;
  #define xthread_self pthread_self
- #define xthread_fork(func,closure) { pthread_t _tmpxthr; \
- 	pthread_create(&_tmpxthr,pthread_attr_default,func,closure); }
  #define xthread_yield() pthread_yield()
  #define xthread_exit(v) pthread_exit(v)
- #define xmutex_init(m) pthread_mutex_init(m, pthread_mutexattr_default)
  #define xmutex_clear(m) pthread_mutex_destroy(m)
  #define xmutex_lock(m) pthread_mutex_lock(m)
  #define xmutex_unlock(m) pthread_mutex_unlock(m)
  #define xcondition_init(c) pthread_cond_init(c, pthread_condattr_default)
  #define xcondition_clear(c) pthread_cond_destroy(c)
  #define xcondition_wait(c,m) pthread_cond_wait(c,m)
  #define xcondition_signal(c) pthread_cond_signal(c)
--- 153,192 ----
  }
  #else
  #include <pthread.h>
+ #ifdef AIXV3
+ #ifndef _AIX32_THREADS
+ #define POSIX_DRAFT7_THREADS
+ #endif
+ #endif
+ /* 
+  * The above would probably be better handled with an imake config
+  * variable, but since AIX 4.X seems to be the only platform implementing
+  * the draft 7 API, this will suffice for now. An imake config variable
+  * would also require changes to the Xlib and Xt Imakefiles to compile 
+  * Xlib's locking.c and  Xt's Threads.c, so this has less impact.
+  */
  typedef pthread_t xthread_t;
  typedef pthread_cond_t xcondition_rec;
  typedef pthread_mutex_t xmutex_rec;
  #define xthread_self pthread_self
  #define xthread_yield() pthread_yield()
  #define xthread_exit(v) pthread_exit(v)
  #define xmutex_clear(m) pthread_mutex_destroy(m)
  #define xmutex_lock(m) pthread_mutex_lock(m)
  #define xmutex_unlock(m) pthread_mutex_unlock(m)
+ #ifndef POSIX_DRAFT7_THREADS
+ #define xthread_fork(func,closure) { pthread_t _tmpxthr; \
+ 	pthread_create(&_tmpxthr,pthread_attr_default,func,closure); }
+ #define xmutex_init(m) pthread_mutex_init(m, pthread_mutexattr_default)
  #define xcondition_init(c) pthread_cond_init(c, pthread_condattr_default)
+ #else /* POSIX_DRAFT7_THREADS */
+ #define xthread_fork(func,closure) { pthread_t _tmpxthr; \
+ 	pthread_create(&_tmpxthr,&pthread_attr_default,func,closure); }
+ #define xmutex_init(m) \
+ 	pthread_mutex_init(m, &pthread_mutexattr_default)
+ #define xcondition_init(c) \
+ 	pthread_cond_init(c, &pthread_condattr_default)
+ #endif /* POSIX_DRAFT7_THREADS */
  #define xcondition_clear(c) pthread_cond_destroy(c)
  #define xcondition_wait(c,m) pthread_cond_wait(c,m)
  #define xcondition_signal(c) pthread_cond_signal(c)
*** -	Fri Jul  7 09:30:35 1995
--- xc/include/extensions/multibufst.h	Fri Jul  7 09:30:35 1995
***************
*** 1,5 ****
  /*
!  * $XConsortium: multibufst.h,v 1.15 94/04/17 20:11:22 dpw Exp $
   *
  Copyright (c) 1989  X Consortium
  
--- 1,5 ----
  /*
!  * $XConsortium: multibufst.h,v 1.16 95/06/08 23:20:39 gildea Exp $
   *
  Copyright (c) 1989  X Consortium
  
***************
*** 37,43 ****
  #include "input.h"
  #endif
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define MbufGetReq(name,req,info) GetReq (name, req); \
  	req->reqType = info->codes->major_opcode; \
  	req->mbufReqType = X_##name;
--- 37,43 ----
  #include "input.h"
  #endif
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define MbufGetReq(name,req,info) GetReq (name, req); \
  	req->reqType = info->codes->major_opcode; \
  	req->mbufReqType = X_##name;
***************
*** 304,310 ****
      pSTRUCT2->FUNC_NAME = tmpFn;					\
  }
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define WRAP_SCREEN_FUNC(pSCREEN,pPRIV,FUNC_NAME, PRIV_FUNC_NAME)	\
  {									\
      if ((pPRIV->funcsWrapped & FUNC_NAME##Mask) == 0)			\
--- 304,310 ----
      pSTRUCT2->FUNC_NAME = tmpFn;					\
  }
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define WRAP_SCREEN_FUNC(pSCREEN,pPRIV,FUNC_NAME, PRIV_FUNC_NAME)	\
  {									\
      if ((pPRIV->funcsWrapped & FUNC_NAME##Mask) == 0)			\
*** -	Fri Jul  7 09:30:36 1995
--- xc/config/util/Imakefile	Fri Jul  7 09:30:36 1995
***************
*** 1,8 ****
! XCOMM $XConsortium: Imakefile,v 1.8 94/03/29 15:54:11 gildea Exp $
  #if UseCCMakeDepend
  MDEP_PROG = makedepend
  #endif
!          PROGRAMS = xmkmf $(MDEP_PROG) mergelib
            DEPLIBS =
    EXTRA_LIBRARIES =
  
--- 1,8 ----
! XCOMM $XConsortium: Imakefile,v 1.9 95/05/05 17:42:43 kaleb Exp $
  #if UseCCMakeDepend
  MDEP_PROG = makedepend
  #endif
!          PROGRAMS = xmkmf $(MDEP_PROG) mergelib makestrs
            DEPLIBS =
    EXTRA_LIBRARIES =
  
***************
*** 19,24 ****
--- 19,26 ----
  SimpleProgramTarget(lndir)
  #endif
  #endif
+ 
+ NormalProgramTarget(makestrs,makestrs.o,,,)
  
  InstallNamedProg(xmkmf,xmkmf,$(BINDIR))
  InstallManPage(xmkmf,$(MANDIR))
*** /dev/null	Fri Jul  7 09:30:37 1995
--- xc/config/util/makestrs.c	Fri Jul  7 09:30:37 1995
***************
*** 0 ****
--- 1,721 ----
+ /* $XConsortium: makestrs.c,v 1.9 95/06/16 14:17:33 kaleb Exp $ */
+ 
+ /*
+ 
+ Copyright (c) 1991  X Consortium
+ 
+ Permission is hereby granted, free of charge, to any person obtaining a copy
+ of this software and associated documentation files (the "Software"), to deal
+ in the Software without restriction, including without limitation the rights
+ to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ copies of the Software, and to permit persons to whom the Software is
+ furnished to do so, subject to the following conditions:
+ 
+ The above copyright notice and this permission notice shall be included in
+ all copies or substantial portions of the Software.
+ 
+ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+ X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ 
+ Except as contained in this notice, the name of the X Consortium shall not be
+ used in advertising or otherwise to promote the sale, use or other dealings
+ in this Software without prior written authorization from the X Consortium.
+ 
+ */
+ 
+ /* Constructs string definitions */
+ 
+ #include <stdio.h>
+ #include <X11/Xos.h>
+ #ifndef X_NOT_STDC_ENV
+ #include <stdlib.h>
+ #else
+ char *malloc();
+ #endif
+ #if defined(macII) && !defined(__STDC__)  /* stdlib.h fails to define these */
+ char *malloc();
+ #endif /* macII */
+ 
+ typedef struct _TableEnt {
+     struct _TableEnt* next;
+     char* left;
+     char* right;
+     int offset;
+ } TableEnt;
+ 
+ typedef struct _Table {
+     struct _Table* next;
+     TableEnt* tableent;
+     TableEnt* tableentcurrent;
+     TableEnt** tableenttail;
+     char* name;
+     int offset;
+ } Table;
+ 
+ typedef struct _File {
+     struct _File* next;
+     FILE* tmpl;
+     char* name;
+     Table* table;
+     Table* tablecurrent;
+     Table** tabletail;
+ } File;
+ 
+ static File* file = NULL;
+ static File* filecurrent = NULL;
+ static File** filetail = &file;
+ static char* prefixstr = NULL;
+ static char* featurestr = NULL;
+ static char* ctmplstr = NULL;
+ static char* fileprotstr;
+ static char* externrefstr;
+ static char* externdefstr;
+ 
+ #define X_DEFAULT_ABI	0
+ #define X_ARRAYPER_ABI	1
+ #define X_INTEL_ABI	2
+ #define X_INTEL_ABI_BC	3
+ #define X_SPARC_ABI	4
+ #define X_FUNCTION_ABI	5
+ 
+ #define X_MAGIC_STRING "<<<STRING_TABLE_GOES_HERE>>>"
+ 
+ static void WriteHeaderProlog (f, phile)
+     FILE* f;
+     File* phile;
+ {
+     Table* t;
+     TableEnt* te;
+ 
+     (void) fprintf (f, "#ifdef %s\n", featurestr);
+     for (t = phile->table; t; t = t->next)
+ 	for (te = t->tableent; te; te = te->next) {
+ 	    if (strcmp (te->left, "RAtom") == 0) {
+ 		(void) fprintf (f, 
+ 			"#ifndef %s%s\n#define %s%s \"%s\"\n#endif\n",
+ 			prefixstr, te->left, prefixstr, te->left, te->right);
+ 	    } else {
+ 		(void) fprintf (f, 
+ 			"#define %s%s \"%s\"\n",
+ 			prefixstr, te->left, te->right);
+ 	    }
+ 	}
+     (void) fprintf (f, "%s", "#else\n");
+ }
+ 
+ static void IntelABIWriteHeader (f, phile)
+     FILE* f;
+     File* phile;
+ {
+     Table* t;
+     TableEnt* te;
+ 
+     WriteHeaderProlog (f, phile);
+ 
+     for (t = phile->table; t; t = t->next) {
+ 	(void) fprintf (f, "%s %sConst char %s[];\n", 
+ 			externrefstr, fileprotstr, t->name);
+ 	for (te = t->tableent; te; te = te->next)
+ 	    (void) fprintf (f, 
+ 		"#ifndef %s%s\n#define %s%s ((char*)&%s[%d])\n#endif\n",
+ 		prefixstr, te->left, prefixstr, te->left, t->name, te->offset);
+     }
+ 
+     (void) fprintf (f, "#endif /* %s */\n", featurestr);
+ }
+ 
+ static void SPARCABIWriteHeader (f, phile)
+     FILE* f;
+     File* phile;
+ {
+     Table* t;
+     TableEnt* te;
+ 
+     for (t = phile->table; t; t = t->next)
+ 	for (te = t->tableent; te; te = te->next)
+ 	    (void) fprintf (f, "#define %s%s \"%s\"\n",
+ 			    prefixstr, te->left, te->right);
+ }
+ 
+ static void FunctionWriteHeader (f, phile)
+     FILE* f;
+     File* phile;
+ {
+     Table* t;
+     TableEnt* te;
+ 
+     WriteHeaderProlog (f, phile);
+ 
+     (void) fprintf (f, "%s %sConst char* %s();\n", 
+ 		    externrefstr, fileprotstr, phile->table->name);
+ 
+     for (t = phile->table; t; t = t->next)
+ 	for (te = t->tableent; te; te = te->next)
+ 	    (void) fprintf (f, 
+ 		"#ifndef %s%s\n#define %s%s (%s(%d))\n#endif\n",
+ 		prefixstr, te->left, prefixstr, te->left, phile->table->name, 
+ 		te->offset);
+ 
+     (void) fprintf (f, "#endif /* %s */\n", featurestr);
+ }
+ 
+ static void ArrayperWriteHeader (f, phile)
+     FILE* f;
+     File* phile;
+ {
+     Table* t;
+     TableEnt* te;
+ 
+     WriteHeaderProlog (f, phile);
+ 
+     for (t = phile->table; t; t = t->next)
+ 	for (te = t->tableent; te; te = te->next)
+ 	    (void) fprintf (f, 
+ 			    "#ifndef %s%s\n%s %sConst char %s%s[];\n#endif\n",
+ 			    prefixstr, te->left, 
+ 			    externrefstr, fileprotstr, 
+ 			    prefixstr, te->left);
+ 
+     (void) fprintf (f, "#endif /* %s */\n", featurestr);
+ }
+ 
+ static void DefaultWriteHeader (f, phile)
+     FILE* f;
+     File* phile;
+ {
+     Table* t;
+     TableEnt* te;
+ 
+     WriteHeaderProlog (f, phile);
+ 
+     (void) fprintf (f, "%s %sConst char %s[];\n", 
+ 		    externrefstr, fileprotstr, phile->table->name);
+ 
+     for (t = phile->table; t; t = t->next)
+ 	for (te = t->tableent; te; te = te->next)
+ 	    (void) fprintf (f, 
+ 		"#ifndef %s%s\n#define %s%s ((char*)&%s[%d])\n#endif\n",
+ 		prefixstr, te->left, prefixstr, te->left, phile->table->name, 
+ 		te->offset);
+ 
+     (void) fprintf (f, "#endif /* %s */\n", featurestr);
+ }
+ 
+ static void CopyTmplProlog (tmpl, f)
+     FILE* tmpl;
+     FILE* f;
+ {
+     char buf[1024];
+     static char* magic_string = X_MAGIC_STRING;
+     int magic_string_len = strlen (magic_string);
+ 
+     while (fgets (buf, sizeof buf, tmpl)) {
+ 	if (strncmp (buf, magic_string, magic_string_len) == 0) {
+ 	    return;
+ 	}
+ 	(void) fputs (buf, f);
+     }
+ }
+ 
+ static void CopyTmplEpilog (tmpl, f)
+     FILE* tmpl;
+     FILE* f;
+ {
+     char buf[1024];
+ 
+     while (fgets (buf, sizeof buf, tmpl))
+ 	(void) fputs (buf, f);
+ }
+ 
+ static char* abistring[] = {
+     "Default", "Array per string", "Intel", "Intel BC", "SPARC", "Function" };
+ 
+ static void WriteHeader (tagline, phile, abi)
+     char* tagline;
+     File* phile;
+     int abi;
+ {
+     FILE* f;
+     char* tmp;
+     Table* t;
+     TableEnt* te;
+     static void (*headerproc[])() = { 
+ 	DefaultWriteHeader, ArrayperWriteHeader,
+ 	IntelABIWriteHeader, IntelABIWriteHeader,
+ 	SPARCABIWriteHeader, FunctionWriteHeader };
+ 
+     if ((f = fopen (phile->name, "w+")) == NULL) exit (1);
+ 
+     if (phile->tmpl) CopyTmplProlog (phile->tmpl, f);
+ 
+     (void) fprintf (f, 
+ 	"%s\n%s\n/* %s ABI version -- Do not edit */\n", 
+ 	"/* $XConsortium: makestrs.c,v 1.9 95/06/16 14:17:33 kaleb Exp $ */",
+ 	"/* This file is automatically generated. */",
+ 	abistring[abi]);
+ 
+     if (tagline) (void) fprintf (f, "/* %s */\n\n", tagline);
+ 
+     /* do the right thing for Motif, i.e. avoid _XmXmStrDefs_h_ */
+     if (strcmp (prefixstr, "Xm") == 0) {
+ 	if ((fileprotstr = malloc (strlen (phile->name) + 3)) == NULL)
+ 	   exit (1);
+ 	(void) sprintf (fileprotstr, "_%s_", phile->name);
+     } else {
+ 	if ((fileprotstr = malloc (strlen (phile->name) + strlen (prefixstr) +  3)) == NULL)
+ 	   exit (1);
+ 	(void) sprintf (fileprotstr, "_%s%s_", prefixstr, phile->name);
+     }
+ 
+     for (tmp = fileprotstr; *tmp; tmp++) if (*tmp == '.') *tmp = '_';
+ 
+     (*headerproc[abi])(f, phile);
+ 
+     if (phile->tmpl) CopyTmplEpilog (phile->tmpl, f);
+ 
+     (void) free (fileprotstr);
+     (void) fclose (phile->tmpl);
+     (void) fclose (f);
+ }
+ 
+ static void WriteSourceLine (te, abi, fudge)
+     TableEnt* te;
+     int abi;
+ {
+     char* c;
+ 
+     for (c = te->right; *c; c++) (void) printf ("'%c',", *c);
+     (void) printf ("%c", '0');
+     if (te->next || fudge) (void) printf ("%c", ',');
+     (void) printf ("%s", "\n");
+ }
+ 
+ static char* conststr = "%s Const char %s[] = {\n";
+ 
+ static void IntelABIWriteSource (abi)
+     int abi;
+ {
+     File* phile;
+ 
+     for (phile = file; phile; phile = phile->next) {
+ 	Table* t;
+ 	TableEnt* te;
+ 
+ 	for (t = phile->table; t; t = t->next) {
+ 	    (void) printf (conststr, externdefstr, t->name);
+ 	    for (te = t->tableent; te; te = te->next)
+ 		WriteSourceLine (te, abi, 0);
+ 	    (void) printf ("%s\n\n", "};");
+ 	}
+     }
+ }
+ 
+ static void IntelABIBCWriteSource (abi)
+     int abi;
+ {
+     File* phile;
+ 
+     for (phile = file; phile; phile = phile->next) {
+ 	Table* t;
+ 	TableEnt* te;
+ 
+ 	(void) printf (conststr, externdefstr, phile->table->name);
+ 
+ 	for (t = phile->table; t; t = t->next) 
+ 	    for (te = t->tableent; te; te = te->next)
+ 		WriteSourceLine (te, abi, t->next ? 1 : 0);
+ 	(void) printf ("%s\n\n", "};");
+ 
+ 	if (phile->table->next) {
+ 	    (void) printf (conststr, externdefstr, phile->table->next->name);
+ 	    for (t = phile->table->next; t; t = t->next) 
+ 		for (te = t->tableent; te; te = te->next)
+ 		    WriteSourceLine (te, abi, 0);
+ 	    (void) printf ("%s\n\n", "};");
+ 	}
+     }
+ }
+ 
+ static void FunctionWriteSource (abi)
+     int abi;
+ {
+     File* phile;
+ 
+     for (phile = file; phile; phile = phile->next) {
+ 	Table* t;
+ 	TableEnt* te;
+ 
+ 	(void) printf ("static Const char _%s[] = {\n", phile->table->name);
+ 
+ 	for (t = phile->table; t; t = t->next) 
+ 	    for (te = t->tableent; te; te = te->next)
+ 		WriteSourceLine (te, abi, t->next ? 1 : 0);
+ 	(void) printf ("%s\n\n", "};");
+ 
+ 	(void) printf ("Const char* %s(index)\n    int index;\n{\n    return &_%s[index];\n}\n\n",
+ 		phile->table->name, phile->table->name);
+     }
+ }
+ 
+ static void ArrayperWriteSource (abi)
+     int abi;
+ {
+     File* phile;
+     static int done_atom;
+ 
+     for (phile = file; phile; phile = phile->next) {
+ 	Table* t;
+ 	TableEnt* te;
+ 
+ 	for (t = phile->table; t; t = t->next) 
+ 	    for (te = t->tableent; te; te = te->next) {
+ 		if (strcmp (te->left, "RAtom") == 0) {
+ 		    if (done_atom) return;
+ 		    done_atom = 1;
+ 		}
+ 		(void) printf ("%s Const char %s%s[] = \"%s\";\n",
+ 			       externdefstr, prefixstr, te->left, te->right);
+ 	    }
+     }
+ }
+ 
+ static void DefaultWriteSource (abi)
+     int abi;
+ {
+     File* phile;
+ 
+     for (phile = file; phile; phile = phile->next) {
+ 	Table* t;
+ 	TableEnt* te;
+ 
+ 	(void) printf (conststr, externdefstr, phile->table->name);
+ 
+ 	for (t = phile->table; t; t = t->next) 
+ 	    for (te = t->tableent; te; te = te->next)
+ 		WriteSourceLine (te, abi, t->next ? 1 : 0);
+ 	(void) printf ("%s\n\n", "};");
+     }
+ }
+ 
+ static void WriteSource(tagline, abi)
+     char* tagline;
+     int abi;
+ {
+     static void (*sourceproc[])() = { 
+ 	DefaultWriteSource, ArrayperWriteSource,
+ 	IntelABIWriteSource, IntelABIBCWriteSource,
+ 	DefaultWriteSource, FunctionWriteSource };
+ 
+     FILE* tmpl;
+ 
+     if (ctmplstr) {
+ 	tmpl = fopen (ctmplstr, "r");
+ 
+ 	if (tmpl) CopyTmplProlog (tmpl, stdout);
+ 	else {
+ 	    (void) fprintf (stderr, "Expected template %s, not found\n",
+ 			    ctmplstr);
+ 	    exit (1);
+ 	}
+     } else
+ 	tmpl = NULL;
+ 
+ 
+     (void) printf ("%s\n%s\n/* %s ABI version -- Do not edit */\n", 
+ 		   "/* $XConsortium: makestrs.c,v 1.9 95/06/16 14:17:33 kaleb Exp $ */",
+ 		   "/* This file is automatically generated. */",
+ 		   abistring[abi]);
+ 
+     if (tagline) (void) printf ("/* %s */\n\n", tagline);
+ 
+     (*sourceproc[abi])(abi);
+ 
+     if (tmpl) CopyTmplEpilog (tmpl, stdout);
+ }
+ 
+ static void DoLine(buf)
+     char* buf;
+ {
+ #define X_NO_TOKEN 0
+ #define X_FILE_TOKEN 1
+ #define X_TABLE_TOKEN 2
+ #define X_PREFIX_TOKEN 3
+ #define X_FEATURE_TOKEN 4
+ #define X_EXTERNREF_TOKEN 5
+ #define X_EXTERNDEF_TOKEN 6
+ #define X_CTMPL_TOKEN 7
+ #define X_HTMPL_TOKEN 8
+ 
+     int token;
+     char lbuf[1024];
+     static char* file_str = "#file";
+     static char* table_str = "#table";
+     static char* prefix_str = "#prefix";
+     static char* feature_str = "#feature";
+     static char* externref_str = "#externref";
+     static char* externdef_str = "#externdef";
+     static char* ctmpl_str = "#ctmpl";
+     static char* htmpl_str = "#htmpl";
+ 
+     if (strncmp (buf, file_str, strlen (file_str)) == 0) 
+ 	token = X_FILE_TOKEN;
+     else if (strncmp (buf, table_str, strlen (table_str)) == 0) 
+ 	token = X_TABLE_TOKEN;
+     else if (strncmp (buf, prefix_str, strlen (prefix_str)) == 0) 
+ 	token = X_PREFIX_TOKEN;
+     else if (strncmp (buf, feature_str, strlen (feature_str)) == 0) 
+ 	token = X_FEATURE_TOKEN;
+     else if (strncmp (buf, externref_str, strlen (externref_str)) == 0) 
+ 	token = X_EXTERNREF_TOKEN;
+     else if (strncmp (buf, externdef_str, strlen (externdef_str)) == 0) 
+ 	token = X_EXTERNDEF_TOKEN;
+     else if (strncmp (buf, ctmpl_str, strlen (ctmpl_str)) == 0) 
+ 	token = X_CTMPL_TOKEN;
+     else if (strncmp (buf, htmpl_str, strlen (htmpl_str)) == 0) 
+ 	token = X_HTMPL_TOKEN;
+     else token = X_NO_TOKEN;
+ 
+     switch (token) {
+     case X_FILE_TOKEN:
+ 	{
+ 	    File* phile;
+ 
+ 	    if ((phile = (File*) malloc (sizeof(File))) == NULL) 
+ 		exit(1);
+ 	    if ((phile->name = malloc (strlen (buf + strlen (file_str)) + 1)) == NULL) 
+ 		exit(1);
+ 	    (void) strcpy (phile->name, buf + strlen (file_str) + 1);
+ 	    phile->table = NULL;
+ 	    phile->tablecurrent = NULL;
+ 	    phile->tabletail = &phile->table;
+ 	    phile->next = NULL;
+ 	    phile->tmpl = NULL;
+ 
+ 	    *filetail = phile;
+ 	    filetail = &phile->next;
+ 	    filecurrent = phile;
+ 	}
+ 	break;
+     case X_TABLE_TOKEN:
+ 	{
+ 	    Table* table;
+ 	    if ((table = (Table*) malloc (sizeof(Table))) == NULL) 
+ 		exit(1);
+ 	    if ((table->name = malloc (strlen (buf + strlen (table_str)) + 1)) == NULL) 
+ 		exit(1);
+ 	    (void) strcpy (table->name, buf + strlen (table_str) + 1);
+ 	    table->tableent = NULL;
+ 	    table->tableentcurrent = NULL;
+ 	    table->tableenttail = &table->tableent;
+ 	    table->next = NULL;
+ 	    table->offset = 0;
+ 
+ 	    *filecurrent->tabletail = table;
+ 	    filecurrent->tabletail = &table->next;
+ 	    filecurrent->tablecurrent = table;
+ 	}
+ 	break;
+     case X_PREFIX_TOKEN:
+ 	if ((prefixstr = malloc (strlen (buf + strlen (prefix_str)) + 1)) == NULL) 
+ 	    exit(1);
+ 	(void) strcpy (prefixstr, buf + strlen (prefix_str) + 1);
+ 	break;
+     case X_FEATURE_TOKEN:
+ 	if ((featurestr = malloc (strlen (buf + strlen (feature_str)) + 1)) == NULL) 
+ 	    exit(1);
+ 	(void) strcpy (featurestr, buf + strlen (feature_str) + 1);
+ 	break;
+     case X_EXTERNREF_TOKEN:
+ 	if ((externrefstr = malloc (strlen (buf + strlen (externref_str)) + 1)) == NULL) 
+ 	    exit(1);
+ 	(void) strcpy (externrefstr, buf + strlen (externref_str) + 1);
+ 	break;
+     case X_EXTERNDEF_TOKEN:
+ 	if ((externdefstr = malloc (strlen (buf + strlen (externdef_str)) + 1)) == NULL) 
+ 	    exit(1);
+ 	(void) strcpy (externdefstr, buf + strlen (externdef_str) + 1);
+ 	break;
+     case X_CTMPL_TOKEN:
+ 	if ((ctmplstr = malloc (strlen (buf + strlen (ctmpl_str)) + 1)) == NULL) 
+ 	    exit(1);
+ 	(void) strcpy (ctmplstr, buf + strlen (ctmpl_str) + 1);
+ 	break;
+     case X_HTMPL_TOKEN:
+ 	if ((filecurrent->tmpl = fopen (buf + strlen (htmpl_str) + 1, "r")) == NULL) {
+ 	    (void) fprintf (stderr, 
+ 			    "Expected template %s, not found\n", htmpl_str);
+ 	    exit (1);
+ 	}
+ 	break;
+     default:
+ 	{
+ 	    char* right;
+ 	    TableEnt* tableent;
+ 	    int llen;
+ 	    int rlen;
+ 	    int len;
+ 
+ 	    if (right = index(buf, ' '))
+ 		*right++ = 0;
+ 	    else
+ 		right = buf + 1;
+ 	    if (buf[0] == 'H') {
+ 		strcpy (lbuf, prefixstr);
+ 		strcat (lbuf, right);
+ 		right = lbuf;
+ 	    }
+ 
+ 	    llen = len = strlen(buf) + 1;
+ 	    rlen = strlen(right) + 1;
+ 	    if (right != buf + 1) len += rlen;
+ 	    if ((tableent = (TableEnt*)malloc(sizeof(TableEnt) + len)) == NULL)
+ 		exit(1);
+ 	    tableent->left = (char *)(tableent + 1);
+ 	    strcpy(tableent->left, buf);
+ 	    if (llen != len) {
+ 		tableent->right = tableent->left + llen;
+ 		strcpy(tableent->right, right);
+ 	    } else {
+ 		tableent->right = tableent->left + 1;
+ 	    }
+ 	    tableent->next = NULL;
+ 
+ 	    *filecurrent->tablecurrent->tableenttail = tableent;
+ 	    filecurrent->tablecurrent->tableenttail = &tableent->next;
+ 	    filecurrent->tablecurrent->tableentcurrent = tableent;
+ 	}
+ 	break;
+     }
+ }
+ 
+ static void IntelABIIndexEntries (file)
+     File* file;
+ {
+     Table* t;
+     TableEnt* te;
+ 
+     for (t = file->table; t; t = t->next)
+ 	for (te = t->tableent; te; te = te->next) {
+ 	    te->offset = t->offset;
+ 	    t->offset += strlen (te->right);
+ 	    t->offset++;
+     }
+ }
+ 
+ static void DefaultIndexEntries (file)
+     File* file;
+ {
+     Table* t;
+     TableEnt* te;
+     int offset = 0;
+ 
+     for (t = file->table; t; t = t->next)
+ 	for (te = t->tableent; te; te = te->next) {
+ 	    te->offset = offset;
+ 	    offset += strlen (te->right);
+ 	    offset++;
+     }
+ }
+ 
+ static void IndexEntries (file,abi)
+     File* file;
+     int abi;
+ {
+     switch (abi) {
+     case X_SPARC_ABI:
+ 	break;
+     case X_INTEL_ABI:
+     case X_INTEL_ABI_BC:
+ 	IntelABIIndexEntries (file);
+ 	break;
+     default:
+ 	DefaultIndexEntries (file);
+ 	break;
+     }
+ }
+ 
+ static char* DoComment (line)
+     char* line;
+ {
+     char* tag;
+     char* eol;
+     char* ret;
+     int len;
+ 
+     /* assume that the first line with two '$' in it is the RCS tag line */
+     if ((tag = index (line, '$')) == NULL) return NULL;
+     if ((eol = index (tag + 1, '$')) == NULL) return NULL;
+     len = eol - tag;
+     if ((ret = malloc (len)) == NULL)
+ 	exit (1);
+     (void) strncpy (ret, tag + 1, len - 1);
+     ret[len - 2] = 0;
+     return ret;
+ }
+ 
+ int main(argc, argv)
+     int argc;
+     char** argv;
+ {
+     int len, i;
+     char* tagline = NULL;
+     File* phile;
+     FILE *f;
+     char buf[1024];
+     int abi = 
+ #ifndef ARRAYPERSTR
+ 	X_DEFAULT_ABI;
+ #else
+ 	X_ARRAYPER_ABI;
+ #endif
+ 
+     f = stdin;
+     if (argc > 1) {
+ 	for (i = 1; i < argc; i++) {
+ 	    if (strcmp (argv[i], "-f") == 0) {
+ 		if (++i < argc)
+ 		    f = fopen (argv[i], "r");
+ 		else
+ 		    return 1;
+ 	    }
+ 	    if (strcmp (argv[i], "-sparcabi") == 0)
+ 		abi = X_SPARC_ABI;
+ 	    if (strcmp (argv[i], "-intelabi") == 0)
+ 		abi = X_INTEL_ABI;
+ 	    if (strcmp (argv[i], "-functionabi") == 0)
+ 		abi = X_FUNCTION_ABI;
+ 	    if (strcmp (argv[i], "-earlyR6bc") == 0 && abi == X_INTEL_ABI)
+ 		abi = X_INTEL_ABI_BC;
+ 	    if (strcmp (argv[i], "-arrayperabi") == 0)
+ 		abi = X_ARRAYPER_ABI;
+ #ifdef ARRAYPERSTR
+ 	    if (strcmp (argv[i], "-defaultabi") == 0)
+ 		abi = X_DEFAULT_ABI;
+ #endif
+ 	}
+     }
+ 
+     if (f == NULL) return 1;
+     while (fgets(buf, sizeof buf, f)) {
+ 	if (!buf[0] || buf[0] == '\n') 
+ 	    continue;
+ 	if (buf[0] == '!') {
+ 	    if (tagline) continue;
+ 	    tagline = DoComment (buf);
+ 	    continue;
+ 	}
+ 	if (buf[(len = strlen (buf) - 1)] == '\n') buf[len] = '\0';
+ 	DoLine(buf);
+     }
+     for (phile = file; phile; phile = phile->next) {
+ 	if (abi != X_ARRAYPER_ABI) IndexEntries (phile, abi);
+ 	WriteHeader (tagline, phile, abi);
+     }
+     WriteSource(tagline, abi);
+     return 0;
+ }
+ 
*** /dev/null	Fri Jul  7 09:30:37 1995
--- xc/config/util/makestrs.man	Fri Jul  7 09:30:37 1995
***************
*** 0 ****
--- 1,213 ----
+ .\" $XConsortium: makestrs.man,v 1.1 95/05/11 22:30:38 kaleb Exp $
+ .\" Copyright (c) 1993, 1994  X Consortium
+ .\" 
+ .\" Permission is hereby granted, free of charge, to any person obtaining a
+ .\" copy of this software and associated documentation files (the "Software"), 
+ .\" to deal in the Software without restriction, including without limitation 
+ .\" the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ .\" and/or sell copies of the Software, and to permit persons to whom the 
+ .\" Software furnished to do so, subject to the following conditions:
+ .\" 
+ .\" The above copyright notice and this permission notice shall be included in
+ .\" all copies or substantial portions of the Software.
+ .\" 
+ .\" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ .\" IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ .\" FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL 
+ .\" THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
+ .\" WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF 
+ .\" OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
+ .\" SOFTWARE.
+ .\" 
+ .\" Except as contained in this notice, the name of the X Consortium shall not 
+ .\" be used in advertising or otherwise to promote the sale, use or other 
+ .\" dealing in this Software without prior written authorization from the 
+ .\" X Consortium.
+ .TH MAKESTRS 1 "Release 6" "X Version 11"
+ .SH NAME
+ makestrs \- makes string table C source and header(s)
+ .SH SYNOPSIS
+ .B makestrs [-f source] [-abioptions ...]
+ .SH DESCRIPTION
+ The
+ .I makestrs
+ command creates string table C source files and headers.
+ If
+ .I -f
+ .I source
+ is not specified
+ .I makestrs
+ will read from
+ .I stdin.
+ The C source file is always written to
+ .I stdout.
+ .I makestrs
+ creates one or more C header files as specified in the source file.
+ The following options may be specified:
+ .I -sparcabi,
+ .I -intelabi,
+ .I -functionabi,
+ .I -arrayperabi,
+ and
+ .I -defaultabi.
+ .LP
+ .I -sparcabi 
+ is used on SPARC platforms conforming to the SPARC 
+ Compliance Definition, i.e. SVR4/Solaris.
+ .LP
+ .I -intelabi 
+ is used on Intel platforms conforming to the System 
+ V Application Binary Interface, i.e. SVR4.
+ .LP
+ .I -earlyR6abi 
+ may be used in addition to 
+ .I -intelabi 
+ for situations 
+ where the vendor wishes to maintain binary compatiblity between 
+ X11R6 public-patch 11 (and earlier) and X11R6 public-patch 12 (and later).
+ .LP
+ .I -functionabi 
+ generates a functional abi to the string table. This 
+ mechanism imposes a severe performance penalty and it's recommended 
+ that you not use it.
+ .LP
+ .I -arrayperabi 
+ results in a separate array for each string. This is 
+ the default behavior if makestrs was compiled with -DARRAYPERSTR 
+ (it almost never is).
+ .LP
+ .I -defaultabi 
+ forces the generation of the "normal" string table even 
+ if makestrs was compiled with -DARRAYPERSTR. Since makestrs is almost 
+ never compiled with -DARRAYPERSTR this is the default behavior if 
+ no abioptions are specified.
+ .SH SYNTAX
+ The syntax for string-list file is (items in square brackets are optional):
+ .RS 4
+ #prefix <text>
+ .RE
+ .RS 4
+ #feature <text>
+ .RE
+ .RS 4
+ #externref <text>
+ .RE
+ .RS 4
+ #externdef [<text>]
+ .RE
+ .RS 4
+ [#ctempl <text>]
+ .RE
+ .LP
+ .RS 4
+ #file <filename>
+ .RE
+ .RS 4
+ #table <tablename>
+ .RE
+ .RS 4
+ [#htempl]
+ .RE
+ .RS 4
+ <text>
+ .RE
+ .RS 4
+ ...
+ .RE
+ .RS 4
+ <text>
+ .RE
+ .RS 4
+ [#table <tablename>
+ .RE
+ .RS 4
+ <text>
+ .RE
+ .RS 4
+ ...
+ .RE
+ .RS 4
+ <text>
+ .RE
+ .RS 4
+ ...
+ .RE
+ .RS 4
+ #table <tablename>
+ .RE
+ .RS 4
+ ...]
+ .RE
+ .RS 4
+ [#file <filename>
+ .RE
+ .RS 4
+ ...]
+ .RE
+ .LP
+ In words you may have one or more #file directives. Each #file may have
+ one or more #table directives.
+ .LP
+ The #prefix directive determines the string that makestr will prefix
+ to each definition.
+ .LP
+ The #feature directive determines the string that makestr will use
+ for the feature-test macro, e.g. X[TM]STRINGDEFINES.
+ .LP
+ The #externref directive determines the string that makestr will use
+ for the extern clause, typically this will be "extern" but Motif wants
+ it to be "externalref"
+ .LP
+ The #externdef directive determines the string that makestr will use
+ for the declaration, typically this will be the null string (note that
+ makestrs requires a trailing space in this case, i.e. "#externdef "),
+ and Motif will use "externaldef(_xmstrings).
+ .LP
+ The #ctmpl directive determines the name of the file used as a template
+ for the C source file that is generated
+ .LP
+ Each #file <filename> directive will result in a corresponding header 
+ file by that name containing the appropriate definitions as specified
+ by command line options. A single C source file containing the
+ declarations for the definitions in all the headers will be printed
+ to stdout.
+ .LP
+ The #htmpl directive determines the name of the file used as a template
+ for the C header file that is generated.
+ .LP
+ Each #table <tablename> directive will be processed in accordance with
+ the ABI. On most platforms all tables will be catenated into a single
+ table with the name of the first table for that file. To conform to
+ the Intel ABI separate tables will be generated with the names indicated.
+ .LP
+ The template files specified by the #ctmpl and #htmpl directives
+ are processed by copying line for line from the template file to
+ the appropriate output file. The line containing the string
+ .I <<<STRING_TABLE_GOES_HERE>>>
+ is not copied to the output file. The appropriate data is then
+ copied to the output file and then the remainder of the template
+ file is copied to the output file.
+ .SH BUGS
+ makestrs is not very forgiving of syntax errors. Sometimes you need
+ a trailing space after # directives, other times they will mess you
+ up. No warning messages are emitted.
+ .SH SEE ALSO
+ SPARC Compliance Definition 2.2., SPARC International Inc.,
+ 535 Middlefield Road, Suite 210, Menlo Park, CA  94025
+ .LP
+ System V Application Binary Interface, Third Edition, 
+ ISBN 0-13-100439-5
+ UNIX Press, PTR Prentice Hall, 113 Sylvan Avenue, Englewood Cliffs, 
+ NJ  07632
+ .LP
+ System V Application Binary Interface, Third Edition, Intel386
+ Architecture Processor Supplement
+ ISBN 0-13-104670-5
+ UNIX Press, PTR Prentice Hall, 113 Sylvan Avenue, Englewood Cliffs, 
+ NJ  07632
+ .LP
+ System V Application Binary Interface, Third Edition, SPARC
+ Architecture Processor Supplement
+ ISBN 0-13-104696-9
+ UNIX Press, PTR Prentice Hall, 113 Sylvan Avenue, Englewood Cliffs, 
+ NJ  07632
*** -	Fri Jul  7 09:30:38 1995
--- xc/lib/X11/Imakefile	Fri Jul  7 09:30:38 1995
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile,v 1.182 94/04/14 09:07:43 rws Exp $
  #define DoNormalLib NormalLibX11
  #define DoSharedLib SharedLibX11
  #define DoDebugLib DebugLibX11
--- 1,4 ----
! XCOMM $XConsortium: Imakefile,v 1.184 95/06/29 18:53:00 kaleb Exp $
  #define DoNormalLib NormalLibX11
  #define DoSharedLib SharedLibX11
  #define DoDebugLib DebugLibX11
***************
*** 463,471 ****
  	Withdraw.c \
  	WMGeom.c \
  	WMProps.c \
! 	$(AUTHSRCS) \
! 	$(XDMAUTHSRCS) \
! 	$(K5SRCS)
  
  OBJS2 = \
  	Macros.o \
--- 463,469 ----
  	Withdraw.c \
  	WMGeom.c \
  	WMProps.c \
! 	$(AUTHSRCS) $(XDMAUTHSRCS) $(K5SRCS)
  
  OBJS2 = \
  	Macros.o \
***************
*** 889,897 ****
  SpecialCLibObjectRule(ErrDes,$(ICONFIGFILES),$(EDB_DEFINES))
  SpecialCLibObjectRule(StrKeysym,$(ICONFIGFILES),$(KDB_DEFINES))
  SpecialCLibObjectRule(ConnDis,$(ICONFIGFILES),$(XDMAUTHDEFS) $(RPCDEFS) $(CONN_DEFINES) $(SOCK_DEFINES) $(POLL_DEFINES) $(XTRANS_X_DEFINES) $(K5INCL) $(K5DEFS))
! SpecialCLibObjectRule(x11trans,$(ICONFIGFILES),$(TRANS_INCLUDES) $(CONN_DEFINES) $(SOCK_DEFINES) $(XTRANS_X_DEFINES))
  LinkFile(x11trans.c,$(TRANSCOMMSRC)/transport.c)
! SpecialCLibObjectRule(ximtrans,$(ICONFIGFILES),$(TRANS_INCLUDES) $(CONN_DEFINES) $(SOCK_DEFINES) $(XTRANS_XIM_DEFINES))
  LinkFile(ximtrans.c,$(TRANSCOMMSRC)/transport.c)
  SpecialCLibObjectRule(OpenDis,$(ICONFIGFILES),$(BC_DEFINES) $(OPEN_DEFINES) $(XTRANS_X_DEFINES) $(XKB_DEFINES))
  SpecialCLibObjectRule(Wrap,$(ICONFIGFILES),$(XDMAUTHDEFS))
--- 887,895 ----
  SpecialCLibObjectRule(ErrDes,$(ICONFIGFILES),$(EDB_DEFINES))
  SpecialCLibObjectRule(StrKeysym,$(ICONFIGFILES),$(KDB_DEFINES))
  SpecialCLibObjectRule(ConnDis,$(ICONFIGFILES),$(XDMAUTHDEFS) $(RPCDEFS) $(CONN_DEFINES) $(SOCK_DEFINES) $(POLL_DEFINES) $(XTRANS_X_DEFINES) $(K5INCL) $(K5DEFS))
! SpecialCLibObjectRule(x11trans,$(ICONFIGFILES),$(TRANS_INCLUDES) $(CONN_DEFINES) $(SOCK_DEFINES) $(XTRANS_X_DEFINES) $(POLL_DEFINES))
  LinkFile(x11trans.c,$(TRANSCOMMSRC)/transport.c)
! SpecialCLibObjectRule(ximtrans,$(ICONFIGFILES),$(TRANS_INCLUDES) $(CONN_DEFINES) $(SOCK_DEFINES) $(XTRANS_XIM_DEFINES) $(POLL_DEFINES))
  LinkFile(ximtrans.c,$(TRANSCOMMSRC)/transport.c)
  SpecialCLibObjectRule(OpenDis,$(ICONFIGFILES),$(BC_DEFINES) $(OPEN_DEFINES) $(XTRANS_X_DEFINES) $(XKB_DEFINES))
  SpecialCLibObjectRule(Wrap,$(ICONFIGFILES),$(XDMAUTHDEFS))
*** -	Fri Jul  7 09:30:39 1995
--- xc/lib/X11/Xlib.h	Fri Jul  7 09:30:39 1995
***************
*** 1,4 ****
! /* $XConsortium: Xlib.h,v 11.237 94/09/01 18:44:49 kaleb Exp $ */
  /* 
  
  Copyright (c) 1985, 1986, 1987, 1991  X Consortium
--- 1,4 ----
! /* $XConsortium: Xlib.h,v 11.239 95/05/22 19:37:37 kaleb Exp $ */
  /* 
  
  Copyright (c) 1985, 1986, 1987, 1991  X Consortium
***************
*** 1082,1089 ****
  } XOrientation;
  
  typedef struct {
!     int num_orient;
!     XOrientation *orient;	/* Input Text description */
  } XOMOrientation;
  
  typedef struct {
--- 1082,1089 ----
  } XOrientation;
  
  typedef struct {
!     int num_orientation;
!     XOrientation *orientation;	/* Input Text description */
  } XOMOrientation;
  
  typedef struct {
***************
*** 1245,1253 ****
  #define	XIMStringConversionSubstitution	(0x0001)
  #define	XIMStringConversionRetrival	(0x0002)
  
  typedef struct _XIMStringConversionCallbackStruct {
      XIMStringConversionPosition position;
!     XIMStringConversionType type;
      XIMStringConversionOperation operation;
      unsigned short factor;
      XIMStringConversionText *text;
--- 1245,1263 ----
  #define	XIMStringConversionSubstitution	(0x0001)
  #define	XIMStringConversionRetrival	(0x0002)
  
+ typedef enum {
+     XIMForwardChar, XIMBackwardChar,
+     XIMForwardWord, XIMBackwardWord,
+     XIMCaretUp, XIMCaretDown,
+     XIMNextLine, XIMPreviousLine,
+     XIMLineStart, XIMLineEnd, 
+     XIMAbsolutePosition,
+     XIMDontChange
+ } XIMCaretDirection;
+ 
  typedef struct _XIMStringConversionCallbackStruct {
      XIMStringConversionPosition position;
!     XIMCaretDirection direction;
      XIMStringConversionOperation operation;
      unsigned short factor;
      XIMStringConversionText *text;
***************
*** 1259,1274 ****
      int chg_length;	/* Length of the change in character count */
      XIMText *text;
  } XIMPreeditDrawCallbackStruct;
- 
- typedef enum {
-     XIMForwardChar, XIMBackwardChar,
-     XIMForwardWord, XIMBackwardWord,
-     XIMCaretUp, XIMCaretDown,
-     XIMNextLine, XIMPreviousLine,
-     XIMLineStart, XIMLineEnd, 
-     XIMAbsolutePosition,
-     XIMDontChange
- } XIMCaretDirection;
  
  typedef enum {
      XIMIsInvisible,	/* Disable caret feedback */ 
--- 1269,1274 ----
*** -	Fri Jul  7 09:30:41 1995
--- xc/lib/X11/Xlibint.h	Fri Jul  7 09:30:41 1995
***************
*** 1,4 ****
! /* $XConsortium: Xlibint.h,v 11.143 94/04/17 20:21:50 rws Exp $ */
  
  /*
  
--- 1,4 ----
! /* $XConsortium: Xlibint.h,v 11.143.1.1 95/06/19 19:33:25 gildea Exp $ */
  
  /*
  
***************
*** 303,311 ****
   */
  #ifdef MALLOC_0_RETURNS_NULL
  
! # define Xmalloc(size) malloc(((size) > 0 ? (size) : 1))
! # define Xrealloc(ptr, size) realloc((ptr), ((size) > 0 ? (size) : 1))
! # define Xcalloc(nelem, elsize) calloc(((nelem) > 0 ? (nelem) : 1), (elsize))
  
  #else
  
--- 303,311 ----
   */
  #ifdef MALLOC_0_RETURNS_NULL
  
! # define Xmalloc(size) malloc(((size) == 0 ? 1 : (size)))
! # define Xrealloc(ptr, size) realloc((ptr), ((size) == 0 ? 1 : (size)))
! # define Xcalloc(nelem, elsize) calloc(((nelem) == 0 ? 1 : (nelem)), (elsize))
  
  #else
  
***************
*** 399,405 ****
   *
   */
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define GetReq(name, req) \
          WORD64ALIGN\
  	if ((dpy->bufptr + SIZEOF(x##name##Req)) > dpy->bufmax)\
--- 399,405 ----
   *
   */
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define GetReq(name, req) \
          WORD64ALIGN\
  	if ((dpy->bufptr + SIZEOF(x##name##Req)) > dpy->bufmax)\
***************
*** 425,431 ****
  /* GetReqExtra is the same as GetReq, but allocates "n" additional
     bytes after the request. "n" must be a multiple of 4!  */
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define GetReqExtra(name, n, req) \
          WORD64ALIGN\
  	if ((dpy->bufptr + SIZEOF(x##name##Req) + n) > dpy->bufmax)\
--- 425,431 ----
  /* GetReqExtra is the same as GetReq, but allocates "n" additional
     bytes after the request. "n" must be a multiple of 4!  */
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define GetReqExtra(name, n, req) \
          WORD64ALIGN\
  	if ((dpy->bufptr + SIZEOF(x##name##Req) + n) > dpy->bufmax)\
***************
*** 454,460 ****
   * "rid" is the name of the resource. 
   */
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define GetResReq(name, rid, req) \
          WORD64ALIGN\
  	if ((dpy->bufptr + SIZEOF(xResourceReq)) > dpy->bufmax)\
--- 454,460 ----
   * "rid" is the name of the resource. 
   */
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define GetResReq(name, rid, req) \
          WORD64ALIGN\
  	if ((dpy->bufptr + SIZEOF(xResourceReq)) > dpy->bufmax)\
***************
*** 482,488 ****
   * GetEmptyReq is for those requests that have no arguments
   * at all. 
   */
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define GetEmptyReq(name, req) \
          WORD64ALIGN\
  	if ((dpy->bufptr + SIZEOF(xReq)) > dpy->bufmax)\
--- 482,488 ----
   * GetEmptyReq is for those requests that have no arguments
   * at all. 
   */
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define GetEmptyReq(name, req) \
          WORD64ALIGN\
  	if ((dpy->bufptr + SIZEOF(xReq)) > dpy->bufmax)\
*** -	Fri Jul  7 09:30:42 1995
--- xc/lib/X11/Xcmsint.h	Fri Jul  7 09:30:42 1995
***************
*** 1,4 ****
! /* $XConsortium: Xcmsint.h,v 1.18 92/06/05 16:47:53 converse Exp $ */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
--- 1,4 ----
! /* $XConsortium: Xcmsint.h,v 1.19 95/06/08 23:20:39 gildea Exp $ */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
***************
*** 194,200 ****
  #define XCMS_SQRT(x)		_XcmsSquareRoot(x)
  #define XCMS_TAN(x)		(XCMS_SIN(x) / XCMS_COS(x))
  
! #if __STDC__
  double _XcmsArcTangent(double a);
  double _XcmsCosine(double a);
  double _XcmsCubeRoot(double a);
--- 194,200 ----
  #define XCMS_SQRT(x)		_XcmsSquareRoot(x)
  #define XCMS_TAN(x)		(XCMS_SIN(x) / XCMS_COS(x))
  
! #ifdef __STDC__
  double _XcmsArcTangent(double a);
  double _XcmsCosine(double a);
  double _XcmsCubeRoot(double a);
*** -	Fri Jul  7 09:30:43 1995
--- xc/lib/X11/XlcPubI.h	Fri Jul  7 09:30:43 1995
***************
*** 1,4 ****
! /* $XConsortium: XlcPubI.h,v 1.3 94/01/20 18:03:11 rws Exp $ */
  /*
   * Copyright 1992, 1993 by TOSHIBA Corp.
   *
--- 1,4 ----
! /* $XConsortium: XlcPubI.h,v 1.4 95/02/22 22:02:55 kaleb Exp $ */
  /*
   * Copyright 1992, 1993 by TOSHIBA Corp.
   *
***************
*** 135,140 ****
--- 135,147 ----
  );
  
  extern XlcCharSet _XlcCreateDefaultCharSet(
+ #if NeedFunctionPrototypes
+     char*		/* name */,
+     char*		/* control_sequence */
+ #endif
+ );
+ 
+ extern XlcCharSet _XlcAddCT(
  #if NeedFunctionPrototypes
      char*		/* name */,
      char*		/* control_sequence */
*** -	Fri Jul  7 09:30:44 1995
--- xc/lib/X11/ChkMaskEv.c	Fri Jul  7 09:30:44 1995
***************
*** 1,4 ****
! /* $XConsortium: ChkMaskEv.c,v 11.25 94/04/17 20:18:46 gildea Exp $ */
  /*
  
  Copyright (c) 1985, 1987  X Consortium
--- 1,4 ----
! /* $XConsortium: ChkMaskEv.c,v 11.26 95/06/08 23:20:39 gildea Exp $ */
  /*
  
  Copyright (c) 1985, 1987  X Consortium
***************
*** 29,35 ****
  #define NEED_EVENTS
  #include "Xlibint.h"
  
! #if __STDC__
  #define Const const
  #else
  #define Const /**/
--- 29,35 ----
  #define NEED_EVENTS
  #include "Xlibint.h"
  
! #ifdef __STDC__
  #define Const const
  #else
  #define Const /**/
*** -	Fri Jul  7 09:30:44 1995
--- xc/lib/X11/ChkWinEv.c	Fri Jul  7 09:30:44 1995
***************
*** 1,4 ****
! /* $XConsortium: ChkWinEv.c,v 11.23 94/04/17 20:18:48 gildea Exp $ */
  /*
  
  Copyright (c) 1985, 1987  X Consortium
--- 1,4 ----
! /* $XConsortium: ChkWinEv.c,v 11.24 95/06/08 23:20:39 gildea Exp $ */
  /*
  
  Copyright (c) 1985, 1987  X Consortium
***************
*** 29,35 ****
  #define NEED_EVENTS
  #include "Xlibint.h"
  
! #if __STDC__
  #define Const const
  #else
  #define Const /**/
--- 29,35 ----
  #define NEED_EVENTS
  #include "Xlibint.h"
  
! #ifdef __STDC__
  #define Const const
  #else
  #define Const /**/
*** -	Fri Jul  7 09:30:46 1995
--- xc/lib/X11/ConnDis.c	Fri Jul  7 09:30:46 1995
***************
*** 1,4 ****
! /* $XConsortium: ConnDis.c,v 11.123 94/05/19 11:00:27 mor Exp $ */
  /*
   
  Copyright (c) 1989  X Consortium
--- 1,4 ----
! /* $XConsortium: ConnDis.c,v 11.123.1.1 95/06/12 18:00:41 mor Exp $ */
  /*
   
  Copyright (c) 1989  X Consortium
***************
*** 105,111 ****
      int family;
      int saddrlen;
      Xtransaddr *saddr;
!     char *lastp, *p;			/* char pointers */
      char *pprotocol = NULL;		/* start of protocol name */
      char *phostname = NULL;		/* start of host of display */
      char *pdpynum = NULL;		/* start of dpynum of display */
--- 105,111 ----
      int family;
      int saddrlen;
      Xtransaddr *saddr;
!     char *lastp, *lastc, *p;		/* char pointers */
      char *pprotocol = NULL;		/* start of protocol name */
      char *phostname = NULL;		/* start of host of display */
      char *pdpynum = NULL;		/* start of dpynum of display */
***************
*** 114,120 ****
      int idisplay;			/* required display number */
      int iscreen = 0;			/* optional screen number */
      int (*connfunc)();			/* method to create connection */
!     int len;				/* length tmp variable */
      int retry;				/* retry counter */
      char address[128];			/* final address passed to
  					   X Transport Interface */
--- 114,120 ----
      int idisplay;			/* required display number */
      int iscreen = 0;			/* optional screen number */
      int (*connfunc)();			/* method to create connection */
!     int len, hostlen;			/* length tmp variable */
      int retry;				/* retry counter */
      char address[128];			/* final address passed to
  					   X Transport Interface */
***************
*** 145,160 ****
  					   case no protocol was given */
  
      /*
!      * Step 1, find the hostname.  This is delimited by the required 
!      * first colon.
       */
-     for (lastp = p; *p && *p != ':'; p++) ;
-     if (!*p) return NULL;		/* must have a colon */
  
!     if (p != lastp) {		/* hostname given? */
! 	phostname = copystring (lastp, p - lastp);
  	if (!phostname) goto bad;	/* no memory */
      }
  #ifdef LOCALCONN
      /* check if phostname == localnodename */
      if (phostname && uname(&sys) >= 0 &&
--- 145,187 ----
  					   case no protocol was given */
  
      /*
!      * Step 1, find the hostname.  This is delimited by either one colon,
!      * or two colons in the case of DECnet (DECnet Phase V allows a single
!      * colon in the hostname).
       */
  
!     lastp = p;
!     lastc = NULL;
!     for (; *p; p++)
! 	if (*p == ':')
! 	    lastc = p;
! 
!     if (!lastc) return NULL;		/* must have a colon */
! 
!     if ((lastp != lastc) && (*(lastc - 1) == ':')) {
! 	/* DECnet display specified */
! 
! #ifndef DNETCONN
! 	goto bad;
! #else
! 	dnet = True;
! 	/* override the protocol specified */
! 	if (pprotocol)
! 	    Xfree (pprotocol);
! 	pprotocol = copystring ("dnet", 4);
! 	hostlen = lastc - 1 - lastp;
! #endif
!     }
!     else
! 	hostlen = lastc - lastp;
! 
!     if (hostlen > 0) {		/* hostname given? */
! 	phostname = copystring (lastp, hostlen);
  	if (!phostname) goto bad;	/* no memory */
      }
+ 
+     p = lastc;
+ 
  #ifdef LOCALCONN
      /* check if phostname == localnodename */
      if (phostname && uname(&sys) >= 0 &&
***************
*** 167,191 ****
  
  
      /*
!      * Step 2, see if this is a DECnet address by looking for the optional
!      * second colon.
!      */
!     if (p[1] == ':') {			/* then DECnet format */
! 	dnet = True;
! 	if( pprotocol ) Xfree(pprotocol); /* override the protocol specified */
! 	pprotocol = copystring ("dnet", 4);
! 	p++;
!     }
! 
!     /*
!      * see if we're allowed to have a DECnet address
!      */
! #ifndef DNETCONN
!     if (dnet) goto bad;
! #endif
! 
!     /*
!      * Step 3, find the display number.  This field is required and is 
       * delimited either by a nul or a period, depending on whether or not
       * a screen number is present.
       */
--- 194,200 ----
  
  
      /*
!      * Step 2, find the display number.  This field is required and is 
       * delimited either by a nul or a period, depending on whether or not
       * a screen number is present.
       */
***************
*** 199,205 ****
  
  
      /*
!      * Step 4, find the screen number.  This field is optional.  It is 
       * present only if the display number was followed by a period (which
       * we've already verified is the only non-nul character).
       */
--- 208,214 ----
  
  
      /*
!      * Step 3, find the screen number.  This field is optional.  It is 
       * present only if the display number was followed by a period (which
       * we've already verified is the only non-nul character).
       */
***************
*** 319,325 ****
  	    sleep(1);
  	    if (saddr)
  	    {
! 		Xfree (saddr);
  		saddr = NULL;
  	    }
  	    continue;
--- 328,334 ----
  	    sleep(1);
  	    if (saddr)
  	    {
! 		free ((char *) saddr);
  		saddr = NULL;
  	    }
  	    continue;
***************
*** 369,375 ****
       */
    bad:
      if (trans_conn) (void)_X11TransClose(trans_conn);
!     if (saddr) Xfree (saddr);
      if (pprotocol) Xfree (pprotocol);
      if (phostname) Xfree (phostname);
      if (pdpynum) Xfree (pdpynum);
--- 378,384 ----
       */
    bad:
      if (trans_conn) (void)_X11TransClose(trans_conn);
!     if (saddr) free ((char *) saddr);
      if (pprotocol) Xfree (pprotocol);
      if (phostname) Xfree (phostname);
      if (pdpynum) Xfree (pdpynum);
***************
*** 1093,1099 ****
  	}
      }
  #endif
!     if (saddr) Xfree (saddr);
      if (*auth_namelenp = auth_namelen)
      {
  	if (*auth_namep = Xmalloc(auth_namelen))
--- 1102,1108 ----
  	}
      }
  #endif
!     if (saddr) free ((char *) saddr);
      if (*auth_namelenp = auth_namelen)
      {
  	if (*auth_namep = Xmalloc(auth_namelen))
*** -	Fri Jul  7 09:30:47 1995
--- xc/lib/X11/CrGC.c	Fri Jul  7 09:30:47 1995
***************
*** 1,4 ****
! /* $XConsortium: CrGC.c,v 11.42 94/04/17 20:18:59 kaleb Exp $ */
  /*
  
  Copyright (c) 1986  X Consortium
--- 1,4 ----
! /* $XConsortium: CrGC.c,v 11.43 95/06/08 23:20:39 gildea Exp $ */
  /*
  
  Copyright (c) 1986  X Consortium
***************
*** 28,34 ****
  
  #include "Xlibint.h"
  
! #if __STDC__
  #define Const const
  #else
  #define Const /**/
--- 28,34 ----
  
  #include "Xlibint.h"
  
! #ifdef __STDC__
  #define Const const
  #else
  #define Const /**/
*** -	Fri Jul  7 09:30:48 1995
--- xc/lib/X11/ErrDes.c	Fri Jul  7 09:30:48 1995
***************
*** 1,5 ****
  /*
!  * $XConsortium: ErrDes.c,v 11.53 94/04/17 20:19:14 kaleb Exp $
   */
  
  /***********************************************************
--- 1,5 ----
  /*
!  * $XConsortium: ErrDes.c,v 11.54 95/06/08 23:20:39 gildea Exp $
   */
  
  /***********************************************************
***************
*** 59,65 ****
  #define ERRORDB "/usr/lib/X11/XErrorDB"
  #endif
  
! #if __STDC__
  #define Const const
  #else
  #define Const /**/
--- 59,65 ----
  #define ERRORDB "/usr/lib/X11/XErrorDB"
  #endif
  
! #ifdef __STDC__
  #define Const const
  #else
  #define Const /**/
*** -	Fri Jul  7 09:30:48 1995
--- xc/lib/X11/FilterEv.c	Fri Jul  7 09:30:48 1995
***************
*** 1,4 ****
! /* $XConsortium: FilterEv.c,v 1.9 94/04/17 20:19:21 rws Exp $ */
  
   /*
    * Copyright 1990, 1991 by OMRON Corporation
--- 1,4 ----
! /* $XConsortium: FilterEv.c,v 1.10 95/06/08 23:20:39 gildea Exp $ */
  
   /*
    * Copyright 1990, 1991 by OMRON Corporation
***************
*** 60,66 ****
  #include "Xlibint.h"
  #include "Xlcint.h"
  
! #if __STDC__
  #define Const const
  #else
  #define Const /**/
--- 60,66 ----
  #include "Xlibint.h"
  #include "Xlcint.h"
  
! #ifdef __STDC__
  #define Const const
  #else
  #define Const /**/
*** -	Fri Jul  7 09:30:49 1995
--- xc/lib/X11/GetAtomNm.c	Fri Jul  7 09:30:49 1995
***************
*** 1,4 ****
! /* $XConsortium: GetAtomNm.c,v 11.22 94/04/17 20:19:29 rws Exp $ */
  /*
  
  Copyright (c) 1986  X Consortium
--- 1,4 ----
! /* $XConsortium: GetAtomNm.c,v 11.23 95/05/02 15:07:06 converse Exp $ */
  /*
  
  Copyright (c) 1986  X Consortium
***************
*** 144,151 ****
      _XGetAsyncData(dpy, state->names[state->idx], buf, len,
  		   SIZEOF(xGetAtomNameReply), repl->nameLength,
  		   repl->length << 2);
!     _XUpdateAtomCache(dpy, state->names[state->idx],
! 		      state->atoms[state->idx], 0, -1, 0);
      return True;
  }
  
--- 144,156 ----
      _XGetAsyncData(dpy, state->names[state->idx], buf, len,
  		   SIZEOF(xGetAtomNameReply), repl->nameLength,
  		   repl->length << 2);
!     if (state->names[state->idx]) {
! 	state->names[state->idx][repl->nameLength] = '\0';
! 	_XUpdateAtomCache(dpy, state->names[state->idx],
! 			  state->atoms[state->idx], 0, -1, 0);
!     } else {
! 	state->status = 0;
!     }
      return True;
  }
  
*** -	Fri Jul  7 09:30:49 1995
--- xc/lib/X11/ImUtil.c	Fri Jul  7 09:30:49 1995
***************
*** 1,4 ****
! /* $XConsortium: ImUtil.c,v 11.60 94/04/17 20:19:59 kaleb Exp $ */
  /*
  
  Copyright (c) 1986  X Consortium
--- 1,4 ----
! /* $XConsortium: ImUtil.c,v 11.61 95/06/08 23:20:39 gildea Exp $ */
  /*
  
  Copyright (c) 1986  X Consortium
***************
*** 30,36 ****
  #include <X11/Xutil.h>
  #include <stdio.h>
  
! #if __STDC__
  #define Const const
  #else
  #define Const /**/
--- 30,36 ----
  #include <X11/Xutil.h>
  #include <stdio.h>
  
! #ifdef __STDC__
  #define Const const
  #else
  #define Const /**/
*** -	Fri Jul  7 09:30:50 1995
--- xc/lib/X11/KeysymStr.c	Fri Jul  7 09:30:50 1995
***************
*** 1,4 ****
! /* $XConsortium: KeysymStr.c,v 11.9 94/04/17 20:20:03 rws Exp $ */
  
  /*
  
--- 1,4 ----
! /* $XConsortium: KeysymStr.c,v 11.10 95/06/08 23:20:39 gildea Exp $ */
  
  /*
  
***************
*** 31,37 ****
  #include <X11/Xresource.h>
  #include <X11/keysymdef.h>
  
! #if __STDC__
  #define Const const
  #else
  #define Const /**/
--- 31,37 ----
  #include <X11/Xresource.h>
  #include <X11/keysymdef.h>
  
! #ifdef __STDC__
  #define Const const
  #else
  #define Const /**/
*** -	Fri Jul  7 09:30:51 1995
--- xc/lib/X11/LRGB.c	Fri Jul  7 09:30:51 1995
***************
*** 1,4 ****
! /* $XConsortium: LRGB.c,v 1.30 94/06/03 17:51:49 rws Exp $" */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
--- 1,4 ----
! /* $XConsortium: LRGB.c,v 1.32 95/06/08 23:20:39 gildea Exp $" */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
***************
*** 42,48 ****
  #include "Xlibint.h"
  #include "Xcmsint.h"
  
! #if __STDC__
  #define Const const
  #else
  #define Const /**/
--- 42,48 ----
  #include "Xlibint.h"
  #include "Xcmsint.h"
  
! #ifdef __STDC__
  #define Const const
  #else
  #define Const /**/
***************
*** 1351,1356 ****
--- 1351,1358 ----
  		    *pShort |= c - ('a' - 10);
  		else return (XcmsFailure);
  	    }
+ 	    if (n == 0)
+ 		return (XcmsFailure);
  	    if (n < 4) {
  		*pShort = ((unsigned long)*pShort * 0xFFFF) / ((1 << n*4) - 1);
  	    }
*** -	Fri Jul  7 09:30:52 1995
--- xc/lib/X11/MaskEvent.c	Fri Jul  7 09:30:52 1995
***************
*** 1,4 ****
! /* $XConsortium: MaskEvent.c,v 11.25 94/04/17 20:20:17 kaleb Exp $ */
  /*
  
  Copyright (c) 1986  X Consortium
--- 1,4 ----
! /* $XConsortium: MaskEvent.c,v 11.26 95/06/08 23:20:39 gildea Exp $ */
  /*
  
  Copyright (c) 1986  X Consortium
***************
*** 29,35 ****
  #define NEED_EVENTS
  #include "Xlibint.h"
  
! #if __STDC__
  #define Const const
  #else
  #define Const /**/
--- 29,35 ----
  #define NEED_EVENTS
  #include "Xlibint.h"
  
! #ifdef __STDC__
  #define Const const
  #else
  #define Const /**/
*** -	Fri Jul  7 09:30:52 1995
--- xc/lib/X11/OpenDis.c	Fri Jul  7 09:30:52 1995
***************
*** 1,4 ****
! /* $XConsortium: OpenDis.c,v 11.152 94/04/17 20:20:21 rws Exp $ */
  /*
  
  Copyright (c) 1985, 1986  X Consortium
--- 1,4 ----
! /* $XConsortium: OpenDis.c,v 11.153 95/06/05 19:02:01 gildea Exp $ */
  /*
  
  Copyright (c) 1985, 1986  X Consortium
***************
*** 71,77 ****
  	0, 0, 0
  };
  
! static OutOfMemory();
  static Bool _XBigReqHandler();
  
  extern Bool _XWireToEvent();
--- 71,77 ----
  	0, 0, 0
  };
  
! static void OutOfMemory();
  static Bool _XBigReqHandler();
  
  extern Bool _XWireToEvent();
***************
*** 302,307 ****
--- 302,317 ----
  	if (prefixread == 0)
  	    _XRead (dpy, (char *)&prefix,(long)SIZEOF(xConnSetupPrefix));
  
+ 	/* an Authenticate reply we weren't expecting? */
+ 	if (prefix.success != xTrue && prefix.success != xFalse) {
+ 	    fprintf (stderr,
+       "Xlib: unexpected connection setup reply from server, type %d.\r\n",
+ 		     prefix.success);
+ 	    _XDisconnectDisplay (dpy->trans_conn);
+ 	    Xfree ((char *)dpy);
+ 	    return(NULL);
+ 	}
+ 
  	if (prefix.majorVersion != X_PROTOCOL) {
  	    /* XXX - printing messages marks a bad programming interface */
  	    fprintf (stderr,
***************
*** 613,630 ****
      return True;
  }
  
- /* OutOfMemory is called if malloc fails.  XOpenDisplay returns NULL
-    after this returns. */
- 
- static OutOfMemory (dpy, setup)
-     Display *dpy;
-     char *setup;
- {
-     _XDisconnectDisplay (dpy->trans_conn);
-     _XFreeDisplayStructure (dpy);
-     if (setup) Xfree (setup);
- }
- 
  
  /* XFreeDisplayStructure frees all the storage associated with a 
   * Display.  It is used by XOpenDisplay if it runs out of memory,
--- 623,628 ----
***************
*** 635,641 ****
   * before the first possible call on this.
   */
  
! _XFreeDisplayStructure(dpy)
  	register Display *dpy;
  {
  	while (dpy->ext_procs) {
--- 633,639 ----
   * before the first possible call on this.
   */
  
! void _XFreeDisplayStructure(dpy)
  	register Display *dpy;
  {
  	while (dpy->ext_procs) {
***************
*** 748,751 ****
--- 746,761 ----
  	    Xfree (dpy->filedes);
  
  	Xfree ((char *)dpy);
+ }
+ 
+ /* OutOfMemory is called if malloc fails.  XOpenDisplay returns NULL
+    after this returns. */
+ 
+ static void OutOfMemory (dpy, setup)
+     Display *dpy;
+     char *setup;
+ {
+     _XDisconnectDisplay (dpy->trans_conn);
+     _XFreeDisplayStructure (dpy);
+     if (setup) Xfree (setup);
  }
*** -	Fri Jul  7 09:30:53 1995
--- xc/lib/X11/PutImage.c	Fri Jul  7 09:30:53 1995
***************
*** 1,4 ****
! /* $XConsortium: PutImage.c,v 11.70 94/04/17 20:20:31 kaleb Exp $ */
  /*
  
  Copyright (c) 1986  X Consortium
--- 1,4 ----
! /* $XConsortium: PutImage.c,v 11.71 95/06/08 23:20:39 gildea Exp $ */
  /*
  
  Copyright (c) 1986  X Consortium
***************
*** 30,41 ****
  #include "Xutil.h"
  #include <stdio.h>
  
! #if __STDC__
  #define Const const
  #else
  #define Const /**/
  #endif
! #if __STDC__ && ((defined(sun) && defined(SVR4)) || defined(WIN32))
  #define RConst /**/
  #else
  #define RConst Const
--- 30,41 ----
  #include "Xutil.h"
  #include <stdio.h>
  
! #ifdef __STDC__
  #define Const const
  #else
  #define Const /**/
  #endif
! #if defined(__STDC__) && ((defined(sun) && defined(SVR4)) || defined(WIN32))
  #define RConst /**/
  #else
  #define RConst Const
***************
*** 128,134 ****
  
  
  /* XXX the following functions are declared int instead of void because various
!  * compilers and lints complain about later intialization of SwapFunc and/or
   * (swapfunc == NoSwap) when void is used.
   */
  
--- 128,134 ----
  
  
  /* XXX the following functions are declared int instead of void because various
!  * compilers and lints complain about later initialization of SwapFunc and/or
   * (swapfunc == NoSwap) when void is used.
   */
  
***************
*** 577,583 ****
  
  /* Cancel a GetReq operation, before doing _XSend or Data */
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define UnGetReq(name)\
      dpy->bufptr -= SIZEOF(x##name##Req);\
      dpy->request--
--- 577,583 ----
  
  /* Cancel a GetReq operation, before doing _XSend or Data */
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define UnGetReq(name)\
      dpy->bufptr -= SIZEOF(x##name##Req);\
      dpy->request--
*** -	Fri Jul  7 09:30:54 1995
--- xc/lib/X11/StrKeysym.c	Fri Jul  7 09:30:54 1995
***************
*** 1,4 ****
! /* $XConsortium: StrKeysym.c,v 11.16 94/04/17 20:21:13 rws Exp $ */
  /*
  
  Copyright (c) 1985, 1987, 1990  X Consortium
--- 1,4 ----
! /* $XConsortium: StrKeysym.c,v 11.17 95/06/08 23:20:39 gildea Exp $ */
  /*
  
  Copyright (c) 1985, 1987, 1990  X Consortium
***************
*** 35,41 ****
  
  extern XrmQuark _XrmInternalStringToQuark();
  
! #if __STDC__
  #define Const const
  #else
  #define Const /**/
--- 35,41 ----
  
  extern XrmQuark _XrmInternalStringToQuark();
  
! #ifdef __STDC__
  #define Const const
  #else
  #define Const /**/
*** -	Fri Jul  7 09:30:54 1995
--- xc/lib/X11/WinEvent.c	Fri Jul  7 09:30:54 1995
***************
*** 1,4 ****
! /* $XConsortium: WinEvent.c,v 11.22 94/04/17 20:21:30 kaleb Exp $ */
  /*
  
  Copyright (c) 1985  X Consortium
--- 1,4 ----
! /* $XConsortium: WinEvent.c,v 11.23 95/06/08 23:20:39 gildea Exp $ */
  /*
  
  Copyright (c) 1985  X Consortium
***************
*** 29,35 ****
  #define NEED_EVENTS
  #include "Xlibint.h"
  
! #if __STDC__
  #define Const const
  #else
  #define Const /**/
--- 29,35 ----
  #define NEED_EVENTS
  #include "Xlibint.h"
  
! #ifdef __STDC__
  #define Const const
  #else
  #define Const /**/
*** -	Fri Jul  7 09:30:55 1995
--- xc/lib/X11/XKBCvt.c	Fri Jul  7 09:30:55 1995
***************
*** 1,4 ****
! /* "$XConsortium: XKBCvt.c,v 1.14 94/04/17 20:21:35 erik Exp $"; */
  /*
  
  Copyright (c) 1988, 1989  X Consortium
--- 1,4 ----
! /* "$XConsortium: XKBCvt.c,v 1.15 95/06/08 23:20:39 gildea Exp $"; */
  /*
  
  Copyright (c) 1988, 1989  X Consortium
***************
*** 52,63 ****
  extern char *getenv();
  #endif
  
! #if __STDC__
  #define Const const
  #else
  #define Const /**/
  #endif
! #if __STDC__ && !defined(NORCONST)
  #define RConst const
  #else
  #define RConst /**/
--- 52,63 ----
  extern char *getenv();
  #endif
  
! #ifdef __STDC__
  #define Const const
  #else
  #define Const /**/
  #endif
! #if defined(__STDC__) && !defined(NORCONST)
  #define RConst const
  #else
  #define RConst /**/
*** -	Fri Jul  7 09:30:56 1995
--- xc/lib/X11/XRGB.c	Fri Jul  7 09:30:56 1995
***************
*** 1,4 ****
! /* $XConsortium: XRGB.c,v 1.5 91/07/22 15:53:56 rws Exp $" */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
--- 1,4 ----
! /* $XConsortium: XRGB.c,v 1.6 95/06/08 23:20:39 gildea Exp $" */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
***************
*** 37,43 ****
  #include "Xlibint.h"
  #include "Xcmsint.h"
  
! #if __STDC__
  #define Const const
  #else
  #define Const /**/
--- 37,43 ----
  #include "Xlibint.h"
  #include "Xcmsint.h"
  
! #ifdef __STDC__
  #define Const const
  #else
  #define Const /**/
*** -	Fri Jul  7 09:30:56 1995
--- xc/lib/X11/Xaixlcint.h	Fri Jul  7 09:30:56 1995
***************
*** 1,4 ****
! /* $XConsortium: Xaixlcint.h,v 1.2 94/01/20 18:02:13 rws Exp $ */
  /*
   *
   * Copyright IBM Corporation 1993
--- 1,4 ----
! /* $XConsortium: Xaixlcint.h,v 1.3 95/04/07 19:22:34 kaleb Exp $ */
  /*
   *
   * Copyright IBM Corporation 1993
***************
*** 44,48 ****
--- 44,54 ----
      XLCd		(*default_loader)();
      Bool		sticky;
  } _XlcCoreObjRec, *_XlcCoreObj;
+ 
+ #if _LC_VERSION < 0x40000000
+ #define __type_id type_id
+ #define __magic magic
+ #define __version version
+ #endif
  
  #endif	/*_Xaixlcint_h*/
*** -	Fri Jul  7 09:30:57 1995
--- xc/lib/X11/Xrm.c	Fri Jul  7 09:30:57 1995
***************
*** 1,4 ****
! /* $XConsortium: Xrm.c,v 1.88 94/04/17 20:21:54 rws Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988, 1990 by Digital Equipment Corporation, Maynard
--- 1,4 ----
! /* $XConsortium: Xrm.c,v 1.89 95/06/08 23:20:39 gildea Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988, 1990 by Digital Equipment Corporation, Maynard
***************
*** 63,74 ****
  #include 	"XrmI.h"
  #include	<X11/Xos.h>
  
! #if __STDC__
  #define Const const
  #else
  #define Const /**/
  #endif
! #if __STDC__ && !defined(NORCONST)
  #define RConst const
  #else
  #define RConst /**/
--- 63,74 ----
  #include 	"XrmI.h"
  #include	<X11/Xos.h>
  
! #ifdef __STDC__
  #define Const const
  #else
  #define Const /**/
  #endif
! #if defined(__STDC__) && !defined(NORCONST)
  #define RConst const
  #else
  #define RConst /**/
*** -	Fri Jul  7 09:30:58 1995
--- xc/lib/X11/aixlcLoad.c	Fri Jul  7 09:30:58 1995
***************
*** 1,4 ****
! /* $XConsortium: aixlcLoad.c,v 1.5 94/01/20 18:03:37 rws Exp $ */
  /*
   *
   * Copyright IBM Corporation 1993
--- 1,4 ----
! /* $XConsortium: aixlcLoad.c,v 1.6 95/04/07 19:22:35 kaleb Exp $ */
  /*
   *
   * Copyright IBM Corporation 1993
***************
*** 229,243 ****
  	return	LDX_INVALID_VERSION;
      }
  
!     if(ldx->lc_object_header.type_id == _LC_LDX_R6 &&
!        ldx->lc_object_header.magic   == _LC_MAGIC &&
!        ldx->lc_object_header.version == _LC_VERSION_R6){
  	return	LDX_R6;
      }
  
!     if(ldx->lc_object_header.type_id == _LC_LDX &&
!        ldx->lc_object_header.magic   == _LC_MAGIC &&
!        ldx->lc_object_header.version == _LC_VERSION){
  	return	LDX_R5;
      }
  
--- 229,243 ----
  	return	LDX_INVALID_VERSION;
      }
  
!     if(ldx->lc_object_header.__type_id == _LC_LDX_R6 &&
!        ldx->lc_object_header.__magic   == _LC_MAGIC &&
!        ldx->lc_object_header.__version == _LC_VERSION_R6){
  	return	LDX_R6;
      }
  
!     if(ldx->lc_object_header.__type_id == _LC_LDX &&
!        ldx->lc_object_header.__magic   == _LC_MAGIC &&
!        ldx->lc_object_header.__version == _LC_VERSION){
  	return	LDX_R5;
      }
  
*** -	Fri Jul  7 09:30:59 1995
--- xc/lib/X11/cmsCmap.c	Fri Jul  7 09:30:59 1995
***************
*** 1,4 ****
! /* $XConsortium: cmsCmap.c,v 1.16 93/09/07 21:32:52 rws Exp $ */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
--- 1,4 ----
! /* $XConsortium: cmsCmap.c,v 1.17 95/04/27 18:28:37 converse Exp $ */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
***************
*** 82,87 ****
--- 82,88 ----
      int nVisualsMatched;	/* Number of visuals that match */
      Window tmpWindow;
      Visual *vp;
+     unsigned long border = 0;
      _XAsyncHandler async;
      _XAsyncErrorState async_state;
  
***************
*** 172,179 ****
  		req->class = CopyFromParent;
  		req->visual = vp->visualid;
  		tmpWindow = req->wid = XAllocID(dpy);
! 		req->mask = CWColormap;
! 		req->length++;
  		Data32 (dpy, (long *) &cmap, 4);
  	    }
  	    {
--- 173,181 ----
  		req->class = CopyFromParent;
  		req->visual = vp->visualid;
  		tmpWindow = req->wid = XAllocID(dpy);
! 		req->mask = CWBorderPixel | CWColormap;
! 		req->length += 2;
! 		Data32 (dpy, (long *) &border, 4);
  		Data32 (dpy, (long *) &cmap, 4);
  	    }
  	    {
*** -	Fri Jul  7 09:30:59 1995
--- xc/lib/X11/cmsColNm.c	Fri Jul  7 09:30:59 1995
***************
*** 1,4 ****
! /* $XConsortium: cmsColNm.c,v 1.28 94/03/31 21:50:05 rws Exp $" */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
--- 1,4 ----
! /* $XConsortium: cmsColNm.c,v 1.30 95/06/08 23:20:39 gildea Exp $" */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
***************
*** 251,257 ****
   */
  static int
  FirstCmp(p1, p2)
! #if __STDC__
      const void *p1, *p2;
  #else
      XcmsPair *p1, *p2;
--- 251,257 ----
   */
  static int
  FirstCmp(p1, p2)
! #ifdef __STDC__
      const void *p1, *p2;
  #else
      XcmsPair *p1, *p2;
***************
*** 753,758 ****
--- 753,759 ----
      pairs = (XcmsPair *)Xcalloc(nEntries, sizeof(XcmsPair));
  
      ReadColornameDB(stream, pairs, strings);
+     (void) fclose(stream);
  
      /*
       * sort the pair recs
*** -	Fri Jul  7 09:31:00 1995
--- xc/lib/X11/cmsMath.c	Fri Jul  7 09:31:00 1995
***************
*** 1,4 ****
! /* $XConsortium: cmsMath.c,v 1.10 94/04/17 20:21:59 rws Exp $ */
  
  /*
  
--- 1,4 ----
! /* $XConsortium: cmsMath.c,v 1.11 95/06/08 23:20:39 gildea Exp $ */
  
  /*
  
***************
*** 34,40 ****
  #include "Xlibint.h"
  #include "Xcmsint.h"
  
! #if !defined(X_NOT_STDC_ENV) && (__STDC__ || !(defined(sun) || (defined(sony) && !defined(SYSTYPE_SYSV) && !defined(_SYSTYPE_SYSV))))
  #include <float.h>
  #endif
  #ifndef DBL_EPSILON
--- 34,40 ----
  #include "Xlibint.h"
  #include "Xcmsint.h"
  
! #if !defined(X_NOT_STDC_ENV) && (defined(__STDC__) || !(defined(sun) || (defined(sony) && !defined(SYSTYPE_SYSV) && !defined(_SYSTYPE_SYSV))))
  #include <float.h>
  #endif
  #ifndef DBL_EPSILON
*** -	Fri Jul  7 09:31:01 1995
--- xc/lib/X11/cmsTrig.c	Fri Jul  7 09:31:01 1995
***************
*** 1,4 ****
! /* $XConsortium: cmsTrig.c,v 1.6 94/02/10 20:10:00 rws Exp $" */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
--- 1,4 ----
! /* $XConsortium: cmsTrig.c,v 1.7 95/06/08 23:20:39 gildea Exp $" */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
***************
*** 63,69 ****
   *	DEFINES
   */
  
! #if __STDC__
  #define Const const
  #else
  #define Const /**/
--- 63,69 ----
   *	DEFINES
   */
  
! #ifdef __STDC__
  #define Const const
  #else
  #define Const /**/
*** -	Fri Jul  7 09:31:02 1995
--- xc/lib/X11/evtomask.c	Fri Jul  7 09:31:01 1995
***************
*** 1,4 ****
! /* $XConsortium: evtomask.c,v 1.9 94/04/17 20:22:01 rws Exp $ */
  /*
  
  Copyright (c) 1987  X Consortium
--- 1,4 ----
! /* $XConsortium: evtomask.c,v 1.10 95/06/08 23:20:39 gildea Exp $ */
  /*
  
  Copyright (c) 1987  X Consortium
***************
*** 28,34 ****
  
  #include <X11/X.h>
  
! #if __STDC__
  #define Const const
  #else
  #define Const /**/
--- 28,34 ----
  
  #include <X11/X.h>
  
! #ifdef __STDC__
  #define Const const
  #else
  #define Const /**/
*** -	Fri Jul  7 09:31:02 1995
--- xc/lib/X11/globals.c	Fri Jul  7 09:31:02 1995
***************
*** 1,4 ****
! /* $XConsortium: globals.c,v 1.18 94/04/17 20:22:01 rws Exp $ */
  /*
  
  Copyright (c) 1989  X Consortium
--- 1,4 ----
! /* $XConsortium: globals.c,v 1.19 95/06/08 23:20:39 gildea Exp $ */
  /*
  
  Copyright (c) 1989  X Consortium
***************
*** 55,61 ****
  /*
   * If we need to define extra variables for each global
   */
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define ZEROINIT(t,var,val) SetZero(t,var,val); \
    SetZero (long, _libX_##var##Flag, 0); \
    SetZero (void *, _libX_##var##Ptr, NULL)
--- 55,61 ----
  /*
   * If we need to define extra variables for each global
   */
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define ZEROINIT(t,var,val) SetZero(t,var,val); \
    SetZero (long, _libX_##var##Flag, 0); \
    SetZero (void *, _libX_##var##Ptr, NULL)
*** -	Fri Jul  7 09:31:03 1995
--- xc/lib/X11/imCallbk.c	Fri Jul  7 09:31:03 1995
***************
*** 1,4 ****
! /* $XConsortium: imCallbk.c,v 1.9 94/10/10 18:31:09 kaleb Exp $ */
  /***********************************************************************
  Copyright 1993 by Digital Equipment Corporation, Maynard, Massachusetts,
  Copyright 1994 by FUJITSU LIMITED
--- 1,4 ----
! /* $XConsortium: imCallbk.c,v 1.13 95/06/08 23:20:39 gildea Exp $ */
  /***********************************************************************
  Copyright 1993 by Digital Equipment Corporation, Maynard, Massachusetts,
  Copyright 1994 by FUJITSU LIMITED
***************
*** 94,100 ****
  Private XimCbStatus _XimStrConversionCallback(Xim, Xic, char*, int);
  Private XimCbStatus _XimPreeditStartCallback(Xim, Xic, char*, int);
  Private XimCbStatus _XimPreeditDoneCallback(Xim, Xic, char*, int);
- Private void _read_text_from_packet(Xim, char*, XIMText*);
  Private void _free_memory_for_text(XIMText*);
  Private XimCbStatus _XimPreeditDrawCallback(Xim, Xic, char*, int);
  Private XimCbStatus _XimPreeditCaretCallback(Xim, Xic, char*, int);
--- 94,99 ----
***************
*** 108,114 ****
  Private XimCbStatus _XimStrConversionCallback();
  Private XimCbStatus _XimPreeditStartCallback();
  Private XimCbStatus _XimPreeditDoneCallback();
- Private void _read_text_from_packet();
  Private void _free_memory_for_text();
  Private XimCbStatus _XimPreeditDrawCallback();
  Private XimCbStatus _XimPreeditCaretCallback();
--- 107,112 ----
***************
*** 118,129 ****
  Private XimCbStatus _XimPreeditStateNotifyCallback();
  #endif /* NeedFunctionPrototypes */
  
! #if __STDC__
  #define Const const
  #else
  #define Const /**/
  #endif
! #if __STDC__ && ((defined(sun) && defined(SVR4)) || defined(WIN32))
  #define RConst /**/
  #else
  #define RConst Const
--- 116,127 ----
  Private XimCbStatus _XimPreeditStateNotifyCallback();
  #endif /* NeedFunctionPrototypes */
  
! #ifdef __STDC__
  #define Const const
  #else
  #define Const /**/
  #endif
! #if defined(__STDC__) && ((defined(sun) && defined(SVR4)) || defined(WIN32))
  #define RConst /**/
  #else
  #define RConst Const
***************
*** 378,384 ****
  	int p = XIM_HEADER_SIZE;
  	cbrec.position = (XIMStringConversionPosition)
  	    *(CARD32*)&proto[p]; p += sz_CARD32;
! 	cbrec.type = (XIMStringConversionType)
  	    *(CARD32*)&proto[p]; p += sz_CARD32;
  	cbrec.operation = (XIMStringConversionOperation)
  	    *(CARD32*)&proto[p]; p += sz_CARD32;
--- 376,382 ----
  	int p = XIM_HEADER_SIZE;
  	cbrec.position = (XIMStringConversionPosition)
  	    *(CARD32*)&proto[p]; p += sz_CARD32;
! 	cbrec.direction = (XIMCaretDirection)
  	    *(CARD32*)&proto[p]; p += sz_CARD32;
  	cbrec.operation = (XIMStringConversionOperation)
  	    *(CARD32*)&proto[p]; p += sz_CARD32;
***************
*** 405,411 ****
  	CARD8	*buf;
  	INT16	 buf_len;
  	int	 p, length_in_bytes, i;
- 	void	*tmp;
  
  	/* Assumption:
  	 * `cbrec.text->length' means the string length in characters
--- 403,408 ----
***************
*** 524,530 ****
  #endif
  {
      XIMCallback* cb = &ic->core.preedit_attr.done_callback;
-     int ret;
  
      /* invoke the callback
       */
--- 521,526 ----
***************
*** 545,562 ****
  #if NeedFunctionPrototypes
  _read_text_from_packet(Xim im, 
  		       char* buf, 
! 		       XIMText* text)
  #else
! _read_text_from_packet(im, buf, text)
    Xim im;
    char* buf;
!   XIMText* text;
  #endif
  {
      int status;
  
      status = (int)*(BITMASK32*)buf; buf += sz_BITMASK32;
  
      /* string part
       */
      if (status & 0x00000001) /* "no string" bit on */ {
--- 541,566 ----
  #if NeedFunctionPrototypes
  _read_text_from_packet(Xim im, 
  		       char* buf, 
! 		       XIMText** text_ptr)
  #else
! _read_text_from_packet(im, buf, text_ptr)
    Xim im;
    char* buf;
!   XIMText** text_ptr;
  #endif
  {
      int status;
+     XIMText* text;
  
      status = (int)*(BITMASK32*)buf; buf += sz_BITMASK32;
  
+     if (status & 0x00000003) {
+ 	*text_ptr = (XIMText*)NULL;
+ 	return;
+     }
+     *text_ptr = text = (XIMText*)Xmalloc(sizeof(XIMText));
+     if (text == (XIMText*)NULL) return;
+ 
      /* string part
       */
      if (status & 0x00000001) /* "no string" bit on */ {
***************
*** 612,618 ****
  
  	i = (int)*(CARD16*)buf; buf += sz_CARD16;
  	buf += sz_CARD16; /* skip `unused' */
! 	text->feedback = (XIMFeedback*)Xmalloc(i);
  	j = 0;
  	while (i > 0) {
  	    text->feedback[j] = (XIMFeedback)*(CARD32*)buf;
--- 616,622 ----
  
  	i = (int)*(CARD16*)buf; buf += sz_CARD16;
  	buf += sz_CARD16; /* skip `unused' */
! 	text->feedback = (XIMFeedback*)Xmalloc(i*(sizeof(XIMFeedback)/sizeof(CARD32)));
  	j = 0;
  	while (i > 0) {
  	    text->feedback[j] = (XIMFeedback)*(CARD32*)buf;
***************
*** 620,625 ****
--- 624,642 ----
  	    i -= sz_CARD32;
  	    j++;
  	}
+ 	/* 
+ 	 * text->length tells how long both the status string and
+ 	 * the feedback array are. If there's "no string" the
+ 	 * text->length was set to zero previously. See above.
+ 	 * But if there is feedback (i.e. not "no feedback") then
+ 	 * we need to convey the length of the feedback array.
+ 	 * It might have been better if the protocol sent two
+ 	 * different values, one for the length of the status
+ 	 * string and one for the length of the feedback array.
+ 	 */
+ 	if (status & 0x00000001) /* "no string" bit on */ {
+ 	    text->length = j;
+ 	}
      }
  }
  
***************
*** 656,673 ****
  {
      XIMCallback* cb = &ic->core.preedit_attr.draw_callback;
      XIMPreeditDrawCallbackStruct cbs;
-     int p;
  
      /* invoke the callback
       */
      if (cb && cb->callback) {
! 	p = 0;
! 	cbs.caret      = (int)*(INT32*)&proto[p]; p += sz_INT32;
! 	cbs.chg_first  = (int)*(INT32*)&proto[p]; p += sz_INT32;
! 	cbs.chg_length = (int)*(INT32*)&proto[p]; p += sz_INT32;
! 	if (cbs.text = (XIMText*)Xmalloc(sizeof(XIMText))) {
! 	    _read_text_from_packet(im, (char*)&proto[p], (XIMText*)cbs.text);
! 	}
  
  	(*cb->callback)((XIC)ic, cb->client_data, &cbs);
  
--- 673,686 ----
  {
      XIMCallback* cb = &ic->core.preedit_attr.draw_callback;
      XIMPreeditDrawCallbackStruct cbs;
  
      /* invoke the callback
       */
      if (cb && cb->callback) {
! 	cbs.caret      = (int)*(INT32*)proto; proto += sz_INT32;
! 	cbs.chg_first  = (int)*(INT32*)proto; proto += sz_INT32;
! 	cbs.chg_length = (int)*(INT32*)proto; proto += sz_INT32;
! 	_read_text_from_packet(im, proto, &cbs.text);
  
  	(*cb->callback)((XIC)ic, cb->client_data, &cbs);
  
***************
*** 704,711 ****
       */
      if (cb && cb->callback) {
  	cbs.position  = (int)*(INT32*)proto; proto += sz_INT32;
! 	cbs.direction = (int)*(CARD32*)proto; proto += sz_CARD32;
! 	cbs.style     = (int)*(CARD32*)proto; proto += sz_CARD32;
  
  	(*cb->callback)((XIC)ic, cb->client_data, &cbs);
      }
--- 717,724 ----
       */
      if (cb && cb->callback) {
  	cbs.position  = (int)*(INT32*)proto; proto += sz_INT32;
! 	cbs.direction = (XIMCaretDirection)*(CARD32*)proto; proto += sz_CARD32;
! 	cbs.style     = (XIMCaretStyle)*(CARD32*)proto; proto += sz_CARD32;
  
  	(*cb->callback)((XIC)ic, cb->client_data, &cbs);
      }
***************
*** 827,835 ****
      if (cb && cb->callback) {
  	cbs.type = (XIMStatusDataType)*(CARD32*)proto; proto += sz_CARD32;
  	if (cbs.type == XIMTextType) {
! 	    if (cbs.data.text = (XIMText*)Xmalloc(sizeof(XIMText))) {
! 		_read_text_from_packet(im, proto, cbs.data.text);
! 	    }
  	}
  	else if (cbs.type == XIMBitmapType) {
  	    cbs.data.bitmap = (Pixmap)*(CARD32*)proto;
--- 840,846 ----
      if (cb && cb->callback) {
  	cbs.type = (XIMStatusDataType)*(CARD32*)proto; proto += sz_CARD32;
  	if (cbs.type == XIMTextType) {
! 	    _read_text_from_packet(im, proto, &cbs.data.text);
  	}
  	else if (cbs.type == XIMBitmapType) {
  	    cbs.data.bitmap = (Pixmap)*(CARD32*)proto;
*** -	Fri Jul  7 09:31:04 1995
--- xc/lib/X11/imDefIc.c	Fri Jul  7 09:31:04 1995
***************
*** 1,4 ****
! /* $XConsortium: imDefIc.c,v 1.11 94/08/02 12:44:21 kaleb Exp $ */
  /******************************************************************
  
             Copyright 1991, 1992 by Sun Microsystems, Inc.
--- 1,4 ----
! /* $XConsortium: imDefIc.c,v 1.12 95/02/22 22:13:59 kaleb Exp $ */
  /******************************************************************
  
             Copyright 1991, 1992 by Sun Microsystems, Inc.
***************
*** 293,299 ****
      CARD16		*buf_s;
      INT16		 len;
      char		 reply[BUFSIZE];
!     XPointer		 preply;
      int			 buf_size;
      int			 ret_code;
      char		*makeid_name;
--- 293,299 ----
      CARD16		*buf_s;
      INT16		 len;
      char		 reply[BUFSIZE];
!     XPointer		 preply = NULL;
      int			 buf_size;
      int			 ret_code;
      char		*makeid_name;
***************
*** 397,402 ****
--- 397,406 ----
  	data = &buf_s[4];
  	data_len = buf_s[2];
      }
+     else {
+ 	return arg->name;
+     }
+ 
      decode_name = _XimDecodeICATTRIBUTE(ic, ic->private.proto.ic_resources,
  			ic->private.proto.ic_num_resources, data, data_len,
  			arg, XIM_GETICVALUES);
***************
*** 671,677 ****
      int			 total;
      XIMArg		*arg_ret;
      char		 reply[BUFSIZE];
!     XPointer		 preply;
      int			 ret_code;
      BITMASK32		 flag = 0L;
      char		*name;
--- 675,681 ----
      int			 total;
      XIMArg		*arg_ret;
      char		 reply[BUFSIZE];
!     XPointer		 preply = NULL;
      int			 ret_code;
      BITMASK32		 flag = 0L;
      char		*name;
***************
*** 737,744 ****
      }
      _XimSetCurrentICValues(ic, &ic_values);
  
!     if (!total)
! 	return (char *)NULL;
  
      buf_s = (CARD16 *)&buf[XIM_HEADER_SIZE];
  
--- 741,752 ----
      }
      _XimSetCurrentICValues(ic, &ic_values);
  
!     if (!total) {
! 	if(arg)
! 	    return arg->name;
! 	else
! 	    return (char *)NULL;
!     }
  
      buf_s = (CARD16 *)&buf[XIM_HEADER_SIZE];
  
*** -	Fri Jul  7 09:31:05 1995
--- xc/lib/X11/imDefLkup.c	Fri Jul  7 09:31:04 1995
***************
*** 1,4 ****
! /* $XConsortium: imDefLkup.c,v 1.12 94/09/01 18:41:58 kaleb Exp $ */
  /******************************************************************
  
             Copyright 1992, 1993, 1994 by FUJITSU LIMITED
--- 1,4 ----
! /* $XConsortium: imDefLkup.c,v 1.14 95/06/07 22:41:51 kaleb Exp $ */
  /******************************************************************
  
             Copyright 1992, 1993, 1994 by FUJITSU LIMITED
***************
*** 632,637 ****
--- 632,638 ----
      info->keysym_len	= keysym_len;
      info->next = ic->private.proto.commit_info;
      ic->private.proto.commit_info = info;
+     return True;
  }
  
  Private void
***************
*** 917,923 ****
  
      if (to && to_len) {
  	from_left = from_len;
! 	to_left = to_len - 1;
  	from_cnvlen = 0;
  	to_cnvlen = 0;
  	for (;;) {
--- 918,924 ----
  
      if (to && to_len) {
  	from_left = from_len;
! 	to_left = to_len;
  	from_cnvlen = 0;
  	to_cnvlen = 0;
  	for (;;) {
***************
*** 934,940 ****
  	    to_cnvlen += (to_savelen - to_left);
  	    if (from_left == 0) {
  		if (to_cnvlen > 0) {
- 		    to[to_cnvlen] = '\0';
  		    *state = XLookupChars;
  		} else {
  		    *state = XLookupNone;
--- 935,940 ----
***************
*** 1003,1009 ****
  
      if (to && to_len) {
  	from_left = from_len;
! 	to_left = to_len - 1;
  	from_cnvlen = 0;
  	to_cnvlen = 0;
  	for (;;) {
--- 1003,1009 ----
  
      if (to && to_len) {
  	from_left = from_len;
! 	to_left = to_len;
  	from_cnvlen = 0;
  	to_cnvlen = 0;
  	for (;;) {
***************
*** 1020,1026 ****
  	    to_cnvlen += (to_savelen - to_left);
  	    if (from_left == 0) {
  		if (to_cnvlen > 0) {
- 		    to[to_cnvlen] = (wchar_t)'\0';
  		    *state = XLookupChars;
  		} else {
  		    *state = XLookupNone;
--- 1020,1025 ----
*** -	Fri Jul  7 09:31:05 1995
--- xc/lib/X11/imLcLkup.c	Fri Jul  7 09:31:05 1995
***************
*** 1,4 ****
! /* $XConsortium: imLcLkup.c,v 1.6 94/07/06 14:46:59 kaleb Exp $ */
  /******************************************************************
  
                Copyright 1992 by Fuji Xerox Co., Ltd.
--- 1,4 ----
! /* $XConsortium: imLcLkup.c,v 1.7 95/06/07 22:41:51 kaleb Exp $ */
  /******************************************************************
  
                Copyright 1992 by Fuji Xerox Co., Ltd.
***************
*** 66,72 ****
  	if(keysym) *keysym = ic->private.local.composed->ks;
  	if (ret > 0) {
  	    if(keysym && *keysym != NoSymbol) {
! 		if(status) *status = XLookupChars;
  	    } else {
  		if(status) *status = XLookupChars;
  	    }
--- 66,72 ----
  	if(keysym) *keysym = ic->private.local.composed->ks;
  	if (ret > 0) {
  	    if(keysym && *keysym != NoSymbol) {
! 		if(status) *status = XLookupBoth;
  	    } else {
  		if(status) *status = XLookupChars;
  	    }
***************
*** 125,131 ****
  	if(keysym) *keysym = ic->private.local.composed->ks;
  	if (ret > 0) {
  	    if(keysym && *keysym != NoSymbol) {
! 		if(status) *status = XLookupChars;
  	    } else {
  		if(status) *status = XLookupChars;
  	    }
--- 125,131 ----
  	if(keysym) *keysym = ic->private.local.composed->ks;
  	if (ret > 0) {
  	    if(keysym && *keysym != NoSymbol) {
! 		if(status) *status = XLookupBoth;
  	    } else {
  		if(status) *status = XLookupChars;
  	    }
***************
*** 191,197 ****
  
      if (to && to_len) {
  	from_left = from_len;
! 	to_left = to_len - 1;
  	from_cnvlen = 0;
  	to_cnvlen = 0;
  	for (;;) {
--- 191,197 ----
  
      if (to && to_len) {
  	from_left = from_len;
! 	to_left = to_len;
  	from_cnvlen = 0;
  	to_cnvlen = 0;
  	for (;;) {
***************
*** 208,214 ****
  	    to_cnvlen += (to_savelen - to_left);
  	    if (from_left == 0) {
  		if (to_cnvlen > 0) {
- 		    to[to_cnvlen] = '\0';
  		    *state = XLookupChars;
  		} else {
  		    *state = XLookupNone;
--- 208,213 ----
***************
*** 277,283 ****
  
      if (to && to_len) {
  	from_left = from_len;
! 	to_left = to_len - 1;
  	from_cnvlen = 0;
  	to_cnvlen = 0;
  	for (;;) {
--- 276,282 ----
  
      if (to && to_len) {
  	from_left = from_len;
! 	to_left = to_len;
  	from_cnvlen = 0;
  	to_cnvlen = 0;
  	for (;;) {
***************
*** 294,300 ****
  	    to_cnvlen += (to_savelen - to_left);
  	    if (from_left == 0) {
  		if (to_cnvlen > 0) {
- 		    to[to_cnvlen] = (wchar_t)'\0';
  		    *state = XLookupChars;
  		} else {
  		    *state = XLookupNone;
--- 293,298 ----
*** -	Fri Jul  7 09:31:06 1995
--- xc/lib/X11/imTransR.c	Fri Jul  7 09:31:06 1995
***************
*** 1,4 ****
! /* $XConsortium: imTransR.c,v 1.7 94/06/03 17:34:28 rws Exp $ */
  /******************************************************************
  
                Copyright 1992 by Sun Microsystems, Inc.
--- 1,4 ----
! /* $XConsortium: imTransR.c,v 1.8 95/02/10 17:52:50 mor Exp $ */
  /******************************************************************
  
                Copyright 1992 by Sun Microsystems, Inc.
***************
*** 44,50 ****
      "local",      _XimTransConf, /* use X transport lib */
  #endif /* UNIXCONN */
  #ifdef DNETCONN
!     "decnet",     _XimTransConf, /* use X transport lib */
  #endif /* DNETCONN */
  #ifdef STREAMSCONN
      "streams",    _XimTransConf, /* use X transport lib */
--- 44,50 ----
      "local",      _XimTransConf, /* use X transport lib */
  #endif /* UNIXCONN */
  #ifdef DNETCONN
!     "dnet",     _XimTransConf, /* use X transport lib */
  #endif /* DNETCONN */
  #ifdef STREAMSCONN
      "streams",    _XimTransConf, /* use X transport lib */
*** -	Fri Jul  7 09:31:07 1995
--- xc/lib/X11/jump_ignore	Fri Jul  7 09:31:07 1995
***************
*** 1,3 ****
! # $XConsortium: jump_ignore,v 1.2 94/12/07 10:48:04 kaleb Exp $
  # $XFree86: xc/lib/X11/jump_ignore,v 3.0 1994/04/28 12:31:17 dawes Exp $
  # jump_ignore
--- 1,5 ----
! # $XConsortium: jump_ignore,v 1.3 95/06/06 21:20:40 kaleb Exp $
  # $XFree86: xc/lib/X11/jump_ignore,v 3.0 1994/04/28 12:31:17 dawes Exp $
  # jump_ignore
+ 00000000 T __XANYSET            libX11         XlibInt
+ 00000000 T __XlcAddCT           libX11         lcCT
*** -	Fri Jul  7 09:31:07 1995
--- xc/lib/X11/lcCT.c	Fri Jul  7 09:31:07 1995
***************
*** 1,4 ****
! /* $XConsortium: lcCT.c,v 1.4 94/07/18 10:17:11 kaleb Exp $ */
  /*
   * Copyright 1992, 1993 by TOSHIBA Corp.
   *
--- 1,4 ----
! /* $XConsortium: lcCT.c,v 1.5 95/02/22 22:03:04 kaleb Exp $ */
  /*
   * Copyright 1992, 1993 by TOSHIBA Corp.
   *
***************
*** 33,38 ****
--- 33,40 ----
      XlcCharSet charset;
      XlcCharSet GL_charset;
      XlcCharSet GR_charset;
+     XlcCharSet ext_seg_charset;
+     int ext_seg_left;
  } StateRec, *State;
  
  typedef struct _CTDataRec {
***************
*** 70,82 ****
      { "JISX0208.1983-0:GR", "\033$)B" },
      { "KSC5601.1987-0:GL", "\033$(C" },
      { "KSC5601.1987-0:GR", "\033$)C" },
      { "JISX0212.1990-0:GL", "\033$(D" },
      { "JISX0212.1990-0:GR", "\033$)D" },
!     { "CNS11643.1986-0:GL", "\033$(G" },
!     { "CNS11643.1986-1:GL", "\033$(H" },
  
      /* Non-Standard Character Set Encodings */
      { "TIS620.2533-1:GR", "\033-T"},
  } ; 
  
  #define XctC0		0x0000
--- 72,88 ----
      { "JISX0208.1983-0:GR", "\033$)B" },
      { "KSC5601.1987-0:GL", "\033$(C" },
      { "KSC5601.1987-0:GR", "\033$)C" },
+ #ifdef notdef
      { "JISX0212.1990-0:GL", "\033$(D" },
      { "JISX0212.1990-0:GR", "\033$)D" },
!     { "CNS11643.1986-1:GL", "\033$(G" },
!     { "CNS11643.1986-1:GR", "\033$)G" },
!     { "CNS11643.1986-2:GL", "\033$(H" },
!     { "CNS11643.1986-2:GR", "\033$)H" },
  
      /* Non-Standard Character Set Encodings */
      { "TIS620.2533-1:GR", "\033-T"},
+ #endif
  } ; 
  
  #define XctC0		0x0000
***************
*** 117,143 ****
      XlcSide side;
      int char_size;
      int set_size;
-     XlcCharSet charset;
      int ext_seg_length;
      int version;
  } CTParseRec, *CTParse;
  
  static CTInfo ct_list = NULL;
  
! static XlcCharSet
! _XlcGetCharSetFromEncoding(encoding, length)
      register char *encoding;
      register int length;
  {
      register CTInfo ct_info;
  
      for (ct_info = ct_list; ct_info; ct_info = ct_info->next) {
! 	if (length >= ct_info->encoding_len &&
! 	    !strncmp(ct_info->encoding, encoding, ct_info->encoding_len))
! 	    return ct_info->charset;
      }
  
!     return (XlcCharSet) NULL;
  }
  
  static unsigned int
--- 123,157 ----
      XlcSide side;
      int char_size;
      int set_size;
      int ext_seg_length;
      int version;
+     CTInfo ct_info;
  } CTParseRec, *CTParse;
  
  static CTInfo ct_list = NULL;
  
! static CTInfo
! _XlcGetCTInfoFromEncoding(encoding, length)
      register char *encoding;
      register int length;
  {
      register CTInfo ct_info;
  
      for (ct_info = ct_list; ct_info; ct_info = ct_info->next) {
! 	if (length >= ct_info->encoding_len) {
! 	    if (ct_info->ext_segment) {
! 		if (!strncmp(ct_info->encoding, encoding, 4) &&
! 		    !strncmp(ct_info->ext_segment, encoding + 6,
! 			     ct_info->ext_segment_len))
! 		    return ct_info;
! 	    } else if (!strncmp(ct_info->encoding, encoding,
! 				ct_info->encoding_len)) {
! 		return ct_info;
! 	    }
! 	}
      }
  
!     return (CTInfo) NULL;
  }
  
  static unsigned int
***************
*** 163,171 ****
  		str += 2;
  		if (*str <= 0x34) {
  		    parse->char_size = *str - 0x30;
  		    ret = XctExtSeg;
! 		    /* XXX */
! 		    parse->charset = _XlcGetCharSetFromEncoding(*text, *length);
  		} else
  		    ret = XctOtherSeg;
  		str++;
--- 177,185 ----
  		str += 2;
  		if (*str <= 0x34) {
  		    parse->char_size = *str - 0x30;
+ 		    if (parse->char_size == 0) parse->char_size = 1;
  		    ret = XctExtSeg;
! 		    parse->ct_info = _XlcGetCTInfoFromEncoding(*text, *length);
  		} else
  		    ret = XctOtherSeg;
  		str++;
***************
*** 236,242 ****
  		    else if (*str >= 0x60)
  			parse->char_size = 3;
  		}
! 		parse->charset = _XlcGetCharSetFromEncoding(*text, *length);
  	    }
  	    str++;
  	    goto done;
--- 250,256 ----
  		    else if (*str >= 0x60)
  			parse->char_size = 3;
  		}
! 		parse->ct_info = _XlcGetCTInfoFromEncoding(*text, *length);
  	    }
  	    str++;
  	    goto done;
***************
*** 290,296 ****
      return ret;
  }
  
- static
  XlcCharSet
  _XlcAddCT(name, encoding)
      char *name;
--- 304,309 ----
***************
*** 300,321 ****
      XlcCharSet charset;
      CTParseRec parse;
      char *ct_ptr = encoding;
-     char *ext_segment = NULL;
      int length;
  
      length = strlen(encoding);
  
!     switch (_XlcParseCT(&parse, &ct_ptr, &length)) {
  	case XctExtSeg:
- 	    /* XXX */
- 	    ext_segment = name;
  	case XctGL94:
  	case XctGL94MB:
  	case XctGR94:
  	case XctGR94MB:
  	case XctGR96:
! 	    if (parse.charset)		/* existed */
! 		return parse.charset;
  	    break;
  	default:
  	    return (XlcCharSet) NULL;
--- 313,332 ----
      XlcCharSet charset;
      CTParseRec parse;
      char *ct_ptr = encoding;
      int length;
+     unsigned int type;
  
      length = strlen(encoding);
  
!     switch (type = _XlcParseCT(&parse, &ct_ptr, &length)) {
  	case XctExtSeg:
  	case XctGL94:
  	case XctGL94MB:
  	case XctGR94:
  	case XctGR94MB:
  	case XctGR96:
! 	    if (parse.ct_info)		/* existed */
! 		return parse.ct_info->charset;
  	    break;
  	default:
  	    return (XlcCharSet) NULL;
***************
*** 331,340 ****
  	return (XlcCharSet) NULL;
      
      ct_info->charset = charset;
!     ct_info->encoding_len = strlen(encoding);
!     ct_info->encoding = encoding;
!     ct_info->ext_segment_len = ext_segment ? strlen(ext_segment) : 0;
!     ct_info->ext_segment = ext_segment;
      ct_info->next = ct_list;
      ct_list = ct_info;
  
--- 342,356 ----
  	return (XlcCharSet) NULL;
      
      ct_info->charset = charset;
!     ct_info->encoding = charset->ct_sequence;
!     ct_info->encoding_len = strlen(ct_info->encoding);
!     if (type == XctExtSeg) {
! 	ct_info->ext_segment = ct_info->encoding + 6;
! 	ct_info->ext_segment_len = strlen(ct_info->ext_segment);
!     } else {
! 	ct_info->ext_segment = NULL;
! 	ct_info->ext_segment_len = 0;
!     }
      ct_info->next = ct_list;
      ct_list = ct_info;
  
***************
*** 423,452 ****
  {
      XlcCharSet charset;
      CTParseRec parse;
  
!     switch (_XlcParseCT(&parse, ctext, ctext_len)) {
! 	case XctExtSeg:
! 	    /* XXX */
! 	case XctGL94:
! 	case XctGL94MB:
! 	case XctGR94:
! 	case XctGR94MB:
! 	case XctGR96:
! 	    charset = parse.charset;
! 	    break;
! 	default:
! 	    /* XXX */
! 	    return 0;
!     }
  
!     if (charset == NULL)
! 	return 0;	/* XXX */
  
-     if (charset->side == XlcGL)
- 	state->GL_charset = charset;
-     else if (charset->side == XlcGR)
- 	state->GR_charset = charset;
- 	
      return 0;
  }
  
--- 439,470 ----
  {
      XlcCharSet charset;
      CTParseRec parse;
+     CTInfo ct_info;
+     int length;
  
!     _XlcParseCT(&parse, ctext, ctext_len);
  
!     ct_info = parse.ct_info;
!     if (parse.ext_seg_length > 0) {	/* XctExtSeg or XctOtherSeg */
! 	if (ct_info) {
! 	    length = ct_info->ext_segment_len;
! 	    *ctext += length;
! 	    *ctext_len -= length;
! 	    state->ext_seg_left = parse.ext_seg_length - length;
! 	    state->ext_seg_charset = ct_info->charset;
! 	} else {
! 	    state->ext_seg_left = parse.ext_seg_length;
! 	    state->ext_seg_charset = NULL;
! 	}
!     } else if (ct_info) {
! 	if (charset = ct_info->charset) {
! 	    if (charset->side == XlcGL)
! 		state->GL_charset = charset;
! 	    else if (charset->side == XlcGR)
! 		state->GR_charset = charset;
! 	}
!     }
  
      return 0;
  }
  
***************
*** 466,471 ****
--- 484,491 ----
  
      state->GL_charset = state->charset = GL_charset;
      state->GR_charset = GR_charset;
+     state->ext_seg_charset = NULL;
+     state->ext_seg_left = 0;
  }
  
  static int
***************
*** 491,501 ****
--- 511,549 ----
      buf_len = *to_left;
  
      while (ctext_len > 0 && buf_len > 0) {
+ 	if (state->ext_seg_left > 0) {
+ 	    length = min(state->ext_seg_left, ctext_len);
+ 	    length = min(length, buf_len);
+ 
+ 	    ctext_len -= length;
+ 	    state->ext_seg_left -= length;
+ 
+ 	    if (state->ext_seg_charset) {
+ 		charset = state->ext_seg_charset;
+ 		buf_len -= length;
+ 		if (charset->side == XlcGL) {
+ 		    while (length-- > 0)
+ 			*bufptr++ = *ctptr++ & 0x7f;
+ 		} else if (charset->side == XlcGR) {
+ 		    while (length-- > 0)
+ 			*bufptr++ = *ctptr++ | 0x80;
+ 		} else {
+ 		    while (length-- > 0)
+ 			*bufptr++ = *ctptr++;
+ 		}
+ 
+ 		if (state->ext_seg_left < 1)
+ 		    state->ext_seg_charset = NULL;
+ 	    }
+ 	    break;
+ 	}
  	ch = *((unsigned char *) ctptr);
  	if (ch == 0x1b || ch == 0x9b) {
  	    length = _XlcCheckCTSequence(state, &ctptr, &ctext_len);
  	    if (length < 0)
  		return -1;
+ 	    if (state->ext_seg_left > 0 && charset)
+ 		break;
  	} else {
  	    if (charset) {
  		if (charset != (ch & 0x80 ? state->GR_charset :
***************
*** 542,548 ****
      XlcSide side;
      unsigned char min_ch, max_ch;
      register unsigned char ch;
!     int length, set_size, cvt_length;
      CTInfo ct_info;
      XlcCharSet charset;
      char *csptr, *ctptr;
--- 590,596 ----
      XlcSide side;
      unsigned char min_ch, max_ch;
      register unsigned char ch;
!     int length;
      CTInfo ct_info;
      XlcCharSet charset;
      char *csptr, *ctptr;
***************
*** 563,624 ****
  	return -1;
  
      side = charset->side;
-     length = charset->char_size;
-     set_size = charset->set_size;
  
!     cvt_length = 0;
!     if (ct_info->ext_segment ||
! 	(side == XlcGR && charset != state->GR_charset) ||
! 	(side == XlcGL && charset != state->GL_charset)) {
! 
! 	ct_len -= ct_info->encoding_len;
! 	if (ct_len < 0)
! 	    return -1;
! 	cvt_length += ct_info->encoding_len;
! 	if (ctptr) {
  	    strcpy(ctptr, ct_info->encoding);
  	    ctptr += ct_info->encoding_len;
  	}
-     }
  
!     min_ch = 0x20;
!     max_ch = 0x7f;
  
!     if (set_size == 94) {
! 	max_ch--;
! 	if (length > 1 || side == XlcGR)
! 	    min_ch++;
!     }
! 
!     while (csstr_len > 0 && ct_len > 0) {
! 	ch = *((unsigned char *) csptr++) & 0x7f;
! 	if (ch < min_ch || ch > max_ch)
! 	    if (ch != 0x00 && ch != 0x09 && ch != 0x0a && ch != 0x1b)
! 		continue;	/* XXX */
! 	cvt_length++;
! 	if (ctptr) {
  	    if (side == XlcGL)
  		*ctptr++ = ch & 0x7f;
  	    else if (side == XlcGR)
  		*ctptr++ = ch | 0x80;
  	    else
  		*ctptr++ = ch;
  	}
! 	csstr_len--;
! 	ct_len--;
      }
  
-     if (side == XlcGR)
- 	state->GR_charset = charset;
-     else if (side == XlcGL)
- 	state->GL_charset = charset;
- 
      *from_left -= csptr - *((char **) from);
      *from = (XPointer) csptr;
  
!     if (ctptr)
! 	*to = (XPointer) ctptr;
!     *to_left -= cvt_length;
  
      return 0;
  }
--- 611,688 ----
  	return -1;
  
      side = charset->side;
  
!     if (ct_info->ext_segment) {
! 	if (charset != state->ext_seg_charset && state->ext_seg_left < 1) {
! 	    length = ct_info->encoding_len;
! 	    if (ct_len < length)
! 		return -1;
! 	    strcpy(ctptr, ct_info->encoding);
! 	    ctptr[4] = ((ct_info->ext_segment_len + csstr_len) / 128) | 0x80;
! 	    ctptr[5] = ((ct_info->ext_segment_len + csstr_len) % 128) | 0x80;
! 	    ctptr += length;
! 	    ct_len -= length;
! 	    state->ext_seg_left = csstr_len;
! 	}
! 	length = min(state->ext_seg_left, csstr_len);
! 	state->ext_seg_left -= length;
! 
! 	if (side == XlcGL) {
! 	    while (length-- > 0)
! 		*ctptr++ = *csptr++ & 0x7f;
! 	} else if (side == XlcGR) {
! 	    while (length-- > 0)
! 		*ctptr++ = *csptr++ | 0x80;
! 	} else {
! 	    while (length-- > 0)
! 		*ctptr++ = *csptr++;
! 	}
! 	state->ext_seg_charset = (state->ext_seg_left > 0) ? charset : NULL;
!     } else {
! 	if ((side == XlcGR && charset != state->GR_charset) ||
! 	    (side == XlcGL && charset != state->GL_charset)) {
! 
! 	    ct_len -= ct_info->encoding_len;
! 	    if (ct_len < 0)
! 		return -1;
  	    strcpy(ctptr, ct_info->encoding);
  	    ctptr += ct_info->encoding_len;
  	}
  
! 	min_ch = 0x20;
! 	max_ch = 0x7f;
  
! 	if (charset->set_size == 94) {
! 	    max_ch--;
! 	    if (charset->char_size > 1 || side == XlcGR)
! 		min_ch++;
! 	}
! 
! 	while (csstr_len > 0 && ct_len > 0) {
! 	    ch = *((unsigned char *) csptr++) & 0x7f;
! 	    if (ch < min_ch || ch > max_ch)
! 		if (ch != 0x00 && ch != 0x09 && ch != 0x0a && ch != 0x1b)
! 		    continue;	/* XXX */
  	    if (side == XlcGL)
  		*ctptr++ = ch & 0x7f;
  	    else if (side == XlcGR)
  		*ctptr++ = ch | 0x80;
  	    else
  		*ctptr++ = ch;
+ 	    csstr_len--;
+ 	    ct_len--;
  	}
! 	if (side == XlcGR)
! 	    state->GR_charset = charset;
! 	else if (side == XlcGL)
! 	    state->GL_charset = charset;
      }
  
      *from_left -= csptr - *((char **) from);
      *from = (XPointer) csptr;
  
!     *to_left -= ctptr - *((char **) to);
!     *to = (XPointer) ctptr;
  
      return 0;
  }
***************
*** 672,678 ****
      char *csptr, *string_ptr;
      int csstr_len, str_len;
      unsigned char ch;
!     int cvt_length, unconv_num = 0;
  
      if (num_args < 1 || (state->GL_charset != (XlcCharSet) args[0] &&
  	state->GR_charset != (XlcCharSet) args[0]))
--- 736,742 ----
      char *csptr, *string_ptr;
      int csstr_len, str_len;
      unsigned char ch;
!     int unconv_num = 0;
  
      if (num_args < 1 || (state->GL_charset != (XlcCharSet) args[0] &&
  	state->GR_charset != (XlcCharSet) args[0]))
***************
*** 683,689 ****
      csstr_len = *from_left;
      str_len = *to_left;
  
-     cvt_length = 0;
      while (csstr_len-- > 0 && str_len > 0) {
  	ch = *((unsigned char *) csptr++);
  	if ((ch < 0x20 && ch != 0x00 && ch != 0x09 && ch != 0x0a) ||
--- 747,752 ----
***************
*** 691,708 ****
  	    unconv_num++;
  	    continue;
  	}
! 	cvt_length++;
! 	if (string_ptr) 
! 	    *((unsigned char *) string_ptr++) = ch;
  	str_len--;
      }
  
      *from_left -= csptr - *((char **) from);
      *from = (XPointer) csptr;
  
!     if (string_ptr)
! 	*to = (XPointer) string_ptr;
!     *to_left -= cvt_length;
  
      return unconv_num;
  }
--- 754,768 ----
  	    unconv_num++;
  	    continue;
  	}
! 	*((unsigned char *) string_ptr++) = ch;
  	str_len--;
      }
  
      *from_left -= csptr - *((char **) from);
      *from = (XPointer) csptr;
  
!     *to_left -= string_ptr - *((char **) to);
!     *to = (XPointer) string_ptr;
  
      return unconv_num;
  }
*** -	Fri Jul  7 09:31:08 1995
--- xc/lib/X11/lcCharSet.c	Fri Jul  7 09:31:08 1995
***************
*** 1,4 ****
! /* $XConsortium: lcCharSet.c,v 1.2 94/01/20 18:06:19 rws Exp $ */
  /*
   * Copyright 1992, 1993 by TOSHIBA Corp.
   *
--- 1,4 ----
! /* $XConsortium: lcCharSet.c,v 1.3 95/02/22 22:02:59 kaleb Exp $ */
  /*
   * Copyright 1992, 1993 by TOSHIBA Corp.
   *
***************
*** 148,155 ****
  	return (XlcCharSet) NULL;
      bzero((char *) charset, sizeof(XlcCharSetRec));
      
!     charset->name = name;
!     charset->ct_sequence = ct_sequence;
      charset->get_values = get_values;
  
      _XlcParseCharSet(charset);
--- 148,161 ----
  	return (XlcCharSet) NULL;
      bzero((char *) charset, sizeof(XlcCharSetRec));
      
!     charset->name = (char *) Xmalloc(strlen(name) + strlen(ct_sequence) + 2);
!     if (charset->name == NULL) {
! 	Xfree((char *) charset);
! 	return (XlcCharSet) NULL;
!     }
!     strcpy(charset->name, name);
!     charset->ct_sequence = charset->name + strlen(name) + 1;
!     strcpy(charset->ct_sequence, ct_sequence);
      charset->get_values = get_values;
  
      _XlcParseCharSet(charset);
*** -	Fri Jul  7 09:31:09 1995
--- xc/lib/X11/lcEuc.c	Fri Jul  7 09:31:09 1995
***************
*** 1,4 ****
! /* $XConsortium: lcEuc.c,v 1.9 94/03/29 22:51:55 rws Exp $ */
  /******************************************************************
  
          Copyright 1992, 1993 by FUJITSU LIMITED
--- 1,4 ----
! /* $XConsortium: lcEuc.c,v 1.10 95/06/26 20:41:49 kaleb Exp $ */
  /******************************************************************
  
          Copyright 1992, 1993 by FUJITSU LIMITED
***************
*** 768,778 ****
      for (i = 0; i < num_codesets; i++) {
  
  	codeset = codesets[i];
! 	num_charsets = codesets[i]->num_charsets;
  
  	for (j = 0; j < num_charsets; j++) {
  
! 	    charset = codesets[i]->charset_list[0];
  
  	    for (ctdp = ctdata; ctdp <= ctd_endp; ctdp++)
  
--- 768,778 ----
      for (i = 0; i < num_codesets; i++) {
  
  	codeset = codesets[i];
! 	num_charsets = codeset->num_charsets;
  
  	for (j = 0; j < num_charsets; j++) {
  
! 	    charset = codeset->charset_list[j];
  
  	    for (ctdp = ctdata; ctdp <= ctd_endp; ctdp++)
  
***************
*** 838,843 ****
--- 838,844 ----
  
      for (length = ctdata[Ascii].length; *from_left > 0; (*from_left) -= length)
      {
+ 	ct_type = CT_STD;
  	if (*inbufptr == '\033' || *inbufptr == (char)'\233') {
  	    for (ctdp = ctdata; ctdp <= ctd_endp ; ctdp++) {
  
***************
*** 857,863 ****
  		    break;
  		}
  	    }
- 
  	    if (ctdp > ctd_endp) 	/* failed to match CT sequence */
  		unconv_num++;
  	}
--- 858,863 ----
***************
*** 1088,1093 ****
--- 1088,1094 ----
  
      for (length = ctdata[Ascii].length; *from_left > 0; (*from_left) -= length)
      {
+ 	ct_type = CT_STD;
  	if (*inbufptr == '\033' || *inbufptr == (char)'\233') {
  
  	    for (ctdp = ctdata; ctdp <= ctd_endp ; ctdp++) {
*** -	Fri Jul  7 09:31:09 1995
--- xc/lib/X11/lcGenConv.c	Fri Jul  7 09:31:09 1995
***************
*** 1,4 ****
! /* $XConsortium: lcGenConv.c,v 1.6 94/11/21 18:23:20 kaleb Exp $ */
  /*
   * Copyright 1992, 1993 by TOSHIBA Corp.
   *
--- 1,4 ----
! /* $XConsortium: lcGenConv.c,v 1.7 95/02/22 22:03:01 kaleb Exp $ */
  /*
   * Copyright 1992, 1993 by TOSHIBA Corp.
   *
***************
*** 47,55 ****
      register XLCdGenericPart *gen = XLC_GENERIC_PART(state->lcd);
      register CodeSet codeset;
  
!     if (codeset = gen->initial_state_GL)
  	state->GL_charset = *codeset->charset_list;
!     if (codeset = gen->initial_state_GR)
  	state->GR_charset = *codeset->charset_list;
  
      if (state->GL_charset == NULL)
--- 47,57 ----
      register XLCdGenericPart *gen = XLC_GENERIC_PART(state->lcd);
      register CodeSet codeset;
  
!     codeset = gen->initial_state_GL;
!     if (codeset && codeset->charset_list)
  	state->GL_charset = *codeset->charset_list;
!     codeset = gen->initial_state_GR;
!     if (codeset && codeset->charset_list)
  	state->GR_charset = *codeset->charset_list;
  
      if (state->GL_charset == NULL)
*** -	Fri Jul  7 09:31:10 1995
--- xc/lib/X11/lcGeneric.c	Fri Jul  7 09:31:10 1995
***************
*** 1,4 ****
! /* $XConsortium: lcGeneric.c,v 1.5 94/03/29 22:52:03 rws Exp $ */
  /*
   * Copyright 1992, 1993 by TOSHIBA Corp.
   *
--- 1,4 ----
! /* $XConsortium: lcGeneric.c,v 1.6 95/02/22 22:03:08 kaleb Exp $ */
  /*
   * Copyright 1992, 1993 by TOSHIBA Corp.
   *
***************
*** 78,110 ****
  
  static Bool
  string_to_encoding(str, encoding)
! char	*str,*encoding;
  {
!      char	*tmp1, *tmp2;
!      int	i, base;
  
!      for(tmp1=str, i=0; *tmp1; i++){
! 	  if(*tmp1++ != '\\'){
! 	       return(False);
! 	  }
! 	  switch(*tmp1++){
! 	  case 'x':
! 	       base = 16;
! 	       break;
! 	  case 'o':
! 	       base = 8;
! 	       break;
! 	  case 'd':
! 	       base = 10;
! 	       break;
! 	  default:
! 	       return(False);
! 	  }
! 	  encoding[i]=(char)strtol(tmp1, &tmp2, base);
! 	  tmp1 = tmp2;
!      }
!      encoding[i]=0;
!      return(True);
  }
  
  static Bool
--- 78,114 ----
  
  static Bool
  string_to_encoding(str, encoding)
!     char *str;
!     char *encoding;
  {
!     char *next;
!     long value;
!     int base;
! 
!     while (*str) {
! 	if (*str == '\\') {
! 	    switch (*(str + 1)) {
! 		case 'x':
! 		case 'X':
! 		    base = 16;
! 		    break;
! 		default:
! 		    base = 8;
! 		    break;
! 	    }
! 	    value = strtol(str + 2, &next, base);
! 	    if (str + 2 != next) {
! 		*((unsigned char *) encoding++) = (unsigned char) value;
! 		str = next;
! 		continue;
! 	    }
! 	}
! 	*encoding++ = *str++;
!     }
  
!     *encoding = '\0';
! 
!     return True;
  }
  
  static Bool
***************
*** 412,422 ****
  	_XlcGetResource(lcd, "XLC_XLOCALE", name, &value, &num);
  	if (num > 0) {
  	    XlcCharSet charset;
  
  	    if (codeset == NULL && (codeset = add_codeset(gen)) == NULL)
  		goto err;
  	    for ( ; num-- > 0; value++) {
! 		if (charset = _XlcGetCharSet(*value)) {
  		    if (add_charset(codeset, charset) == False)
  			goto err;
  		}
--- 416,443 ----
  	_XlcGetResource(lcd, "XLC_XLOCALE", name, &value, &num);
  	if (num > 0) {
  	    XlcCharSet charset;
+ 	    char *encoding;
  
  	    if (codeset == NULL && (codeset = add_codeset(gen)) == NULL)
  		goto err;
  	    for ( ; num-- > 0; value++) {
! 		string_to_encoding(*value, name);
! 		charset = NULL;
! 		if ((encoding = strchr(name, ':')) &&
! 		    (encoding = strchr(encoding + 1, ':'))) {
! 		    *encoding++ = '\0';
! 		    charset = _XlcAddCT(name, encoding);
! 		}
! 		if (charset == NULL) {
! 		    charset = _XlcGetCharSet(name);
! 		    if (charset == NULL &&
! 			(charset = _XlcCreateDefaultCharSet(name, ""))) {
! 			charset->side = codeset->side;
! 			charset->char_size = codeset->length;
! 			_XlcAddCharSet(charset);
! 		    }
! 		}
! 		if (charset) {
  		    if (add_charset(codeset, charset) == False)
  			goto err;
  		}
*** -	Fri Jul  7 09:31:11 1995
--- xc/lib/X11/lcSjis.c	Fri Jul  7 09:31:11 1995
***************
*** 1,4 ****
! /* $XConsortium: lcSjis.c,v 1.13 94/03/29 22:52:06 rws Exp $ */
  /****************************************************************
  
          Copyright 1992, 1993 by FUJITSU LIMITED
--- 1,4 ----
! /* $XConsortium: lcSjis.c,v 1.14 95/06/26 20:41:49 kaleb Exp $ */
  /****************************************************************
  
          Copyright 1992, 1993 by FUJITSU LIMITED
***************
*** 839,849 ****
      for (i = 0; i < num_codesets; i++) {
  
  	codeset = codesets[i];
! 	num_charsets = codesets[i]->num_charsets;
  
  	for (j = 0; j < num_charsets; j++) {
  
! 	    charset = codesets[i]->charset_list[0];
  
  	    for (ctdp = ctdata; ctdp <= ctd_endp; ctdp++)
  
--- 839,849 ----
      for (i = 0; i < num_codesets; i++) {
  
  	codeset = codesets[i];
! 	num_charsets = codeset->num_charsets;
  
  	for (j = 0; j < num_charsets; j++) {
  
! 	    charset = codeset->charset_list[j];
  
  	    for (ctdp = ctdata; ctdp <= ctd_endp; ctdp++)
  
***************
*** 1174,1180 ****
  		    break;
  		}
  	    }
- 
  	    if (ctdp > ctd_endp)  	/* failed to match CT sequence */
  		unconv_num++;
  	}
--- 1174,1179 ----
***************
*** 1287,1293 ****
  		    break;
  		}
  	    }
- 
  	    if (ctdp > ctd_endp)    	/* failed to match CT sequence */
  		unconv_num++;
  	}
--- 1286,1291 ----
*** -	Fri Jul  7 09:31:12 1995
--- xc/lib/X11/lcTxtPr.c	Fri Jul  7 09:31:12 1995
***************
*** 1,4 ****
! /* $XConsortium: lcTxtPr.c,v 1.3 94/01/20 18:07:37 rws Exp $ */
  /*
   * Copyright 1992, 1993 by TOSHIBA Corp.
   *
--- 1,4 ----
! /* $XConsortium: lcTxtPr.c,v 1.5 95/06/07 15:32:21 kaleb Exp $ */
  /*
   * Copyright 1992, 1993 by TOSHIBA Corp.
   *
***************
*** 148,158 ****
      for (i = 1; to_left > 0; i++) {
  	if (is_wide_char) {
  	    from = (XPointer) *wc_list;
! 	    from_left = _Xwcslen(*wc_list) + 1;
  	    wc_list++;
  	} else {
  	    from = (XPointer) *mb_list;
! 	    from_left = strlen(*mb_list) + 1;
  	    mb_list++;
  	}
  
--- 148,158 ----
      for (i = 1; to_left > 0; i++) {
  	if (is_wide_char) {
  	    from = (XPointer) *wc_list;
! 	    from_left = _Xwcslen(*wc_list);
  	    wc_list++;
  	} else {
  	    from = (XPointer) *mb_list;
! 	    from_left = strlen(*mb_list);
  	    mb_list++;
  	}
  
***************
*** 170,175 ****
--- 170,177 ----
  	}
  
  	unconv_num += ret;
+ 	*to++ = '\0';
+ 	to_left--;
  
  	if (i >= count)
  	    break;
*** -	Fri Jul  7 09:31:12 1995
--- xc/lib/X11/lcWrap.c	Fri Jul  7 09:31:12 1995
***************
*** 1,4 ****
! /* $XConsortium: lcWrap.c,v 11.21 94/09/01 18:40:04 kaleb Exp $ */
  /*
  
  Copyright (c) 1991  X Consortium
--- 1,4 ----
! /* $XConsortium: lcWrap.c,v 11.23 95/06/08 23:20:39 gildea Exp $ */
  /*
  
  Copyright (c) 1991  X Consortium
***************
*** 65,71 ****
  #endif
  #include <X11/Xutil.h>
  
! #if __STDC__
  #define Const const
  #else
  #define Const /**/
--- 65,71 ----
  #endif
  #include <X11/Xutil.h>
  
! #ifdef __STDC__
  #define Const const
  #else
  #define Const /**/
***************
*** 270,278 ****
      XLCd lcd;
      XlcLoaderList loader;
      XLCdList cur;
  
!     if (name == NULL)
  	name = setlocale (LC_CTYPE, (char *)NULL);
  
      _XLockMutex(_Xi18n_lock);
  
--- 270,286 ----
      XLCd lcd;
      XlcLoaderList loader;
      XLCdList cur;
+ #if !defined(X_NOT_STDC_ENV) && !defined(X_LOCALE)
+     char siname[256];
+     char *_XlcMapOSLocaleName();
+ #endif
  
!     if (name == NULL) {
  	name = setlocale (LC_CTYPE, (char *)NULL);
+ #if !defined(X_NOT_STDC_ENV) && !defined(X_LOCALE)
+ 	name = _XlcMapOSLocaleName (name, siname); 
+ #endif
+     }
  
      _XLockMutex(_Xi18n_lock);
  
*** -	Fri Jul  7 09:31:13 1995
--- xc/lib/X11/omGeneric.c	Fri Jul  7 09:31:13 1995
***************
*** 1,4 ****
! /* $XConsortium: omGeneric.c,v 1.6 94/03/29 22:52:12 rws Exp $ */
  /*
   * Copyright 1992, 1993 by TOSHIBA Corp.
   *
--- 1,4 ----
! /* $XConsortium: omGeneric.c,v 1.8 95/06/02 23:29:17 converse Exp $ */
  /*
   * Copyright 1992, 1993 by TOSHIBA Corp.
   *
***************
*** 125,140 ****
      FontData data;
      FontSet font_set;
      XFontStruct *fs_list;
!     char **fn_list, *fname, *prop_fname;
      int list_num, font_set_num, i;
  
!     fn_list = XListFontsWithInfo(dpy, name, MAXFONTS, &list_num, &fs_list);
      if (fn_list == NULL)
  	return found_num;
  
      for (i = 0; i < list_num; i++) {
  	fname = fn_list[i];
-  	prop_fname = get_prop_name(dpy, fs_list + i);
  
  	font_set = gen->font_set;
  	font_set_num = gen->font_set_num;
--- 125,141 ----
      FontData data;
      FontSet font_set;
      XFontStruct *fs_list;
!     char **fn_list, *fname, *prop_fname = NULL;
      int list_num, font_set_num, i;
+     int list2_num;
+     char **fn2_list = NULL;
  
!     fn_list = XListFonts(dpy, name, MAXFONTS, &list_num);
      if (fn_list == NULL)
  	return found_num;
  
      for (i = 0; i < list_num; i++) {
  	fname = fn_list[i];
  
  	font_set = gen->font_set;
  	font_set_num = gen->font_set_num;
***************
*** 143,170 ****
  	    if (font_set->font_name)
  		continue;
  
! 	    if (data = check_charset(font_set, fname))
! 		goto found;
! 	    else if (prop_fname &&
! 		     (data = check_charset(font_set, prop_fname))) {
! 		fname = prop_fname;
! found:
  		font_set->side = data->side;
  		font_set->font_name = (char *) Xmalloc(strlen(fname) + 1);
  		if (font_set->font_name) {
  		    strcpy(font_set->font_name, fname);
  		    found_num++;
  		}
- 		if (found_num == gen->font_set_num)
- 		    break;
  	    }
  	}
- 	if (prop_fname)
- 	    Xfree(prop_fname);
      }
! 
!     XFreeFontInfo(fn_list, fs_list, list_num);
! 
      return found_num;
  }
  
--- 144,177 ----
  	    if (font_set->font_name)
  		continue;
  
! 	    if ((data = check_charset(font_set, fname)) == NULL) {
! 		if ((fn2_list = XListFontsWithInfo(dpy, name, MAXFONTS,
! 					      &list2_num, &fs_list))
! 		    && (prop_fname = get_prop_name(dpy, fs_list))
! 		    && (data = check_charset(font_set, prop_fname)))
! 		    fname = prop_fname;
! 	    }
! 	    if (data) {
  		font_set->side = data->side;
  		font_set->font_name = (char *) Xmalloc(strlen(fname) + 1);
  		if (font_set->font_name) {
  		    strcpy(font_set->font_name, fname);
  		    found_num++;
  		}
  	    }
+ 	    if (fn2_list) {
+ 		XFreeFontInfo(fn2_list, fs_list, list2_num);
+ 		fn2_list = NULL;
+ 		if (prop_fname) {
+ 		    Xfree(prop_fname);
+ 		    prop_fname = NULL;
+ 		}
+ 	    }
+ 	    if (found_num == gen->font_set_num)
+ 		break;
  	}
      }
!     XFreeFontNames(fn_list);
      return found_num;
  }
  
***************
*** 797,804 ****
  	XFreeStringList(om->core.required_charset.charset_list);
      else
  	Xfree((char*)om->core.required_charset.charset_list);
!     if (om->core.orientation_list.orient)
! 	Xfree(om->core.orientation_list.orient);
  
      Xfree(om);
  
--- 804,811 ----
  	XFreeStringList(om->core.required_charset.charset_list);
      else
  	Xfree((char*)om->core.required_charset.charset_list);
!     if (om->core.orientation_list.orientation)
! 	Xfree(om->core.orientation_list.orientation);
  
      Xfree(om);
  
***************
*** 1021,1028 ****
  	return False;
  
      *orientation = XOMOrientation_LTR_TTB;
!     om->core.orientation_list.orient = orientation;
!     om->core.orientation_list.num_orient = 1;
  
      return True;
  }
--- 1028,1035 ----
  	return False;
  
      *orientation = XOMOrientation_LTR_TTB;
!     om->core.orientation_list.orientation = orientation;
!     om->core.orientation_list.num_orientation = 1;
  
      return True;
  }
*** -	Fri Jul  7 09:31:14 1995
--- xc/lib/Xext/globals.c	Fri Jul  7 09:31:14 1995
***************
*** 1,4 ****
! /* $XConsortium: globals.c,v 1.4 94/04/17 20:22:58 rws Exp $ */
  /*
  
  Copyright (c) 1989  X Consortium
--- 1,4 ----
! /* $XConsortium: globals.c,v 1.5 95/06/08 23:20:39 gildea Exp $ */
  /*
  
  Copyright (c) 1989  X Consortium
***************
*** 54,60 ****
  /*
   * If we need to define extra variables for each global
   */
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define ZEROINIT(t,var,val) SetZero(t,var,val); \
    SetZero (long, _libX_##var##Flag, 0); \
    SetZero (void *, _libX_##var##Ptr, NULL)
--- 54,60 ----
  /*
   * If we need to define extra variables for each global
   */
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define ZEROINIT(t,var,val) SetZero(t,var,val); \
    SetZero (long, _libX_##var##Flag, 0); \
    SetZero (void *, _libX_##var##Ptr, NULL)
*** -	Fri Jul  7 09:31:15 1995
--- xc/lib/Xt/Imakefile	Fri Jul  7 09:31:15 1995
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile,v 1.110 94/04/04 21:54:23 gildea Exp $
  #define DoNormalLib NormalLibXt
  #define DoSharedLib SharedLibXt
  #define DoDebugLib DebugLibXt
--- 1,4 ----
! XCOMM $XConsortium: Imakefile,v 1.112 95/06/16 17:47:39 gildea Exp $
  #define DoNormalLib NormalLibXt
  #define DoSharedLib SharedLibXt
  #define DoDebugLib DebugLibXt
***************
*** 61,66 ****
--- 61,68 ----
   RCONST_DEFINES = -DNORCONST
  #endif
  
+ STRINGSABIOPTIONS = ToolkitStringsABIOptions
+ 
         LINTLIBS = $(LINTXLIB)
  
  HEADERS = \
***************
*** 210,214 ****
--- 212,221 ----
  #if DoSharedLib
  SpecialCObjectRule(sharedlib,$(_NOOP_),$(SHLIBDEF))
  #endif
+ 
+ STRINGS_FILES = StringDefs.c StringDefs.h Shell.h
+ STRINGS_TMPLS = util/StrDefs.ct util/StrDefs.ht util/Shell.ht
+ 
+ ToolkitMakeStrings($(STRINGS_FILES),util/string.list,$(STRINGSABIOPTIONS),$(STRINGS_TMPLS),StringDefs.c)
  
  DependTarget()
*** -	Fri Jul  7 09:31:16 1995
--- xc/lib/Xt/Converters.c	Fri Jul  7 09:31:16 1995
***************
*** 1,4 ****
! /* $XConsortium: Converters.c,v 1.99 94/04/17 20:13:50 rws Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts
--- 1,4 ----
! /* $XConsortium: Converters.c,v 1.101 95/06/08 23:20:39 gildea Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts
***************
*** 76,82 ****
  extern int errno;	
  #endif
  
! #if __STDC__
  #define Const const
  #else
  #define Const /**/
--- 76,82 ----
  extern int errno;	
  #endif
  
! #ifdef __STDC__
  #define Const const
  #else
  #define Const /**/
***************
*** 1514,1520 ****
      XtPointer	*closure_ret;
  {
      String str;
-     int len;
      char directory[PATH_MAX+1];
  
      if (*num_args != 0)
--- 1514,1519 ----
***************
*** 1524,1530 ****
             (String *)NULL, (Cardinal *)NULL);
  
      str = (String)fromVal->addr;
!     if (CompareISOLatin1(str, "XtCurrentDirectory")) {
  	/* uglier, but does not depend on compiler knowing return type */
  #if !defined(X_NOT_POSIX) || defined(SYSV) || defined(WIN32)
  	if (getcwd(directory, PATH_MAX + 1))
--- 1523,1529 ----
             (String *)NULL, (Cardinal *)NULL);
  
      str = (String)fromVal->addr;
!     if (CompareISOLatin1(str, "XtCurrentDirectory") == 0) {
  	/* uglier, but does not depend on compiler knowing return type */
  #if !defined(X_NOT_POSIX) || defined(SYSV) || defined(WIN32)
  	if (getcwd(directory, PATH_MAX + 1))
***************
*** 1536,1545 ****
  	if (!str) {
  	    if (errno == EACCES)
  		errno = 0;	    /* reset errno */
  	    return False;
  	}
      }
!     done(String, str);	/* core dumps, don't use this converter yet */
  }
  
  /*ARGSUSED*/
--- 1535,1569 ----
  	if (!str) {
  	    if (errno == EACCES)
  		errno = 0;	    /* reset errno */
+ 	    XtDisplayStringConversionWarning(dpy, (char *) fromVal->addr,
+ 					     XtRDirectoryString);
  	    return False;
  	}
      }
! 
!     /* Since memory from the resource database or from static buffers of
!      * system libraries may be freed or overwritten, allocate memory.
!      * The memory is freed when all cache references are released.
!      */
!     str = XtNewString(str);
!     done(String, str);
! }
! 
! /*ARGSUSED*/
! static void FreeDirectoryString(app, toVal, closure, args, num_args)
!     XtAppContext app;
!     XrmValuePtr	toVal;
!     XtPointer	closure;	/* unused */
!     XrmValuePtr	args;
!     Cardinal	*num_args;
! {
!     if (*num_args != 0)
! 	XtAppWarningMsg(app,
! 		 XtNwrongParameters,"freeDirectoryString",XtCXtToolkitError,
! 		 "Free Directory String requires no extra arguments",
!                  (String *) NULL, (Cardinal *) NULL);
! 
!     XtFree((char *) toVal->addr);
  }
  
  /*ARGSUSED*/
***************
*** 1776,1783 ****
  	displayConvertArg, XtNumber(displayConvertArg),
  	XtCacheByDisplay, FreeCursor);
      Add(_XtQString, XtQDimension, XtCvtStringToDimension,NULL, 0, XtCacheNone);
!     Add(_XtQString, XtQDirectoryString,
!                           XtCvtStringToDirectoryString, NULL, 0, XtCacheNone);
      Add(_XtQString, XtQDisplay,   XtCvtStringToDisplay, NULL, 0, XtCacheAll);
     Add2(_XtQString, XtQFile,      XtCvtStringToFile,    NULL, 0,
  	XtCacheAll | XtCacheRefCount, FreeFile);
--- 1800,1807 ----
  	displayConvertArg, XtNumber(displayConvertArg),
  	XtCacheByDisplay, FreeCursor);
      Add(_XtQString, XtQDimension, XtCvtStringToDimension,NULL, 0, XtCacheNone);
!    Add2(_XtQString, XtQDirectoryString, XtCvtStringToDirectoryString, NULL, 0,
! 	XtCacheNone | XtCacheRefCount, FreeDirectoryString);
      Add(_XtQString, XtQDisplay,   XtCvtStringToDisplay, NULL, 0, XtCacheAll);
     Add2(_XtQString, XtQFile,      XtCvtStringToFile,    NULL, 0,
  	XtCacheAll | XtCacheRefCount, FreeFile);
*** -	Fri Jul  7 09:31:17 1995
--- xc/lib/Xt/Display.c	Fri Jul  7 09:31:17 1995
***************
*** 1,4 ****
! /* $XConsortium: Display.c,v 1.116 94/06/01 15:34:15 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $XConsortium: Display.c,v 1.118 95/06/16 19:25:22 kaleb Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 120,125 ****
--- 120,126 ----
  	}
  
  	app->list[app->count++] = d;
+ 	app->rebuild_fdlist = TRUE;
  #ifndef USE_POLL
  	if (ConnectionNumber(d) + 1 > app->fds.nfds) {
  	    app->fds.nfds = ConnectionNumber(d) + 1;
***************
*** 143,148 ****
--- 144,150 ----
  	    for (i++; i < app->count; i++) app->list[i-1] = app->list[i];
  	    app->count--;
  	}
+ 	app->rebuild_fdlist = TRUE;
  	app->fds.nfds--;
  }
  
***************
*** 382,393 ****
  	app->lock_info = NULL;
  	app->lock = NULL;
  	app->unlock = NULL;
  	app->restore_lock = NULL;
  	app->free_lock = NULL;
- 	app->push_thread = NULL;
- 	app->pop_thread = NULL;
- 	app->is_top_thread = NULL;
- 	app->wait_thread = NULL;
  #endif
  	INIT_APP_LOCK(app);
  	LOCK_APP(app);
--- 384,392 ----
  	app->lock_info = NULL;
  	app->lock = NULL;
  	app->unlock = NULL;
+ 	app->yield_lock = NULL;
  	app->restore_lock = NULL;
  	app->free_lock = NULL;
  #endif
  	INIT_APP_LOCK(app);
  	LOCK_APP(app);
***************
*** 436,441 ****
--- 435,441 ----
  	app->dpy_destroy_count = 0;
  	app->dpy_destroy_list = NULL;
  	app->exit_flag = FALSE;
+ 	app->rebuild_fdlist = TRUE;
  	UNLOCK_PROCESS;
  	UNLOCK_APP(app);
  	return app;
*** -	Fri Jul  7 09:31:18 1995
--- xc/lib/Xt/Event.c	Fri Jul  7 09:31:18 1995
***************
*** 1,4 ****
! /* $XConsortium: Event.c,v 1.169 94/09/15 19:42:47 kaleb Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $XConsortium: Event.c,v 1.172 95/06/08 23:20:39 gildea Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 64,70 ****
  #include "Shell.h"
  #include "StringDefs.h"
  
! #if __STDC__
  #define Const const
  #else
  #define Const /**/
--- 64,70 ----
  #include "Shell.h"
  #include "StringDefs.h"
  
! #ifdef __STDC__
  #define Const const
  #else
  #define Const /**/
***************
*** 1329,1340 ****
  {
  
      if (event->type == EnterNotify &&
! 	    widget->core.widget_class->core_class.compress_enterleave) {
  	if (XPending(event->xcrossing.display)) {
  	    XEvent nextEvent;
  	    XPeekEvent(event->xcrossing.display, &nextEvent);
  	    if (nextEvent.type == LeaveNotify &&
! 		    event->xcrossing.window == nextEvent.xcrossing.window &&
  		(event->xcrossing.detail != NotifyInferior &&
  		 nextEvent.xcrossing.detail != NotifyInferior ||
  		 event->xcrossing.detail == NotifyInferior &&
--- 1329,1342 ----
  {
  
      if (event->type == EnterNotify &&
! 	event->xcrossing.mode == NotifyNormal &&
! 	widget->core.widget_class->core_class.compress_enterleave) {
  	if (XPending(event->xcrossing.display)) {
  	    XEvent nextEvent;
  	    XPeekEvent(event->xcrossing.display, &nextEvent);
  	    if (nextEvent.type == LeaveNotify &&
! 		event->xcrossing.window == nextEvent.xcrossing.window &&
! 		nextEvent.xcrossing.mode == NotifyNormal &&
  		(event->xcrossing.detail != NotifyInferior &&
  		 nextEvent.xcrossing.detail != NotifyInferior ||
  		 event->xcrossing.detail == NotifyInferior &&
*** -	Fri Jul  7 09:31:20 1995
--- xc/lib/Xt/InitialI.h	Fri Jul  7 09:31:20 1995
***************
*** 1,4 ****
! /* $XConsortium: InitialI.h,v 1.82 94/04/17 20:14:11 kaleb Exp $ */
  
  /***********************************************************
  
--- 1,4 ----
! /* $XConsortium: InitialI.h,v 1.82.1.1 95/06/29 13:56:28 kaleb Exp $ */
  
  /***********************************************************
  
***************
*** 190,195 ****
--- 190,196 ----
      Display **dpy_destroy_list;
      int dpy_destroy_count;
      Boolean exit_flag;
+     Boolean rebuild_fdlist;
  #ifdef XTHREADS
      LockPtr lock_info;
      ThreadAppProc lock;
***************
*** 197,206 ****
      ThreadAppYieldLockProc yield_lock;
      ThreadAppRestoreLockProc restore_lock;
      ThreadAppProc free_lock;
-     ThreadAppProc push_thread;
-     ThreadAppProc pop_thread;
-     ThreadAppTopProc is_top_thread;
-     ThreadAppProc wait_thread;
  #endif
  } XtAppStruct;
  
--- 198,203 ----
*** -	Fri Jul  7 09:31:21 1995
--- xc/lib/Xt/Initialize.c	Fri Jul  7 09:31:21 1995
***************
*** 1,4 ****
! /* $XConsortium: Initialize.c,v 1.222 94/12/12 18:59:11 kaleb Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts
--- 1,4 ----
! /* $XConsortium: Initialize.c,v 1.223 95/06/08 23:20:39 gildea Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts
***************
*** 72,78 ****
  #include <stdio.h>
  #include <X11/Xlocale.h>
  
! #if __STDC__
  #define Const const
  #else
  #define Const /**/
--- 72,78 ----
  #include <stdio.h>
  #include <X11/Xlocale.h>
  
! #ifdef __STDC__
  #define Const const
  #else
  #define Const /**/
*** -	Fri Jul  7 09:31:22 1995
--- xc/lib/Xt/Intrinsic.c	Fri Jul  7 09:31:22 1995
***************
*** 1,4 ****
! /* $XConsortium: Intrinsic.c,v 1.196 94/11/21 18:20:56 kaleb Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $XConsortium: Intrinsic.c,v 1.197 95/04/07 19:51:22 kaleb Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 306,311 ****
--- 306,312 ----
      Window			window;
      Display*			display;
      String			class_name;
+     Widget			hookobj;
  
      if (!XtIsWidget(widget) || XtIsRealized(widget)) return;
      display = XtDisplay(widget);
***************
*** 323,328 ****
--- 324,339 ----
  		      (String *)NULL, (Cardinal *)NULL);
      else (*realize) (widget, &value_mask, &values);
      window = XtWindow(widget);
+     hookobj = XtHooksOfDisplay(XtDisplayOfObject(widget));
+     if (XtHasCallbacks(hookobj,XtNchangeHook) == XtCallbackHasSome) {
+ 	XtChangeHookDataRec call_data;
+ 
+ 	call_data.type = XtHrealizeWidget;
+ 	call_data.widget = widget;
+ 	XtCallCallbackList(hookobj, 
+ 		((HookObject)hookobj)->hooks.changehook_callbacks, 
+ 		(XtPointer)&call_data);
+     }
  #ifndef NO_IDENTIFY_WINDOWS
      if (_XtGetPerDisplay(display)->appContext->identify_windows) {
  	int len_nm, len_cl;
***************
*** 378,384 ****
  void XtRealizeWidget (widget)
      Widget		widget;
  {
-     Widget hookobj;
      WIDGET_TO_APPCON(widget);
  
      LOCK_APP(app);
--- 389,394 ----
***************
*** 388,403 ****
      }
      CallChangeManaged(widget);
      RealizeWidget(widget);
-     hookobj = XtHooksOfDisplay(XtDisplayOfObject(widget));
-     if (XtHasCallbacks(hookobj,XtNchangeHook) == XtCallbackHasSome) {
- 	XtChangeHookDataRec call_data;
- 
- 	call_data.type = XtHrealizeWidget;
- 	call_data.widget = widget;
- 	XtCallCallbackList(hookobj, 
- 		((HookObject)hookobj)->hooks.changehook_callbacks, 
- 		(XtPointer)&call_data);
-     }
      UNLOCK_APP(app);
  } /* XtRealizeWidget */
  
--- 398,403 ----
*** -	Fri Jul  7 09:31:23 1995
--- xc/lib/Xt/Intrinsic.h	Fri Jul  7 09:31:23 1995
***************
*** 1,4 ****
! /* $XConsortium: Intrinsic.h,v 1.199 94/04/17 20:14:22 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $XConsortium: Intrinsic.h,v 1.200 95/06/08 23:20:39 gildea Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 751,757 ****
  #endif
  );
  
! #if __STDC__
  externalref XtConvertArgRec const colorConvertArgs[];
  externalref XtConvertArgRec const screenConvertArg[];
  #else
--- 751,757 ----
  #endif
  );
  
! #ifdef __STDC__
  externalref XtConvertArgRec const colorConvertArgs[];
  externalref XtConvertArgRec const screenConvertArg[];
  #else
*** -	Fri Jul  7 09:31:24 1995
--- xc/lib/Xt/Keyboard.c	Fri Jul  7 09:31:24 1995
***************
*** 1,4 ****
! /* $XConsortium: Keyboard.c,v 1.34 94/04/17 20:14:26 kaleb Exp $ */
  
  /********************************************************
  
--- 1,4 ----
! /* $XConsortium: Keyboard.c,v 1.36 95/06/15 20:32:00 converse Exp $ */
  
  /********************************************************
  
***************
*** 69,80 ****
  extern void _XtFillAncestorList();
  extern void _XtSendFocusEvent();
  
! /* FindKeyDestination, ancestor list for Xt focus management */
! static Display	*pseudoTraceDisplay = NULL;
  static Widget	*pseudoTrace = NULL;
  static int	pseudoTraceDepth = 0;
  static int	pseudoTraceMax = 0;
  
  
  static XtServerGrabPtr CheckServerGrabs(event, trace, traceDepth)
      XEvent	*event;
--- 69,91 ----
  extern void _XtFillAncestorList();
  extern void _XtSendFocusEvent();
  
! /* InActiveSubtree cache of the current focus source and its ancestors */
! static Widget	*pathTrace = NULL;
! static int	pathTraceDepth = 0;
! static int	pathTraceMax = 0;
! 
! /* FindKeyDestination cache of focus destination and ancestors up to source */
  static Widget	*pseudoTrace = NULL;
  static int	pseudoTraceDepth = 0;
  static int	pseudoTraceMax = 0;
  
+ void _XtClearAncestorCache(widget)
+     Widget widget;
+ {
+     /* the caller must lock the process lock */
+     if (pathTraceDepth && pathTrace[0] == widget)
+ 	pathTraceDepth = 0;
+ }
  
  static XtServerGrabPtr CheckServerGrabs(event, trace, traceDepth)
      XEvent	*event;
***************
*** 330,337 ****
  			    XtServerGrabPtr	grab;
  
  			    if (!pseudoTraceDepth || 
- 				!(pseudoTraceDisplay ==
- 				 XtDisplay(widget)) ||
  				!(focusWidget == pseudoTrace[0]) ||
  				!(lca == pseudoTrace[pseudoTraceDepth]))
  			      {
--- 341,346 ----
***************
*** 345,351 ****
  						   &pseudoTraceDepth,
  						   focusWidget,
  						   lca);
- 				  pseudoTraceDisplay = XtDisplay(widget);
  				  /* ignore lca */
  				  pseudoTraceDepth--;
  			      }
--- 354,359 ----
***************
*** 456,478 ****
  static ActiveType InActiveSubtree(widget)
      Widget	widget;
  {
-     static Widget	*pathTrace = NULL;
-     static int		pathTraceDepth = 0;
-     static int		pathTraceMax = 0;
-     static Display	*display = NULL;
      Boolean		isTarget;
      ActiveType		retval;
  
      LOCK_PROCESS;
!     if (!pathTraceDepth || 
! 	!(display == XtDisplay(widget)) ||
! 	!(widget == pathTrace[0])) {
  	_XtFillAncestorList(&pathTrace, 
  			    &pathTraceMax, 
  			    &pathTraceDepth,
  			    widget,
  			    NULL);
- 	display = XtDisplay(widget);
      }
      if (widget == _FindFocusWidget(widget, 
  				   pathTrace,
--- 464,479 ----
  static ActiveType InActiveSubtree(widget)
      Widget	widget;
  {
      Boolean		isTarget;
      ActiveType		retval;
  
      LOCK_PROCESS;
!     if (!pathTraceDepth || widget != pathTrace[0]) {
  	_XtFillAncestorList(&pathTrace, 
  			    &pathTraceMax, 
  			    &pathTraceDepth,
  			    widget,
  			    NULL);
      }
      if (widget == _FindFocusWidget(widget, 
  				   pathTrace,
***************
*** 747,753 ****
      Widget widget;
      Widget descendant;
  {
-     Display* dpy;
      XtPerDisplayInput pdi;
      XtPerWidgetInput pwi;
      Widget oldDesc, oldTarget, target, hookobj;
--- 748,753 ----
***************
*** 755,762 ****
  
      LOCK_APP(app);
      LOCK_PROCESS;
!     dpy = XtDisplay (widget);
!     pdi = _XtGetPerDisplayInput(dpy);
      pwi = _XtGetPerWidgetInput(widget, TRUE);
      oldDesc = pwi->focusKid;
  
--- 755,761 ----
  
      LOCK_APP(app);
      LOCK_PROCESS;
!     pdi = _XtGetPerDisplayInput(XtDisplay(widget));
      pwi = _XtGetPerWidgetInput(widget, TRUE);
      oldDesc = pwi->focusKid;
  
***************
*** 775,782 ****
  	
  	if (oldDesc) {
  	    /* invalidate FindKeyDestination's ancestor list */
! 	    if (pseudoTraceDepth && pseudoTraceDisplay == dpy &&
! 		oldTarget == pseudoTrace[0])
  		pseudoTraceDepth = 0;
  
  	    XtRemoveCallback(oldDesc, XtNdestroyCallback, 
--- 774,780 ----
  	
  	if (oldDesc) {
  	    /* invalidate FindKeyDestination's ancestor list */
! 	    if (pseudoTraceDepth && oldTarget == pseudoTrace[0])
  		pseudoTraceDepth = 0;
  
  	    XtRemoveCallback(oldDesc, XtNdestroyCallback, 
*** -	Fri Jul  7 09:31:25 1995
--- xc/lib/Xt/Manage.c	Fri Jul  7 09:31:25 1995
***************
*** 1,4 ****
! /* $XConsortium: Manage.c,v 1.33 94/04/17 20:14:28 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $XConsortium: Manage.c,v 1.35 95/06/29 19:19:29 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 88,93 ****
--- 88,98 ----
  		    ->composite_class.change_managed;
  	UNLOCK_PROCESS;
  	parent_realized = XtIsRealized((Widget)parent);
+     } else {
+         XtAppErrorMsg(XtWidgetToApplicationContext((Widget)parent),
+ 		      "invalidParent",caller_func, XtCXtToolkitError,
+ 		   "Attempt to unmanage a child when parent is not Composite",
+ 		      (String *) NULL, (Cardinal *) NULL);
      }
  
      for (i = 0; i < num_children; i++) {
***************
*** 283,288 ****
--- 288,294 ----
      Widget parent, hookobj;
      XtAppContext app;
  
+     if (num_children == 0) return;
      if (children[0] == NULL) {
  	XtWarningMsg(XtNinvalidChild, XtNxtManageChildren, XtCXtToolkitError,
  		     "null child passed to XtManageChildren",
***************
*** 418,425 ****
  	XtAppWarningMsg(app, "ambiguousParent", XtNxtChangeManagedSet,
  			XtCXtToolkitError, "Not all children have same parent",
  			(String *)NULL, (Cardinal *)NULL);
- 	UNLOCK_APP(app);
- 	return;
      }
      if (! XtIsComposite(parent)) {
  	UNLOCK_APP(app);
--- 424,429 ----
*** -	Fri Jul  7 09:31:26 1995
--- xc/lib/Xt/NextEvent.c	Fri Jul  7 09:31:26 1995
***************
*** 1,4 ****
! /* $XConsortium: NextEvent.c,v 1.145 94/10/10 18:59:29 kaleb Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $XConsortium: NextEvent.c,v 1.145.1.1 95/07/07 13:26:11 kaleb Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 210,215 ****
--- 210,216 ----
      int nfds;
  #else
      struct pollfd* fdlist;
+     struct pollfd* stack;
      int fdlistlen, num_dpys;
  #endif
  } wait_fds_t, *wait_fds_ptr_t;
***************
*** 221,226 ****
--- 222,228 ----
      wait_fds_ptr_t wf;
  {
      int ii;
+     app->rebuild_fdlist = FALSE;
  #ifndef USE_POLL
      wf->nfds = app->fds.nfds;
      if( !ignoreInputs ) {
***************
*** 235,240 ****
--- 237,283 ----
  	    FD_SET (ConnectionNumber(app->list[ii]), &wf->rmask);
  	}
  #else
+ #ifdef POLLRDNORM
+ #define XPOLL_READ POLLIN|POLLRDNORM
+ #else
+ #define XPOLL_READ POLLIN
+ #endif
+ #ifdef POLLWRNORM
+ #if (POLLWRNORM == POLLOUT)
+ #define XPOLL_WRITE POLLOUT
+ #else
+ #define XPOLL_WRITE POLLOUT|POLLWRNORM
+ #endif
+ #else
+ #define XPOLL_WRITE POLLOUT
+ #endif
+ #ifdef POLLRDBAND
+ #define XPOLL_EXCEPT POLLPRI|POLLRDBAND|POLLWRBAND
+ #else
+ #define XPOLL_EXCEPT POLLPRI
+ #endif
+ 
+     if (!ignoreEvents)
+ 	wf->fdlistlen = wf->num_dpys = app->count;
+     else
+ 	wf->fdlistlen = wf->num_dpys = 0;
+ 
+     if (!ignoreInputs && app->input_list != NULL) {
+ 	int ii;
+ 	for (ii = 0; ii < (int) app->input_max; ii++)
+ 	    if (app->input_list[ii] != NULL)
+ 		wf->fdlistlen++;
+     }
+ 
+     if (!wf->fdlist || wf->fdlist == wf->stack) {
+ 	wf->fdlist = (struct pollfd*)
+ 	    XtStackAlloc (sizeof (struct pollfd) * wf->fdlistlen, wf->stack);
+     } else {
+ 	wf->fdlist = (struct pollfd*)
+ 	    XtRealloc ((char*) wf->fdlist, 
+ 		       sizeof (struct pollfd) * wf->fdlistlen);
+     }
+ 
      if (wf->fdlistlen) {
  	struct pollfd* fdlp = wf->fdlist;
  	InputEvent* iep;
***************
*** 252,260 ****
  		    fdlp->events = 0;
  		    for ( ; iep; iep = iep->ie_next) {
  			if (iep->ie_condition & XtInputReadMask)
! 			    fdlp->events |= POLLIN;
  			if (iep->ie_condition & XtInputWriteMask)
! 			    fdlp->events |= POLLOUT;
  		    }
  		    fdlp++;
  		}
--- 295,305 ----
  		    fdlp->events = 0;
  		    for ( ; iep; iep = iep->ie_next) {
  			if (iep->ie_condition & XtInputReadMask)
! 			    fdlp->events |= XPOLL_READ;
  			if (iep->ie_condition & XtInputWriteMask)
! 			    fdlp->events |= XPOLL_WRITE;
! 			if (iep->ie_condition & XtInputExceptMask)
! 			    fdlp->events |= XPOLL_EXCEPT;
  		    }
  		    fdlp++;
  		}
***************
*** 412,434 ****
  	for (ii = wf->num_dpys; ii < wf->fdlistlen; ii++, fdlp++) {
  	    condition = 0;
  	    if (fdlp->revents) {
! 		if (fdlp->revents & (POLLIN|POLLHUP)
  #ifdef XTHREADS
  		    && !(fdlp->revents & POLLNVAL)
  #endif
  		)
  		    condition = XtInputReadMask;
! 		if (fdlp->revents & POLLOUT
! #ifdef XTHREADS
! 		    && !(fdlp->revents & POLLNVAL)
! #endif
! 		)
  		    condition |= XtInputWriteMask;
! 		if (fdlp->revents & POLLERR
! #ifdef XTHREADS
! 		    && !(fdlp->revents & POLLNVAL)
! #endif
! 		)
  		    condition |= XtInputExceptMask;
  	    }
  	    if (condition) {
--- 457,471 ----
  	for (ii = wf->num_dpys; ii < wf->fdlistlen; ii++, fdlp++) {
  	    condition = 0;
  	    if (fdlp->revents) {
! 		if (fdlp->revents & (XPOLL_READ|POLLHUP|POLLERR)
  #ifdef XTHREADS
  		    && !(fdlp->revents & POLLNVAL)
  #endif
  		)
  		    condition = XtInputReadMask;
! 		if (fdlp->revents & XPOLL_WRITE)
  		    condition |= XtInputWriteMask;
! 		if (fdlp->revents & XPOLL_EXCEPT)
  		    condition |= XtInputExceptMask;
  	    }
  	    if (condition) {
***************
*** 524,529 ****
--- 561,568 ----
      int nfds, dpy_no, found_input, dd;
  #ifdef XTHREADS
      Boolean push_thread = TRUE;
+     Boolean pushed_thread = FALSE;
+     int level = 0;
  #endif
  #ifdef USE_POLL
      struct pollfd fdlist[XT_DEFAULT_FDLIST_SIZE];
***************
*** 539,564 ****
      InitTimes (block, howlong, &wt);
  
  #ifdef USE_POLL
!     if (!ignoreEvents)
! 	wf.fdlistlen = wf.num_dpys = app->count;
!     else
! 	wf.fdlistlen = wf.num_dpys = 0;
! 
!     if (!ignoreInputs && app->input_list != NULL) {
! 	int ii;
! 	for (ii = 0; ii < (int) app->input_max; ii++)
! 	    if (app->input_list[ii] != NULL)
! 		wf.fdlistlen++;
!     }
! 
!     wf.fdlist = (struct pollfd*)
! 	XtStackAlloc (sizeof (struct pollfd) * wf.fdlistlen, fdlist);
  #endif
  
!     InitFds (app, ignoreEvents, ignoreInputs, &wf);
  
- WaitLoop:
      while (1) {
  	AdjustTimes (app, block, howlong, ignoreTimers, &wt);
  
  	if (block && app->block_hook_list) {
--- 578,591 ----
      InitTimes (block, howlong, &wt);
  
  #ifdef USE_POLL
!     wf.fdlist = NULL;
!     wf.stack = fdlist;
  #endif
  
!     app->rebuild_fdlist = TRUE;
  
      while (1) {
+ WaitLoop:
  	AdjustTimes (app, block, howlong, ignoreTimers, &wt);
  
  	if (block && app->block_hook_list) {
***************
*** 567,590 ****
  		 hook != NULL; 
  		 hook = hook->next)
  		(*hook->proc) (hook->closure);
  	}
  
  #ifdef XTHREADS /* { */
  	if (drop_lock) {
! 	    int yield = 0;
! 	    if (push_thread) {
! 		PUSH_THREAD(app);
! 		push_thread = FALSE;
! 	    }
! 	    yield = YIELD_APP_LOCK(app);
  	    nfds = IoWait (&wt, &wf); 
! 
! 	    if (!IS_TOP_THREAD(app))
! 		goto WaitLoop;
! 
! 	    RESTORE_APP_LOCK(app, yield);
! 	    POP_THREAD(app);
! 	    push_thread = TRUE;
  	} else
  #endif /* } */
  	nfds = IoWait (&wt, &wf);
--- 594,619 ----
  		 hook != NULL; 
  		 hook = hook->next)
  		(*hook->proc) (hook->closure);
+ 
+ 	    if (!ignoreEvents)
+ 		/* see if the hook(s) generated any protocol */
+ 		for (dd = 0; dd < app->count; dd++)
+ 		    if (XEventsQueued(app->list[dd], QueuedAlready)) {
+ #if USE_POLL
+ 			XtStackFree ((XtPointer) wf.fdlist, fdlist);
+ #endif
+ 			return dd;
+ 		    }
  	}
  
+ 	if (app->rebuild_fdlist)
+ 	    InitFds (app, ignoreEvents, ignoreInputs, &wf);
+ 
  #ifdef XTHREADS /* { */
  	if (drop_lock) {
! 	    YIELD_APP_LOCK(app, &push_thread, &pushed_thread, &level);
  	    nfds = IoWait (&wt, &wf); 
! 	    RESTORE_APP_LOCK(app, level, &pushed_thread);
  	} else
  #endif /* } */
  	nfds = IoWait (&wt, &wf);
***************
*** 985,990 ****
--- 1014,1020 ----
  	    app->fds.nfds++;
  #endif
  	app->input_count++;
+ 	app->rebuild_fdlist = TRUE;
  	UNLOCK_APP(app);
  	return((XtInputId)sptr);
  }
***************
*** 1047,1052 ****
--- 1077,1083 ----
  	    if (app->input_list[source] == NULL)
  		app->fds.nfds--;
  #endif
+ 	    app->rebuild_fdlist = TRUE;
  	} else
  	    XtAppWarningMsg(app, "invalidProcedure","inputHandler",
  			    XtCXtToolkitError, 
*** -	Fri Jul  7 09:31:28 1995
--- xc/lib/Xt/PassivGrab.c	Fri Jul  7 09:31:28 1995
***************
*** 1,4 ****
! /* $XConsortium: PassivGrab.c,v 1.26 94/04/17 20:14:33 converse Exp $ */
  
  /********************************************************
  
--- 1,4 ----
! /* $XConsortium: PassivGrab.c,v 1.27 95/06/15 20:03:09 converse Exp $ */
  
  /********************************************************
  
***************
*** 503,508 ****
--- 503,509 ----
  
      LOCK_PROCESS;
      pdi = _XtGetPerDisplayInput(XtDisplay(w));
+     _XtClearAncestorCache(w);
      UNLOCK_PROCESS;
      
      /* Remove the active grab, if necessary */
*** -	Fri Jul  7 09:31:29 1995
--- xc/lib/Xt/Selection.c	Fri Jul  7 09:31:29 1995
***************
*** 1,4 ****
! /* $XConsortium: Selection.c,v 1.96 94/04/17 20:14:42 kaleb Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $XConsortium: Selection.c,v 1.100 95/06/23 22:36:25 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 669,677 ****
  unsigned long length;
  int format;
  {
- 	req->requestor = window;
  	req->type = targetType;
- 	req->property = property;
  	req->value = value;
  	req->bytelength = BYTELENGTH(length,format);
  	req->format = format;
--- 669,675 ----
***************
*** 695,707 ****
  			(unsigned char *)&req->bytelength, 1);
  }
  
! static Boolean GetConversion(ctx, event, target, property, widget, incremental)
  Select ctx;			/* logical owner */
  XSelectionRequestEvent* event;
  Atom target;
  Atom property;			/* requestor's property */
  Widget widget;			/* physical owner (receives events) */
- Boolean *incremental;
  {
      XtPointer value = NULL;
      unsigned long length;
--- 693,704 ----
  			(unsigned char *)&req->bytelength, 1);
  }
  
! static Boolean GetConversion(ctx, event, target, property, widget)
  Select ctx;			/* logical owner */
  XSelectionRequestEvent* event;
  Atom target;
  Atom property;			/* requestor's property */
  Widget widget;			/* physical owner (receives events) */
  {
      XtPointer value = NULL;
      unsigned long length;
***************
*** 712,717 ****
--- 709,716 ----
  
      req->ctx = ctx;
      req->event = *event;
+     req->property = property;
+     req->requestor = event->requestor;
  
      if (timestamp_target) {
  	value = XtMalloc(sizeof(long));
***************
*** 736,742 ****
  	     StartProtectedSection(ctx->dpy, event->requestor);
  	     PrepareIncremental(req, widget, event->requestor, property,
  				target, targetType, value, length, format);
- 	     *incremental = True;
  	     return(TRUE);
  	}
  	ctx->req = req;
--- 735,740 ----
***************
*** 754,762 ****
  	if (! timestamp_target) {
  	    if (ctx->notify != NULL) {
  		  req->target = target;
- 		  req->property = property;
  		  req->widget = widget;
- 		  req->requestor = event->requestor;
  		  req->allSent = TRUE;
  #ifndef DEBUG_WO_TIMERS
  		  {
--- 752,758 ----
***************
*** 778,788 ****
  	    XtFree((char*)value);
  	    XtFree((char*)req);
  	}
- 	*incremental = FALSE;
      } else {
  	 PrepareIncremental(req, widget, event->requestor, property,
  			    target, targetType, value, length, format);
- 	 *incremental = True;
      }
      return(TRUE);
  }
--- 774,782 ----
***************
*** 796,802 ****
  {
      Select ctx;
      XSelectionEvent ev;
-     Boolean incremental;
      Atom target;
      int count;
      Boolean writeback = FALSE;
--- 790,795 ----
***************
*** 845,852 ****
  	      for (p = (IndirectPair *)value; count; p++, count--) {
  		  EndProtectedSection(ctx->dpy);
  		  if (!GetConversion(ctx, (XSelectionRequestEvent*)event,
! 				     p->target, p->property, widget,
! 				     &incremental)) {
  
  			p->target = None;
  			writeback = TRUE;
--- 838,844 ----
  	      for (p = (IndirectPair *)value; count; p++, count--) {
  		  EndProtectedSection(ctx->dpy);
  		  if (!GetConversion(ctx, (XSelectionRequestEvent*)event,
! 				     p->target, p->property, widget)) {
  
  			p->target = None;
  			writeback = TRUE;
***************
*** 862,868 ****
  	       if (GetConversion(ctx, (XSelectionRequestEvent*)event,
  				 event->xselectionrequest.target,
  				 event->xselectionrequest.property,
! 				 widget, &incremental))
  		   ev.property = event->xselectionrequest.property;
  	       else {
  		   ev.property = None;
--- 854,860 ----
  	       if (GetConversion(ctx, (XSelectionRequestEvent*)event,
  				 event->xselectionrequest.target,
  				 event->xselectionrequest.property,
! 				 widget))
  		   ev.property = event->xselectionrequest.property;
  	       else {
  		   ev.property = None;
***************
*** 1205,1221 ****
          (*info->callbacks[n])(widget, *info->req_closure, &ctx->selection, 
  			      &info->type, value, &length, &info->format);
        } else {
!           if ((BYTELENGTH(length,info->format)+info->offset) 
! 			> info->bytelength) {
! 	      unsigned int bytes;
! 	      bytes = (info->bytelength *= 2);
! 	      info->value = XtRealloc(info->value, bytes);
!           }
!           (void) memmove(&info->value[info->offset], value, 
! 			 (int) BYTELENGTH(length, info->format));
!           info->offset += BYTELENGTH(length, info->format);
!          XFree(value);
!      }
       /* reset timer */
  #ifndef DEBUG_WO_TIMERS
       {
--- 1197,1213 ----
          (*info->callbacks[n])(widget, *info->req_closure, &ctx->selection, 
  			      &info->type, value, &length, &info->format);
        } else {
! 	  int size = BYTELENGTH(length, info->format);
! 	  if (info->offset + size > info->bytelength) {
! 	      /* allocate enough for this and the next increment */
! 	      info->bytelength = info->offset + size * 2;
! 	      info->value = XtRealloc(info->value,
! 				      (Cardinal) info->bytelength);
! 	  }
! 	  (void) memmove(&info->value[info->offset], value, size);
! 	  info->offset += size;
! 	  XFree(value);
!       }
       /* reset timer */
  #ifndef DEBUG_WO_TIMERS
       {
***************
*** 1432,1439 ****
      Atom resulttype;
      unsigned long totallength = 0;
  
          req->event.target = target;
!         req->event.property = property;
  
  	if (ctx->incremental) {
  	   unsigned long size = MAX_SELECTION_INCR(ctx->dpy);
--- 1424,1433 ----
      Atom resulttype;
      unsigned long totallength = 0;
  
+         req->event.type = 0;
          req->event.target = target;
!         req->event.property = req->property = property;
!         req->event.requestor = req->requestor = XtWindow(widget);
  
  	if (ctx->incremental) {
  	   unsigned long size = MAX_SELECTION_INCR(ctx->dpy);
***************
*** 1539,1546 ****
  	RequestRec req;
  	ctx->req = &req;
  	req.ctx = ctx;
- 	req.event.type = 0;
- 	req.event.requestor = XtWindow(widget);
  	req.event.time = time;
  	ctx->ref_count++;
  	DoLocalTransfer(&req, selection, target, widget,
--- 1533,1538 ----
***************
*** 1642,1649 ****
  	RequestRec req;
  	ctx->req = &req;
  	req.ctx = ctx;
- 	req.event.type = 0;
- 	req.event.requestor = XtWindow(widget);
  	req.event.time = time;
  	ctx->ref_count++;
  	for (i = 0, j = 0; count; count--, i++, j++ ) {
--- 1634,1639 ----
***************
*** 1764,1779 ****
  }
  
  
! XSelectionRequestEvent *XtGetSelectionRequest( widget, selection, id )
      Widget widget;
      Atom selection;
      XtRequestId id;
  { 
      Request req = (Request)id;
!     Select ctx;
!     XtAppContext app = XtWidgetToApplicationContext (widget);
  
-     LOCK_APP(app);
      if (   (req == NULL
  	    && ((ctx = FindCtx( XtDisplay(widget), selection )) == NULL
  		|| ctx->req == NULL
--- 1754,1767 ----
  }
  
  
! static Request GetRequestRecord(widget, selection, id)
      Widget widget;
      Atom selection;
      XtRequestId id;
  { 
      Request req = (Request)id;
!     Select ctx = NULL;
  
      if (   (req == NULL
  	    && ((ctx = FindCtx( XtDisplay(widget), selection )) == NULL
  		|| ctx->req == NULL
***************
*** 1786,1810 ****
      {
  	String params = XtName(widget);
  	Cardinal num_params = 1;
! 	XtAppWarningMsg(app,
  			 "notInConvertSelection", "xtGetSelectionRequest",
  			 XtCXtToolkitError,
! 			 "XtGetSelectionRequest called for widget \"%s\" outside of ConvertSelection proc",
  			 &params, &num_params
  		       );
- 	UNLOCK_APP(app);
  	return NULL;
      }
  
      if (req == NULL) {
  	/* non-incremental owner; only one request can be
  	 * outstanding at a time, so it's safe to keep ptr in ctx */
- #ifdef lint
- 	ctx = NULL;
- #endif
  	req = ctx->req;
      }
  
      if (req->event.type == 0) {
  	/* owner is local; construct the remainder of the event */
  	req->event.type = SelectionRequest;
--- 1774,1813 ----
      {
  	String params = XtName(widget);
  	Cardinal num_params = 1;
! 	XtAppWarningMsg(XtWidgetToApplicationContext(widget),
  			 "notInConvertSelection", "xtGetSelectionRequest",
  			 XtCXtToolkitError,
! 			 "XtGetSelectionRequest or XtGetSelectionParameters called for widget \"%s\" outside of ConvertSelection proc",
  			 &params, &num_params
  		       );
  	return NULL;
      }
  
      if (req == NULL) {
  	/* non-incremental owner; only one request can be
  	 * outstanding at a time, so it's safe to keep ptr in ctx */
  	req = ctx->req;
      }
+     return req;
+ }
+ 
+ XSelectionRequestEvent *XtGetSelectionRequest(widget, selection, id)
+     Widget widget;
+     Atom selection;
+     XtRequestId id;
+ { 
+     Request req = (Request)id;
+     WIDGET_TO_APPCON(widget);
  
+     LOCK_APP(app);
+ 
+     req = GetRequestRecord(widget, selection, id);
+ 
+     if (! req) {
+ 	UNLOCK_APP(app);
+ 	return (XSelectionRequestEvent*) NULL;
+     }
+     
      if (req->event.type == 0) {
  	/* owner is local; construct the remainder of the event */
  	req->event.type = SelectionRequest;
***************
*** 1812,1822 ****
  	req->event.send_event = True;
  	req->event.display = XtDisplay(widget);
  	req->event.owner = XtWindow(req->ctx->widget);
-     /*  req->event.requestor = XtWindow(requesting_widget); */
  	req->event.selection = selection;
-     /*  req->event.target = requestors_target; */
-     /*	req->event.property = None; /* %%% what to do about side-effects? */
-     /*  req->event.time = requestors_time; */
      }
      UNLOCK_APP(app);
      return &req->event;
--- 1815,1821 ----
***************
*** 2147,2157 ****
      AddParamInfo(requestor, selection, property);
    }
  
-   StartProtectedSection(dpy, window);
    XChangeProperty(dpy, window, property,
  		  type, format, PropModeReplace,
  		  (unsigned char *) value, length);
-   EndProtectedSection(dpy);
  }
  
  /* Retrieves data passed in a parameter. Data for this is stored
--- 2146,2154 ----
***************
*** 2166,2335 ****
      unsigned long* length_return;
      int* format_return;
  {
!   Display *dpy = XtDisplay(owner);
!   XSelectionRequestEvent *xselevent = 
!     XtGetSelectionRequest(owner, selection, request_id);
!   unsigned long max = XMaxRequestSize(dpy);
!   unsigned long dummy;
! 
!   if (xselevent->property != None) {
!     StartProtectedSection(dpy, XtWindow(owner));
!     XGetWindowProperty(dpy, xselevent->requestor,
! 		       xselevent->property,
! 		       0, max, False, AnyPropertyType,
! 		       type_return, format_return,
! 		       length_return, &dummy, 
! 		       (unsigned char**) value_return);
!     EndProtectedSection(dpy);
!   } else {
!     value_return = NULL;
!     length_return = 0;
!     format_return = 0;
!     type_return = None;
!   }
! }
  
! /* Temporary storage for parameter information is kept off the
!    requestor widget in an XContext.  This is kept as a list to
!    deal with multiple selections building requests.  Perhaps the
!    context should be deleted when its list is empty?  
! 
!    For now there is a destroyCallback set to free the context 
!    block when the widget is destroyed. */
! static void RemoveParmContext(w, ignored, client_data)
!      Widget w;
!      XtPointer ignored;
!      XtPointer client_data;
! {
!   ParamInfo pinfo = (ParamInfo) client_data;
  
!   LOCK_PROCESS;
!   XtFree((char*) pinfo->paramlist);
!   XtFree((char*) pinfo);
  
!   (void)XDeleteContext(XtDisplay(w), XtWindow(w), paramPropertyContext);
!   UNLOCK_PROCESS;
  }
  
  static void AddParamInfo(w, selection, param_atom)
!      Widget w;
!      Atom selection;
!      Atom param_atom;
  {
!   ParamInfo pinfo;
!   Param cparm;
!   Display *dpy = XtDisplay(w);
!   Window window = XtWindow(w);
! 
!   LOCK_PROCESS;
!   if (paramPropertyContext == 0) paramPropertyContext = XUniqueContext();
! 
!   pinfo = NULL;
!   (void) XFindContext(dpy, window, paramPropertyContext,
! 		      (XPointer *)&pinfo);
! 
!   if (pinfo == NULL) {
!     pinfo = (ParamInfo) XtMalloc(sizeof(ParamInfoRec));
!     pinfo->count = 0;
!     pinfo->paramlist = NULL;
!     XtAddCallback(w, XtNdestroyCallback, RemoveParmContext, pinfo);
!   }
  
!   pinfo->count++;
!   pinfo->paramlist = (Param) XtRealloc((char*) pinfo->paramlist, 
! 					 pinfo->count * sizeof(ParamRec));
!   cparm = &pinfo->paramlist[pinfo->count - 1];
!   cparm->selection = selection;
!   cparm->param = param_atom;
  
!   (void)XSaveContext(dpy, window, paramPropertyContext,
! 		     (char *)pinfo);
!   UNLOCK_PROCESS;
  }
  
  static void RemoveParamInfo(w, selection)
!      Widget w;
!      Atom selection;
  {
!   ParamInfo pinfo;
!   Param cparm;
!   Display *dpy = XtDisplay(w);
!   Window window = XtWindow(w);
! 
!   LOCK_PROCESS;
!   if (paramPropertyContext == 0) paramPropertyContext = XUniqueContext();
  
!   pinfo = NULL;
!   (void) XFindContext(dpy, window, paramPropertyContext,
! 		      (XPointer *)&pinfo);
! 
!   if (pinfo != NULL) {
!     int i = 0;
!     Boolean modified = False;
! 
!     while(i < pinfo->count) {
!       if (pinfo->paramlist[i].selection == selection) {
! 	pinfo->count--;
! 	modified = True;
! 	break;
!       }
!       i++;
!     }
! 
!     /* Shift the remaining list elements back to fill in the removed
!        item.  If the removed item is the last,  pinfo->count will
!        be equal to i and this code won't execute as we decremented
!        count.  Same for the case where the particular parameter
!        wasn't found. */
!     if (modified) {
!       while(i < pinfo->count) {
! 	pinfo->paramlist[i].selection = pinfo->paramlist[i + 1].selection;
! 	pinfo->paramlist[i].param = pinfo->paramlist[i + 1].param;
! 	i++;
!       }
! 
!       /* Only need to save if we've modified */
!       (void)XSaveContext(dpy, window, paramPropertyContext,
! 			 (char *)pinfo);
      }
!   }
!   UNLOCK_PROCESS;
  }
  
  static Atom GetParamInfo(w, selection)
!      Widget w;
!      Atom selection;
  {
!   ParamInfo pinfo;
!   Param cparm;
!   Display *dpy = XtDisplay(w);
!   Window window = XtWindow(w);
!   Boolean found = False;
!   Atom retval;
!   int i = 0;
! 
!   LOCK_PROCESS;
!   if (paramPropertyContext == 0) paramPropertyContext = XUniqueContext();
  
!   pinfo = NULL;
!   (void) XFindContext(dpy, window, paramPropertyContext,
! 		      (XPointer *)&pinfo);
! 
!   if (pinfo != NULL) {
!     while(i < pinfo->count) {
!       if (pinfo->paramlist[i].selection == selection) {
! 	pinfo->count--;
! 	found = True;
! 	break;
!       }
!       i++;
      }
!   }
! 
!   if (found)
!     retval = pinfo->paramlist[i].param;
!   else
!     retval = None;
!   UNLOCK_PROCESS;
!   return retval;
  }
--- 2163,2302 ----
      unsigned long* length_return;
      int* format_return;
  {
!     Request req;
!     Display *dpy = XtDisplay(owner);
!     WIDGET_TO_APPCON(owner);
! 
!     *value_return = NULL;
!     *length_return = *format_return = 0;
!     *type_return = None;
  
!     LOCK_APP(app);
  
!     req = GetRequestRecord(owner, selection, request_id);
  
!     if (req && req->property) {
! 	unsigned long bytes_after;	/* unused */
! 	StartProtectedSection(dpy, req->requestor);
! 	XGetWindowProperty(dpy, req->requestor, req->property, 0L, 10000000,
! 			   False, AnyPropertyType, type_return, format_return,
! 			   length_return, &bytes_after, 
! 			   (unsigned char**) value_return);
! 	EndProtectedSection(dpy);
! #ifdef XT_COPY_SELECTION
! 	if (*value_return) {
! 	    int size = BYTELENGTH(*length_return, *format_return) + 1;
! 	    char *tmp = XtMalloc((Cardinal) size);
! 	    (void) memmove(tmp, *value_return, size);
! 	    XFree(*value_return);
! 	    *value_return = tmp;
! 	}
! #endif
!     }
!     UNLOCK_APP(app);
  }
  
+ /*  Parameters are temporarily stashed in an XContext.  A list is used because
+  *  there may be more than one selection request in progress.  The context
+  *  data is deleted when the list is empty.  In the future, the parameter
+  *  context could be merged with other contexts used during selections.
+  */
+ 
  static void AddParamInfo(w, selection, param_atom)
!     Widget w;
!     Atom selection;
!     Atom param_atom;
  {
!     int n;
!     Param p;
!     ParamInfo pinfo;
  
!     LOCK_PROCESS;
!     if (paramPropertyContext == 0)
! 	paramPropertyContext = XUniqueContext();
  
!     if (XFindContext(XtDisplay(w), XtWindow(w), paramPropertyContext,
! 		     (XPointer *) &pinfo)) {
! 	pinfo = (ParamInfo) XtMalloc(sizeof(ParamInfoRec));
! 	pinfo->count = 1;
! 	pinfo->paramlist = XtNew(ParamRec);
! 	p = pinfo->paramlist;
! 	(void) XSaveContext(XtDisplay(w), XtWindow(w), paramPropertyContext,
! 			    (char *)pinfo);
!     }
!     else {
! 	for (n = pinfo->count, p = pinfo->paramlist; n; n--, p++) {
! 	    if (p->selection == None || p->selection == selection)
! 		break;
! 	}
! 	if (n == 0) {
! 	    pinfo->count++;
! 	    pinfo->paramlist = (Param)
! 		XtRealloc((char*) pinfo->paramlist,
! 			  pinfo->count * sizeof(ParamRec));
! 	    p = &pinfo->paramlist[pinfo->count - 1];
! 	    (void) XSaveContext(XtDisplay(w), XtWindow(w),
! 				paramPropertyContext, (char *)pinfo);
! 	}
!     }
!     p->selection = selection;
!     p->param = param_atom;
!     UNLOCK_PROCESS;
  }
  
  static void RemoveParamInfo(w, selection)
!     Widget w;
!     Atom selection;
  {
!     int n;
!     Param p;
!     ParamInfo pinfo;
!     Boolean retain = False;
  
!     LOCK_PROCESS;
!     if (paramPropertyContext
! 	&& (XFindContext(XtDisplay(w), XtWindow(w), paramPropertyContext,
! 			 (XPointer *) &pinfo) == 0)) {
! 
! 	/* Find and invalidate the parameter data. */
! 	for (n = pinfo->count, p = pinfo->paramlist; n; n--, p++) {
! 	    if (p->selection != None) {
! 		if (p->selection == selection)
! 		    p->selection = None;
! 		else
! 		    retain = True;
! 	    }
! 	}
! 	/* If there's no valid data remaining, release the context entry. */
! 	if (! retain) {
! 	    XtFree((char*) pinfo->paramlist);
! 	    XtFree((char*) pinfo);
! 	    XDeleteContext(XtDisplay(w), XtWindow(w), paramPropertyContext);
! 	}
      }
!     UNLOCK_PROCESS;
  }
  
  static Atom GetParamInfo(w, selection)
!     Widget w;
!     Atom selection;
  {
!     int n;
!     Param p;
!     ParamInfo pinfo;
!     Atom atom = None;
  
!     LOCK_PROCESS;
!     if (paramPropertyContext
! 	&& (XFindContext(XtDisplay(w), XtWindow(w), paramPropertyContext,
! 			 (XPointer *) &pinfo) == 0)) {
! 
! 	for (n = pinfo->count, p = pinfo->paramlist; n; n--, p++)
! 	    if (p->selection == selection) {
! 		atom = p->param;
! 		break;
! 	    }
      }
!     UNLOCK_PROCESS;
!     return atom;
  }
*** -	Fri Jul  7 09:31:31 1995
--- xc/lib/Xt/Shell.c	Fri Jul  7 09:31:31 1995
***************
*** 1,4 ****
! /* $XConsortium: Shell.c,v 1.168 95/01/06 21:14:23 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts
--- 1,4 ----
! /* $XConsortium: Shell.c,v 1.169 95/06/22 22:31:11 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts
***************
*** 1045,1050 ****
--- 1045,1051 ----
  	    w->wm.wm_hints.initial_state = IconicState;
  }
  
+ static String *NewArgv();
  static String *NewStringArray();
  static void FreeStringArray();
  
***************
*** 1056,1063 ****
  {
      ApplicationShellWidget w = (ApplicationShellWidget)new;
  
!     if (w->application.argv) w->application.argv =
! 	NewStringArray(w->application.argv);
  }
  
  #define XtSaveInactive 0
--- 1057,1065 ----
  {
      ApplicationShellWidget w = (ApplicationShellWidget)new;
  
!     if (w->application.argc > 0)
! 	w->application.argv = NewArgv(w->application.argc,
! 				      w->application.argv);
  }
  
  #define XtSaveInactive 0
***************
*** 1664,1670 ****
      Widget wid;
  {
      ApplicationShellWidget w = (ApplicationShellWidget) wid;
!     FreeStringArray(w->application.argv);
  }
  
  static void SessionDestroy(wid)
--- 1666,1673 ----
      Widget wid;
  {
      ApplicationShellWidget w = (ApplicationShellWidget) wid;
!     if (w->application.argc > 0)
! 	FreeStringArray(w->application.argv);
  }
  
  static void SessionDestroy(wid)
***************
*** 2364,2369 ****
--- 2367,2403 ----
      return False;
  }
  
+ static String * NewArgv(count, str)
+     int count;
+     String *str;  /* do not assume it's terminated by a NULL element */
+ {
+     Cardinal nbytes = 0;
+     Cardinal num = 0;
+     String *newarray, *new;
+     String *strarray = str;
+     String sptr;
+ 
+     if (count <= 0 || !str) return NULL;
+ 
+     for (num = count; num--; str++) {
+ 	nbytes += strlen(*str);
+ 	nbytes++;
+     }
+     num = (count+1) * sizeof(String);
+     new = newarray = (String *) XtMalloc(num + nbytes);
+     sptr = ((char *) new) + num;
+ 
+     for (str = strarray; count--; str++) {
+ 	*new = sptr;
+ 	strcpy(*new, *str);
+ 	new++;
+ 	sptr = strchr(sptr, '\0');
+ 	sptr++;
+     }
+     *new = NULL;
+     return newarray;
+ }
+ 
  
  /*ARGSUSED*/
  static Boolean ApplicationSetValues(current, request, new, args, num_args)
***************
*** 2374,2386 ****
      ApplicationShellWidget nw = (ApplicationShellWidget) new;
      ApplicationShellWidget cw = (ApplicationShellWidget) current;
  
!     if (cw->application.argv != nw->application.argv) {
! 	nw->application.argv = NewStringArray(nw->application.argv);
! 	FreeStringArray(cw->application.argv);
!     }
  
-     if (cw->application.argv != nw->application.argv ||
- 	cw->application.argc != nw->application.argc) {
  	if (XtIsRealized(new) && !nw->shell.override_redirect) {
  	    if (nw->application.argc >= 0 && nw->application.argv)
  		XSetCommand(XtDisplay(new), XtWindow(new),
--- 2408,2422 ----
      ApplicationShellWidget nw = (ApplicationShellWidget) new;
      ApplicationShellWidget cw = (ApplicationShellWidget) current;
  
!     if (cw->application.argc != nw->application.argc ||
! 	cw->application.argv != nw->application.argv) {
! 
! 	if (nw->application.argc > 0)
! 	    nw->application.argv = NewArgv(nw->application.argc,
! 					   nw->application.argv);
! 	if (cw->application.argc > 0)
! 	    FreeStringArray(cw->application.argv);
  
  	if (XtIsRealized(new) && !nw->shell.override_redirect) {
  	    if (nw->application.argc >= 0 && nw->application.argv)
  		XSetCommand(XtDisplay(new), XtWindow(new),
*** -	Fri Jul  7 09:31:32 1995
--- xc/lib/Xt/TMaction.c	Fri Jul  7 09:31:32 1995
***************
*** 1,4 ****
! /* $XConsortium: TMaction.c,v 1.25 94/04/17 20:14:50 kaleb Exp $ */
  /*LINTLIBRARY*/
  
  /***********************************************************
--- 1,4 ----
! /* $XConsortium: TMaction.c,v 1.27 95/06/28 16:03:40 converse Exp $ */
  /*LINTLIBRARY*/
  
  /***********************************************************
***************
*** 68,74 ****
  #include "IntrinsicI.h"
  #include "StringDefs.h"
  
! #if __STDC__ && !defined(NORCONST)
  #define RConst const
  #else
  #define RConst /**/
--- 68,74 ----
  #include "IntrinsicI.h"
  #include "StringDefs.h"
  
! #if defined(__STDC__) && !defined(NORCONST)
  #define RConst const
  #else
  #define RConst /**/
***************
*** 838,844 ****
  		"invalidPopup","unsupportedOperation",XtCXtToolkitError,
  "Pop-up menu creation is only supported on ButtonPress, KeyPress or EnterNotify events.",
                    (String *)NULL, (Cardinal *)NULL);
! 	spring_loaded = False;
      }
  
      popup_shell = _XtFindPopup(widget, params[0]);
--- 838,845 ----
  		"invalidPopup","unsupportedOperation",XtCXtToolkitError,
  "Pop-up menu creation is only supported on ButtonPress, KeyPress or EnterNotify events.",
                    (String *)NULL, (Cardinal *)NULL);
! 	UNLOCK_APP(app);
! 	return;
      }
  
      popup_shell = _XtFindPopup(widget, params[0]);
*** -	Fri Jul  7 09:31:33 1995
--- xc/lib/Xt/TMkey.c	Fri Jul  7 09:31:33 1995
***************
*** 1,4 ****
! /* $XConsortium: TMkey.c,v 1.27 94/04/17 20:14:52 rws Exp $ */
  /*LINTLIBRARY*/
  
  /***********************************************************
--- 1,4 ----
! /* $XConsortium: TMkey.c,v 1.29 95/06/22 15:39:05 kaleb Exp $ */
  /*LINTLIBRARY*/
  
  /***********************************************************
***************
*** 88,95 ****
  
  #define FM(i) i >> (8 - TMKEYCACHELOG2)
  static Const unsigned char modmix[256] = {
! FM(0x00), FM(0x80), FM(0x40), FM(0xc0), FM(0x20), FM(0xa0), FM(0x60), FM(0xe0),
! FM(0x10), FM(0x90), FM(0x50), FM(0xd0), FM(0x30), FM(0xb0), FM(0x70), FM(0xf0),
  FM(0x08), FM(0x88), FM(0x48), FM(0xc8), FM(0x28), FM(0xa8), FM(0x68), FM(0xe8),
  FM(0x18), FM(0x98), FM(0x58), FM(0xd8), FM(0x38), FM(0xb8), FM(0x78), FM(0xf8),
  FM(0x04), FM(0x84), FM(0x44), FM(0xc4), FM(0x24), FM(0xa4), FM(0x64), FM(0xe4),
--- 88,111 ----
  
  #define FM(i) i >> (8 - TMKEYCACHELOG2)
  static Const unsigned char modmix[256] = {
! FM(0x0f), FM(0x8f), FM(0x4f), FM(0xcf), FM(0x2f), FM(0xaf), FM(0x6f), FM(0xef),
! FM(0x1f), FM(0x9f), FM(0x5f), FM(0xdf), FM(0x3f), FM(0xbf), FM(0x7f), FM(0xff),
! FM(0x07), FM(0x87), FM(0x47), FM(0xc7), FM(0x27), FM(0xa7), FM(0x67), FM(0xe7),
! FM(0x17), FM(0x97), FM(0x57), FM(0xd7), FM(0x37), FM(0xb7), FM(0x77), FM(0xf7),
! FM(0x0b), FM(0x8b), FM(0x4b), FM(0xcb), FM(0x2b), FM(0xab), FM(0x6b), FM(0xeb),
! FM(0x1b), FM(0x9b), FM(0x5b), FM(0xdb), FM(0x3b), FM(0xbb), FM(0x7b), FM(0xfb),
! FM(0x03), FM(0x83), FM(0x43), FM(0xc3), FM(0x23), FM(0xa3), FM(0x63), FM(0xe3),
! FM(0x13), FM(0x93), FM(0x53), FM(0xd3), FM(0x33), FM(0xb3), FM(0x73), FM(0xf3),
! FM(0x0d), FM(0x8d), FM(0x4d), FM(0xcd), FM(0x2d), FM(0xad), FM(0x6d), FM(0xed),
! FM(0x1d), FM(0x9d), FM(0x5d), FM(0xdd), FM(0x3d), FM(0xbd), FM(0x7d), FM(0xfd),
! FM(0x05), FM(0x85), FM(0x45), FM(0xc5), FM(0x25), FM(0xa5), FM(0x65), FM(0xe5),
! FM(0x15), FM(0x95), FM(0x55), FM(0xd5), FM(0x35), FM(0xb5), FM(0x75), FM(0xf5),
! FM(0x09), FM(0x89), FM(0x49), FM(0xc9), FM(0x29), FM(0xa9), FM(0x69), FM(0xe9),
! FM(0x19), FM(0x99), FM(0x59), FM(0xd9), FM(0x39), FM(0xb9), FM(0x79), FM(0xf9),
! FM(0x01), FM(0x81), FM(0x41), FM(0xc1), FM(0x21), FM(0xa1), FM(0x61), FM(0xe1),
! FM(0x11), FM(0x91), FM(0x51), FM(0xd1), FM(0x31), FM(0xb1), FM(0x71), FM(0xf1),
! FM(0x00), FM(0x8e), FM(0x4e), FM(0xce), FM(0x2e), FM(0xae), FM(0x6e), FM(0xee),
! FM(0x1e), FM(0x9e), FM(0x5e), FM(0xde), FM(0x3e), FM(0xbe), FM(0x7e), FM(0xfe),
  FM(0x08), FM(0x88), FM(0x48), FM(0xc8), FM(0x28), FM(0xa8), FM(0x68), FM(0xe8),
  FM(0x18), FM(0x98), FM(0x58), FM(0xd8), FM(0x38), FM(0xb8), FM(0x78), FM(0xf8),
  FM(0x04), FM(0x84), FM(0x44), FM(0xc4), FM(0x24), FM(0xa4), FM(0x64), FM(0xe4),
***************
*** 103,125 ****
  FM(0x06), FM(0x86), FM(0x46), FM(0xc6), FM(0x26), FM(0xa6), FM(0x66), FM(0xe6),
  FM(0x16), FM(0x96), FM(0x56), FM(0xd6), FM(0x36), FM(0xb6), FM(0x76), FM(0xf6),
  FM(0x0e), FM(0x8e), FM(0x4e), FM(0xce), FM(0x2e), FM(0xae), FM(0x6e), FM(0xee),
! FM(0x1e), FM(0x9e), FM(0x5e), FM(0xde), FM(0x3e), FM(0xbe), FM(0x7e), FM(0xfe),
! FM(0x01), FM(0x81), FM(0x41), FM(0xc1), FM(0x21), FM(0xa1), FM(0x61), FM(0xe1),
! FM(0x11), FM(0x91), FM(0x51), FM(0xd1), FM(0x31), FM(0xb1), FM(0x71), FM(0xf1),
! FM(0x09), FM(0x89), FM(0x49), FM(0xc9), FM(0x29), FM(0xa9), FM(0x69), FM(0xe9),
! FM(0x19), FM(0x99), FM(0x59), FM(0xd9), FM(0x39), FM(0xb9), FM(0x79), FM(0xf9),
! FM(0x05), FM(0x85), FM(0x45), FM(0xc5), FM(0x25), FM(0xa5), FM(0x65), FM(0xe5),
! FM(0x15), FM(0x95), FM(0x55), FM(0xd5), FM(0x35), FM(0xb5), FM(0x75), FM(0xf5),
! FM(0x0d), FM(0x8d), FM(0x4d), FM(0xcd), FM(0x2d), FM(0xad), FM(0x6d), FM(0xed),
! FM(0x1d), FM(0x9d), FM(0x5d), FM(0xdd), FM(0x3d), FM(0xbd), FM(0x7d), FM(0xfd),
! FM(0x03), FM(0x83), FM(0x43), FM(0xc3), FM(0x23), FM(0xa3), FM(0x63), FM(0xe3),
! FM(0x13), FM(0x93), FM(0x53), FM(0xd3), FM(0x33), FM(0xb3), FM(0x73), FM(0xf3),
! FM(0x0b), FM(0x8b), FM(0x4b), FM(0xcb), FM(0x2b), FM(0xab), FM(0x6b), FM(0xeb),
! FM(0x1b), FM(0x9b), FM(0x5b), FM(0xdb), FM(0x3b), FM(0xbb), FM(0x7b), FM(0xfb),
! FM(0x07), FM(0x87), FM(0x47), FM(0xc7), FM(0x27), FM(0xa7), FM(0x67), FM(0xe7),
! FM(0x17), FM(0x97), FM(0x57), FM(0xd7), FM(0x37), FM(0xb7), FM(0x77), FM(0xf7),
! FM(0x0f), FM(0x8f), FM(0x4f), FM(0xcf), FM(0x2f), FM(0xaf), FM(0x6f), FM(0xef),
! FM(0x1f), FM(0x9f), FM(0x5f), FM(0xdf), FM(0x3f), FM(0xbf), FM(0x7f), FM(0xff)
  };
  #undef FM
  
--- 119,125 ----
  FM(0x06), FM(0x86), FM(0x46), FM(0xc6), FM(0x26), FM(0xa6), FM(0x66), FM(0xe6),
  FM(0x16), FM(0x96), FM(0x56), FM(0xd6), FM(0x36), FM(0xb6), FM(0x76), FM(0xf6),
  FM(0x0e), FM(0x8e), FM(0x4e), FM(0xce), FM(0x2e), FM(0xae), FM(0x6e), FM(0xee),
! FM(0x1e), FM(0x9e), FM(0x5e), FM(0xde), FM(0x3e), FM(0xbe), FM(0x7e), FM(0xfe)
  };
  #undef FM
  
***************
*** 228,234 ****
      Modifiers modifiers_return;
      KeySym keysym_return;
      Modifiers useful_mods;
!     int i;
      Modifiers computed = 0;
      Modifiers computedMask = 0;
      Boolean resolved = TRUE;
--- 228,234 ----
      Modifiers modifiers_return;
      KeySym keysym_return;
      Modifiers useful_mods;
!     int i, num_modbits;
      Modifiers computed = 0;
      Modifiers computedMask = 0;
      Boolean resolved = TRUE;
***************
*** 261,281 ****
  	}
          useful_mods = ~computedMask & modifiers_return;
          if (useful_mods == 0) return FALSE;
! 	for (least_mod = 1; (least_mod & useful_mods)==0; least_mod <<= 1){/*EMPTY*/};
!         for (i = modifiers_return; i >= least_mod; i--)
! 	  /* all useful combinations of 8 modifier bits */
! 	  if (useful_mods & i) {
! 	      TRANSLATE(tm_context, pd, dpy, eventSeq->event.eventCode,
! 			(Modifiers)i, modifiers_return, keysym_return);
! 	      if (keysym_return  ==
! 		  (typeMatch->eventCode & typeMatch->eventCodeMask)) {
! 		  tm_context->event = eventSeq->xev;
! 		  tm_context->serial = eventSeq->xev->xany.serial;
! 		  tm_context->keysym = keysym_return;
! 		  tm_context->modifiers = (Modifiers)i;
! 		  return TRUE;
! 	      }
! 	  }
      }
      return FALSE;
  }
--- 261,326 ----
  	}
          useful_mods = ~computedMask & modifiers_return;
          if (useful_mods == 0) return FALSE;
! 
! 	for (num_modbits = 0, least_mod = useful_mods;
! 	     least_mod != 0; least_mod >>= 1)
! 	    if (least_mod & 1) num_modbits++;
! 
! 	switch (num_modbits) {
! 	case 1:
! 	case 8:
! 	    /* 
! 	     * one modbit should never happen, in fact the implementation
! 	     * of XtTranslateKey and XmTranslateKey guarantee that it
! 	     * won't, so don't care if the loop is set up for the case 
! 	     * when one modbit is set.
! 	     * The performance implications of all eight modbits being
! 	     * set is horrendous. This isn't a problem with Xt/Xaw based
! 	     * applications. We can only hope that Motif's virtual
! 	     * modifiers won't result in all eight modbits being set.
! 	     */
! 	    for (i = useful_mods; i > 0; i--) {
! 		TRANSLATE(tm_context, pd, dpy, eventSeq->event.eventCode,
! 			  (Modifiers)i, modifiers_return, keysym_return);
! 		if (keysym_return ==
! 		    (typeMatch->eventCode & typeMatch->eventCodeMask)) {
! 		    tm_context->event = eventSeq->xev;
! 		    tm_context->serial = eventSeq->xev->xany.serial;
! 		    tm_context->keysym = keysym_return;
! 		    tm_context->modifiers = (Modifiers)i;
! 		    return TRUE;
! 		}
! 	    }
! 	    break;
! 	default: /* (2..7) */
! 	    {
! 	    /*
! 	     * Only translate using combinations of the useful modifiers.
! 	     * to minimize the chance of invalidating the cache.
! 	     */
! 		static char pows[] = { 0, 1, 3, 7, 15, 31, 63, 127 };
! 		Modifiers tmod, mod_masks[8];
! 		int j;
! 		for (tmod = 1, i = 0; tmod <= (Mod5Mask<<1); tmod <<= 1)
! 		    if (tmod & useful_mods) mod_masks[i++] = tmod;
! 		for (j = (int) pows[num_modbits]; j > 0; j--) {
! 		    tmod = 0;
! 		    for (i = 0; i < num_modbits; i++)
! 			if (j & (1<<i)) tmod |= mod_masks[i];
! 		    TRANSLATE(tm_context, pd, dpy, eventSeq->event.eventCode,
! 			      tmod, modifiers_return, keysym_return);
! 		    if (keysym_return ==
! 			(typeMatch->eventCode & typeMatch->eventCodeMask)) {
! 			tm_context->event = eventSeq->xev;
! 			tm_context->serial = eventSeq->xev->xany.serial;
! 			tm_context->keysym = keysym_return;
! 			tm_context->modifiers = (Modifiers)i;
! 			return TRUE;
! 		    }
! 		}
! 	    }
! 	    break;
! 	} /* switch (num_modbits) */
      }
      return FALSE;
  }
*** -	Fri Jul  7 09:31:35 1995
--- xc/lib/Xt/TMstate.c	Fri Jul  7 09:31:34 1995
***************
*** 1,4 ****
! /* $XConsortium: TMstate.c,v 1.175 94/09/16 19:17:43 kaleb Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $XConsortium: TMstate.c,v 1.176 95/06/22 17:19:25 kaleb Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 2040,2046 ****
  	    XSelectInput(XtDisplay(dest), XtWindow(dest), 
  			 XtBuildEventMask(dest));
      }
!     XtStackFree((char *)newBindings, (char *)stackBindings);
      return(newTable != NULL);
  }
  
--- 2040,2046 ----
  	    XSelectInput(XtDisplay(dest), XtWindow(dest), 
  			 XtBuildEventMask(dest));
      }
!     XtStackFree((XtPointer)newBindings, (XtPointer)stackBindings);
      return(newTable != NULL);
  }
  
*** -	Fri Jul  7 09:31:36 1995
--- xc/lib/Xt/ThreadsI.h	Fri Jul  7 09:31:35 1995
***************
*** 1,4 ****
! /* $XConsortium: ThreadsI.h,v 1.9 94/04/17 20:15:00 kaleb Exp $ */
  
  /************************************************************
  Copyright 1993 by Sun Microsystems, Inc. Mountain View, CA.
--- 1,4 ----
! /* $XConsortium: ThreadsI.h,v 1.10 95/06/06 21:00:38 kaleb Exp $ */
  
  /************************************************************
  Copyright 1993 by Sun Microsystems, Inc. Mountain View, CA.
***************
*** 64,85 ****
  #endif
  );
  
! typedef int (*ThreadAppYieldLockProc)(
  #if NeedFunctionPrototypes
!     XtAppContext /* app */
  #endif
  );
  
  typedef void (*ThreadAppRestoreLockProc)(
  #if NeedFunctionPrototypes
      XtAppContext /* app */,
!     int /* recursion */
! #endif
! );
! 
! typedef Boolean (*ThreadAppTopProc)(
! #if NeedFunctionPrototypes
!     XtAppContext /* app */
  #endif
  );
  
--- 64,83 ----
  #endif
  );
  
! typedef void (*ThreadAppYieldLockProc)(
  #if NeedFunctionPrototypes
!     XtAppContext, /* app */
!     Boolean*, /* push_thread */
!     Boolean*, /* pushed_thread */
!     int* /* level */
  #endif
  );
  
  typedef void (*ThreadAppRestoreLockProc)(
  #if NeedFunctionPrototypes
      XtAppContext /* app */,
!     int, /* level */
!     Boolean* /* pushed_thread */
  #endif
  );
  
***************
*** 102,120 ****
  );
  
  #define INIT_APP_LOCK(app) if(_XtInitAppLock) (*_XtInitAppLock)(app)
  
  #define LOCK_PROCESS if(_XtProcessLock)(*_XtProcessLock)()
  #define UNLOCK_PROCESS if(_XtProcessUnlock)(*_XtProcessUnlock)()
  #define LOCK_APP(app) if(app && app->lock)(*app->lock)(app)
  #define UNLOCK_APP(app) if(app && app->unlock)(*app->unlock)(app)
  
! #define YIELD_APP_LOCK(app) (app && app->yield_lock ? (*app->yield_lock)(app): -1)
! #define RESTORE_APP_LOCK(app,r) if(app && app->restore_lock)(*app->restore_lock)(app,r)
! #define FREE_APP_LOCK(app) if(app && app->free_lock)(*app->free_lock)(app)
! 
! #define PUSH_THREAD(app) if(app && app->push_thread)(*app->push_thread)(app) 
! #define POP_THREAD(app) if(app && app->pop_thread)(*app->pop_thread)(app) 
! #define IS_TOP_THREAD(app) (app && app->is_top_thread ? (*app->is_top_thread)(app): TRUE) 
  
  #define WIDGET_TO_APPCON(w) \
      XtAppContext app = (w && _XtProcessLock ? \
--- 100,116 ----
  );
  
  #define INIT_APP_LOCK(app) if(_XtInitAppLock) (*_XtInitAppLock)(app)
+ #define FREE_APP_LOCK(app) if(app && app->free_lock)(*app->free_lock)(app)
  
  #define LOCK_PROCESS if(_XtProcessLock)(*_XtProcessLock)()
  #define UNLOCK_PROCESS if(_XtProcessUnlock)(*_XtProcessUnlock)()
  #define LOCK_APP(app) if(app && app->lock)(*app->lock)(app)
  #define UNLOCK_APP(app) if(app && app->unlock)(*app->unlock)(app)
  
! #define YIELD_APP_LOCK(app,push,pushed,level)\
! 	 if(app && app->yield_lock) (*app->yield_lock)(app,push,pushed,level)
! #define RESTORE_APP_LOCK(app,level,pushed)\
! 	 if(app && app->restore_lock) (*app->restore_lock)(app,level,pushed)
  
  #define WIDGET_TO_APPCON(w) \
      XtAppContext app = (w && _XtProcessLock ? \
***************
*** 132,139 ****
  
  #define INIT_APP_LOCK(app)
  #define FREE_APP_LOCK(app)
- 
- #define IS_TOP_THREAD(app)
  
  #define WIDGET_TO_APPCON(w)
  #define DPY_TO_APPCON(d)
--- 128,133 ----
*** -	Fri Jul  7 09:31:36 1995
--- xc/lib/Xt/Threads.c	Fri Jul  7 09:31:36 1995
***************
*** 1,4 ****
! /* $XConsortium: Threads.c,v 1.15 94/04/17 20:14:59 kaleb Exp $ */
  
  /************************************************************
  Copyright 1993 by Sun Microsystems, Inc. Mountain View, CA.
--- 1,4 ----
! /* $XConsortium: Threads.c,v 1.16 95/06/06 21:00:38 kaleb Exp $ */
  
  /************************************************************
  Copyright 1993 by Sun Microsystems, Inc. Mountain View, CA.
***************
*** 65,70 ****
--- 65,71 ----
  
  #define NDEBUG
  #include <assert.h>
+ #include <stdio.h>
  
  typedef struct _ThreadStack {
      unsigned int size;
***************
*** 175,203 ****
      xmutex_lock(app_lock->mutex);
      app_lock->level++;
  #else
!     xthread_t this_thread = xthread_self();
!     
      xmutex_lock(app_lock->mutex);
-     
      if (!xthread_have_id(app_lock->holder)) {
! 	app_lock->holder = this_thread;
!     	assert(xthread_equal(app_lock->holder, this_thread));
  	xmutex_unlock(app_lock->mutex);
  	return;
      }
!     
!     if (xthread_equal(app_lock->holder, this_thread)) {
  	app_lock->level++;
  	xmutex_unlock(app_lock->mutex);
  	return;
      }
!     
!     while(xthread_have_id(app_lock->holder))
  	xcondition_wait(app_lock->cond, app_lock->mutex);
!     
!     app_lock->holder = this_thread;
!     assert(xthread_equal(app_lock->holder, this_thread));
!     
      xmutex_unlock(app_lock->mutex);
  #endif
  }
--- 176,199 ----
      xmutex_lock(app_lock->mutex);
      app_lock->level++;
  #else
!     xthread_t self = xthread_self();
      xmutex_lock(app_lock->mutex);
      if (!xthread_have_id(app_lock->holder)) {
! 	app_lock->holder = self;
!     	assert(xthread_equal(app_lock->holder, self));
  	xmutex_unlock(app_lock->mutex);
  	return;
      }
!     if (xthread_equal(app_lock->holder, self)) {
  	app_lock->level++;
  	xmutex_unlock(app_lock->mutex);
  	return;
      }
!     while(xthread_have_id(app_lock->holder)) {
  	xcondition_wait(app_lock->cond, app_lock->mutex);
!     }
!     app_lock->holder = self;
!     assert(xthread_equal(app_lock->holder, self));
      xmutex_unlock(app_lock->mutex);
  #endif
  }
***************
*** 212,301 ****
  #endif
  {
      LockPtr app_lock = app->lock_info;
- 
  #ifdef _XMUTEX_NESTS
      app_lock->level--;
      xmutex_unlock(app_lock->mutex);
  #else
      xmutex_lock(app_lock->mutex);
!     assert(xthread_equal(app_lock->holder, xthread_self()));
      if (app_lock->level != 0) {
  	app_lock->level--;
  	xmutex_unlock(app_lock->mutex);
  	return;
      }
- 
      xthread_clear_id(app_lock->holder);
      xcondition_signal(app_lock->cond);
- 
      xmutex_unlock(app_lock->mutex);
  #endif
  }
  
! static int
  #if NeedFunctionPrototypes
  YieldAppLock(
!     XtAppContext app)
! #else
! YieldAppLock(app)
!     XtAppContext app;
  #endif
  {
      LockPtr app_lock = app->lock_info;
!     int level;
  #ifdef _XMUTEX_NESTS
!     level = app_lock->level;
!     while (app_lock->level) {
  	app_lock->level--;
  	xmutex_unlock(app_lock->mutex);
      }
  #else
!     xthread_t this_thread = xthread_self();
!     
!     xmutex_lock(app_lock->mutex);
! 
!     assert(xthread_equal(app_lock->holder, this_thread));
! 
!     level = app_lock->level;
! 
      app_lock->level = 0;
      xthread_clear_id(app_lock->holder);
- 
-     xcondition_signal(app_lock->cond);
      xmutex_unlock(app_lock->mutex);
  #endif
-     return level;
  }
  
- 
  static void
  #if NeedFunctionPrototypes
  RestoreAppLock(
      XtAppContext app, 
!     int level)
  #else
! RestoreAppLock(app, level)
      XtAppContext app;
      int level;
  #endif
  {
      LockPtr app_lock = app->lock_info;
  #ifdef _XMUTEX_NESTS
!     while (--level >= 0) {
  	xmutex_lock(app_lock->mutex);
  	app_lock->level++;
      }
  #else
!     xthread_t this_thread = xthread_self();
! 
!     xmutex_lock(app_lock->mutex);
!     while(xthread_have_id(app_lock->holder))
! 	xcondition_wait(app_lock->cond, app_lock->mutex);
! 
!     app_lock->holder = this_thread;
      app_lock->level = level;
!     assert(xthread_equal(app_lock->holder, this_thread)); 
! 
      xmutex_unlock(app_lock->mutex);
  #endif
  }
--- 208,339 ----
  #endif
  {
      LockPtr app_lock = app->lock_info;
  #ifdef _XMUTEX_NESTS
      app_lock->level--;
      xmutex_unlock(app_lock->mutex);
  #else
+     xthread_t self = xthread_self();
      xmutex_lock(app_lock->mutex);
!     assert(xthread_equal(app_lock->holder, self));
      if (app_lock->level != 0) {
  	app_lock->level--;
  	xmutex_unlock(app_lock->mutex);
  	return;
      }
      xthread_clear_id(app_lock->holder);
      xcondition_signal(app_lock->cond);
      xmutex_unlock(app_lock->mutex);
  #endif
  }
  
! static void
  #if NeedFunctionPrototypes
  YieldAppLock(
!     XtAppContext app,
!     Boolean* push_thread,
!     Boolean* pushed_thread,
!     int* level)
! #else
! YieldAppLock(app, push_thread, pushed_thread, level)
!     XtAppContext app;
!     Boolean* push_thread;
!     Boolean* pushed_thread;
!     int* level;
  #endif
  {
      LockPtr app_lock = app->lock_info;
!     xthread_t self = xthread_self();
! #ifndef _XMUTEX_NESTS
!     xmutex_lock(app_lock->mutex);
!     assert(xthread_equal(app_lock->holder, self));
! #endif
!     *level = app_lock->level;
!     if (*push_thread) {
! 	*push_thread = FALSE;
! 	*pushed_thread = TRUE;
! 
! 	if(app_lock->stack.sp == app_lock->stack.size - 1) {
! 	    int ii;
! 	    app_lock->stack.st = (struct _Tstack *) 
! 		XtRealloc ((char *)app_lock->stack.st, 
! 		(app_lock->stack.size + STACK_INCR) * sizeof (struct _Tstack));
! 	    ii = app_lock->stack.size;
! 	    app_lock->stack.size += STACK_INCR;
! 	    for ( ; ii < app_lock->stack.size; ii++) {
! 		app_lock->stack.st[ii].c = xcondition_malloc();
! 		xcondition_init(app_lock->stack.st[ii].c);
! 	    }
! 	}
! 	app_lock->stack.st[++(app_lock->stack.sp)].t = self;
!     }
  #ifdef _XMUTEX_NESTS
!     while (app_lock->level > 0) {
  	app_lock->level--;
  	xmutex_unlock(app_lock->mutex);
      }
  #else
!     xcondition_signal(app_lock->cond);
      app_lock->level = 0;
      xthread_clear_id(app_lock->holder);
      xmutex_unlock(app_lock->mutex);
  #endif
  }
  
  static void
  #if NeedFunctionPrototypes
  RestoreAppLock(
      XtAppContext app, 
!     int level,
!     Boolean* pushed_thread)
  #else
! RestoreAppLock(app, level, pushed_thread)
      XtAppContext app;
      int level;
+     Boolean* pushed_thread;
  #endif
  {
      LockPtr app_lock = app->lock_info;
+     xthread_t self = xthread_self();
+     xmutex_lock(app_lock->mutex);
+ #ifdef _XMUTEX_NESTS
+     app_lock->level++;
+ #else
+     while(xthread_have_id(app_lock->holder)) {
+ 	xcondition_wait(app_lock->cond, app_lock->mutex);
+     }
+ #endif
+     if (!xthread_equal(app_lock->stack.st[app_lock->stack.sp].t, self)) {
+ 	int ii;
+ 	for (ii = app_lock->stack.sp - 1; ii >= 0; ii--) {
+ 	    if (xthread_equal(app_lock->stack.st[ii].t, self)) {
+ 		xcondition_wait(app_lock->stack.st[ii].c, app_lock->mutex);
+ 		break;
+ 	    }
+ 	}
+ #ifndef _XMUTEX_NESTS
+ 	while(xthread_have_id(app_lock->holder)) {
+ 	    xcondition_wait(app_lock->cond, app_lock->mutex);
+ 	}
+ #endif
+     }
  #ifdef _XMUTEX_NESTS
!     while (app_lock->level < level) {
  	xmutex_lock(app_lock->mutex);
  	app_lock->level++;
      }
  #else
!     app_lock->holder = self;
      app_lock->level = level;
!     assert(xthread_equal(app_lock->holder, self)); 
! #endif
!     if (*pushed_thread) {
! 	*pushed_thread = FALSE;
! 	(app_lock->stack.sp)--;
! 	if (app_lock->stack.sp >= 0) {
! 	    xcondition_signal (app_lock->stack.st[app_lock->stack.sp].c);
! 	}
!     }
! #ifndef _XMUTEX_NESTS
      xmutex_unlock(app_lock->mutex);
  #endif
  }
***************
*** 331,424 ****
      }
  }
  
- /*
-  * When this function is called, the app lock must be held 
-  */
- 
- static void 
- #if NeedFunctionPrototypes
- PushThread(
-     XtAppContext app)
- #else
- PushThread(app)
-     XtAppContext app;
- #endif
- {
-     unsigned int ii;
-     LockPtr app_lock = app->lock_info;
- 
-     xmutex_lock(app_lock->mutex);
-     assert(xthread_equal((app_lock->holder), (xthread_self()) ) );
-     if(app_lock->stack.sp == app_lock->stack.size - 1) {
- 	app_lock->stack.st = (struct _Tstack *) 
- 	    XtRealloc ((char *)app_lock->stack.st, 
- 		(app_lock->stack.size + STACK_INCR) * sizeof (struct _Tstack));
- 	ii = app_lock->stack.size;
- 	app_lock->stack.size += STACK_INCR;
- 	for ( ; ii < app_lock->stack.size; ii++) {
- 	    app_lock->stack.st[ii].c = xcondition_malloc();
- 	    xcondition_init(app_lock->stack.st[ii].c);
- 	}
-     }
-     app_lock->stack.st[++(app_lock->stack.sp)].t = xthread_self();
-     xmutex_unlock(app_lock->mutex);
- }
- 
- /*
-  * When this function is called, the app lock must be held 
-  */
- 
- static void
- #if NeedFunctionPrototypes
- PopThread(
-     XtAppContext app)
- #else
- PopThread(app)
-     XtAppContext app;
- #endif
- {
-     LockPtr app_lock = app->lock_info;
- 
-     xmutex_lock(app_lock->mutex);
-     assert(xthread_equal((app_lock->holder), (xthread_self()) ) );
-     assert(app_lock->stack.sp >= 0);
- 
-     (app_lock->stack.sp)--;
-     if (app_lock->stack.sp >= 0)
- 	xcondition_signal (app_lock->stack.st[app_lock->stack.sp].c);
-     xmutex_unlock(app_lock->mutex);
- }
- 
- static Boolean
- #if NeedFunctionPrototypes
- IsTopThread(
-     XtAppContext app)
- #else
- IsTopThread(app)
-     XtAppContext app;
- #endif
- {
-     Boolean retval;
-     LockPtr app_lock = app->lock_info;
-     xthread_t self = xthread_self();
- 
-     xmutex_lock(app_lock->mutex);
-     assert(app_lock->stack.sp >= 0);
-     if (xthread_equal(app_lock->stack.st[app_lock->stack.sp].t, self))
- 	retval = TRUE;
-     else {
- 	int ii;
- 	retval = FALSE;
- 	for (ii = app_lock->stack.sp - 1; ii >= 0; ii--)
- 	    if (xthread_equal(app_lock->stack.st[ii].t, self)) {
- 		xcondition_wait(app_lock->stack.st[ii].c, app_lock->mutex);
- 		break;
- 	    }
-     }
-     xmutex_unlock(app_lock->mutex);
-     return retval;
- }
- 
  static void
  #if NeedFunctionPrototypes
  InitAppLock(
--- 369,374 ----
***************
*** 437,446 ****
      app->restore_lock = RestoreAppLock;
      app->free_lock = FreeAppLock;
  
-     app->push_thread = PushThread;
-     app->pop_thread = PopThread;
-     app->is_top_thread = IsTopThread;
- 
      app_lock = app->lock_info = XtNew(LockRec);
      app_lock->mutex = xmutex_malloc();
      xmutex_init(app_lock->mutex);
--- 387,392 ----
***************
*** 523,525 ****
--- 469,472 ----
      return False;
  #endif
  }
+ 
*** -	Fri Jul  7 09:31:37 1995
--- xc/lib/Xt/VarCreate.c	Fri Jul  7 09:31:37 1995
***************
*** 1,4 ****
! /* $XConsortium: VarCreate.c,v 1.31 94/06/07 11:17:18 kaleb Exp $ */
  
  /*
  
--- 1,4 ----
! /* $XConsortium: VarCreate.c,v 1.32 95/06/07 19:12:49 converse Exp $ */
  
  /*
  
***************
*** 273,281 ****
  
      _XtVaToArgList(widget, var, total_count, &args, &num_args);
      XtSetValues(widget, args, num_args);
!     if (args != NULL) {
! 	XtFree((XtPointer)args);
!     }
      UNLOCK_APP(app);
      va_end(var);
  }
--- 273,280 ----
  
      _XtVaToArgList(widget, var, total_count, &args, &num_args);
      XtSetValues(widget, args, num_args);
!     _XtFreeArgList(args, total_count, typed_count);
! 
      UNLOCK_APP(app);
      va_end(var);
  }
*** -	Fri Jul  7 09:31:38 1995
--- xc/lib/Xt/VarargsI.h	Fri Jul  7 09:31:38 1995
***************
*** 1,4 ****
! /* $XConsortium: VarargsI.h,v 1.16 94/04/17 20:15:03 converse Exp $ */
  
  /*
  
--- 1,4 ----
! /* $XConsortium: VarargsI.h,v 1.17 95/06/07 19:12:49 converse Exp $ */
  
  /*
  
***************
*** 61,66 ****
--- 61,72 ----
  extern XtTypedArgList _XtVaCreateTypedArgList(
  #if NeedFunctionPrototypes
      va_list /*var*/, int /*count*/
+ #endif
+ );
+ 
+ extern void _XtFreeArgList(
+ #if NeedFunctionPrototypes
+     ArgList /*args*/, int /*total_count*/, int /*typed_count*/
  #endif
  );
  
*** -	Fri Jul  7 09:31:38 1995
--- xc/lib/Xt/Varargs.c	Fri Jul  7 09:31:38 1995
***************
*** 1,4 ****
! /* $XConsortium: Varargs.c,v 1.26 94/04/17 20:15:03 converse Exp $ */
  
  /*
  
--- 1,4 ----
! /* $XConsortium: Varargs.c,v 1.30 95/06/15 19:30:38 converse Exp $ */
  
  /*
  
***************
*** 185,204 ****
  /*
   *    _XtTypedArgToArg() invokes a resource converter to convert the
   *    passed typed arg into a name/value pair and stores the name/value
!  *    pair in the passed Arg structure. It returns 1 if the conversion
!  *    succeeded and 0 if the conversion failed.
   */
  static int
! _XtTypedArgToArg(widget, typed_arg, arg_return, resources, num_resources)
      Widget              widget;
      XtTypedArgList      typed_arg;
      ArgList             arg_return;
      XtResourceList      resources;
      Cardinal            num_resources;
  {     
      String              to_type = NULL;
      XrmValue            from_val, to_val;
-     register int        i;
        
  
      if (widget == NULL) {
--- 185,207 ----
  /*
   *    _XtTypedArgToArg() invokes a resource converter to convert the
   *    passed typed arg into a name/value pair and stores the name/value
!  *    pair in the passed Arg structure.  If memory is allocated for the
!  *    converted value, the address is returned in the value field of 
!  *    memory_return; otherwise that field is NULL.  The function returns
!  *    1 if the conversion succeeded and 0 if the conversion failed.
   */
  static int
! _XtTypedArgToArg(widget, typed_arg, arg_return, resources, num_resources,
! 		 memory_return)
      Widget              widget;
      XtTypedArgList      typed_arg;
      ArgList             arg_return;
      XtResourceList      resources;
      Cardinal            num_resources;
+     ArgList		memory_return;
  {     
      String              to_type = NULL;
      XrmValue            from_val, to_val;
        
  
      if (widget == NULL) {
***************
*** 211,223 ****
         
      /* again we assume that the XtResourceList is un-compiled */
  
!     for (i = 0; i < num_resources; i++) {
!         if (StringToName(typed_arg->name) ==
!             StringToName(resources[i].resource_name)) {
!             to_type = resources[i].resource_type;
!             break;
!         }
!     }
  
      if (to_type == NULL) {
          XtAppWarningMsg(XtWidgetToApplicationContext(widget),
--- 214,224 ----
         
      /* again we assume that the XtResourceList is un-compiled */
  
!     for (; num_resources--; resources++)
! 	if (strcmp(typed_arg->name, resources->resource_name) == 0) {
! 	    to_type = resources->resource_type;
! 	    break;
! 	}
  
      if (to_type == NULL) {
          XtAppWarningMsg(XtWidgetToApplicationContext(widget),
***************
*** 246,251 ****
--- 247,253 ----
      }
  
      arg_return->name = typed_arg->name;
+     memory_return->value = (XtArgVal) NULL;
  
      if (strcmp(to_type, XtRString) == 0) {
  	arg_return->value = (XtArgVal) to_val.addr;
***************
*** 259,264 ****
--- 261,271 ----
  	    arg_return->value = (XtArgVal) *(char *)to_val.addr;
  	else if (to_val.size == sizeof(XtArgVal))
  	    arg_return->value = *(XtArgVal *)to_val.addr;
+ 	else if (to_val.size > sizeof(XtArgVal)) {
+ 	    arg_return->value = (XtArgVal) XtMalloc(to_val.size);
+ 	    memory_return->value = (XtArgVal)
+ 		memcpy((void *)arg_return->value, to_val.addr, to_val.size);
+ 	}
      }
         
      return(1);
***************
*** 270,281 ****
   *    an ArgList/count.
   */
  static int
! _XtNestedArgtoArg(widget, avlist, args, resources, num_resources)
      Widget              widget;
      XtTypedArgList      avlist;
      ArgList             args;
      XtResourceList      resources;
      Cardinal            num_resources;
  {
      int         count = 0;
   
--- 277,290 ----
   *    an ArgList/count.
   */
  static int
! _XtNestedArgtoArg(widget, avlist, args, resources, num_resources,
! 		  memory_return)
      Widget              widget;
      XtTypedArgList      avlist;
      ArgList             args;
      XtResourceList      resources;
      Cardinal            num_resources;
+     ArgList		memory_return;
  {
      int         count = 0;
   
***************
*** 285,295 ****
              if (widget != NULL) {
                  /* this is a typed arg */
                  count += _XtTypedArgToArg(widget, avlist, (args+count),
!                              resources, num_resources);
              }
          } else if (strcmp(avlist->name, XtVaNestedList) == 0) {
              count += _XtNestedArgtoArg(widget, (XtTypedArgList)avlist->value,
!                         (args+count), resources, num_resources);
          } else {
              (args+count)->name = avlist->name;
              (args+count)->value = avlist->value;
--- 294,306 ----
              if (widget != NULL) {
                  /* this is a typed arg */
                  count += _XtTypedArgToArg(widget, avlist, (args+count),
! 					  resources, num_resources,
! 					  (memory_return+count));
              }
          } else if (strcmp(avlist->name, XtVaNestedList) == 0) {
              count += _XtNestedArgtoArg(widget, (XtTypedArgList)avlist->value,
! 				       (args+count), resources, num_resources,
! 				       (memory_return+count));
          } else {
              (args+count)->name = avlist->name;
              (args+count)->value = avlist->value;
***************
*** 300,312 ****
      return(count);
  }
  
  static void		GetResources();
  
   
  /* 
   *    Given a variable argument list, _XtVaToArgList() returns the 
   *    equivalent ArgList and count. _XtVaToArgList() handles nested 
!  *    lists and typed arguments. 
   */
  #if NeedFunctionPrototypes
  void
--- 311,367 ----
      return(count);
  }
  
+ /*
+  * Free memory allocated through _XtVaToArgList.  The actual args array
+  * size is expected to be total_count * 2, where total_count is the number
+  * of elements needed for resource representations.  The lower half of the
+  * array contains pairs of resource names and values as usual.  For each
+  * element [n] in the lower half of the array, the value field of the
+  * corresponding element [n + total_count] in the upper half of the array
+  * has been pressed into service in order to note whether the resource value
+  * is a pointer to memory that was allocated in _XtTypedArgToArg.  In the
+  * upper half, if the value field is not NULL, it contains the address of
+  * memory which should now be freed.  That memory could have been allocated
+  * only as a result of the conversion of typed arguments.  Therefore, if
+  * there were no typed arguments in the original varargs, there is no need
+  * to examine the upper half of the array.  In the choice of data structure
+  * to make this representation, priority was given to the wish to retrofit
+  * the release of memory around the existing signature of _XtVaToArgList.
+  */
+ #if NeedFunctionPrototypes
+ void
+ _XtFreeArgList(
+     ArgList	args,	     /* as returned by _XtVaToArgList */
+     int		total_count, /*  argument count returned by _XtCountVaList */
+     int 	typed_count) /* typed arg count returned by _XtCountVaList */
+ #else
+ void
+ _XtFreeArgList(args, total_count, typed_count)
+     ArgList	args;
+     int		total_count;
+     int 	typed_count;
+ #endif
+ {
+     ArgList p;
+ 
+     if (args) {
+ 	if (typed_count)
+ 	    for (p = args + total_count; total_count--; ++p) {
+ 		if (p->value) XtFree((char *)p->value);
+ 	    }
+ 	XtFree((char *)args);
+     }
+ }
+ 
+ 
  static void		GetResources();
  
   
  /* 
   *    Given a variable argument list, _XtVaToArgList() returns the 
   *    equivalent ArgList and count. _XtVaToArgList() handles nested 
!  *    lists and typed arguments.  If typed arguments are present, the
!  *    ArgList should be freed with _XtFreeArgList.
   */
  #if NeedFunctionPrototypes
  void
***************
*** 327,333 ****
  #endif
  {
      String		attr;
!     int			count = 0;
      ArgList		args = (ArgList)NULL;
      XtTypedArg		typed_arg;
      XtResourceList	resources = (XtResourceList)NULL;
--- 382,388 ----
  #endif
  {
      String		attr;
!     int			count;
      ArgList		args = (ArgList)NULL;
      XtTypedArg		typed_arg;
      XtResourceList	resources = (XtResourceList)NULL;
***************
*** 340,347 ****
  	return;
      }
  
! 
      args = (ArgList)XtMalloc((unsigned)(max_count * sizeof(Arg)));
  
      for(attr = va_arg(var, String) ; attr != NULL;
  			attr = va_arg(var, String)) {
--- 395,406 ----
  	return;
      }
  
!     max_count *= 2;
      args = (ArgList)XtMalloc((unsigned)(max_count * sizeof(Arg)));
+     for (count = max_count; --count >= 0; )
+ 	args[count].value = (XtArgVal) NULL;
+     max_count /= 2;
+     count = 0;
  
      for(attr = va_arg(var, String) ; attr != NULL;
  			attr = va_arg(var, String)) {
***************
*** 358,364 ****
  		    fetched_resource_list = True;
  		}
  		count += _XtTypedArgToArg(widget, &typed_arg, &args[count],
! 			     resources, num_resources);
  	    }
  	} else if (strcmp(attr, XtVaNestedList) == 0) {
  	    if (widget != NULL || !fetched_resource_list) {
--- 417,424 ----
  		    fetched_resource_list = True;
  		}
  		count += _XtTypedArgToArg(widget, &typed_arg, &args[count],
! 					  resources, num_resources,
! 					  &args[max_count + count]);
  	    }
  	} else if (strcmp(attr, XtVaNestedList) == 0) {
  	    if (widget != NULL || !fetched_resource_list) {
***************
*** 367,373 ****
  	    }
  
  	    count += _XtNestedArgtoArg(widget, va_arg(var, XtTypedArgList),
! 			&args[count], resources, num_resources);
  	} else {
  	    args[count].name = attr;
  	    args[count].value = va_arg(var, XtArgVal);
--- 427,434 ----
  	    }
  
  	    count += _XtNestedArgtoArg(widget, va_arg(var, XtTypedArgList),
! 				       &args[count], resources, num_resources,
! 				       &args[max_count + count]);
  	} else {
  	    args[count].name = attr;
  	    args[count].value = va_arg(var, XtArgVal);
***************
*** 401,408 ****
      XtInitializeWidgetClass(XtClass(widget));
      XtGetResourceList(XtClass(widget), res_list, number);
      
!     /* assert: !XtIsShell(w) => (XtParent(w) != NULL) */
!     if (!XtIsShell(widget) && XtIsConstraint(parent)) {
  	XtResourceList res, constraint, cons_top;
  	Cardinal num_constraint, temp;
  
--- 462,468 ----
      XtInitializeWidgetClass(XtClass(widget));
      XtGetResourceList(XtClass(widget), res_list, number);
      
!     if (!XtIsShell(widget) && parent && XtIsConstraint(parent)) {
  	XtResourceList res, constraint, cons_top;
  	Cardinal num_constraint, temp;
  
*** -	Fri Jul  7 09:31:40 1995
--- xc/lib/Xt/jump_ignore	Fri Jul  7 09:31:39 1995
***************
*** 1,3 ****
! # $XConsortium: jump_ignore,v 1.2 94/12/07 10:45:51 kaleb Exp $
  # $XFree86: xc/lib/Xt/jump_ignore,v 3.0 1994/04/28 12:32:14 dawes Exp $
  # jump_ignore
--- 1,6 ----
! # $XConsortium: jump_ignore,v 1.3 95/06/30 18:48:53 kaleb Exp $
  # $XFree86: xc/lib/Xt/jump_ignore,v 3.0 1994/04/28 12:32:14 dawes Exp $
  # jump_ignore
+ 00000000 T __XtFreeArgList		libXt	Varargs
+ 00000000 T __XtClearAncestorCache	libXt	Keyboard
+ 
*** -	Fri Jul  7 09:31:40 1995
--- xc/lib/Xt/sharedlib.c	Fri Jul  7 09:31:40 1995
***************
*** 1,4 ****
! /* $XConsortium: sharedlib.c,v 1.17 94/04/17 20:15:06 converse Exp $ */
  
  /*
  
--- 1,4 ----
! /* $XConsortium: sharedlib.c,v 1.18 95/03/30 19:00:57 converse Exp $ */
  
  /*
  
***************
*** 242,248 ****
      extern Widget _XtVaOpenApplication();
  
      VENDORINIT
!     Va_start(var, fallback_resources);
      return _XtVaOpenApplication(app_context_return, application_class, options,
  				num_options, argc_in_out, argv_in_out,
  				fallback_resources, widget_class, var);
--- 242,248 ----
      extern Widget _XtVaOpenApplication();
  
      VENDORINIT
!     Va_start(var, widget_class);
      return _XtVaOpenApplication(app_context_return, application_class, options,
  				num_options, argc_in_out, argv_in_out,
  				fallback_resources, widget_class, var);
*** /dev/null	Fri Jul  7 09:31:41 1995
--- xc/lib/Xt/util/Shell.ht	Fri Jul  7 09:31:41 1995
***************
*** 0 ****
--- 1,100 ----
+ /* $XConsortium: Shell.ht,v 1.34 95/05/10 15:09:48 kaleb Exp $ */
+ 
+ /***********************************************************
+ 
+ Copyright (c) 1987, 1988, 1994  X Consortium
+ 
+ Permission is hereby granted, free of charge, to any person obtaining a copy
+ of this software and associated documentation files (the "Software"), to deal
+ in the Software without restriction, including without limitation the rights
+ to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ copies of the Software, and to permit persons to whom the Software is
+ furnished to do so, subject to the following conditions:
+ 
+ The above copyright notice and this permission notice shall be included in
+ all copies or substantial portions of the Software.
+ 
+ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+ X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ 
+ Except as contained in this notice, the name of the X Consortium shall not be
+ used in advertising or otherwise to promote the sale, use or other dealings
+ in this Software without prior written authorization from the X Consortium.
+ 
+ 
+ Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts.
+ 
+                         All Rights Reserved
+ 
+ Permission to use, copy, modify, and distribute this software and its 
+ documentation for any purpose and without fee is hereby granted, 
+ provided that the above copyright notice appear in all copies and that
+ both that copyright notice and this permission notice appear in 
+ supporting documentation, and that the name of Digital not be
+ used in advertising or publicity pertaining to distribution of the
+ software without specific, written prior permission.  
+ 
+ DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+ DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+ WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ SOFTWARE.
+ 
+ ******************************************************************/
+ 
+ #ifndef _XtShell_h
+ #define _XtShell_h
+ 
+ #include <X11/SM/SMlib.h>
+ 
+ /***********************************************************************
+  *
+  * Shell Widget
+  *
+  ***********************************************************************/
+ /*
+  * Shell-specific resources names, classes, and a representation type.
+  */
+ 
+ #ifndef XTSTRINGDEFINES
+ #ifdef __STDC__
+ #define _XtShell_h_Const const
+ #else
+ #define _XtShell_h_Const /**/
+ #endif
+ #endif
+ 
+ <<<STRING_TABLE_GOES_HERE>>>
+ 
+ #ifndef XTSTRINGDEFINES
+ #undef _XtShell_h_Const
+ #endif
+ 
+ /* Class record constants */
+ 
+ typedef struct _ShellClassRec *ShellWidgetClass;
+ typedef struct _OverrideShellClassRec *OverrideShellWidgetClass;
+ typedef struct _WMShellClassRec *WMShellWidgetClass;
+ typedef struct _TransientShellClassRec *TransientShellWidgetClass;
+ typedef struct _TopLevelShellClassRec *TopLevelShellWidgetClass;
+ typedef struct _ApplicationShellClassRec *ApplicationShellWidgetClass;
+ typedef struct _SessionShellClassRec *SessionShellWidgetClass;
+ 
+ #ifndef SHELL 
+ externalref WidgetClass shellWidgetClass;
+ externalref WidgetClass overrideShellWidgetClass;
+ externalref WidgetClass wmShellWidgetClass;
+ externalref WidgetClass transientShellWidgetClass;
+ externalref WidgetClass topLevelShellWidgetClass;
+ externalref WidgetClass applicationShellWidgetClass;
+ externalref WidgetClass sessionShellWidgetClass;
+ #endif
+ 
+ #endif /* _XtShell_h */
+ /* DON'T ADD STUFF AFTER THIS #endif */
*** /dev/null	Fri Jul  7 09:31:42 1995
--- xc/lib/Xt/util/StrDefs.ct	Fri Jul  7 09:31:42 1995
***************
*** 0 ****
--- 1,58 ----
+ /* $XConsortium: StrDefs.ct,v 1.1 95/05/10 15:10:56 kaleb Exp $ */
+ 
+ /***********************************************************
+ 
+ Copyright (c) 1987, 1988, 1994  X Consortium
+ 
+ Permission is hereby granted, free of charge, to any person obtaining a copy
+ of this software and associated documentation files (the "Software"), to deal
+ in the Software without restriction, including without limitation the rights
+ to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ copies of the Software, and to permit persons to whom the Software is
+ furnished to do so, subject to the following conditions:
+ 
+ The above copyright notice and this permission notice shall be included in
+ all copies or substantial portions of the Software.
+ 
+ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+ X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ 
+ Except as contained in this notice, the name of the X Consortium shall not be
+ used in advertising or otherwise to promote the sale, use or other dealings
+ in this Software without prior written authorization from the X Consortium.
+ 
+ 
+ Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts.
+ 
+                         All Rights Reserved
+ 
+ Permission to use, copy, modify, and distribute this software and its 
+ documentation for any purpose and without fee is hereby granted, 
+ provided that the above copyright notice appear in all copies and that
+ both that copyright notice and this permission notice appear in 
+ supporting documentation, and that the name of Digital not be
+ used in advertising or publicity pertaining to distribution of the
+ software without specific, written prior permission.  
+ 
+ DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+ DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+ WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ SOFTWARE.
+ 
+ ******************************************************************/
+ 
+ #ifdef __STDC__
+ #define Const const
+ #else
+ #define Const /**/
+ #endif
+ 
+ <<<STRING_TABLE_GOES_HERE>>>
+ 
*** /dev/null	Fri Jul  7 09:31:42 1995
--- xc/lib/Xt/util/StrDefs.ht	Fri Jul  7 09:31:42 1995
***************
*** 0 ****
--- 1,68 ----
+ /* $XConsortium: StrDefs.ht,v 1.2 95/05/10 15:10:40 kaleb Exp $ */
+ 
+ /***********************************************************
+ 
+ Copyright (c) 1987, 1988, 1994  X Consortium
+ 
+ Permission is hereby granted, free of charge, to any person obtaining a copy
+ of this software and associated documentation files (the "Software"), to deal
+ in the Software without restriction, including without limitation the rights
+ to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ copies of the Software, and to permit persons to whom the Software is
+ furnished to do so, subject to the following conditions:
+ 
+ The above copyright notice and this permission notice shall be included in
+ all copies or substantial portions of the Software.
+ 
+ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+ X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ 
+ Except as contained in this notice, the name of the X Consortium shall not be
+ used in advertising or otherwise to promote the sale, use or other dealings
+ in this Software without prior written authorization from the X Consortium.
+ 
+ 
+ Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts.
+ 
+                         All Rights Reserved
+ 
+ Permission to use, copy, modify, and distribute this software and its 
+ documentation for any purpose and without fee is hereby granted, 
+ provided that the above copyright notice appear in all copies and that
+ both that copyright notice and this permission notice appear in 
+ supporting documentation, and that the name of Digital not be
+ used in advertising or publicity pertaining to distribution of the
+ software without specific, written prior permission.  
+ 
+ DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+ DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+ WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ SOFTWARE.
+ 
+ ******************************************************************/
+ 
+ #ifndef _XtStringDefs_h_
+ #define _XtStringDefs_h_
+ 
+ #ifndef XTSTRINGDEFINES
+ #ifdef __STDC__
+ #define _XtStringDefs_h_Const const
+ #else
+ #define _XtStringDefs_h_Const /**/
+ #endif
+ #endif
+ 
+ <<<STRING_TABLE_GOES_HERE>>>
+ 
+ #ifndef XTSTRINGDEFINES
+ #undef _XtStringDefs_h_Const
+ #endif
+ 
+ #endif /* _XtStringDefs_h_ */
*** -	Fri Jul  7 09:31:43 1995
--- xc/lib/Xt/util/string.list	Fri Jul  7 09:31:43 1995
***************
*** 1,8 ****
! ! $XConsortium: string.list,v 1.11 94/04/17 14:11:28 kaleb Exp $
  ! NOTE: To maintain binary compatibility, you can only APPEND items within
  !	a given list!!!!
  
! :StringDefs.h XtStrings
  
  Naccelerators
  NallowHoriz
--- 1,20 ----
! ! $XConsortium: string.list,v 1.12 95/05/11 22:32:57 kaleb Exp $
  ! NOTE: To maintain binary compatibility, you can only APPEND items within
  !	a given list!!!!
+ !
+ ! See the makestrs(1) manual.
+ !
  
! #prefix Xt
! #feature XTSTRINGDEFINES
! #externref extern
! #externdef 
! ! note that the trailing space is required in the #externdef line.
! #ctmpl util/StrDefs.ct
! 
! #file StringDefs.h
! #table XtStrings
! #htmpl util/StrDefs.ht
  
  Naccelerators
  NallowHoriz
***************
*** 217,222 ****
--- 229,237 ----
  NfontSet
  RFontSet
  CFontSet
+ 
+ #table XtStringsR6
+ 
  RGravity
  NcreateHook
  NchangeHook
***************
*** 259,266 ****
  HpostGeometry
  Hdestroy
  
! 
! :ShellStr.h XtShellStrings
  
  NiconName
  CIconName
--- 274,282 ----
  HpostGeometry
  Hdestroy
  
! #file Shell.h
! #table XtShellStrings
! #htmpl util/Shell.ht
  
  NiconName
  CIconName
***************
*** 339,344 ****
--- 355,363 ----
  CWmTimeout
  NwaitForWm waitforwm
  CWaitForWm Waitforwm
+ 
+ #table XtShellStringsR6
+ 
  Nwaitforwm
  CWaitforwm
  NclientLeader
***************
*** 377,379 ****
--- 396,399 ----
  NshutdownCommand
  CShutdownCommand
  NerrorCallback
+ 
*** -	Fri Jul  7 09:31:44 1995
--- xc/lib/Xmu/Atoms.c	Fri Jul  7 09:31:44 1995
***************
*** 1,4 ****
! /* $XConsortium: Atoms.c,v 1.18 94/04/17 20:15:49 kaleb Exp $ */
   
  /* 
  
--- 1,4 ----
! /* $XConsortium: Atoms.c,v 1.19 95/06/08 23:20:39 gildea Exp $ */
   
  /* 
  
***************
*** 60,66 ****
  #define STATIC static
  #endif
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define DeclareAtom(atom,text) \
  STATIC struct _AtomRec __##atom = { text, NULL }; \
  AtomPtr _##atom = &__##atom;
--- 60,66 ----
  #define STATIC static
  #endif
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define DeclareAtom(atom,text) \
  STATIC struct _AtomRec __##atom = { text, NULL }; \
  AtomPtr _##atom = &__##atom;
*** -	Fri Jul  7 09:31:45 1995
--- xc/lib/Xmu/CursorName.c	Fri Jul  7 09:31:45 1995
***************
*** 1,4 ****
! /* $XConsortium: CursorName.c,v 1.8 94/04/17 20:15:55 rws Exp $ */
  
  /*
   
--- 1,4 ----
! /* $XConsortium: CursorName.c,v 1.9 95/06/08 23:20:39 gildea Exp $ */
  
  /*
   
***************
*** 32,38 ****
  #include <X11/Xmu/CurUtil.h>
  #include <X11/cursorfont.h>
  
! #if __STDC__
  #define Const const
  #else
  #define Const /**/
--- 32,38 ----
  #include <X11/Xmu/CurUtil.h>
  #include <X11/cursorfont.h>
  
! #ifdef __STDC__
  #define Const const
  #else
  #define Const /**/
*** -	Fri Jul  7 09:31:45 1995
--- xc/lib/Xmu/Lookup.c	Fri Jul  7 09:31:45 1995
***************
*** 1,4 ****
! /* $XConsortium: Lookup.c,v 1.14 94/04/17 20:16:10 rws Exp $ */
  
  /* 
   
--- 1,4 ----
! /* $XConsortium: Lookup.c,v 1.15 95/06/08 23:20:39 gildea Exp $ */
  
  /* 
   
***************
*** 33,39 ****
  #define XK_PUBLISHING
  #include <X11/keysymdef.h>
  
! #if __STDC__
  #define Const const
  #else
  #define Const /**/
--- 33,39 ----
  #define XK_PUBLISHING
  #include <X11/keysymdef.h>
  
! #ifdef __STDC__
  #define Const const
  #else
  #define Const /**/
*** -	Fri Jul  7 09:31:46 1995
--- xc/lib/Xmu/sharedlib.c	Fri Jul  7 09:31:46 1995
***************
*** 1,4 ****
! /* $XConsortium: sharedlib.c,v 1.8 94/04/17 20:16:27 rws Exp $ */
  
  /*
  
--- 1,4 ----
! /* $XConsortium: sharedlib.c,v 1.9 95/06/08 23:20:39 gildea Exp $ */
  
  /*
  
***************
*** 36,42 ****
      struct _DisplayRec* head;
  };
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define DeclareAtom(atom) \
  extern struct _AtomRec __##atom; \
  AtomPtr _##atom = &__##atom;
--- 36,42 ----
      struct _DisplayRec* head;
  };
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define DeclareAtom(atom) \
  extern struct _AtomRec __##atom; \
  AtomPtr _##atom = &__##atom;
*** -	Fri Jul  7 09:31:47 1995
--- xc/lib/Xaw/XawImP.h	Fri Jul  7 09:31:47 1995
***************
*** 1,4 ****
! /* $XConsortium: XawImP.h,v 1.3 94/04/17 20:13:32 kaleb Exp $ */
  
  /*
   * Copyright 1991 by OMRON Corporation
--- 1,4 ----
! /* $XConsortium: XawImP.h,v 1.4 95/06/06 20:50:30 kaleb Exp $ */
  
  /*
   * Copyright 1991 by OMRON Corporation
***************
*** 181,186 ****
--- 181,187 ----
  #endif
  );
  
+ /* DON'T USE THIS FUNCTION -- it's going away in the next release */
  void _XawImVASetValues( 
  #if NeedVarargsPrototypes
      Widget,  /* w */
***************
*** 196,201 ****
--- 197,203 ----
  #endif
  );
  
+ /* DON'T USE THIS FUNCTION -- it's going away in the next release */
  void _XawImVASetFocusValues( 
  #if NeedVarargsPrototypes
      Widget,  /* w */
*** -	Fri Jul  7 09:31:47 1995
--- xc/lib/Xaw/AsciiText.c	Fri Jul  7 09:31:47 1995
***************
*** 1,4 ****
! /* $XConsortium: AsciiText.c,v 1.46 94/04/17 20:11:50 kaleb Exp $ */
  
  /*
  
--- 1,4 ----
! /* $XConsortium: AsciiText.c,v 1.47 95/06/06 20:50:30 kaleb Exp $ */
  
  /*
  
***************
*** 182,195 ****
    /* If we are using a MultiSink we need to tell the input method stuff. */
  
    if ( w->simple.international == True ) {
  
!       sink = (MultiSinkObject)w->text.sink;
!       _XawImRegister( new );
!       _XawImVASetValues( new, XtNfontSet, sink->multi_sink.fontset,
! 		    XtNinsertPosition, w->text.insertPos,
! 		    XtNforeground, sink->text_sink.foreground,
! 		    XtNbackground, sink->text_sink.background,
! 		    NULL );
    }
  }
  
--- 182,197 ----
    /* If we are using a MultiSink we need to tell the input method stuff. */
  
    if ( w->simple.international == True ) {
+     Arg list[4];
+     Cardinal ac = 0;
  
!     sink = (MultiSinkObject)w->text.sink;
!     _XawImRegister( new );
!     XtSetArg (list[ac], XtNfontSet, sink->multi_sink.fontset); ac++;
!     XtSetArg (list[ac], XtNinsertPosition, w->text.insertPos); ac++;
!     XtSetArg (list[ac], XtNforeground, sink->text_sink.foreground); ac++;
!     XtSetArg (list[ac], XtNbackground, sink->text_sink.background); ac++;
!     _XawImSetValues(new, list, ac);
    }
  }
  
*** -	Fri Jul  7 09:31:48 1995
--- xc/lib/Xaw/MenuButton.c	Fri Jul  7 09:31:48 1995
***************
*** 1,4 ****
! /* $XConsortium: MenuButton.c,v 1.20 94/04/17 20:12:19 kaleb Exp $ */
  
  /*
  Copyright (c) 1989, 1994  X Consortium
--- 1,4 ----
! /* $XConsortium: MenuButton.c,v 1.21 95/06/26 20:35:12 kaleb Exp $ */
  
  /*
  Copyright (c) 1989, 1994  X Consortium
***************
*** 59,67 ****
  #define superclass ((CommandWidgetClass)&commandClassRec)
  
  static char defaultTranslations[] = 
!     "<EnterWindow>:     highlight()             \n\
!      <LeaveWindow>:     reset()                 \n\
!      <BtnDown>:         reset() PopupMenu()     ";
  
  /****************************************************************
   *
--- 59,67 ----
  #define superclass ((CommandWidgetClass)&commandClassRec)
  
  static char defaultTranslations[] = 
! "<EnterWindow>: highlight()\n\
!  <LeaveWindow>: reset()\n\
!  Any<BtnDown>:  reset() PopupMenu()";
  
  /****************************************************************
   *
*** -	Fri Jul  7 09:31:49 1995
--- xc/lib/Xaw/Text.c	Fri Jul  7 09:31:49 1995
***************
*** 1,4 ****
! /* $XConsortium: Text.c,v 1.194 94/07/08 09:45:41 kaleb Exp $ */
  
  /***********************************************************
  
--- 1,4 ----
! /* $XConsortium: Text.c,v 1.197 95/06/14 15:07:27 kaleb Exp $ */
  
  /***********************************************************
  
***************
*** 67,73 ****
  #include <X11/Xaw/Scrollbar.h>
  #include <X11/Xaw/TextP.h>
  #include <X11/Xaw/MultiSinkP.h>
! #include <X11/Xaw/XawImP.h>	/* for _XawImVASetValues */
  
  #include <X11/Xfuncs.h>
  #include <ctype.h>		/* for isprint() */
--- 67,73 ----
  #include <X11/Xaw/Scrollbar.h>
  #include <X11/Xaw/TextP.h>
  #include <X11/Xaw/MultiSinkP.h>
! #include <X11/Xaw/XawImP.h>
  
  #include <X11/Xfuncs.h>
  #include <ctype.h>		/* for isprint() */
***************
*** 514,521 ****
    ctx->text.copy_area_offsets = NULL;
    ctx->text.salt2 = NULL;
  
-   ctx->text.internal_selection = NULL;
- 
    if (ctx->core.height == DEFAULT_TEXT_HEIGHT) {
      ctx->core.height = VMargins(ctx);
      if (ctx->text.sink != NULL)
--- 514,519 ----
***************
*** 662,670 ****
  
    /* Keep Input Method up to speed  */
  
!   if ( ctx->simple.international )
!       _XawImVASetValues( w, XtNinsertPosition, ctx->text.insertPos, NULL );
  
  }
  
  /*
--- 660,671 ----
  
    /* Keep Input Method up to speed  */
  
!   if ( ctx->simple.international ) {
!     Arg list[1];
  
+     XtSetArg (list[0], XtNinsertPosition, ctx->text.insertPos);
+     _XawImSetValues (w, list, 1);
+   }
  }
  
  /*
***************
*** 1143,1148 ****
--- 1144,1150 ----
  {
    XawTextPosition top, target;
    int y;
+   Arg list[1];
    XawTextLineTable * lt = &(ctx->text.lt);
  
    if (abs(n) > ctx->text.lt.lines) 
***************
*** 1213,1220 ****
      else if (lt->top != target)
        DisplayTextWindow((Widget)ctx);
    }
!   _XawImVASetValues( (Widget) ctx, XtNinsertPosition,		/*i18n patch3*/
! 	   (ctx->text.lt.top + ctx->text.lt.lines), NULL);	/*i18n patch3*/
  }
  
  /*ARGSUSED*/
--- 1215,1222 ----
      else if (lt->top != target)
        DisplayTextWindow((Widget)ctx);
    }
!   XtSetArg (list[0], XtNinsertPosition, ctx->text.lt.top+ctx->text.lt.lines);
!   _XawImSetValues ((Widget) ctx, list, 1);
  }
  
  /*ARGSUSED*/
***************
*** 1690,1696 ****
    atomP = ctx->text.s.selections;
    for (i = 0 ; i < ctx->text.s.atom_count; i++, atomP++)
      if ( (*selection == *atomP) || 
-  	( *atomP == XInternAtom( XtDisplay(w), "INTERNAL", True ) ) ||
  	(GetCutBufferNumber(*atomP) != NOT_A_CUT_BUFFER) )/* is a cut buffer */
        *atomP = (Atom)0;
  
--- 1692,1697 ----
***************
*** 1807,1814 ****
      j = 0;
      for (i = 0; i < num_atoms; i++)
      {
! 	if ( (GetCutBufferNumber (selections[i]) == NOT_A_CUT_BUFFER) &&
!  	( selections[i] != XInternAtom( XtDisplay( (Widget)ctx ), "INTERNAL", True ) ) )
  	{
  	    salt->s.selections[j++] = selections[i];
  	    XtOwnSelection ((Widget) ctx, selections[i], ctx->text.time,
--- 1808,1814 ----
      j = 0;
      for (i = 0; i < num_atoms; i++)
      {
! 	if (GetCutBufferNumber (selections[i]) == NOT_A_CUT_BUFFER)
  	{
  	    salt->s.selections[j++] = selections[i];
  	    XtOwnSelection ((Widget) ctx, selections[i], ctx->text.time,
***************
*** 1854,1900 ****
      Widget w = (Widget) ctx;
      int buffer;
      
-     /* There are three storage classes currently supported:
- 	INTERNAL	stores selected data in the widget record
- 	CUT_BUFFER0-7	stores selected data in a root property
- 	[other]		taken as a selection name to assert ownership of
- 
-     The INTERNAL type is new for R6 and allows better performance than the
-     CUT_BUFFER, and allows selecting non-ASCII text and pasting it into the
-     same widget even with intervening mouse cursor positionings. */
- 
      while (count) {
        Atom selection = selections[--count];
  
!       if ( selection == XInternAtom( XtDisplay(w), "INTERNAL", True ) ) {
! 
!           /* CASE 1: INTERNAL */
! 
!           unsigned char *ptr = (unsigned char *)
! 			_XawTextGetText(ctx, ctx->text.s.left, ctx->text.s.right);
! 
!           if (_XawTextFormat(ctx) == XawFmtWide) {
!               XTextProperty textprop;
!               if (XwcTextListToTextProperty(XtDisplay(w), (wchar_t**)&ptr, 1,
! 			                  XCompoundTextStyle, &textprop) < Success) {
!                   XtFree((char *)ptr);
!                   return;
!               }
!               XtFree((char *)ptr);
!               ptr = textprop.value;
!           }
!           if ( strlen( (char *)ptr ) ) {
!               if ( ctx->text.internal_selection != NULL )
!                   XtFree( ctx->text.internal_selection );
!               ctx->text.internal_selection = XtNewString( (char *)ptr );
!           }
! 
!       }
! 
!       else if ((buffer = GetCutBufferNumber(selection)) != NOT_A_CUT_BUFFER) {
! 
!         /* CASE 2: CUT_BUFFERx */
  
  	unsigned char *ptr, *tptr;
  	unsigned int amount, max_len = MAX_CUT_LEN(XtDisplay(w));
  	unsigned long len;
--- 1854,1867 ----
      Widget w = (Widget) ctx;
      int buffer;
      
      while (count) {
        Atom selection = selections[--count];
  
! /*
!  * If this is a cut buffer.
!  */
  
+       if ((buffer = GetCutBufferNumber(selection)) != NOT_A_CUT_BUFFER) {
  	unsigned char *ptr, *tptr;
  	unsigned int amount, max_len = MAX_CUT_LEN(XtDisplay(w));
  	unsigned long len;
***************
*** 2479,2488 ****
      ctx->text.s.selections = sel;
    }
    for (n=nelems; --n >= 0; sel++, list++)
- 
-     /* I changed this to True so that atoms besides CUT_BUFFERx and
-     PRIMARY, SECONDARY can be used - specifically, INTERNAL. */
- 
      *sel = XInternAtom(dpy, *list, True);
    ctx->text.s.atom_count = nelems;
    return ctx->text.s.selections;
--- 2446,2451 ----
***************
*** 2854,2861 ****
    XtFree((char *)ctx->text.search);
    XtFree((char *)ctx->text.updateFrom);
    XtFree((char *)ctx->text.updateTo);
- 
-   XtFree((char *)ctx->text.internal_selection);
  }
  
  /*
--- 2817,2822 ----
***************
*** 3334,3341 ****
  /*
   * As selections are lost the atom_count will decrement.
   */
!       if ( (GetCutBufferNumber(sel) == NOT_A_CUT_BUFFER) &&
! 	( sel != XInternAtom( XtDisplay(w), "INTERNAL", True ) ) )
  	XtDisownSelection(w, sel, ctx->text.time);
        LoseSelection(w, &sel); /* In case this is a cut buffer, or 
  				 XtDisownSelection failed to call us. */
--- 3295,3301 ----
  /*
   * As selections are lost the atom_count will decrement.
   */
!       if (GetCutBufferNumber(sel) == NOT_A_CUT_BUFFER)
  	XtDisownSelection(w, sel, ctx->text.time);
        LoseSelection(w, &sel); /* In case this is a cut buffer, or 
  				 XtDisownSelection failed to call us. */
*** -	Fri Jul  7 09:31:51 1995
--- xc/lib/Xaw/TextAction.c	Fri Jul  7 09:31:51 1995
***************
*** 1,4 ****
! /* $XConsortium: TextAction.c,v 1.51 94/04/17 20:13:07 kaleb Exp $ */
  
  /*
  
--- 1,4 ----
! /* $XConsortium: TextAction.c,v 1.53 95/06/14 15:07:27 kaleb Exp $ */
  
  /*
  
***************
*** 292,317 ****
      int buffer;
  
      selection = XInternAtom(XtDisplay(w), *params, False);
- 
-     /* CASE 1: INTERNAL */
- 
-     if ( ( strcmp( params[0], "INTERNAL" ) == 0 ) &&
- 	 	 ( ((TextWidget)w)->text.internal_selection != NULL ) ) {
- 	int fmt8 = 8;
- 	Atom type = XA_COMPOUND_TEXT(XtDisplay(w));
- 	char *line = XtNewString( ((TextWidget)w)->text.internal_selection );
- 	unsigned long length = strlen( line );
- 	if ( length ) {
- 	    _SelectionReceived(w, (XtPointer) NULL, &selection, &type, (XPointer)line,
- 				&length, &fmt8);
- 	    return;
- 	}
- 	else if (num_params > 1)
- 	    GetSelection(w, time, params+1, num_params-1);
-     }
- 
-     /* CASE 2: CUT_BUFFERx */
- 
      switch (selection) {
        case XA_CUT_BUFFER0: buffer = 0; break;
        case XA_CUT_BUFFER1: buffer = 1; break;
--- 292,297 ----
***************
*** 335,343 ****
  	else if (num_params > 1)
  	    GetSelection(w, time, params+1, num_params-1);
      } else {
- 
-         /* CASE 3: a real selection */
- 
  	struct _SelectionList* list;
  	if (--num_params) {
  	    list = XtNew(struct _SelectionList);
--- 315,320 ----
***************
*** 1441,1447 ****
    TextWidget ctx = (TextWidget) w;
  
    /* Let the input method know focus has arrived. */
!   _XawImVASetFocusValues(w, NULL);
    if ( event->xfocus.detail == NotifyPointer ) return;
  
    ctx->text.hasfocus = TRUE; 
--- 1418,1424 ----
    TextWidget ctx = (TextWidget) w;
  
    /* Let the input method know focus has arrived. */
!   _XawImSetFocusValues (w, NULL, 0);
    if ( event->xfocus.detail == NotifyPointer ) return;
  
    ctx->text.hasfocus = TRUE; 
***************
*** 1475,1481 ****
  
    if ((event->xcrossing.detail != NotifyInferior) && event->xcrossing.focus &&
        !ctx->text.hasfocus) {
! 	_XawImVASetFocusValues(w, NULL);
    }
  }
  
--- 1452,1458 ----
  
    if ((event->xcrossing.detail != NotifyInferior) && event->xcrossing.focus &&
        !ctx->text.hasfocus) {
! 	_XawImSetFocusValues(w, NULL, 0);
    }
  }
  
*** -	Fri Jul  7 09:31:52 1995
--- xc/lib/Xaw/TextP.h	Fri Jul  7 09:31:52 1995
***************
*** 1,5 ****
  /*
! * $XConsortium: TextP.h,v 1.53 94/04/17 20:13:08 kaleb Exp $
  */
  
  
--- 1,5 ----
  /*
! * $XConsortium: TextP.h,v 1.54 95/06/14 15:07:27 kaleb Exp $
  */
  
  
***************
*** 220,227 ****
      /* private state, shared w/Source and Sink */
      Boolean	    redisplay_needed; /* in SetValues */
      XawTextSelectionSalt    *salt2;	     /* salted away selections */
- 
-     String	internal_selection; /* stores the selection for later pastage */
  } TextPart;
  
  /*************************************************************
--- 220,225 ----
*** -	Fri Jul  7 09:31:52 1995
--- xc/lib/Xaw/TextTr.c	Fri Jul  7 09:31:52 1995
***************
*** 1,4 ****
! /* $XConsortium: TextTr.c,v 1.19 94/04/17 20:13:16 kaleb Exp $ */
  
  /*
  
--- 1,4 ----
! /* $XConsortium: TextTr.c,v 1.20 95/06/14 15:07:27 kaleb Exp $ */
  
  /*
  
***************
*** 41,53 ****
  
  The Japanese user typically hits their Kanji key when they want to do
  input.  This merely makes sure the input is connected.
! 
! /* INTERNAL SELECTION STORAGE:
! 
!      The Xaw Text now can store its most recent selection in itself, triggered
! by the INTERNAL argument to the extend-end() and insert-selection() routines. 
! Drawback: if anyone is using the CUT_BUFFERs for IPC to and from Xaw-based
! clients (which I doubt:) they will want the CUT_BUFFER left in. */
  
  char *_XawDefaultTextTranslations1 =
  "\
--- 41,47 ----
  
  The Japanese user typically hits their Kanji key when they want to do
  input.  This merely makes sure the input is connected.
! */
  
  char *_XawDefaultTextTranslations1 =
  "\
*** -	Fri Jul  7 09:31:54 1995
--- xc/lib/font/Speedo/speedo.h	Fri Jul  7 09:31:54 1995
***************
*** 1,4 ****
! /* $XConsortium: speedo.h,v 1.6 94/02/07 10:00:41 gildea Exp $ */
  
  /*
  
--- 1,4 ----
! /* $XConsortium: speedo.h,v 1.7 95/06/08 23:20:39 gildea Exp $ */
  
  /*
  
***************
*** 280,286 ****
                                     /*   Bit 14: Clip top if set             */
                                     /*   Bit 15: Clip bottom if set          */
                                     /*   Bits 16-31   not used               */
! #if __STDC__
      void *out_info;                /* information for output module         */
  #else
      char *out_info;
--- 280,286 ----
                                     /*   Bit 14: Clip top if set             */
                                     /*   Bit 15: Clip bottom if set          */
                                     /*   Bits 16-31   not used               */
! #ifdef __STDC__
      void *out_info;                /* information for output module         */
  #else
      char *out_info;
*** -	Fri Jul  7 09:31:55 1995
--- xc/lib/font/Type1/spaces.c	Fri Jul  7 09:31:55 1995
***************
*** 1,4 ****
! /* $XConsortium: spaces.c,v 1.7 94/02/06 16:26:52 gildea Exp $ */
  /* Copyright International Business Machines, Corp. 1991
   * All Rights Reserved
   * Copyright Lexmark International, Inc. 1991
--- 1,4 ----
! /* $XConsortium: spaces.c,v 1.8 95/06/08 23:20:39 gildea Exp $ */
  /* Copyright International Business Machines, Corp. 1991
   * All Rights Reserved
   * Copyright Lexmark International, Inc. 1991
***************
*** 45,52 ****
  #include "arith.h"
  #include "trig.h"
  
! static FindFfcn();
! static FindIfcn();
  /*
  :h3.Entry Points Provided to the TYPE1IMAGER User
  */
--- 45,52 ----
  #include "arith.h"
  #include "trig.h"
  
! static void FindFfcn();
! static void FindIfcn();
  /*
  :h3.Entry Points Provided to the TYPE1IMAGER User
  */
***************
*** 183,189 ****
   
  /*SHARED LINE(S) ORIGINATED HERE*/
  
! #if __STDC__
  #define   pointer          void *
  #else
  #define   pointer          char *
--- 183,189 ----
   
  /*SHARED LINE(S) ORIGINATED HERE*/
  
! #ifdef __STDC__
  #define   pointer          void *
  #else
  #define   pointer          char *
***************
*** 542,548 ****
  being zero:
  */
   
! static FindFfcn(cx, cy, fcnP)
         register double cx,cy;  /* x and y coefficients                       */
         register fractpel (**fcnP)();  /* pointer to function to set          */
  {
--- 542,548 ----
  being zero:
  */
   
! static void FindFfcn(cx, cy, fcnP)
         register double cx,cy;  /* x and y coefficients                       */
         register fractpel (**fcnP)();  /* pointer to function to set          */
  {
***************
*** 565,571 ****
  floating point.
  */
   
! static FindIfcn(cx, cy, icxP, icyP, fcnP)
         register double cx,cy;  /* x and y coefficients                       */
         register fractpel *icxP,*icyP;  /* fixed point coefficients to set    */
         register fractpel (**fcnP)();  /* pointer to function to set          */
--- 565,571 ----
  floating point.
  */
   
! static void FindIfcn(cx, cy, icxP, icyP, fcnP)
         register double cx,cy;  /* x and y coefficients                       */
         register fractpel *icxP,*icyP;  /* fixed point coefficients to set    */
         register fractpel (**fcnP)();  /* pointer to function to set          */
*** -	Fri Jul  7 09:31:55 1995
--- xc/lib/font/Type1/t1io.c	Fri Jul  7 09:31:55 1995
***************
*** 1,4 ****
! /* $XConsortium: t1io.c,v 1.9 94/04/17 20:17:24 gildea Exp $ */
  /* Copyright International Business Machines,Corp. 1991
   * All Rights Reserved
   *
--- 1,4 ----
! /* $XConsortium: t1io.c,v 1.10 95/06/09 22:29:35 gildea Exp $ */
  /* Copyright International Business Machines,Corp. 1991
   * All Rights Reserved
   *
***************
*** 170,176 ****
    return close(f->fd);
  } /* end Close */
  
! #if __STDC__
  #define   pointer          void *
  #else
  #define   pointer          char *
--- 170,176 ----
    return close(f->fd);
  } /* end Close */
  
! #ifdef __STDC__
  #define   pointer          void *
  #else
  #define   pointer          char *
*** -	Fri Jul  7 09:31:56 1995
--- xc/lib/font/fc/fservestr.h	Fri Jul  7 09:31:56 1995
***************
*** 1,4 ****
! /* $XConsortium: fservestr.h,v 1.12 94/02/04 09:15:58 gildea Exp $ */
  /*
   * Copyright 1990 Network Computing Devices
   *
--- 1,4 ----
! /* $XConsortium: fservestr.h,v 1.13 95/06/09 22:16:29 gildea Exp $ */
  /*
   * Copyright 1990 Network Computing Devices
   *
***************
*** 142,148 ****
  } FSReconnectRec, *FSReconnectPtr;
  
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define fsCat(x,y) x##_##y
  #else
  #define fsCat(x,y) x/**/_/**/y
--- 142,148 ----
  } FSReconnectRec, *FSReconnectPtr;
  
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define fsCat(x,y) x##_##y
  #else
  #define fsCat(x,y) x/**/_/**/y
*** -	Fri Jul  7 09:31:57 1995
--- xc/lib/font/fontfile/fontdir.c	Fri Jul  7 09:31:57 1995
***************
*** 1,4 ****
! /* $XConsortium: fontdir.c,v 1.22 94/04/17 20:17:05 gildea Exp $ */
  
  /*
  
--- 1,4 ----
! /* $XConsortium: fontdir.c,v 1.23 95/02/21 14:25:17 mor Exp $ */
  
  /*
  
***************
*** 79,86 ****
--- 79,88 ----
      case FONT_ENTRY_ALIAS:
  	xfree (entry->u.alias.resolved);
  	break;
+ #ifdef NOTYET
      case FONT_ENTRY_BC:
  	break;
+ #endif
      }
  }
  
*** -	Fri Jul  7 09:31:58 1995
--- xc/lib/font/fontfile/fontfile.c	Fri Jul  7 09:31:58 1995
***************
*** 1,4 ****
! /* $XConsortium: fontfile.c,v 1.27 94/04/17 20:17:06 gildea Exp $ */
  
  /*
  
--- 1,4 ----
! /* $XConsortium: fontfile.c,v 1.28 95/02/21 14:17:19 mor Exp $ */
  
  /*
  
***************
*** 289,294 ****
--- 289,295 ----
  				     entry->u.alias.resolved, aliasName, &vals);
  	    ret = FontNameAlias;
  	    break;
+ #ifdef NOTYET
  	case FONT_ENTRY_BC:
  	    bc = &entry->u.bc;
  	    entry = bc->entry;
***************
*** 298,303 ****
--- 299,305 ----
  	    if (ret == Successful && *pFont)
  		(*pFont)->fpe = fpe;
  	    break;
+ #endif
  	default:
  	    ret = BadFontName;
  	}
***************
*** 687,694 ****
      lowerName.length = len;
      lowerName.ndashes = FontFileCountDashes (lowerChars, len);
  
-     if (max <= 0) return result;
- 
      /* Match XLFD patterns */
  
      strcpy (zeroChars, lowerChars);
--- 689,694 ----
***************
*** 947,954 ****
  	    *namelenp = strlen (*namep = alias->resolved);
  	    ret = FontNameAlias;
  	    break;
- 	case FONT_ENTRY_BC:
  #ifdef NOTYET
  	    /* no LFWI for this yet */
  	    bc = &entry->u.bc;
  	    entry = bc->entry;
--- 947,954 ----
  	    *namelenp = strlen (*namep = alias->resolved);
  	    ret = FontNameAlias;
  	    break;
  #ifdef NOTYET
+ 	case FONT_ENTRY_BC:
  	    /* no LFWI for this yet */
  	    bc = &entry->u.bc;
  	    entry = bc->entry;
***************
*** 957,964 ****
      	    strcat (fileName, scalable->fileName);
  	    ret = (*scalable->renderer->GetInfoScalable)
  		    (fpe, *pFontInfo, entry, tmpName, fileName, &bc->vals);
- #endif
  	    break;
  	default:
  	    ret = BadFontName;
  	}
--- 957,964 ----
      	    strcat (fileName, scalable->fileName);
  	    ret = (*scalable->renderer->GetInfoScalable)
  		    (fpe, *pFontInfo, entry, tmpName, fileName, &bc->vals);
  	    break;
+ #endif
  	default:
  	    ret = BadFontName;
  	}
*** -	Fri Jul  7 09:31:59 1995
--- xc/lib/FS/FSlibint.h	Fri Jul  7 09:31:59 1995
***************
*** 1,4 ****
! /* $XConsortium: FSlibint.h,v 1.12 94/04/17 20:15:22 gildea Exp $ */
  
  /*
   * Copyright 1990 Network Computing Devices;
--- 1,4 ----
! /* $XConsortium: FSlibint.h,v 1.13 95/06/08 23:20:39 gildea Exp $ */
  
  /*
   * Copyright 1990 Network Computing Devices;
***************
*** 132,138 ****
   *
   */
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define GetReq(name, req) \
          WORD64ALIGN\
  	if ((svr->bufptr + SIZEOF(fs##name##Req)) > svr->bufmax)\
--- 132,138 ----
   *
   */
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define GetReq(name, req) \
          WORD64ALIGN\
  	if ((svr->bufptr + SIZEOF(fs##name##Req)) > svr->bufmax)\
***************
*** 159,165 ****
  /* GetReqExtra is the same as GetReq, but allocates "n" additional
     bytes after the request. "n" must be a multiple of 4!  */
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define GetReqExtra(name, n, req) \
          WORD64ALIGN\
  	if ((svr->bufptr + SIZEOF(fs##name##Req) + n) > svr->bufmax)\
--- 159,165 ----
  /* GetReqExtra is the same as GetReq, but allocates "n" additional
     bytes after the request. "n" must be a multiple of 4!  */
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define GetReqExtra(name, n, req) \
          WORD64ALIGN\
  	if ((svr->bufptr + SIZEOF(fs##name##Req) + n) > svr->bufmax)\
***************
*** 188,194 ****
   * "rid" is the name of the resource.
   */
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define GetResReq(name, rid, req) \
          WORD64ALIGN\
  	if ((svr->bufptr + SIZEOF(fsResourceReq)) > svr->bufmax)\
--- 188,194 ----
   * "rid" is the name of the resource.
   */
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define GetResReq(name, rid, req) \
          WORD64ALIGN\
  	if ((svr->bufptr + SIZEOF(fsResourceReq)) > svr->bufmax)\
***************
*** 217,223 ****
   * at all.
   */
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define GetEmptyReq(name, req) \
          WORD64ALIGN\
  	if ((svr->bufptr + SIZEOF(fsReq)) > svr->bufmax)\
--- 217,223 ----
   * at all.
   */
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define GetEmptyReq(name, req) \
          WORD64ALIGN\
  	if ((svr->bufptr + SIZEOF(fsReq)) > svr->bufmax)\
***************
*** 327,333 ****
  				 * don't line up with proto */
  
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define FSCat(x,y) x##_##y
  #else
  #define FSCat(x,y) x/**/_/**/y
--- 327,333 ----
  				 * don't line up with proto */
  
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define FSCat(x,y) x##_##y
  #else
  #define FSCat(x,y) x/**/_/**/y
*** -	Fri Jul  7 09:32:00 1995
--- xc/lib/xtrans/Xtrans.c	Fri Jul  7 09:32:00 1995
***************
*** 1,4 ****
! /* $XConsortium: Xtrans.c,v 1.28 94/12/01 16:30:09 kaleb Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
--- 1,4 ----
! /* $XConsortium: Xtrans.c,v 1.31 95/03/28 19:49:02 mor Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
***************
*** 196,204 ****
  
  {
      /*
!      * Address is a string formatted as "protocol/host:port". If the protocol
!      * part is missing, then assume INET. If the protocol part and host part
!      * are missing, then assume local. If a "::" is found then assume DNET.
       */
  
      char	*mybuf, *tmpptr;
--- 196,212 ----
  
  {
      /*
!      * For the font library, the address is a string formatted
!      * as "protocol/host:port[/catalogue]".  Note that the catologue
!      * is optional.  At this time, the catologue info is ignored, but
!      * we have to parse it anyways.
!      *
!      * Other than fontlib, the address is a string formatted
!      * as "protocol/host:port".
!      *
!      * If the protocol part is missing, then assume INET.
!      * If the protocol part and host part are missing, then assume local.
!      * If a "::" is found then assume DNET.
       */
  
      char	*mybuf, *tmpptr;
***************
*** 282,308 ****
  
      if (strlen(_host) == 0)
      {
- #if defined(UNIXCONN) || defined(LOCALCONN)
- 	_host = "local";
- #else
  	TRANS(GetHostname) (hostnamebuf, sizeof (hostnamebuf));
  	_host = hostnamebuf;
- #endif
      }
  
      /* Check for DECnet */
  
      if (*mybuf == ':')
      {
! 	_protocol = "decnet";
  	mybuf++;
      }
  
!     /* The rest is the port */
  
  get_port:
  
      _port = mybuf;
  
      /*
       * Now that we have all of the components, allocate new
--- 290,327 ----
  
      if (strlen(_host) == 0)
      {
  	TRANS(GetHostname) (hostnamebuf, sizeof (hostnamebuf));
  	_host = hostnamebuf;
      }
  
      /* Check for DECnet */
  
      if (*mybuf == ':')
      {
! 	_protocol = "dnet";
  	mybuf++;
      }
  
!     /* Get the port */
  
  get_port:
  
      _port = mybuf;
+ 
+ #if defined(FONT_t) || defined(FS_t)
+     /*
+      * Is there an optional catalogue list?
+      */
+ 
+     if ((mybuf = strchr (mybuf,'/')) != NULL)
+ 	*mybuf ++= '\0';
+ 
+     /*
+      * The rest, if any, is the (currently unused) catalogue list.
+      *
+      * _catalogue = mybuf;
+      */
+ #endif
  
      /*
       * Now that we have all of the components, allocate new
*** -	Fri Jul  7 09:32:01 1995
--- xc/lib/xtrans/Xtrans.h	Fri Jul  7 09:32:01 1995
***************
*** 1,4 ****
! /* $XConsortium: Xtrans.h,v 1.28 94/10/18 15:57:42 mor Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
--- 1,4 ----
! /* $XConsortium: Xtrans.h,v 1.29 95/06/08 23:20:39 gildea Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
***************
*** 64,70 ****
   */
  
  #ifdef X11_t
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define TRANS(func) _X11Trans##func
  #else
  #define TRANS(func) _X11Trans/**/func
--- 64,70 ----
   */
  
  #ifdef X11_t
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define TRANS(func) _X11Trans##func
  #else
  #define TRANS(func) _X11Trans/**/func
***************
*** 72,78 ****
  #endif /* X11_t */
  
  #ifdef XSERV_t
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define TRANS(func) _XSERVTrans##func
  #else
  #define TRANS(func) _XSERVTrans/**/func
--- 72,78 ----
  #endif /* X11_t */
  
  #ifdef XSERV_t
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define TRANS(func) _XSERVTrans##func
  #else
  #define TRANS(func) _XSERVTrans/**/func
***************
*** 81,87 ****
  #endif /* X11_t */
  
  #ifdef XIM_t
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define TRANS(func) _XimXTrans##func
  #else
  #define TRANS(func) _XimXTrans/**/func
--- 81,87 ----
  #endif /* X11_t */
  
  #ifdef XIM_t
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define TRANS(func) _XimXTrans##func
  #else
  #define TRANS(func) _XimXTrans/**/func
***************
*** 89,95 ****
  #endif /* XIM_t */
  
  #ifdef FS_t
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define TRANS(func) _FSTrans##func
  #else
  #define TRANS(func) _FSTrans/**/func
--- 89,95 ----
  #endif /* XIM_t */
  
  #ifdef FS_t
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define TRANS(func) _FSTrans##func
  #else
  #define TRANS(func) _FSTrans/**/func
***************
*** 97,103 ****
  #endif /* FS_t */
  
  #ifdef FONT_t
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define TRANS(func) _FontTrans##func
  #else
  #define TRANS(func) _FontTrans/**/func
--- 97,103 ----
  #endif /* FS_t */
  
  #ifdef FONT_t
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define TRANS(func) _FontTrans##func
  #else
  #define TRANS(func) _FontTrans/**/func
***************
*** 105,111 ****
  #endif /* FONT_t */
  
  #ifdef ICE_t
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define TRANS(func) _IceTrans##func
  #else
  #define TRANS(func) _IceTrans/**/func
--- 105,111 ----
  #endif /* FONT_t */
  
  #ifdef ICE_t
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define TRANS(func) _IceTrans##func
  #else
  #define TRANS(func) _IceTrans/**/func
***************
*** 113,119 ****
  #endif /* ICE_t */
  
  #ifdef TEST_t
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define TRANS(func) _TESTTrans##func
  #else
  #define TRANS(func) _TESTTrans/**/func
--- 113,119 ----
  #endif /* ICE_t */
  
  #ifdef TEST_t
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define TRANS(func) _TESTTrans##func
  #else
  #define TRANS(func) _TESTTrans/**/func
***************
*** 121,127 ****
  #endif /* TEST_t */
  
  #if !defined(TRANS)
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define TRANS(func) _XTrans##func
  #else
  #define TRANS(func) _XTrans/**/func
--- 121,127 ----
  #endif /* TEST_t */
  
  #if !defined(TRANS)
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define TRANS(func) _XTrans##func
  #else
  #define TRANS(func) _XTrans/**/func
*** -	Fri Jul  7 09:32:01 1995
--- xc/lib/xtrans/Xtransdnet.c	Fri Jul  7 09:32:01 1995
***************
*** 1,4 ****
! /* $XConsortium: Xtransdnet.c,v 1.15 94/10/18 15:53:05 mor Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
--- 1,4 ----
! /* $XConsortium: Xtransdnet.c,v 1.16 95/02/10 17:54:09 mor Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
***************
*** 668,674 ****
  
  Xtransport	TRANS(DNETFuncs) = {
      /* DNET Interface */
!     "decnet",
      0,
  #ifdef TRANS_CLIENT
      TRANS(DNETOpenCOTSClient),
--- 668,674 ----
  
  Xtransport	TRANS(DNETFuncs) = {
      /* DNET Interface */
!     "dnet",
      0,
  #ifdef TRANS_CLIENT
      TRANS(DNETOpenCOTSClient),
*** -	Fri Jul  7 09:32:03 1995
--- xc/lib/xtrans/Xtranslcl.c	Fri Jul  7 09:32:02 1995
***************
*** 1,4 ****
! /* $XConsortium: Xtranslcl.c,v 1.21 95/01/19 18:06:04 mor Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
--- 1,4 ----
! /* $XConsortium: Xtranslcl.c,v 1.23 95/04/28 15:23:33 mor Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
***************
*** 1796,1801 ****
--- 1796,1841 ----
  
  #ifdef TRANS_CLIENT
  
+ #ifdef NEED_UTSNAME
+ #include <sys/utsname.h>
+ #endif
+ 
+ /*
+  * Make sure 'host' is really local.
+  */
+ 
+ static int
+ HostReallyLocal (host)
+ 
+ char *host;
+ 
+ {
+     /*
+      * The 'host' passed to this function may have been generated
+      * by either uname() or gethostname().  We try both if possible.
+      */
+ 
+ #ifdef NEED_UTSNAME
+     struct utsname name;
+ #endif
+     char buf[256];
+ 
+ #ifdef NEED_UTSNAME
+     if (uname (&name) >= 0 && strcmp (host, name.nodename) == 0)
+ 	return (1);
+ #endif
+ 
+     buf[0] = '\0';
+     (void) gethostname (buf, 256);
+     buf[255] = '\0';
+ 
+     if (strcmp (host, buf) == 0)
+ 	return (1);
+ 
+     return (0);
+ }
+ 
+ 
  static XtransConnInfo
  TRANS(LocalOpenClient)(type, protocol, host, port)
  
***************
*** 1809,1817 ****
      LOCALtrans2dev *transptr;
      XtransConnInfo ciptr;
      int index;
!     
      PRMSG(3,"TRANS(LocalOpenClient)()\n", 0,0,0 );
      
  #if defined(X11_t)
      /*
       * X has a well known port, that is transport dependant. It is easier
--- 1849,1874 ----
      LOCALtrans2dev *transptr;
      XtransConnInfo ciptr;
      int index;
! 
      PRMSG(3,"TRANS(LocalOpenClient)()\n", 0,0,0 );
      
+     /*
+      * Make sure 'host' is really local.  If not, we return failure.
+      * The reason we make this check is because a process may advertise
+      * a "local" address for which it can accept connections, but if a
+      * process on a remote machine tries to connect to this address,
+      * we know for sure it will fail.
+      */
+ 
+     if (strcmp (host, "unix") != 0 && !HostReallyLocal (host))
+     {
+ 	PRMSG (1,
+ 	   "TRANS(LocalOpenClient): Cannot connect to non-local host %s\n",
+ 	       host, 0, 0);
+ 	return NULL;
+     }
+ 
+ 
  #if defined(X11_t)
      /*
       * X has a well known port, that is transport dependant. It is easier
*** -	Fri Jul  7 09:32:05 1995
--- xc/lib/xtrans/Xtranssock.c	Fri Jul  7 09:32:05 1995
***************
*** 1,4 ****
! /* $XConsortium: Xtranssock.c,v 1.34 95/01/12 18:25:25 kaleb Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
--- 1,4 ----
! /* $XConsortium: Xtranssock.c,v 1.36 95/04/28 15:23:33 mor Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
***************
*** 1352,1358 ****
--- 1352,1452 ----
  #endif /* TCPCONN */
  
  
+ 
  #ifdef UNIXCONN
+ 
+ /*
+  * Make sure 'host' is really local.
+  */
+ 
+ static int
+ UnixHostReallyLocal (host)
+ 
+ char *host;
+ 
+ {
+     char hostnamebuf[256];
+ 
+     TRANS(GetHostname) (hostnamebuf, sizeof (hostnamebuf));
+ 
+     if (strcmp (hostnamebuf, host) == 0)
+     {
+ 	return (1);
+     }
+     else
+     {
+ 	/*
+ 	 * A host may have more than one network address.  If any of the
+ 	 * network addresses of 'host' (specified to the connect call)
+ 	 * match any of the network addresses of 'hostname' (determined
+ 	 * by TRANS(GetHostname)), then the two hostnames are equivalent,
+ 	 * and we know that 'host' is really a local host.
+ 	 */
+ 
+ 	struct hostent *specified_local_host;
+ 	struct hostent *actual_local_host;
+ 	char specified_local_addr_list[10][4];
+ 	int scount, equiv, i, j;
+ 
+ 	if ((specified_local_host = gethostbyname (host)) == NULL)
+ 	    return (0);
+ 
+ 	scount = 0;
+ 	while (specified_local_host->h_addr_list[scount] && scount <= 8)
+ 	{
+ 	    /*
+ 	     * The 2nd call to gethostname() overrides the data
+ 	     * from the 1st call, so we must save the address list.
+ 	     */
+ 
+ 	    specified_local_addr_list[scount][0] =
+ 		specified_local_host->h_addr_list[scount][0];
+ 	    specified_local_addr_list[scount][1] =
+ 		specified_local_host->h_addr_list[scount][1];
+ 	    specified_local_addr_list[scount][2] =
+ 		specified_local_host->h_addr_list[scount][2];
+ 	    specified_local_addr_list[scount][3] =
+ 		specified_local_host->h_addr_list[scount][3];
+ 	    scount++;
+ 	}
+ 
+ 	if ((actual_local_host = gethostbyname (hostnamebuf)) == NULL)
+ 	    return (0);
+ 
+ 	equiv = 0;
+ 	i = 0;
+ 
+ 	while (i < scount && !equiv)
+ 	{
+ 	    j = 0;
+ 
+ 	    while (actual_local_host->h_addr_list[j])
+ 	    {
+ 		if ((specified_local_addr_list[i][0] ==
+ 		     actual_local_host->h_addr_list[j][0]) &&
+ 		    (specified_local_addr_list[i][1] ==
+ 		     actual_local_host->h_addr_list[j][1]) &&
+ 		    (specified_local_addr_list[i][2] ==
+ 		     actual_local_host->h_addr_list[j][2]) &&
+ 		    (specified_local_addr_list[i][3] ==
+ 		     actual_local_host->h_addr_list[j][3]))
+ 		{
+ 		    /* They're equal, so we're done */
+ 		    
+ 		    equiv = 1;
+ 		    break;
+ 		}
+ 
+ 		j++;
+ 	    }
+ 
+ 	    i++;
+ 	}
+ 	
+     return (equiv);
+     }
+ }
+ 
  static int
  TRANS(SocketUNIXConnect) (ciptr, host, port)
  
***************
*** 1372,1377 ****
--- 1466,1492 ----
  
      PRMSG (2,"TRANS(SocketUNIXConnect) (%d,%s,%s)\n", ciptr->fd, host, port);
      
+     /*
+      * Make sure 'host' is really local.  If not, we return failure.
+      * The reason we make this check is because a process may advertise
+      * a "local" network ID for which it can accept connections, but if
+      * a process on a remote machine tries to connect to this network ID,
+      * we know for sure it will fail.
+      */
+ 
+     if (strcmp (host, "unix") != 0 && !UnixHostReallyLocal (host))
+     {
+ 	PRMSG (1,
+ 	   "TRANS(SocketUNIXConnect): Cannot connect to non-local host %s\n",
+ 	       host, 0, 0);
+ 	return TRANS_CONNECT_FAILED;
+     }
+ 
+ 
+     /*
+      * Check the port.
+      */
+ 
      if (!port || !*port)
      {
  	PRMSG (1,"TRANS(SocketUNIXConnect): Missing port specification\n",
*** -	Fri Jul  7 09:32:06 1995
--- xc/lib/xtrans/Xtransutil.c	Fri Jul  7 09:32:06 1995
***************
*** 1,4 ****
! /* $XConsortium: Xtransutil.c,v 1.18 94/10/18 15:57:42 mor Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
--- 1,4 ----
! /* $XConsortium: Xtransutil.c,v 1.19 95/02/10 17:54:09 mor Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
***************
*** 272,278 ****
  
  	networkId = (char *) malloc (
  	    13 + strlen (hostnamebuf) + saddr->sdn_objnamel);
! 	sprintf (networkId, "decnet/%s::%s",
  	    hostnamebuf, saddr->sdn_objname);
  	break;
      }
--- 272,278 ----
  
  	networkId = (char *) malloc (
  	    13 + strlen (hostnamebuf) + saddr->sdn_objnamel);
! 	sprintf (networkId, "dnet/%s::%s",
  	    hostnamebuf, saddr->sdn_objname);
  	break;
      }
*** -	Fri Jul  7 09:32:06 1995
--- xc/lib/ICE/shutdown.c	Fri Jul  7 09:32:06 1995
***************
*** 1,4 ****
! /* $XConsortium: shutdown.c,v 1.16 94/08/19 15:49:57 mor Exp $ */
  /******************************************************************************
  
  
--- 1,4 ----
! /* $XConsortium: shutdown.c,v 1.17 95/02/10 15:44:33 mor Exp $ */
  /******************************************************************************
  
  
***************
*** 282,288 ****
  	}
      }
  
!     if (iceConn->trans_conn && iceConn->io_ok)
  	_IceTransClose (iceConn->trans_conn);
  
      if (iceConn->connection_string)
--- 282,288 ----
  	}
      }
  
!     if (iceConn->trans_conn)
  	_IceTransClose (iceConn->trans_conn);
  
      if (iceConn->connection_string)
*** -	Fri Jul  7 09:32:07 1995
--- xc/lib/XIE/XIElibint.h	Fri Jul  7 09:32:07 1995
***************
*** 1,4 ****
! /* $XConsortium: XIElibint.h,v 1.7 94/04/17 20:18:17 rws Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
--- 1,4 ----
! /* $XConsortium: XIElibint.h,v 1.8 95/06/08 23:20:39 gildea Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
***************
*** 158,164 ****
   * Request names and opcodes.
   */
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define REQNAME(_name_) xie##_name_##Req
  #define REQOPCODE(_name_) X_ie##_name_
  #define REQSIZE(_name_) sz_xie##_name_##Req
--- 158,164 ----
   * Request names and opcodes.
   */
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define REQNAME(_name_) xie##_name_##Req
  #define REQOPCODE(_name_) X_ie##_name_
  #define REQSIZE(_name_) sz_xie##_name_##Req
*** -	Fri Jul  7 09:32:08 1995
--- xc/lib/XIE/elements.h	Fri Jul  7 09:32:08 1995
***************
*** 1,4 ****
! /* $XConsortium: elements.h,v 1.4 94/04/17 20:18:22 mor Exp $ */
  
  /*
  
--- 1,4 ----
! /* $XConsortium: elements.h,v 1.5 95/06/08 23:20:39 gildea Exp $ */
  
  /*
  
***************
*** 33,39 ****
  #ifndef _ELEMENTS_H_
  #define _ELEMENTS_H_
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define ELEM_NAME(_name_) xieFlo##_name_
  #define ELEM_SIZE(_name_) sz_xieFlo##_name_
  #else
--- 33,39 ----
  #ifndef _ELEMENTS_H_
  #define _ELEMENTS_H_
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define ELEM_NAME(_name_) xieFlo##_name_
  #define ELEM_SIZE(_name_) sz_xieFlo##_name_
  #else
*** -	Fri Jul  7 09:32:09 1995
--- xc/lib/XIE/XIElib.h	Fri Jul  7 09:32:09 1995
***************
*** 1,4 ****
! /* $XConsortium: XIElib.h,v 1.11 94/12/19 16:57:13 mor Exp $ */
  
  /*
  
--- 1,4 ----
! /* $XConsortium: XIElib.h,v 1.12 95/04/28 18:01:11 mor Exp $ */
  
  /*
  
***************
*** 884,889 ****
--- 884,890 ----
      unsigned int	elem_type;
      unsigned int	technique_number;
      unsigned int	num_tech_params;
+     XieTechniqueGroup	tech_group;
  } XieFloTechniqueError;
  
  typedef struct {
*** -	Fri Jul  7 09:32:09 1995
--- xc/lib/XIE/errors.c	Fri Jul  7 09:32:09 1995
***************
*** 1,4 ****
! /* $XConsortium: errors.c,v 1.4 94/04/17 20:18:22 rws Exp $ */
  
  /*
  
--- 1,4 ----
! /* $XConsortium: errors.c,v 1.5 95/04/28 18:01:11 mor Exp $ */
  
  /*
  
***************
*** 119,124 ****
--- 119,125 ----
  
  	host_error->technique_number = wire_error->techniqueNumber;
  	host_error->num_tech_params  = wire_error->lenTechParams;
+ 	host_error->tech_group = wire_error->techniqueGroup;
  	break;
      }
  
*** -	Fri Jul  7 09:32:10 1995
--- xc/lib/XIE/init.c	Fri Jul  7 09:32:10 1995
***************
*** 1,4 ****
! /* $XConsortium: init.c,v 1.10 94/04/17 20:18:25 rws Exp $ */
  
  /*
  
--- 1,4 ----
! /* $XConsortium: init.c,v 1.11 95/04/28 18:01:11 mor Exp $ */
  
  /*
  
***************
*** 459,464 ****
--- 459,466 ----
  		tech_error->technique_number);
  	    fprintf (fp, "  Number of technique params:  %d\n",
  		tech_error->num_tech_params);
+ 	    fprintf (fp, "  Technique group:  %d\n",
+ 		tech_error->tech_group);
  	    break;
  
  	case xieErrNoFloValue:
*** -	Fri Jul  7 09:32:11 1995
--- xc/lib/PEX5/PEXlibint.h	Fri Jul  7 09:32:11 1995
***************
*** 1,4 ****
! /* $XConsortium: PEXlibint.h,v 1.17 94/04/17 20:22:24 rws Exp $ */
  
  /******************************************************************************
  
--- 1,4 ----
! /* $XConsortium: PEXlibint.h,v 1.18 95/06/08 23:20:39 gildea Exp $ */
  
  /******************************************************************************
  
***************
*** 270,276 ****
   * Request names and opcodes.
   */
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define REQNAME(_name_) pex##_name_##Req
  #define REQOPCODE(_name_) PEXRC##_name_
  #define REQSIZE(_name_) sz_pex##_name_##Req
--- 270,276 ----
   * Request names and opcodes.
   */
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define REQNAME(_name_) pex##_name_##Req
  #define REQOPCODE(_name_) PEXRC##_name_
  #define REQSIZE(_name_) sz_pex##_name_##Req
*** -	Fri Jul  7 09:32:12 1995
--- xc/lib/PEX5/pl_extract.h	Fri Jul  7 09:32:12 1995
***************
*** 1,4 ****
! /* $XConsortium: pl_extract.h,v 1.4 94/04/17 20:22:29 mor Exp $ */
  /*
  
  Copyright (c) 1992  X Consortium
--- 1,4 ----
! /* $XConsortium: pl_extract.h,v 1.5 95/06/08 23:20:39 gildea Exp $ */
  /*
  
  Copyright (c) 1992  X Consortium
***************
*** 246,252 ****
  /* ------------------------------------------------------------------------ */
  
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define GET_TEMP(_pexType, _tFoo, _foo) GET_TEMP_##_pexType (_tFoo, _foo);
  #else
  #define GET_TEMP(_pexType, _tFoo, _foo) GET_TEMP_/**/_pexType (_tFoo, _foo);
--- 246,252 ----
  /* ------------------------------------------------------------------------ */
  
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define GET_TEMP(_pexType, _tFoo, _foo) GET_TEMP_##_pexType (_tFoo, _foo);
  #else
  #define GET_TEMP(_pexType, _tFoo, _foo) GET_TEMP_/**/_pexType (_tFoo, _foo);
***************
*** 398,404 ****
  /*   EXTRACT_FOOFP and EXTRACT_LISTOF_FOOFP    			    	    */
  /* ------------------------------------------------------------------------ */
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define DOEXTRACT(_pexType, _src, _dst, _fpConvert, _fpFormat) \
      DOEXTRACT_##_pexType (_src, _dst, _fpConvert, _fpFormat)
  #else
--- 398,404 ----
  /*   EXTRACT_FOOFP and EXTRACT_LISTOF_FOOFP    			    	    */
  /* ------------------------------------------------------------------------ */
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define DOEXTRACT(_pexType, _src, _dst, _fpConvert, _fpFormat) \
      DOEXTRACT_##_pexType (_src, _dst, _fpConvert, _fpFormat)
  #else
*** -	Fri Jul  7 09:32:13 1995
--- xc/lib/PEX5/pl_oc_util.h	Fri Jul  7 09:32:13 1995
***************
*** 1,4 ****
! /* $XConsortium: pl_oc_util.h,v 1.11 94/04/17 20:22:42 mor Exp $ */
  
  /******************************************************************************
  
--- 1,4 ----
! /* $XConsortium: pl_oc_util.h,v 1.12 95/06/08 23:20:39 gildea Exp $ */
  
  /******************************************************************************
  
***************
*** 217,223 ****
   * Output Command names and opcodes.
   */
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define OCNAME(_name_) pex##_name_
  #define OCOPCODE(_name_) PEXOC##_name_
  #define OCSIZE(_name_) sz_pex##_name_
--- 217,223 ----
   * Output Command names and opcodes.
   */
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define OCNAME(_name_) pex##_name_
  #define OCOPCODE(_name_) PEXOC##_name_
  #define OCSIZE(_name_) sz_pex##_name_
***************
*** 464,470 ****
   * Generic macros to store OC data.
   * ------------------------------------------------------------------------- */
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  
  #define STORE_LIST(_name, _count, _pList, _pBuf) \
      STORE_LISTOF_##_name (_count, _pList, _pBuf)
--- 464,470 ----
   * Generic macros to store OC data.
   * ------------------------------------------------------------------------- */
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  
  #define STORE_LIST(_name, _count, _pList, _pBuf) \
      STORE_LISTOF_##_name (_count, _pList, _pBuf)
*** -	Fri Jul  7 09:32:14 1995
--- xc/lib/PEX5/pl_store.h	Fri Jul  7 09:32:14 1995
***************
*** 1,4 ****
! /* $XConsortium: pl_store.h,v 1.3 94/04/17 20:22:46 mor Exp $ */
  /*
  
  Copyright (c) 1992  X Consortium
--- 1,4 ----
! /* $XConsortium: pl_store.h,v 1.4 95/06/08 23:20:39 gildea Exp $ */
  /*
  
  Copyright (c) 1992  X Consortium
***************
*** 213,219 ****
  /* ------------------------------------------------------------------------ */
  
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define PUT_TEMP(_pexType, _foo, _tFoo) PUT_TEMP_##_pexType (_foo, _tFoo);
  #else
  #define PUT_TEMP(_pexType, _foo, _tFoo) PUT_TEMP_/**/_pexType (_foo, _tFoo);
--- 213,219 ----
  /* ------------------------------------------------------------------------ */
  
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define PUT_TEMP(_pexType, _foo, _tFoo) PUT_TEMP_##_pexType (_foo, _tFoo);
  #else
  #define PUT_TEMP(_pexType, _foo, _tFoo) PUT_TEMP_/**/_pexType (_foo, _tFoo);
***************
*** 341,347 ****
  /*   STORE_FOOFP and STORE_LISTOF_FOOFP				    	    */
  /* ------------------------------------------------------------------------ */
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define DOSTORE(_pexType, _src, _dst, _fpConvert, _fpFormat) \
      DOSTORE_##_pexType (_src, _dst, _fpConvert, _fpFormat)
  #else
--- 341,347 ----
  /*   STORE_FOOFP and STORE_LISTOF_FOOFP				    	    */
  /* ------------------------------------------------------------------------ */
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define DOSTORE(_pexType, _src, _dst, _fpConvert, _fpFormat) \
      DOSTORE_##_pexType (_src, _dst, _fpConvert, _fpFormat)
  #else
*** -	Fri Jul  7 09:32:15 1995
--- xc/programs/Xserver/include/os.h	Fri Jul  7 09:32:15 1995
***************
*** 46,52 ****
  
  ******************************************************************/
  
! /* $XConsortium: os.h,v 1.64 95/01/05 19:50:01 kaleb Exp $ */
  
  #ifndef OS_H
  #define OS_H
--- 46,52 ----
  
  ******************************************************************/
  
! /* $XConsortium: os.h,v 1.64.1.1 95/06/12 17:13:50 mor Exp $ */
  
  #ifndef OS_H
  #define OS_H
***************
*** 100,107 ****
  #endif /* defined(__HIGHC__) */
  
  
! #if defined(__GNUC__) && !defined(alloca)
  #define alloca __builtin_alloca
  #else
  
  /*
--- 100,111 ----
  #endif /* defined(__HIGHC__) */
  
  
! #ifdef __GNUC__
! #ifndef alloca
  #define alloca __builtin_alloca
+ #endif /* !alloca */
+ #define ALLOCATE_LOCAL(size) alloca((int)(size))
+ #define DEALLOCATE_LOCAL(ptr)  /* as nothing */
  #else
  
  /*
***************
*** 653,657 ****
--- 657,673 ----
      int /*i*/
  #endif
  );
+ 
+ #ifdef LBX
+ extern ClientPtr AllocPiggybackConnection(
+ #if NeedFunctionPrototypes
+     ClientPtr /* client */,
+     int (* /* read */ )(),
+     int (* /* write*/)(),
+     void (* /* close */)()
+ #endif
+ );
+ 
+ #endif /* LBX */
  
  #endif /* OS_H */
*** -	Fri Jul  7 09:32:17 1995
--- xc/programs/Xserver/dix/swaprep.c	Fri Jul  7 09:32:17 1995
***************
*** 46,52 ****
  
  ********************************************************/
  
! /* $XConsortium: swaprep.c,v 1.42 94/04/17 20:26:44 dpw Exp $ */
  
  #include "X.h"
  #define NEED_REPLIES
--- 46,52 ----
  
  ********************************************************/
  
! /* $XConsortium: swaprep.c,v 1.43 95/05/02 19:41:30 mor Exp $ */
  
  #include "X.h"
  #define NEED_REPLIES
***************
*** 420,426 ****
      (void)WriteToClient(pClient, size, (char *) pRep);
  }
  
! static void
  SwapCharInfo(pInfo)
      xCharInfo	*pInfo;
  {
--- 420,429 ----
      (void)WriteToClient(pClient, size, (char *) pRep);
  }
  
! #ifndef LBX
! static
! #endif
! void
  SwapCharInfo(pInfo)
      xCharInfo	*pInfo;
  {
*** -	Fri Jul  7 09:32:18 1995
--- xc/programs/Xserver/mfb/mergerop.h	Fri Jul  7 09:32:18 1995
***************
*** 1,5 ****
  /*
!  * $XConsortium: mergerop.h,v 1.10 94/04/17 20:28:14 dpw Exp $
   *
  Copyright (c) 1989  X Consortium
  
--- 1,5 ----
  /*
!  * $XConsortium: mergerop.h,v 1.11 95/06/08 23:20:39 gildea Exp $
   *
  Copyright (c) 1989  X Consortium
  
***************
*** 178,184 ****
  #define MROP_PREBUILT_MASK(src,dst,mask)    MROP_MASK(src,dst,mask)
  #endif
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define MROP_NAME_CAT(prefix,suffix)	prefix##suffix
  #else
  #define MROP_NAME_CAT(prefix,suffix)	prefix/**/suffix
--- 178,184 ----
  #define MROP_PREBUILT_MASK(src,dst,mask)    MROP_MASK(src,dst,mask)
  #endif
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define MROP_NAME_CAT(prefix,suffix)	prefix##suffix
  #else
  #define MROP_NAME_CAT(prefix,suffix)	prefix/**/suffix
*** -	Fri Jul  7 09:32:19 1995
--- xc/programs/Xserver/cfb/cfbmap.h	Fri Jul  7 09:32:19 1995
***************
*** 1,5 ****
  /*
!  * $XConsortium: cfbmap.h,v 1.10 94/09/22 21:12:06 dpw Exp $
   *
  Copyright (c) 1991  X Consortium
  
--- 1,5 ----
  /*
!  * $XConsortium: cfbmap.h,v 1.11 95/06/08 23:20:39 gildea Exp $
   *
  Copyright (c) 1991  X Consortium
  
***************
*** 35,41 ****
  
  #if PSZ != 8
  #if PSZ == 32
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define NAME(subname) cfb32##subname
  #else
  #define NAME(subname) cfb32/**/subname
--- 35,41 ----
  
  #if PSZ != 8
  #if PSZ == 32
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define NAME(subname) cfb32##subname
  #else
  #define NAME(subname) cfb32/**/subname
***************
*** 43,49 ****
  #endif
  
  #if PSZ == 16
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define NAME(subname) cfb16##subname
  #else
  #define NAME(subname) cfb16/**/subname
--- 43,49 ----
  #endif
  
  #if PSZ == 16
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define NAME(subname) cfb16##subname
  #else
  #define NAME(subname) cfb16/**/subname
***************
*** 51,57 ****
  #endif
  
  #if PSZ == 4
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define NAME(subname) cfb4##subname
  #else
  #define NAME(subname) cfb4/**/subname
--- 51,57 ----
  #endif
  
  #if PSZ == 4
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define NAME(subname) cfb4##subname
  #else
  #define NAME(subname) cfb4/**/subname
***************
*** 62,68 ****
  cfb can not hack PSZ yet
  #endif
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define CATNAME(prefix,subname) prefix##subname
  #else
  #define CATNAME(prefix,subname) prefix/**/subname
--- 62,68 ----
  cfb can not hack PSZ yet
  #endif
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define CATNAME(prefix,subname) prefix##subname
  #else
  #define CATNAME(prefix,subname) prefix/**/subname
*** -	Fri Jul  7 09:32:20 1995
--- xc/programs/Xserver/cfb/cfbrrop.h	Fri Jul  7 09:32:19 1995
***************
*** 1,5 ****
  /*
!  * $XConsortium: cfbrrop.h,v 1.9 94/04/17 20:29:00 dpw Exp $
   *
  Copyright (c) 1989  X Consortium
  
--- 1,5 ----
  /*
!  * $XConsortium: cfbrrop.h,v 1.10 95/06/08 23:20:39 gildea Exp $
   *
  Copyright (c) 1989  X Consortium
  
***************
*** 144,150 ****
      }
  #endif
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define RROP_NAME_CAT(prefix,suffix)	prefix##suffix
  #else
  #define RROP_NAME_CAT(prefix,suffix)	prefix/**/suffix
--- 144,150 ----
      }
  #endif
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define RROP_NAME_CAT(prefix,suffix)	prefix##suffix
  #else
  #define RROP_NAME_CAT(prefix,suffix)	prefix/**/suffix
*** -	Fri Jul  7 09:32:21 1995
--- xc/programs/Xserver/os/access.c	Fri Jul  7 09:32:20 1995
***************
*** 1,4 ****
! /* $XConsortium: access.c,v 1.75 94/11/21 18:27:47 kaleb Exp $ */
  /***********************************************************
  
  Copyright (c) 1987  X Consortium
--- 1,4 ----
! /* $XConsortium: access.c,v 1.76 95/04/06 16:10:29 mor Exp $ */
  /***********************************************************
  
  Copyright (c) 1987  X Consortium
***************
*** 1121,1127 ****
      switch (saddr->sa_family)
      {
      case AF_UNSPEC:
! #ifdef UNIXCONN
      case AF_UNIX:
  #endif
          return FamilyLocal;
--- 1121,1127 ----
      switch (saddr->sa_family)
      {
      case AF_UNSPEC:
! #if defined(UNIXCONN) || defined(LOCALCONN)
      case AF_UNIX:
  #endif
          return FamilyLocal;
*** -	Fri Jul  7 09:32:23 1995
--- xc/programs/Xserver/os/connection.c	Fri Jul  7 09:32:22 1995
***************
*** 1,4 ****
! /* $XConsortium: connection.c,v 1.190 94/11/08 20:47:43 mor Exp $ */
  /***********************************************************
  
  Copyright (c) 1987, 1989  X Consortium
--- 1,4 ----
! /* $XConsortium: connection.c,v 1.190.1.1 95/06/12 17:17:15 mor Exp $ */
  /***********************************************************
  
  Copyright (c) 1987, 1989  X Consortium
***************
*** 73,79 ****
  #include <sys/socket.h>
  
  #include <signal.h>
- #include <setjmp.h>
  
  #ifdef hpux
  #include <sys/utsname.h>
--- 73,78 ----
***************
*** 393,399 ****
  	switch (saddr->sa_family)
  	{
  	case AF_UNSPEC:
! #ifdef UNIXCONN
  	case AF_UNIX:
  #endif
  	    strcpy(addr, "local host");
--- 392,398 ----
  	switch (saddr->sa_family)
  	{
  	case AF_UNSPEC:
! #if defined(UNIXCONN) || defined(LOCALCONN)
  	case AF_UNIX:
  #endif
  	    strcpy(addr, "local host");
***************
*** 514,528 ****
  
  #ifdef LBX
  
- XtransConnInfo
- ClientTransportObject(client)
-     ClientPtr	client;
- {
-     OsCommPtr oc = (OsCommPtr) client->osPrivate;
- 
-     return oc->trans_conn;
- }
- 
  int
  ClientConnectionNumber (client)
      ClientPtr	client;
--- 513,518 ----
***************
*** 592,597 ****
--- 582,598 ----
      client->public.uncompressedWriteToClient = UncompressWriteToClient;
      client->public.requestLength = StandardRequestLength;
      return client;
+ }
+ 
+ ClientPtr
+ AllocPiggybackConnection (client, Read, Writev, Close)
+     ClientPtr client;
+     int	    (*Read)();
+     int	    (*Writev)();
+     void    (*Close)();
+ {
+     OsCommPtr oc = (OsCommPtr) client->osPrivate;
+     return AllocNewConnection(oc->trans_conn, oc->fd, Read, Writev, Close);
  }
  
  void
*** -	Fri Jul  7 09:32:25 1995
--- xc/programs/Xserver/os/k5auth.c	Fri Jul  7 09:32:24 1995
***************
*** 1,4 ****
! /* $XConsortium: k5auth.c,v 1.8 94/04/17 20:27:02 gildea Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
--- 1,4 ----
! /* $XConsortium: k5auth.c,v 1.9 95/04/06 16:10:29 mor Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
***************
*** 304,312 ****
  	    krb5_free_creds(creds);
  	return(SendConnSetup(client, "Krb5 stage1: getpeername failed"));
      }
!     if (cli_net_addr.sa_family == AF_UNSPEC ||
! #ifdef UNIXCONN
! 	cli_net_addr.sa_family == AF_UNIX
  #endif
  	)			/* assume local host */
      {
--- 304,312 ----
  	    krb5_free_creds(creds);
  	return(SendConnSetup(client, "Krb5 stage1: getpeername failed"));
      }
!     if (cli_net_addr.sa_family == AF_UNSPEC
! #if defined(UNIXCONN) || defined(LOCALCONN)
! 	|| cli_net_addr.sa_family == AF_UNIX
  #endif
  	)			/* assume local host */
      {
*** -	Fri Jul  7 09:32:25 1995
--- xc/programs/Xserver/hw/hp/input/cr16.s	Fri Jul  7 09:32:25 1995
***************
*** 1,4 ****
! ; $XConsortium: cr16.s,v 1.1 93/08/08 12:58:34 rws Exp $
          .SPACE  $TEXT$
          .SUBSPA $CODE$
          .export cr16
--- 1,4 ----
! ; $XConsortium: cr16.s,v 1.2 95/06/15 15:25:19 dpw Exp $
          .SPACE  $TEXT$
          .SUBSPA $CODE$
          .export cr16
***************
*** 8,11 ****
--- 8,12 ----
  cr16
          bv      (%rp)
  	mfctl	16,%ret0
+ 	.EXIT
          .PROCEND
*** -	Fri Jul  7 09:32:27 1995
--- xc/programs/Xserver/hw/sun/sunGX.c	Fri Jul  7 09:32:27 1995
***************
*** 1,5 ****
  #ifndef lint
! static char *rid="$XConsortium: sunGX.c,v 1.26 94/04/17 20:29:38 kaleb Exp $";
  #endif /* lint */
  /*
  Copyright (c) 1991  X Consortium
--- 1,5 ----
  #ifndef lint
! static char *rid="$XConsortium: sunGX.c,v 1.27 95/06/15 18:32:58 dpw Exp $";
  #endif /* lint */
  /*
  Copyright (c) 1991  X Consortium
***************
*** 1483,1490 ****
  		saveAddr = 0;
  	    else
  		save = *saveAddr;
- 	    gx->alinex = x;
  	    gx->aliney = y;
  	    GXDrawDone(gx,r);
  	    GXWait(gx,r);
  	    if (saveAddr)
--- 1483,1490 ----
  		saveAddr = 0;
  	    else
  		save = *saveAddr;
  	    gx->aliney = y;
+ 	    gx->alinex = x;
  	    GXDrawDone(gx,r);
  	    GXWait(gx,r);
  	    if (saveAddr)
*** -	Fri Jul  7 09:32:28 1995
--- xc/programs/Xserver/hw/xfree86/SuperProbe/OS_SYSV.c	Fri Jul  7 09:32:28 1995
***************
*** 25,31 ****
   *
   */
  
! /* $XConsortium: OS_SYSV.c,v 1.5 95/01/16 13:16:18 kaleb Exp $ */
  /* $XFree86: xc/programs/Xserver/hw/xfree86/SuperProbe/OS_SYSV.c,v 3.5 1995/01/07 04:02:38 dawes Exp $ */
  
  #include "Probe.h"
--- 25,31 ----
   *
   */
  
! /* $XConsortium: OS_SYSV.c,v 1.7 95/03/20 15:48:29 kaleb Exp $ */
  /* $XFree86: xc/programs/Xserver/hw/xfree86/SuperProbe/OS_SYSV.c,v 3.5 1995/01/07 04:02:38 dawes Exp $ */
  
  #include "Probe.h"
***************
*** 101,106 ****
--- 101,114 ----
  # define DEV_MEM	"/dev/mem"
  #endif
  
+ #ifndef SI86IOPL
+ #define SET_IOPL() sysi86(SI86V86,V86SC_IOPL,PS_IOPL)
+ #define RESET_IOPL() sysi86(SI86V86,V86SC_IOPL,0)
+ #else
+ #define SET_IOPL() sysi86(SI86IOPL,3)
+ #define RESET_IOPL() sysi86(SI86IOPL,0)
+ #endif
+ 
  static int VT_fd = -1;
  static int VT_num = -1;
  static int BIOS_fd = -1;
***************
*** 167,173 ****
  		 */
  		sleep(1);
  	}
! 	(void)sysi86(SI86V86, V86SC_IOPL, PS_IOPL);
  	return(VT_fd);
  }
  
--- 175,181 ----
  		 */
  		sleep(1);
  	}
! 	(void)SET_IOPL();
  	return(VT_fd);
  }
  
***************
*** 181,187 ****
  {
  	if (VT_fd != -1)
  	{
! 		(void)sysi86(SI86V86, V86SC_IOPL, 0);
  	}
  	if (VT_fd > 0)
  	{
--- 189,195 ----
  {
  	if (VT_fd != -1)
  	{
! 		(void)RESET_IOPL();
  	}
  	if (VT_fd > 0)
  	{
*** -	Fri Jul  7 09:32:29 1995
--- xc/programs/Xserver/hw/xfree86/accel/agx/xf86RamDac.c	Fri Jul  7 09:32:29 1995
***************
*** 1,4 ****
! /* $XConsortium: xf86RamDac.c,v 1.3 95/01/26 15:34:05 kaleb Exp $ */
  /* $XFree86: xc/programs/Xserver/hw/xfree86/accel/agx/xf86RamDac.c,v 3.3 1995/01/26 02:16:52 dawes Exp $ */
  /*
   * Copyright 1994 by Henry A. Worth, Sunnyvale, California.
--- 1,4 ----
! /* $XConsortium: xf86RamDac.c,v 1.4 95/06/09 20:57:00 gildea Exp $ */
  /* $XFree86: xc/programs/Xserver/hw/xfree86/accel/agx/xf86RamDac.c,v 3.3 1995/01/26 02:16:52 dawes Exp $ */
  /*
   * Copyright 1994 by Henry A. Worth, Sunnyvale, California.
***************
*** 345,351 ****
  }
  
  void 
! #if __STDC__ 
  xf86RamDacHWNoop( union xf86RamDacSave * save )
  #else
  xf86RamDacHWNoop( save )
--- 345,351 ----
  }
  
  void 
! #ifdef __STDC__ 
  xf86RamDacHWNoop( union xf86RamDacSave * save )
  #else
  xf86RamDacHWNoop( save )
***************
*** 356,362 ****
  
  void 
  xf86RamDacNoopInit(
! #if __STDC__
          void
  #endif
  )
--- 356,362 ----
  
  void 
  xf86RamDacNoopInit(
! #ifdef __STDC__
          void
  #endif
  )
*** -	Fri Jul  7 09:32:30 1995
--- xc/programs/Xserver/hw/xfree86/accel/et4000w32/w32/w32map.h	Fri Jul  7 09:32:30 1995
***************
*** 1,4 ****
! /* $XConsortium: w32map.h,v 1.2 94/11/21 22:31:09 kaleb Exp $ */
  /* $XFree86: xc/programs/Xserver/hw/xfree86/accel/et4000w32/w32/w32map.h,v 3.0 1994/09/11 00:42:25 dawes Exp $ */
  /*
   *
--- 1,4 ----
! /* $XConsortium: w32map.h,v 1.3 95/06/09 20:57:00 gildea Exp $ */
  /* $XFree86: xc/programs/Xserver/hw/xfree86/accel/et4000w32/w32/w32map.h,v 3.0 1994/09/11 00:42:25 dawes Exp $ */
  /*
   *
***************
*** 36,42 ****
  
  #if PSZ != 8
  #if PSZ == 32
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define NAME(subname) W3232##subname
  #else
  #define NAME(subname) W3232/**/subname
--- 36,42 ----
  
  #if PSZ != 8
  #if PSZ == 32
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define NAME(subname) W3232##subname
  #else
  #define NAME(subname) W3232/**/subname
***************
*** 44,50 ****
  #endif
  
  #if PSZ == 16
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define NAME(subname) W3216##subname
  #else
  #define NAME(subname) W3216/**/subname
--- 44,50 ----
  #endif
  
  #if PSZ == 16
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define NAME(subname) W3216##subname
  #else
  #define NAME(subname) W3216/**/subname
***************
*** 52,58 ****
  #endif
  
  #if PSZ == 4
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define NAME(subname) W324##subname
  #else
  #define NAME(subname) W324/**/subname
--- 52,58 ----
  #endif
  
  #if PSZ == 4
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define NAME(subname) W324##subname
  #else
  #define NAME(subname) W324/**/subname
***************
*** 63,69 ****
  W32 can not hack PSZ yet
  #endif
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define CATNAME(prefix,subname) prefix##subname
  #else
  #define CATNAME(prefix,subname) prefix/**/subname
--- 63,69 ----
  W32 can not hack PSZ yet
  #endif
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define CATNAME(prefix,subname) prefix##subname
  #else
  #define CATNAME(prefix,subname) prefix/**/subname
*** -	Fri Jul  7 09:32:31 1995
--- xc/programs/Xserver/hw/xfree86/accel/s3/s3.c	Fri Jul  7 09:32:31 1995
***************
*** 1,4 ****
! /* $XConsortium: s3.c,v 1.8 95/01/25 00:44:45 kaleb Exp $ */
  /* $XFree86: xc/programs/Xserver/hw/xfree86/accel/s3/s3.c,v 3.69 1995/01/23 01:29:21 dawes Exp $ */
  /*
   * Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.
--- 1,4 ----
! /* $XConsortium: s3.c,v 1.9 95/04/07 19:28:18 kaleb Exp $ */
  /* $XFree86: xc/programs/Xserver/hw/xfree86/accel/s3/s3.c,v 3.69 1995/01/23 01:29:21 dawes Exp $ */
  /*
   * Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.
***************
*** 349,355 ****
      */
     
     unsigned char saveCR55, savelut[6];
!    int i;
     long clock01, clock23;
     Bool found = FALSE;
  
--- 349,355 ----
      */
     
     unsigned char saveCR55, savelut[6];
!    unsigned int i;		/* don't use signed int, UW2.0 compiler bug */
     long clock01, clock23;
     Bool found = FALSE;
  
*** -	Fri Jul  7 09:32:32 1995
--- xc/programs/Xserver/hw/xfree86/accel/s3/s3name.h	Fri Jul  7 09:32:32 1995
***************
*** 1,4 ****
! /* $XConsortium: s3name.h,v 1.2 94/10/12 20:07:37 kaleb Exp $ */
  /* $XFree86: xc/programs/Xserver/hw/xfree86/accel/s3/s3name.h,v 3.4 1994/09/22 15:50:07 dawes Exp $ */
  /*
   * Copyright 1993 by David Dawes <dawes@physics.su.oz.au>
--- 1,4 ----
! /* $XConsortium: s3name.h,v 1.3 95/06/09 20:57:00 gildea Exp $ */
  /* $XFree86: xc/programs/Xserver/hw/xfree86/accel/s3/s3name.h,v 3.4 1994/09/22 15:50:07 dawes Exp $ */
  /*
   * Copyright 1993 by David Dawes <dawes@physics.su.oz.au>
***************
*** 28,34 ****
  #ifndef S3_NAME_H
  #define S3_NAME_H
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP) || (defined (sun) && defined (i386) && defined (SVR4) && defined (__STDC__) && !defined (__GNUC__))
  #define CATNAME(prefix,subname) prefix##subname
  #else
  #define CATNAME(prefix,subname) prefix/**/subname
--- 28,34 ----
  #ifndef S3_NAME_H
  #define S3_NAME_H
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP) || (defined (sun) && defined (i386) && defined (SVR4) && defined (__STDC__) && !defined (__GNUC__))
  #define CATNAME(prefix,subname) prefix##subname
  #else
  #define CATNAME(prefix,subname) prefix/**/subname
*** -	Fri Jul  7 09:32:33 1995
--- xc/programs/Xserver/hw/xfree86/os-support/amoeba/am_io.c	Fri Jul  7 09:32:33 1995
***************
*** 1,4 ****
! /* $XConsortium: am_io.c,v 1.1 94/03/28 21:27:35 dpw Exp $ */
  /*
   * Copyright 1993 by Vrije Universiteit, The Netherlands
   * Copyright 1993 by David Dawes <dawes@physics.su.oz.au>
--- 1,4 ----
! /* $XConsortium: am_io.c,v 1.3 95/06/14 15:19:17 kaleb Exp $ */
  /*
   * Copyright 1993 by Vrije Universiteit, The Netherlands
   * Copyright 1993 by David Dawes <dawes@physics.su.oz.au>
***************
*** 95,101 ****
  	return cur_leds;
  }
  
! #if __STDC__
  void xf86SetKbdRepeat(char rad)
  #else
  void xf86SetKbdRepeat(rad)
--- 95,101 ----
  	return cur_leds;
  }
  
! #if NeedFunctionPrototypes
  void xf86SetKbdRepeat(char rad)
  #else
  void xf86SetKbdRepeat(rad)
*** -	Fri Jul  7 09:32:34 1995
--- xc/programs/Xserver/hw/xfree86/os-support/bsd/bsd_io.c	Fri Jul  7 09:32:34 1995
***************
*** 1,4 ****
! /* $XConsortium: bsd_io.c,v 1.3 95/01/16 13:17:58 kaleb Exp $ */
  /* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/bsd/bsd_io.c,v 3.2 1995/01/10 10:28:47 dawes Exp $ */
  /*
   * Copyright 1992 by Rich Murphey <Rich@Rice.edu>
--- 1,4 ----
! /* $XConsortium: bsd_io.c,v 1.5 95/06/14 15:19:17 kaleb Exp $ */
  /* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/bsd/bsd_io.c,v 3.2 1995/01/10 10:28:47 dawes Exp $ */
  /*
   * Copyright 1992 by Rich Murphey <Rich@Rice.edu>
***************
*** 128,134 ****
  	return(leds);
  }
  
! #if __STDC__
  void xf86SetKbdRepeat(char rad)
  #else
  void xf86SetKbdRepeat(rad)
--- 128,134 ----
  	return(leds);
  }
  
! #if NeedFunctionPrototypes
  void xf86SetKbdRepeat(char rad)
  #else
  void xf86SetKbdRepeat(rad)
*** -	Fri Jul  7 09:32:35 1995
--- xc/programs/Xserver/hw/xfree86/os-support/bsdi/bsdi_io.c	Fri Jul  7 09:32:34 1995
***************
*** 1,4 ****
! /* $XConsortium: bsdi_io.c,v 1.1 94/03/28 21:28:32 dpw Exp $ */
  /*
   * Copyright 1992 by Rich Murphey <Rich@Rice.edu>
   * Copyright 1993 by David Dawes <dawes@physics.su.oz.au>
--- 1,4 ----
! /* $XConsortium: bsdi_io.c,v 1.3 95/06/14 15:19:17 kaleb Exp $ */
  /*
   * Copyright 1992 by Rich Murphey <Rich@Rice.edu>
   * Copyright 1993 by David Dawes <dawes@physics.su.oz.au>
***************
*** 62,68 ****
  	return(0);
  }
  
! #if __STDC__
  void xf86SetKbdRepeat(char rad)
  #else
  void xf86SetKbdRepeat(rad)
--- 62,68 ----
  	return(0);
  }
  
! #if NeedFunctionPrototypes
  void xf86SetKbdRepeat(char rad)
  #else
  void xf86SetKbdRepeat(rad)
*** -	Fri Jul  7 09:32:36 1995
--- xc/programs/Xserver/hw/xfree86/os-support/linux/lnx_io.c	Fri Jul  7 09:32:35 1995
***************
*** 1,4 ****
! /* $XConsortium: lnx_io.c,v 1.1 94/03/28 21:28:56 dpw Exp $ */
  /*
   * Copyright 1992 by Orest Zborowski <obz@Kodak.com>
   * Copyright 1993 by David Dawes <dawes@physics.su.oz.au>
--- 1,4 ----
! /* $XConsortium: lnx_io.c,v 1.2 95/06/14 15:19:17 kaleb Exp $ */
  /*
   * Copyright 1992 by Orest Zborowski <obz@Kodak.com>
   * Copyright 1993 by David Dawes <dawes@physics.su.oz.au>
***************
*** 64,71 ****
--- 64,75 ----
  	return(leds);
  }
  
+ #if NeedFunctionPrototypes
+ void xf86SetKbdRepeat(char rad)
+ #else
  void xf86SetKbdRepeat(rad)
  char rad;
+ #endif
  {
  	return;
  }
*** -	Fri Jul  7 09:32:36 1995
--- xc/programs/Xserver/hw/xfree86/os-support/mach/mach_io.c	Fri Jul  7 09:32:36 1995
***************
*** 1,4 ****
! /* $XConsortium: mach_io.c,v 1.1 94/03/28 21:29:27 dpw Exp $ */
  /*
   * Copyright 1992 by Robert Baron <Robert.Baron@ernst.mach.cs.cmu.edu>
   * Copyright 1993 by David Dawes <dawes@physics.su.oz.au>
--- 1,4 ----
! /* $XConsortium: mach_io.c,v 1.2 95/06/14 15:19:17 kaleb Exp $ */
  /*
   * Copyright 1992 by Robert Baron <Robert.Baron@ernst.mach.cs.cmu.edu>
   * Copyright 1993 by David Dawes <dawes@physics.su.oz.au>
***************
*** 111,118 ****
--- 111,122 ----
  #endif
  }
  
+ #if NeedFunctionPrototypes
+ void xf86SetKbdRepeat(char rad)
+ #else
  void xf86SetKbdRepeat(rad)
  char rad;
+ #endif
  {
  	return;
  }
*** -	Fri Jul  7 09:32:37 1995
--- xc/programs/Xserver/hw/xfree86/os-support/minix/mnx_io.c	Fri Jul  7 09:32:37 1995
***************
*** 1,4 ****
! /* $XConsortium: mnx_io.c,v 1.2 94/10/12 20:47:58 kaleb Exp $ */
  /* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/minix/mnx_io.c,v 3.0 1994/05/08 05:23:49 dawes Exp $ */
  /*
   * Copyright 1993 by Vrije Universiteit, The Netherlands
--- 1,4 ----
! /* $XConsortium: mnx_io.c,v 1.4 95/06/14 15:20:35 kaleb Exp $ */
  /* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/minix/mnx_io.c,v 3.0 1994/05/08 05:23:49 dawes Exp $ */
  /*
   * Copyright 1993 by Vrije Universiteit, The Netherlands
***************
*** 81,87 ****
  	return(0);
  }
  
! #if __STDC__
  void xf86SetKbdRepeat(char rad)
  #else
  void xf86SetKbdRepeat(rad)
--- 81,87 ----
  	return(0);
  }
  
! #if NeedFunctionPrototypes
  void xf86SetKbdRepeat(char rad)
  #else
  void xf86SetKbdRepeat(rad)
*** -	Fri Jul  7 09:32:38 1995
--- xc/programs/Xserver/hw/xfree86/os-support/sysv/sysv_video.c	Fri Jul  7 09:32:38 1995
***************
*** 1,4 ****
! /* $XConsortium: sysv_video.c,v 1.1 94/03/28 21:33:15 dpw Exp $ */
  /*
   * Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany
   * Copyright 1993 by David Wexelblat <dwex@goblin.org>
--- 1,4 ----
! /* $XConsortium: sysv_video.c,v 1.2 95/03/01 16:11:01 kaleb Exp $ */
  /*
   * Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany
   * Copyright 1993 by David Wexelblat <dwex@goblin.org>
***************
*** 34,39 ****
--- 34,47 ----
  #include "xf86Priv.h"
  #include "xf86_OSlib.h"
  
+ #ifndef SI86IOPL
+ #define SET_IOPL() sysi86(SI86V86,V86SC_IOPL,PS_IOPL)
+ #define RESET_IOPL() sysi86(SI86V86,V86SC_IOPL,0)
+ #else
+ #define SET_IOPL() sysi86(SI86IOPL,3)
+ #define RESET_IOPL() sysi86(SI86IOPL,0)
+ #endif
+ 
  /***************************************************************************/
  /* Video Memory Mapping section                                            */
  /***************************************************************************/
***************
*** 282,288 ****
  	{
  		if (ExtendedPorts[i] && (ScreenEnabled[i] || i == ScreenNum))
  		{
! 		    if (sysi86(SI86V86, V86SC_IOPL, PS_IOPL) < 0)
  		    {
  			FatalError("%s: Failed to set IOPL for extended I/O\n",
  				   "xf86EnableIOPorts");
--- 290,296 ----
  	{
  		if (ExtendedPorts[i] && (ScreenEnabled[i] || i == ScreenNum))
  		{
! 		    if (SET_IOPL() < 0)
  		    {
  			FatalError("%s: Failed to set IOPL for extended I/O\n",
  				   "xf86EnableIOPorts");
***************
*** 294,300 ****
  	/* If extended I/O was used, but isn't any more */
  	if (ExtendedEnabled && i == MAXSCREENS)
  	{
! 		sysi86(SI86V86, V86SC_IOPL, 0);
  		ExtendedEnabled = FALSE;
  	}
  	/*
--- 302,308 ----
  	/* If extended I/O was used, but isn't any more */
  	if (ExtendedEnabled && i == MAXSCREENS)
  	{
! 		RESET_IOPL();
  		ExtendedEnabled = FALSE;
  	}
  	/*
***************
*** 361,367 ****
  	}
  	if (ExtendedEnabled && i == MAXSCREENS)
  	{
! 		sysi86(SI86V86, V86SC_IOPL, 0);
  		ExtendedEnabled = FALSE;
  	}
  	/* Turn off I/O before changing the access list */
--- 369,375 ----
  	}
  	if (ExtendedEnabled && i == MAXSCREENS)
  	{
! 		RESET_IOPL();
  		ExtendedEnabled = FALSE;
  	}
  	/* Turn off I/O before changing the access list */
***************
*** 419,425 ****
  void xf86DisableIOPrivs()
  {
  	if (ExtendedEnabled)
! 		sysi86(SI86V86, V86SC_IOPL, 0);
  	return;
  }
  
--- 427,433 ----
  void xf86DisableIOPrivs()
  {
  	if (ExtendedEnabled)
! 		RESET_IOPL();
  	return;
  }
  
***************
*** 431,437 ****
  {
  	if (!ExtendedEnabled)
  	{
! 		if (sysi86(SI86V86, V86SC_IOPL, PS_IOPL) < 0)
  		{
  			return(FALSE);
  		}
--- 439,445 ----
  {
  	if (!ExtendedEnabled)
  	{
! 		if (SET_IOPL() < 0)
  		{
  			return(FALSE);
  		}
***************
*** 445,451 ****
  
  	if (!ExtendedEnabled)
  	{
! 		sysi86(SI86V86, V86SC_IOPL, 0);
  	}
  	return(TRUE);
  }
--- 453,459 ----
  
  	if (!ExtendedEnabled)
  	{
! 		RESET_IOPL();
  	}
  	return(TRUE);
  }
***************
*** 454,460 ****
  {
  	if (!ExtendedEnabled)
  	{
! 		if (sysi86(SI86V86, V86SC_IOPL, PS_IOPL) < 0)
  		{
  			return;
  		}
--- 462,468 ----
  {
  	if (!ExtendedEnabled)
  	{
! 		if (SET_IOPL() < 0)
  		{
  			return;
  		}
***************
*** 468,474 ****
  
  	if (!ExtendedEnabled)
  	{
! 		sysi86(SI86V86, V86SC_IOPL, 0);
  	}
  	return;
  }
--- 476,482 ----
  
  	if (!ExtendedEnabled)
  	{
! 		RESET_IOPL();
  	}
  	return;
  }
*** -	Fri Jul  7 09:32:39 1995
--- xc/programs/Xserver/hw/xfree86/vga256/enhanced/vgaFasm.h	Fri Jul  7 09:32:39 1995
***************
*** 1,4 ****
! /* $XConsortium: vgaFasm.h,v 1.3 95/01/05 20:50:47 kaleb Exp $ */
  /* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/enhanced/vgaFasm.h,v 3.2 1994/10/21 11:24:26 dawes Exp $ */
  /* Copyright 1992 by James Tsillas, Arlignton, Massachusetts.
  
--- 1,4 ----
! /* $XConsortium: vgaFasm.h,v 1.4 95/06/09 20:57:00 gildea Exp $ */
  /* $XFree86: xc/programs/Xserver/hw/xfree86/vga256/enhanced/vgaFasm.h,v 3.2 1994/10/21 11:24:26 dawes Exp $ */
  /* Copyright 1992 by James Tsillas, Arlignton, Massachusetts.
  
***************
*** 23,29 ****
  
  
  #ifndef RROP_NAME_CAT
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP) || (defined (sun) && defined (__STDC__) && !defined (__GNUC__))
  #define RROP_NAME_CAT(prefix,suffix)    prefix##suffix
  #else
  #define RROP_NAME_CAT(prefix,suffix)    prefix/**/suffix
--- 23,29 ----
  
  
  #ifndef RROP_NAME_CAT
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP) || (defined (sun) && defined (__STDC__) && !defined (__GNUC__))
  #define RROP_NAME_CAT(prefix,suffix)    prefix##suffix
  #else
  #define RROP_NAME_CAT(prefix,suffix)    prefix/**/suffix
*** -	Fri Jul  7 09:32:40 1995
--- xc/programs/Xserver/hw/xfree86/xf86config/cards.c	Fri Jul  7 09:32:40 1995
***************
*** 1,4 ****
! /* $XConsortium: cards.c,v 1.3 95/01/23 15:35:22 kaleb Exp $ */
  /* $XFree86: xc/programs/Xserver/hw/xfree86/xf86config/cards.c,v 3.2 1995/01/23 01:33:07 dawes Exp $ */
  
  /*
--- 1,4 ----
! /* $XConsortium: cards.c,v 1.4 95/06/09 20:57:00 gildea Exp $ */
  /* $XFree86: xc/programs/Xserver/hw/xfree86/xf86config/cards.c,v 3.2 1995/01/23 01:33:07 dawes Exp $ */
  
  /*
***************
*** 245,251 ****
  	return 0;
  }
  
! #if __STDC__
  #define CONST const
  #else
  #define CONST
--- 245,251 ----
  	return 0;
  }
  
! #ifdef __STDC__
  #define CONST const
  #else
  #define CONST
*** -	Fri Jul  7 09:32:42 1995
--- xc/programs/Xserver/Xext/shm.c	Fri Jul  7 09:32:42 1995
***************
*** 27,33 ****
  
  /* THIS IS NOT AN X CONSORTIUM STANDARD */
  
! /* $XConsortium: shm.c,v 1.23 94/04/17 20:32:56 dpw Exp $ */
  
  #include <sys/types.h>
  #include <sys/ipc.h>
--- 27,33 ----
  
  /* THIS IS NOT AN X CONSORTIUM STANDARD */
  
! /* $XConsortium: shm.c,v 1.23.1.1 95/05/03 20:32:23 dpw Exp $ */
  
  #include <sys/types.h>
  #include <sys/ipc.h>
***************
*** 59,78 ****
      unsigned long size;
  } ShmDescRec, *ShmDescPtr;
  
- #if NeedFunctionPrototypes
- 
- #if defined(SVR4)
- void *shmat(int, void*, int);
- #else
- #if !defined(sgi) && !defined(hpux) && !defined(__alpha) && !defined(__FreeBSD__) && !defined(__386BSD__) && !defined(__NetBSD__)
- char *shmat(int, char*, int);
- #endif
- #endif
- 
- #else
- char *shmat();
- #endif
- 
  static void miShmPutImage(), fbShmPutImage();
  static PixmapPtr fbShmCreatePixmap();
  static int ProcShmDispatch(), SProcShmDispatch();
--- 59,64 ----
***************
*** 254,260 ****
  	shmdesc = (ShmDescPtr) xalloc(sizeof(ShmDescRec));
  	if (!shmdesc)
  	    return BadAlloc;
! 	shmdesc->addr = shmat(stuff->shmid, 0,
  			      stuff->readOnly ? SHM_RDONLY : 0);
  	if ((shmdesc->addr == ((char *)-1)) ||
  	    shmctl(stuff->shmid, IPC_STAT, &buf))
--- 240,246 ----
  	shmdesc = (ShmDescPtr) xalloc(sizeof(ShmDescRec));
  	if (!shmdesc)
  	    return BadAlloc;
! 	shmdesc->addr = (char *)shmat(stuff->shmid, 0,
  			      stuff->readOnly ? SHM_RDONLY : 0);
  	if ((shmdesc->addr == ((char *)-1)) ||
  	    shmctl(stuff->shmid, IPC_STAT, &buf))
*** -	Fri Jul  7 09:32:43 1995
--- xc/programs/Xserver/PEX5/ddpex/mi/level2/miCopy.c	Fri Jul  7 09:32:43 1995
***************
*** 1,4 ****
! /* $XConsortium: miCopy.c,v 5.8 94/04/17 20:37:04 hersh Exp $ */
  
  /***********************************************************
  
--- 1,4 ----
! /* $XConsortium: miCopy.c,v 5.9 95/06/08 23:20:39 gildea Exp $ */
  
  /***********************************************************
  
***************
*** 71,77 ****
      happen during freeing of storage.
   */
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define CAT(a,b)    a##b
  #else
  #define CAT(a,b)    a/**/b
--- 71,77 ----
      happen during freeing of storage.
   */
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define CAT(a,b)    a##b
  #else
  #define CAT(a,b)    a/**/b
*** -	Fri Jul  7 09:32:44 1995
--- xc/programs/Xserver/PEX5/ddpex/mi/level2/miDestroy.c	Fri Jul  7 09:32:44 1995
***************
*** 1,4 ****
! /* $XConsortium: miDestroy.c,v 5.3 94/04/17 20:37:05 rws Exp $ */
  
  /***********************************************************
  
--- 1,4 ----
! /* $XConsortium: miDestroy.c,v 5.4 95/06/08 23:20:39 gildea Exp $ */
  
  /***********************************************************
  
***************
*** 64,70 ****
   ****Note that these functions may be replaced by PEX server porters.
   **/
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define CAT(a,b)    a##b
  #else
  #define CAT(a,b)    a/**/b
--- 64,70 ----
   ****Note that these functions may be replaced by PEX server porters.
   **/
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define CAT(a,b)    a##b
  #else
  #define CAT(a,b)    a/**/b
*** -	Fri Jul  7 09:32:44 1995
--- xc/programs/Xserver/PEX5/ddpex/mi/level2/miInquire.c	Fri Jul  7 09:32:44 1995
***************
*** 1,4 ****
! /* $XConsortium: miInquire.c,v 5.9 94/04/17 20:37:06 hersh Exp $ */
  
  /***********************************************************
  
--- 1,4 ----
! /* $XConsortium: miInquire.c,v 5.10 95/06/08 23:20:39 gildea Exp $ */
  
  /***********************************************************
  
***************
*** 69,75 ****
      a corresponding modification to the level function tables (miTables.c)
   */
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define CAT(a,b)    a##b
  #else
  #define CAT(a,b)    a/**/b
--- 69,75 ----
      a corresponding modification to the level function tables (miTables.c)
   */
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define CAT(a,b)    a##b
  #else
  #define CAT(a,b)    a/**/b
*** -	Fri Jul  7 09:32:45 1995
--- xc/programs/Xserver/PEX5/ddpex/mi/level2/miReplace.c	Fri Jul  7 09:32:45 1995
***************
*** 1,4 ****
! /* $XConsortium: miReplace.c,v 5.4 94/04/17 20:37:17 rws Exp $ */
  
  /***********************************************************
  
--- 1,4 ----
! /* $XConsortium: miReplace.c,v 5.5 95/06/08 23:20:39 gildea Exp $ */
  
  /***********************************************************
  
***************
*** 77,83 ****
  extern int  CountFacetOptData();
  extern int  CountVertexData();
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define CAT(a,b)    a##b
  #else
  #define CAT(a,b)    a/**/b
--- 77,83 ----
  extern int  CountFacetOptData();
  extern int  CountVertexData();
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define CAT(a,b)    a##b
  #else
  #define CAT(a,b)    a/**/b
*** -	Fri Jul  7 09:32:46 1995
--- xc/programs/Xserver/PEX5/ddpex/mi/level2/pexOCParse.c	Fri Jul  7 09:32:46 1995
***************
*** 1,4 ****
! /* $XConsortium: pexOCParse.c,v 5.9 94/04/17 20:37:23 hersh Exp $ */
  
  /***********************************************************
  
--- 1,4 ----
! /* $XConsortium: pexOCParse.c,v 5.10 95/06/08 23:20:39 gildea Exp $ */
  
  /***********************************************************
  
***************
*** 95,101 ****
   **	copy and inquire routines (see miCopy.c and miInquire.c).
   **/
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define CAT(a,b)    a##b
  #else
  #define CAT(a,b)    a/**/b
--- 95,101 ----
   **	copy and inquire routines (see miCopy.c and miInquire.c).
   **/
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define CAT(a,b)    a##b
  #else
  #define CAT(a,b)    a/**/b
*** -	Fri Jul  7 09:32:47 1995
--- xc/programs/Xserver/PEX5/dipex/swap/ConvName.h	Fri Jul  7 09:32:47 1995
***************
*** 1,4 ****
! /* $XConsortium: ConvName.h,v 5.3 94/04/17 20:36:15 rws Exp $ */
  
  /***********************************************************
  
--- 1,4 ----
! /* $XConsortium: ConvName.h,v 5.4 95/06/08 23:20:39 gildea Exp $ */
  
  /***********************************************************
  
***************
*** 48,54 ****
  ******************************************************************/
  
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define SWAP_FUNC_PREFIX(nm)	c##nm
  #define SWAP_FUNC_PEX_PFX(nm)	cPEX##nm
  #else
--- 48,54 ----
  ******************************************************************/
  
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define SWAP_FUNC_PREFIX(nm)	c##nm
  #define SWAP_FUNC_PEX_PFX(nm)	cPEX##nm
  #else
*** -	Fri Jul  7 09:32:48 1995
--- xc/programs/Xserver/PEX5/dipex/swap/UconvName.h	Fri Jul  7 09:32:48 1995
***************
*** 1,4 ****
! /* $XConsortium: UconvName.h,v 5.3 94/04/17 20:36:24 rws Exp $ */
  
  /***********************************************************
  
--- 1,4 ----
! /* $XConsortium: UconvName.h,v 5.4 95/06/09 22:14:34 gildea Exp $ */
  
  /***********************************************************
  
***************
*** 47,53 ****
  
  ******************************************************************/
  
! #if (__STDC__&& !defined(UNIXCPP)) || defined(ANSICPP)
  #define SWAP_FUNC_PREFIX(nm)	u##nm
  #define SWAP_FUNC_PEX_PFX(nm)	uPEX##nm
  #else
--- 47,53 ----
  
  ******************************************************************/
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define SWAP_FUNC_PREFIX(nm)	u##nm
  #define SWAP_FUNC_PEX_PFX(nm)	uPEX##nm
  #else
*** -	Fri Jul  7 09:32:49 1995
--- xc/programs/bitmap/Bitmap.ad	Fri Jul  7 09:32:49 1995
***************
*** 1,4 ****
! ! $XConsortium: Bitmap.ad,v 1.18 94/02/09 19:43:57 gildea Exp $
  ! The App-defaults file for Bitmap.
  
  *TransientShell.allowShellResize:	True
--- 1,4 ----
! ! $XConsortium: Bitmap.ad,v 1.19 95/06/29 19:25:34 kaleb Exp $
  ! The App-defaults file for Bitmap.
  
  *TransientShell.allowShellResize:	True
***************
*** 45,51 ****
  
  *MenuButton.translations:<EnterWindow>:		highlight()\n\
  			<LeaveWindow>:  	reset()\n\
! 			<BtnDown>:  		reset() fix-menu() PopupMenu()
  
  *Dialog*baseTranslations:#override\
  			<Key>Return:	set-dialog-button(okay, yes, retry)\n\
--- 45,51 ----
  
  *MenuButton.translations:<EnterWindow>:		highlight()\n\
  			<LeaveWindow>:  	reset()\n\
! 			Any<BtnDown>:  		reset() fix-menu() PopupMenu()
  
  *Dialog*baseTranslations:#override\
  			<Key>Return:	set-dialog-button(okay, yes, retry)\n\
*** -	Fri Jul  7 09:32:50 1995
--- xc/programs/fsinfo/fsinfo.c	Fri Jul  7 09:32:50 1995
***************
*** 2,8 ****
   * fsinfo -- report info about a font server
   */
  
! /* $XConsortium: fsinfo.c,v 1.5 94/04/17 20:24:18 dpw Exp $ */
  /*
  
  Portions Copyright (c) 1987  X Consortium
--- 2,8 ----
   * fsinfo -- report info about a font server
   */
  
! /* $XConsortium: fsinfo.c,v 1.6 95/04/06 19:50:32 mor Exp $ */
  /*
  
  Portions Copyright (c) 1987  X Consortium
***************
*** 84,89 ****
--- 84,90 ----
      FSServer   *svr;
      char       *servername = NULL;
      int         i;
+     char	*sp;
  
      progname = argv[0];
  
***************
*** 100,107 ****
      svr = FSOpenServer(servername);
  
      if (!svr) {
  	fprintf(stderr, "%s:  unable to open server \"%s\"\n",
! 		progname, FSServerName(servername));
  	exit(1);
      }
      print_server_info(svr);
--- 101,109 ----
      svr = FSOpenServer(servername);
  
      if (!svr) {
+ 	sp = FSServerName(servername);
  	fprintf(stderr, "%s:  unable to open server \"%s\"\n",
! 		progname, sp ? sp : "NULL");
  	exit(1);
      }
      print_server_info(svr);
*** -	Fri Jul  7 09:32:53 1995
--- xc/programs/smproxy/smproxy.c	Fri Jul  7 09:32:53 1995
***************
*** 1,4 ****
! /* $XConsortium: smproxy.c,v 1.28 95/01/04 22:28:03 mor Exp $ */
  /******************************************************************************
  
  Copyright (c) 1994  X Consortium
--- 1,4 ----
! /* $XConsortium: smproxy.c,v 1.29 95/04/04 15:17:40 mor Exp $ */
  /******************************************************************************
  
  Copyright (c) 1994  X Consortium
***************
*** 31,37 ****
  
  XtAppContext appContext;
  Display *disp;
- Window root;
  
  Atom wmProtocolsAtom;
  Atom wmSaveYourselfAtom;
--- 31,36 ----
***************
*** 1174,1180 ****
  
  
  void
! CheckForExistingWindows ()
  
  {
      Window dontCare1, dontCare2, *children, client_window;
--- 1173,1181 ----
  
  
  void
! CheckForExistingWindows (root)
! 
! Window root;
  
  {
      Window dontCare1, dontCare2, *children, client_window;
***************
*** 1275,1291 ****
  	exit (1);
      }
  
-     root = DefaultRootWindow (disp);
- 
      wmProtocolsAtom = XInternAtom (disp, "WM_PROTOCOLS", False);
      wmSaveYourselfAtom = XInternAtom (disp, "WM_SAVE_YOURSELF", False);
      wmStateAtom = XInternAtom (disp, "WM_STATE", False);
      smClientIdAtom = XInternAtom (disp, "SM_CLIENT_ID", False);
      wmClientLeaderAtom = XInternAtom (disp, "WM_CLIENT_LEADER", False);
  
!     XSelectInput (disp, root, SubstructureNotifyMask | PropertyChangeMask);
! 
!     CheckForExistingWindows ();
  
      while (1)
      {
--- 1276,1293 ----
  	exit (1);
      }
  
      wmProtocolsAtom = XInternAtom (disp, "WM_PROTOCOLS", False);
      wmSaveYourselfAtom = XInternAtom (disp, "WM_SAVE_YOURSELF", False);
      wmStateAtom = XInternAtom (disp, "WM_STATE", False);
      smClientIdAtom = XInternAtom (disp, "SM_CLIENT_ID", False);
      wmClientLeaderAtom = XInternAtom (disp, "WM_CLIENT_LEADER", False);
  
!     for (i = 0; i < ScreenCount (disp); i++)
!     {
! 	Window root = RootWindow (disp, i);
! 	XSelectInput (disp, root, SubstructureNotifyMask | PropertyChangeMask);
! 	CheckForExistingWindows (root);
!     }
  
      while (1)
      {
*** -	Fri Jul  7 09:32:55 1995
--- xc/programs/twm/lex.l	Fri Jul  7 09:32:54 1995
***************
*** 53,59 ****
  
  /***********************************************************************
   *
!  * $XConsortium: lex.l,v 1.69 94/11/21 18:33:32 kaleb Exp $
   *
   * .twmrc lex file
   *
--- 53,59 ----
  
  /***********************************************************************
   *
!  * $XConsortium: lex.l,v 1.70 95/03/01 16:37:51 kaleb Exp $
   *
   * .twmrc lex file
   *
***************
*** 67,73 ****
  extern char *ProgramName;
  
  extern int ParseError;
! #if defined(CSRG_BASED) || defined(linux)
  int yylineno;
  
  #undef YY_INPUT
--- 67,73 ----
  extern char *ProgramName;
  
  extern int ParseError;
! #ifdef FLEX_SCANNER
  int yylineno;
  
  #undef YY_INPUT
*** -	Fri Jul  7 09:32:55 1995
--- xc/programs/twm/session.c	Fri Jul  7 09:32:55 1995
***************
*** 1,4 ****
! /* $XConsortium: session.c,v 1.18 95/01/04 22:28:37 mor Exp $ */
  /******************************************************************************
  
  Copyright (c) 1994  X Consortium
--- 1,4 ----
! /* $XConsortium: session.c,v 1.19 95/04/07 19:22:37 kaleb Exp $ */
  /******************************************************************************
  
  Copyright (c) 1994  X Consortium
***************
*** 27,33 ****
  Author:  Ralph Mor, X Consortium
  ******************************************************************************/
  
! #include <X11/Xosdefs.h>
  
  #ifndef X_NOT_POSIX
  #ifdef _POSIX_SOURCE
--- 27,33 ----
  Author:  Ralph Mor, X Consortium
  ******************************************************************************/
  
! #include <X11/Xos.h>
  
  #ifndef X_NOT_POSIX
  #ifdef _POSIX_SOURCE
*** -	Fri Jul  7 09:32:56 1995
--- xc/programs/xclock/Clock.c	Fri Jul  7 09:32:56 1995
***************
*** 1,4 ****
! /* $XConsortium: Clock.c,v 1.73 94/04/17 20:23:50 rws Exp $ */
  
  /***********************************************************
  
--- 1,4 ----
! /* $XConsortium: Clock.c,v 1.74 95/06/08 23:20:39 gildea Exp $ */
  
  /***********************************************************
  
***************
*** 54,60 ****
  #include "ClockP.h"
  #include <X11/Xosdefs.h>
  
! #if __STDC__ && !defined(AIXV3) /* AIX is broken */
  #define Const const
  #else
  #define Const /**/
--- 54,60 ----
  #include "ClockP.h"
  #include <X11/Xosdefs.h>
  
! #if defined(__STDC__) && !defined(AIXV3) /* AIX is broken */
  #define Const const
  #else
  #define Const /**/
*** -	Fri Jul  7 09:32:58 1995
--- xc/programs/xdm/chooser.c	Fri Jul  7 09:32:58 1995
***************
*** 1,5 ****
  /*
!  * $XConsortium: chooser.c,v 1.21 94/11/21 18:33:11 kaleb Exp $
   *
  Copyright (c) 1990  X Consortium
  
--- 1,5 ----
  /*
!  * $XConsortium: chooser.c,v 1.22 95/06/08 23:20:39 gildea Exp $
   *
  Copyright (c) 1990  X Consortium
  
***************
*** 188,194 ****
  
  static int
  HostnameCompare (a, b)
! #if __STDC__
      const void *a, *b;
  #else
      char *a, *b;
--- 188,194 ----
  
  static int
  HostnameCompare (a, b)
! #ifdef __STDC__
      const void *a, *b;
  #else
      char *a, *b;
***************
*** 199,204 ****
--- 199,205 ----
  
  static void
  RebuildTable (size)
+     int size;
  {
      char	**newTable = 0;
      HostName	*names;
***************
*** 325,331 ****
      return 1;
  }
  
! static
  DisposeHostname (host)
      HostName	*host;
  {
--- 326,332 ----
      return 1;
  }
  
! static void
  DisposeHostname (host)
      HostName	*host;
  {
***************
*** 336,342 ****
      free ((char *) host);
  }
  
! static
  RemoveHostname (host)
      HostName	*host;
  {
--- 337,343 ----
      free ((char *) host);
  }
  
! static void
  RemoveHostname (host)
      HostName	*host;
  {
***************
*** 357,363 ****
      RebuildTable (NameTableSize);
  }
  
! static
  EmptyHostnames ()
  {
      HostName	*hosts, *next;
--- 358,364 ----
      RebuildTable (NameTableSize);
  }
  
! static void
  EmptyHostnames ()
  {
      HostName	*hosts, *next;
***************
*** 434,439 ****
--- 435,441 ----
      }
  }
  
+ static void
  RegisterHostaddr (addr, len, type)
      struct sockaddr *addr;
      int		    len;
***************
*** 466,471 ****
--- 468,474 ----
   *  addresses on the local host.
   */
  
+ static void
  RegisterHostname (name)
      char    *name;
  {
***************
*** 613,618 ****
--- 616,622 ----
  
  static ARRAYofARRAY8	AuthenticationNames;
  
+ static void
  RegisterAuthenticationName (name, namelen)
      char    *name;
      int	    namelen;
***************
*** 627,639 ****
      memmove( authName->data, name, namelen);
  }
  
  InitXDMCP (argv)
      char    **argv;
  {
      int	soopts = 1;
      XdmcpHeader	header;
      int	i;
-     int optlen;
  
      header.version = XDM_PROTOCOL_VERSION;
      header.opcode = (CARD16) BROADCAST_QUERY;
--- 631,643 ----
      memmove( authName->data, name, namelen);
  }
  
+ int
  InitXDMCP (argv)
      char    **argv;
  {
      int	soopts = 1;
      XdmcpHeader	header;
      int	i;
  
      header.version = XDM_PROTOCOL_VERSION;
      header.opcode = (CARD16) BROADCAST_QUERY;
***************
*** 676,682 ****
      return 1;
  }
  
! Boolean
  Choose (h)
      HostName	*h;
  {
--- 680,686 ----
      return 1;
  }
  
! static void
  Choose (h)
      HostName	*h;
  {
***************
*** 863,868 ****
--- 867,873 ----
  };
  
  main (argc, argv)
+     int     argc;
      char    **argv;
  {
      Arg		position[3];
*** -	Fri Jul  7 09:33:00 1995
--- xc/programs/xdm/session.c	Fri Jul  7 09:32:59 1995
***************
*** 1,4 ****
! /* $XConsortium: session.c,v 1.72 94/04/17 20:03:45 gildea Exp $ */
  /*
  
  Copyright (c) 1988  X Consortium
--- 1,4 ----
! /* $XConsortium: session.c,v 1.72.1.1 95/06/19 20:29:12 gildea Exp $ */
  /*
  
  Copyright (c) 1988  X Consortium
***************
*** 169,175 ****
      int pid;
  {
      int	sig = SIGTERM;
! #if __STDC__
      volatile int	i;
  #else
      int	i;
--- 169,175 ----
      int pid;
  {
      int	sig = SIGTERM;
! #ifdef __STDC__
      volatile int	i;
  #else
      int	i;
*** -	Fri Jul  7 09:33:01 1995
--- xc/programs/xdm/greeter/greet.c	Fri Jul  7 09:33:01 1995
***************
*** 1,4 ****
! /* $XConsortium: greet.c,v 1.40 94/04/17 20:03:54 gildea Exp $ */
  /*
  
  Copyright (c) 1988  X Consortium
--- 1,4 ----
! /* $XConsortium: greet.c,v 1.41 94/09/12 21:32:49 converse Exp $ */
  /*
  
  Copyright (c) 1988  X Consortium
***************
*** 211,233 ****
  {
      Boolean	    allow;
      Arg	    arglist[1];
  
      if (pingTimeout)
      {
  	XtRemoveTimeOut (pingTimeout);
  	pingTimeout = 0;
      }
!     UnsecureDisplay (d, XtDisplay (toplevel));
      XtSetArg (arglist[0], XtNallowAccess, (char *) &allow);
      XtGetValues (login, arglist, 1);
      if (allow)
      {
  	Debug ("Disabling access control\n");
! 	XSetAccessControl (XtDisplay (toplevel), DisableAccess);
      }
      XtDestroyWidget (toplevel);
!     ClearCloseOnFork (XConnectionNumber (XtDisplay (toplevel)));
!     XCloseDisplay (XtDisplay (toplevel));
      Debug ("Greet connection closed\n");
  }
  
--- 211,234 ----
  {
      Boolean	    allow;
      Arg	    arglist[1];
+     Display *dpy = XtDisplay(toplevel);
  
      if (pingTimeout)
      {
  	XtRemoveTimeOut (pingTimeout);
  	pingTimeout = 0;
      }
!     UnsecureDisplay (d, dpy);
      XtSetArg (arglist[0], XtNallowAccess, (char *) &allow);
      XtGetValues (login, arglist, 1);
      if (allow)
      {
  	Debug ("Disabling access control\n");
! 	XSetAccessControl (dpy, DisableAccess);
      }
      XtDestroyWidget (toplevel);
!     ClearCloseOnFork (XConnectionNumber (dpy));
!     XCloseDisplay (dpy);
      Debug ("Greet connection closed\n");
  }
  
*** -	Fri Jul  7 09:33:02 1995
--- xc/programs/xfs/include/misc.h	Fri Jul  7 09:33:02 1995
***************
*** 1,4 ****
! /* $XConsortium: misc.h,v 1.8 94/04/17 19:55:59 mor Exp $ */
  /*
   
  Copyright (c) 1990, 1991  X Consortium
--- 1,4 ----
! /* $XConsortium: misc.h,v 1.9 95/06/08 23:20:39 gildea Exp $ */
  /*
   
  Copyright (c) 1990, 1991  X Consortium
***************
*** 136,142 ****
  extern long GetTimeInMillis();
  
  
! #if (__STDC__ && !defined(UNIXCPP)) || defined(ANSICPP)
  #define fsCat(x,y) x##_##y
  #else
  #define fsCat(x,y) x/**/_/**/y
--- 136,142 ----
  extern long GetTimeInMillis();
  
  
! #if (defined(__STDC__) && !defined(UNIXCPP)) || defined(ANSICPP)
  #define fsCat(x,y) x##_##y
  #else
  #define fsCat(x,y) x/**/_/**/y
*** -	Fri Jul  7 09:33:03 1995
--- xc/programs/xfs/include/os.h	Fri Jul  7 09:33:03 1995
***************
*** 1,4 ****
! /* $XConsortium: os.h,v 1.9 94/09/16 19:00:32 kaleb Exp $ */
  /*
  Copyright (c) 1987  X Consortium
  
--- 1,4 ----
! /* $XConsortium: os.h,v 1.10 95/04/07 20:34:17 kaleb Exp $ */
  /*
  Copyright (c) 1987  X Consortium
  
***************
*** 98,104 ****
--- 98,108 ----
  #endif /* __HIGHC__ */
  
  #ifdef __GNUC__
+ #ifndef alloca
  #define alloca __builtin_alloca
+ #endif /* !alloca */
+ #define ALLOCATE_LOCAL(size) alloca((int)(size))
+ #define DEALLOCATE_LOCAL(ptr)  /* as nothing */
  #else
  
  /*
*** -	Fri Jul  7 09:33:04 1995
--- xc/programs/xfs/os/Imakefile	Fri Jul  7 09:33:04 1995
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile,v 1.15 94/03/31 17:49:40 mor Exp $
  #undef ServerDefines
  #include <Server.tmpl>
  
--- 1,4 ----
! XCOMM $XConsortium: Imakefile,v 1.16 95/04/07 19:42:56 kaleb Exp $
  #undef ServerDefines
  #include <Server.tmpl>
  
***************
*** 17,31 ****
  
  /* ERROR_DEFINES = -DUSE_SYSLOG */
  
  NormalLibraryObjectRule()
  NormalLibraryTarget(os,$(OBJS))
  
! SpecialCObjectRule(connection,$(ICONFIGFILES),$(CONN_DEFINES) $(SIGNAL_DEFINES) $(SOCK_DEFINES))
  
  SpecialCObjectRule(io,$(ICONFIGFILES),$(CONN_DEFINES))
  
  SpecialCObjectRule(error,$(ICONFIGFILES),$(ERROR_DEFINES))
  
! SpecialCObjectRule(osglue,$(ICONFIGFILES),$(CONN_DEFINES))
  
  DependTarget()
--- 17,33 ----
  
  /* ERROR_DEFINES = -DUSE_SYSLOG */
  
+ OS_DEFINES = ServerOSDefines
+ 
  NormalLibraryObjectRule()
  NormalLibraryTarget(os,$(OBJS))
  
! SpecialCObjectRule(connection,$(ICONFIGFILES),$(CONN_DEFINES) $(SIGNAL_DEFINES) $(SOCK_DEFINES) $(OS_DEFINES))
  
  SpecialCObjectRule(io,$(ICONFIGFILES),$(CONN_DEFINES))
  
  SpecialCObjectRule(error,$(ICONFIGFILES),$(ERROR_DEFINES))
  
! SpecialCObjectRule(osglue,$(ICONFIGFILES),$(CONN_DEFINES) $(OS_DEFINES))
  
  DependTarget()
*** -	Fri Jul  7 09:33:06 1995
--- xc/programs/xfs/os/connection.c	Fri Jul  7 09:33:06 1995
***************
*** 1,4 ****
! /* $XConsortium: connection.c,v 1.29 94/04/17 19:56:05 mor Exp $ */
  /*
   * handles connections
   */
--- 1,4 ----
! /* $XConsortium: connection.c,v 1.30 95/03/04 12:41:51 kaleb Exp $ */
  /*
   * handles connections
   */
***************
*** 190,200 ****
      for (i = 0; i < MAXSOCKS; i++)
  	ConnectionTranslation[i] = 0;
  
! #if defined(hpux) || defined(SVR4)
      lastfdesc = _NFILE - 1;
  #else
      lastfdesc = getdtablesize() - 1;
! #endif				/* hpux */
  
      if (lastfdesc > MAXSOCKS) {
  	lastfdesc = MAXSOCKS;
--- 190,204 ----
      for (i = 0; i < MAXSOCKS; i++)
  	ConnectionTranslation[i] = 0;
  
! #if !defined(X_NOT_POSIX) && !defined(__FreeBSD__) && !defined(__386BSD__) && !defined(__NetBSD__)
!     lastfdesc = sysconf(_SC_OPEN_MAX) - 1;
! #else
! #ifdef hpux
      lastfdesc = _NFILE - 1;
  #else
      lastfdesc = getdtablesize() - 1;
! #endif
! #endif
  
      if (lastfdesc > MAXSOCKS) {
  	lastfdesc = MAXSOCKS;
*** -	Fri Jul  7 09:33:08 1995
--- xc/programs/xfs/os/osglue.c	Fri Jul  7 09:33:08 1995
***************
*** 1,4 ****
! /* $XConsortium: osglue.c,v 1.10 94/04/17 19:56:07 dpw Exp $ */
  /*
  Copyright (c) 1987  X Consortium
  
--- 1,4 ----
! /* $XConsortium: osglue.c,v 1.12 95/04/07 19:42:57 kaleb Exp $ */
  /*
  Copyright (c) 1987  X Consortium
  
***************
*** 302,312 ****
  
      old_listen_arg[0] = '\0';
  
! #if defined(hpux) || defined(SVR4)
      lastfdesc = _NFILE - 1;
  #else
      lastfdesc = getdtablesize() - 1;
! #endif				/* hpux */
  
      NoticeF("attempting clone...\n");
      child = fork();
--- 302,319 ----
  
      old_listen_arg[0] = '\0';
  
! #ifdef XNO_SYSCONF	/* should only be on FreeBSD 1.x and NetBSD 0.x */
! #undef _SC_OPEN_MAX
! #endif
! #ifdef _SC_OPEN_MAX
!     lastfdesc = sysconf(_SC_OPEN_MAX) - 1;
! #else
! #ifdef hpux
      lastfdesc = _NFILE - 1;
  #else
      lastfdesc = getdtablesize() - 1;
! #endif
! #endif
  
      NoticeF("attempting clone...\n");
      child = fork();
*** -	Fri Jul  7 09:33:10 1995
--- xc/programs/xhost/xhost.c	Fri Jul  7 09:33:09 1995
***************
*** 1,4 ****
! /* $XConsortium: xhost.c,v 11.62 94/04/17 20:23:18 rws Exp $ */
  /*
  
  Copyright (c) 1985, 1986, 1987  X Consortium
--- 1,4 ----
! /* $XConsortium: xhost.c,v 11.63 95/04/03 20:56:49 mor Exp $ */
  /*
  
  Copyright (c) 1985, 1986, 1987  X Consortium
***************
*** 300,312 ****
      static char *remove_msg = "being removed from access control list";
  
      namelen = strlen(name);
!     if ((lname = (char *)malloc(namelen)) == NULL) {
  	fprintf (stderr, "%s: malloc bombed in change_host\n", ProgramName);
  	exit (1);
      }
      for (i = 0; i < namelen; i++) {
  	lname[i] = tolower(name[i]);
      }
      if (!strncmp("inet:", lname, 5)) {
  #if defined(TCPCONN) || defined(STREAMSCONN)
  	family = FamilyInternet;
--- 300,313 ----
      static char *remove_msg = "being removed from access control list";
  
      namelen = strlen(name);
!     if ((lname = (char *)malloc(namelen+1)) == NULL) {
  	fprintf (stderr, "%s: malloc bombed in change_host\n", ProgramName);
  	exit (1);
      }
      for (i = 0; i < namelen; i++) {
  	lname[i] = tolower(name[i]);
      }
+     lname[namelen] = '\0';
      if (!strncmp("inet:", lname, 5)) {
  #if defined(TCPCONN) || defined(STREAMSCONN)
  	family = FamilyInternet;
*** -	Fri Jul  7 09:33:11 1995
--- xc/programs/xmh/init.c	Fri Jul  7 09:33:11 1995
***************
*** 1,5 ****
  /*
!  * $XConsortium: init.c,v 2.80 95/01/25 14:33:57 swick Exp $
   *
   *
   *		        COPYRIGHT 1987, 1989
--- 1,5 ----
  /*
!  * $XConsortium: init.c,v 2.81 95/01/25 14:56:39 swick Exp $
   *
   *
   *		        COPYRIGHT 1987, 1989
***************
*** 365,371 ****
      static Arg shell_args[] = {
  	{XtNinput, (XtArgVal)True},
  	{XtNjoinSession, (XtArgVal)False}, /* join is delayed to end of init */
! 	{XtNenvironment, NULL},	/* set dynamically below */
  	{XtNmappedWhenManaged, (XtArgVal)False}
      };
  
--- 365,371 ----
      static Arg shell_args[] = {
  	{XtNinput, (XtArgVal)True},
  	{XtNjoinSession, (XtArgVal)False}, /* join is delayed to end of init */
! 	{XtNenvironment, (XtArgVal)NULL},  /* set dynamically below */
  	{XtNmappedWhenManaged, (XtArgVal)False}
      };
  
*** -	Fri Jul  7 09:33:13 1995
--- xc/programs/xterm/main.c	Fri Jul  7 09:33:13 1995
***************
*** 1,5 ****
  #ifndef lint
! static char *rid="$XConsortium: main.c,v 1.225.1.1 95/01/13 21:13:04 kaleb Exp $";
  #endif /* lint */
  
  /*
--- 1,5 ----
  #ifndef lint
! static char *rid="$XConsortium: main.c,v 1.227.1.2 95/06/29 18:13:15 kaleb Exp $";
  #endif /* lint */
  
  /*
***************
*** 84,101 ****
  #define ATT
  #endif
  
  #ifdef SVR4
  #define SYSV			/* SVR4 is (approx) superset of SVR3 */
  #define ATT
  #define USE_SYSV_UTMP
  #define USE_TERMIOS
- #define HAS_UTMP_UT_HOST
  #endif
- 
- #if defined(sgi) && OSMAJORVERSION >= 5
- #define SVR4			/* close enough for xterm */
- #define USE_SYSV_UTMP
- #define USE_TERMIOS
  #define HAS_UTMP_UT_HOST
  #endif
  
--- 84,101 ----
  #define ATT
  #endif
  
+ #if defined(sgi) && (OSMAJORVERSION >= 5)
+ #undef SYSV
+ #define SVR4
+ #endif
+ 
  #ifdef SVR4
  #define SYSV			/* SVR4 is (approx) superset of SVR3 */
  #define ATT
  #define USE_SYSV_UTMP
+ #ifndef sgi
  #define USE_TERMIOS
  #endif
  #define HAS_UTMP_UT_HOST
  #endif
  
***************
*** 106,112 ****
  static Bool IsPts = False;
  #endif
  
! #ifdef ATT
  #define USE_USG_PTYS
  #else
  #define USE_HANDSHAKE
--- 106,112 ----
  static Bool IsPts = False;
  #endif
  
! #if defined(ATT) && !defined(sgi)
  #define USE_USG_PTYS
  #else
  #define USE_HANDSHAKE
***************
*** 195,203 ****
--- 195,206 ----
  #define HAS_BSD_GROUPS
  #define USE_SYSV_UTMP
  #define HAS_UTMP_UT_HOST
+ #define USE_POSIX_WAIT
  #include <sys/ptyio.h>
  #endif /* hpux */
  #ifdef sgi
+ #define USE_SYSV_ENVVARS
+ #define HAS_BSD_GROUPS
  #include <sys/sysmacros.h>
  #endif /* sgi */
  #ifdef sun
***************
*** 347,352 ****
--- 350,359 ----
  extern char *ttyname();
  #endif
  
+ #ifdef sgi
+ #include <locale.h>
+ #endif
+ 
  #ifdef SYSV
  extern char *ptsname();
  #endif
***************
*** 371,376 ****
--- 378,388 ----
  #ifdef TIOCSLTC
  static struct ltchars d_ltc;
  #endif	/* TIOCSLTC */
+ 
+ #ifdef sgi
+ #undef TIOCLSET /* XXX why is this undef-ed again? */
+ #endif
+ 
  #ifdef TIOCLSET
  static unsigned int d_lmode;
  #endif	/* TIOCLSET */
***************
*** 396,401 ****
--- 408,448 ----
  #endif /* sony */
  #endif /* USE_SYSV_TERMIO */
  
+ /* allow use of system default characters if defined and reasonable */
+ #ifndef CEOF
+ #define CEOF ('D'&037)
+ #endif
+ #ifndef CSUSP
+ #define CSUSP ('Z'&037)
+ #endif
+ #ifndef CQUIT
+ #define CQUIT ('\\'&037)
+ #endif
+ #ifndef CEOL
+ #define CEOL 0
+ #endif
+ #ifndef CSWTCH
+ #define CSWTCH 0
+ #endif
+ #ifndef CLNEXT
+ #define CLNEXT ('V'&037)
+ #endif
+ #ifndef CWERASE
+ #define CWERASE ('W'&037)
+ #endif
+ #ifndef CRPRNT
+ #define CRPRNT ('R'&037)
+ #endif
+ #ifndef CFLUSH
+ #define CFLUSH ('O'&037)
+ #endif
+ #ifndef CSTOP
+ #define CSTOP ('S'&037)
+ #endif
+ #ifndef CSTART
+ #define CSTART ('Q'&037)
+ #endif
+ 
  static int parse_tty_modes ();
  /*
   * SYSV has the termio.c_cc[V] and ltchars; BSD has tchars and ltchars;
***************
*** 444,450 ****
  };
  
  #ifdef USE_SYSV_UTMP
! #if defined(X_NOT_STDC_ENV) || defined(AIXV3)
  extern struct utmp *getutent();
  extern struct utmp *getutid();
  extern struct utmp *getutline();
--- 491,497 ----
  };
  
  #ifdef USE_SYSV_UTMP
! #if defined(X_NOT_STDC_ENV) || (defined(AIXV3) && OSMAJORVERSION < 4)
  extern struct utmp *getutent();
  extern struct utmp *getutid();
  extern struct utmp *getutline();
***************
*** 517,522 ****
--- 564,572 ----
      Boolean sunFunctionKeys;	/* %%% should be widget resource? */
      Boolean wait_for_map;
      Boolean useInsertMode;
+ #ifdef sgi
+     Boolean useLocale;
+ #endif
  } resource;
  
  /* used by VT (charproc.c) */
***************
*** 544,549 ****
--- 594,603 ----
          offset(wait_for_map), XtRString, "false"},
      {"useInsertMode", "UseInsertMode", XtRBoolean, sizeof (Boolean),
          offset(useInsertMode), XtRString, "false"},
+ #ifdef sgi
+     {"useLocale", "UseLocale", XtRBoolean, sizeof(Boolean),
+ 	offset(useLocale), XtRString, "true"},
+ #endif
  };
  #undef offset
  
***************
*** 611,616 ****
--- 665,674 ----
  {"+t",		"*tekStartup",	XrmoptionNoArg,		(caddr_t) "off"},
  {"-tm",		"*ttyModes",	XrmoptionSepArg,	(caddr_t) NULL},
  {"-tn",		"*termName",	XrmoptionSepArg,	(caddr_t) NULL},
+ #ifdef sgi
+ {"-ul",		"*useLocale",	XrmoptionNoArg,		(caddr_t) "on"},
+ {"+ul",		"*useLocale",	XrmoptionNoArg,		(caddr_t) "off"},
+ #endif
  {"-ut",		"*utmpInhibit",	XrmoptionNoArg,		(caddr_t) "on"},
  {"+ut",		"*utmpInhibit",	XrmoptionNoArg,		(caddr_t) "off"},
  {"-im",		"*useInsertMode", XrmoptionNoArg,	(caddr_t) "on"},
***************
*** 683,688 ****
--- 741,749 ----
  { "-/+t",                  "turn on/off Tek emulation window" },
  { "-tm string",            "terminal mode keywords and characters" },
  { "-tn name",              "TERM environment variable name" },
+ #ifdef sgi
+ { "-/+ul",                 "use/don't use locale for character input" },
+ #endif
  #ifdef UTMP
  { "-/+ut",                 "turn on/off utmp inhibit" },
  #else
***************
*** 859,879 ****
  	strcpy (ttydev, TTYDEV);
  	strcpy (ptydev, PTYDEV);
  
! #ifdef USE_SYSV_TERMIO
  	/* Initialization is done here rather than above in order
  	** to prevent any assumptions about the order of the contents
  	** of the various terminal structures (which may change from
  	** implementation to implementation).
  	*/
- #if defined(macII) || defined(ATT) || defined(CRAY)
  	d_tio.c_iflag = ICRNL|IXON;
  	d_tio.c_oflag = OPOST|ONLCR|TAB3;
      	d_tio.c_cflag = B9600|CS8|CREAD|PARENB|HUPCL;
      	d_tio.c_lflag = ISIG|ICANON|ECHO|ECHOE|ECHOK;
  
! #ifndef USE_TERMIOS
  	d_tio.c_line = 0;
! #endif
  
  	d_tio.c_cc[VINTR] = CINTR;
  	d_tio.c_cc[VQUIT] = CQUIT;
--- 920,946 ----
  	strcpy (ttydev, TTYDEV);
  	strcpy (ptydev, PTYDEV);
  
! #ifdef USE_SYSV_TERMIO /* { */
  	/* Initialization is done here rather than above in order
  	** to prevent any assumptions about the order of the contents
  	** of the various terminal structures (which may change from
  	** implementation to implementation).
  	*/
  	d_tio.c_iflag = ICRNL|IXON;
  	d_tio.c_oflag = OPOST|ONLCR|TAB3;
+ #if defined(macII) || defined(ATT) || defined(CRAY) /* { */
      	d_tio.c_cflag = B9600|CS8|CREAD|PARENB|HUPCL;
      	d_tio.c_lflag = ISIG|ICANON|ECHO|ECHOE|ECHOK;
+ #ifdef ECHOKE
+ 	d_tio.c_lflag |= ECHOKE|IEXTEN;
+ #endif
+ #ifdef ECHOCTL
+ 	d_tio.c_lflag |= ECHOCTL|IEXTEN;
+ #endif
  
! #ifndef USE_TERMIOS /* { */
  	d_tio.c_line = 0;
! #endif /* } */
  
  	d_tio.c_cc[VINTR] = CINTR;
  	d_tio.c_cc[VQUIT] = CQUIT;
***************
*** 884,935 ****
  	d_tio.c_cc[VEOL2] = CNUL;
  	d_tio.c_cc[VSWTCH] = CNUL;
  
! #ifdef USE_TERMIOS
  	d_tio.c_cc[VSUSP] = CSUSP;
  	d_tio.c_cc[VDSUSP] = CDSUSP;
! 	d_tio.c_cc[VREPRINT] = CNUL;
! 	d_tio.c_cc[VDISCARD] = CNUL;
! 	d_tio.c_cc[VWERASE] = CNUL;
! 	d_tio.c_cc[VLNEXT] = CNUL;
! #endif
! #ifdef TIOCSLTC
          d_ltc.t_suspc = CSUSP;		/* t_suspc */
          d_ltc.t_dsuspc = CDSUSP;	/* t_dsuspc */
!         d_ltc.t_rprntc = 0;		/* reserved...*/
!         d_ltc.t_flushc = 0;
!         d_ltc.t_werasc = 0;
!         d_ltc.t_lnextc = 0;
! #endif /* TIOCSLTC */
! #ifdef TIOCLSET
  	d_lmode = 0;
! #endif /* TIOCLSET */
! #else  /* else !macII */
! 	d_tio.c_iflag = ICRNL|IXON;
! 	d_tio.c_oflag = OPOST|ONLCR|TAB3;
! #ifdef BAUD_0
      	d_tio.c_cflag = CS8|CREAD|PARENB|HUPCL;
! #else	/* !BAUD_0 */
      	d_tio.c_cflag = B9600|CS8|CREAD|PARENB|HUPCL;
! #endif	/* !BAUD_0 */
      	d_tio.c_lflag = ISIG|ICANON|ECHO|ECHOE|ECHOK;
! #ifndef sgi
! 	d_tio.c_line = 0;
  #endif
! #ifndef linux
! 	d_tio.c_cc[VINTR] = 0x7f;		/* DEL  */
! 	d_tio.c_cc[VERASE] = '#';		/* '#'	*/
! 	d_tio.c_cc[VKILL] = '@';		/* '@'	*/
  #else
  	d_tio.c_cc[VINTR] = 'C' & 0x3f;		/* '^C'	*/
  	d_tio.c_cc[VERASE] = 0x7f;		/* DEL	*/
  	d_tio.c_cc[VKILL] = 'U' & 0x3f;		/* '^U'	*/
! #endif
! 	d_tio.c_cc[VQUIT] = '\\' & 0x3f;	/* '^\'	*/
!     	d_tio.c_cc[VEOF] = 'D' & 0x3f;		/* '^D'	*/
! 	d_tio.c_cc[VEOL] = '@' & 0x3f;		/* '^@'	*/
  #ifdef VSWTCH
! 	d_tio.c_cc[VSWTCH] = '@' & 0x3f;	/* '^@'	*/
! #endif	/* VSWTCH */
  	/* now, try to inherit tty settings */
  	{
  	    int i;
--- 951,1036 ----
  	d_tio.c_cc[VEOL2] = CNUL;
  	d_tio.c_cc[VSWTCH] = CNUL;
  
! #ifdef USE_TERMIOS /* { */
  	d_tio.c_cc[VSUSP] = CSUSP;
  	d_tio.c_cc[VDSUSP] = CDSUSP;
! 	d_tio.c_cc[VREPRINT] = CRPRNT;
! 	d_tio.c_cc[VDISCARD] = CFLUSH;
! 	d_tio.c_cc[VWERASE] = CWERASE;
! 	d_tio.c_cc[VLNEXT] = CLNEXT;
! #endif /* } */
! #ifdef TIOCSLTC /* { */
          d_ltc.t_suspc = CSUSP;		/* t_suspc */
          d_ltc.t_dsuspc = CDSUSP;	/* t_dsuspc */
!         d_ltc.t_rprntc = CRPRNT;
!         d_ltc.t_flushc = CFLUSH;
!         d_ltc.t_werasc = CWERASE;
!         d_ltc.t_lnextc = CLNEXT;
! #endif /* } TIOCSLTC */
! #ifdef TIOCLSET /* { */
  	d_lmode = 0;
! #endif /* } TIOCLSET */
! #else  /* }{ else !macII, ATT, CRAY */
! #ifdef BAUD_0 /* { */
      	d_tio.c_cflag = CS8|CREAD|PARENB|HUPCL;
! #else	/* }{ !BAUD_0 */
      	d_tio.c_cflag = B9600|CS8|CREAD|PARENB|HUPCL;
! #endif	/* } !BAUD_0 */
      	d_tio.c_lflag = ISIG|ICANON|ECHO|ECHOE|ECHOK;
! #ifdef ECHOKE
! 	d_tio.c_lflag |= ECHOKE|IEXTEN;
  #endif
! #ifdef ECHOCTL
! 	d_tio.c_lflag |= ECHOCTL|IEXTEN;
! #endif
! #ifdef NTTYDISC
!         d_tio.c_line = NTTYDISC;
  #else
+ 	d_tio.c_line = 0;
+ #endif	
+ #ifdef sgi
+         d_tio.c_cflag &= ~(HUPCL|PARENB);
+         d_tio.c_iflag |= BRKINT|ISTRIP|IGNPAR;
+ #endif
  	d_tio.c_cc[VINTR] = 'C' & 0x3f;		/* '^C'	*/
  	d_tio.c_cc[VERASE] = 0x7f;		/* DEL	*/
  	d_tio.c_cc[VKILL] = 'U' & 0x3f;		/* '^U'	*/
! 	d_tio.c_cc[VQUIT] = CQUIT;		/* '^\'	*/
!     	d_tio.c_cc[VEOF] = CEOF;		/* '^D'	*/
! 	d_tio.c_cc[VEOL] = CEOL;		/* '^@'	*/
  #ifdef VSWTCH
! 	d_tio.c_cc[VSWTCH] = CSWTCH;            /* usually '^Z' */
! #endif
! #ifdef VLNEXT
! 	d_tio.c_cc[VLNEXT] = CLNEXT;
! #endif
! #ifdef VWERASE
! 	d_tio.c_cc[VWERASE] = CWERASE;
! #endif
! #ifdef VREPRINT
! 	d_tio.c_cc[VREPRINT] = CRPRNT;
! #endif
! #ifdef VRPRNT
! 	d_tio.c_cc[VRPRNT] = CRPRNT;
! #endif
! #ifdef VDISCARD
! 	d_tio.c_cc[VDISCARD] = CFLUSH;
! #endif
! #ifdef VFLUSHO
! 	d_tio.c_cc[VFLUSHO] = CFLUSH;
! #endif
! #ifdef VSTOP
! 	d_tio.c_cc[VSTOP] = CSTOP;
! #endif
! #ifdef VSTART
! 	d_tio.c_cc[VSTART] = CSTART;
! #endif
! #ifdef VSUSP
! 	d_tio.c_cc[VSUSP] = CSUSP;
! #endif
! #ifdef VDSUSP
! 	d_tio.c_cc[VDSUSP] = CDSUSP;
! #endif
  	/* now, try to inherit tty settings */
  	{
  	    int i;
***************
*** 945,980 ****
  		    d_tio.c_cc[VEOL] = deftio.c_cc[VEOL];
  #ifdef VSWTCH
  		    d_tio.c_cc[VSWTCH] = deftio.c_cc[VSWTCH];
! #endif /* VSWTCH */
  		    break;
  		}
  	    }
  	}
! #ifdef TIOCSLTC
          d_ltc.t_suspc = '\000';		/* t_suspc */
          d_ltc.t_dsuspc = '\000';	/* t_dsuspc */
          d_ltc.t_rprntc = '\377';	/* reserved...*/
          d_ltc.t_flushc = '\377';
          d_ltc.t_werasc = '\377';
          d_ltc.t_lnextc = '\377';
! #endif	/* TIOCSLTC */
! #ifdef USE_TERMIOS
! #ifndef linux
! 	d_tio.c_cc[VSUSP] = '\000';
! #else
! 	d_tio.c_cc[VSUSP] = 'Z' & 0x3f;
! #endif
  	d_tio.c_cc[VDSUSP] = '\000';
  	d_tio.c_cc[VREPRINT] = '\377';
  	d_tio.c_cc[VDISCARD] = '\377';
  	d_tio.c_cc[VWERASE] = '\377';
  	d_tio.c_cc[VLNEXT] = '\377';
! #endif
! #ifdef TIOCLSET
  	d_lmode = 0;
! #endif	/* TIOCLSET */
! #endif  /* macII */
! #endif	/* USE_SYSV_TERMIO */
  
  	/* Init the Toolkit. */
  	XtSetErrorHandler(xt_error);
--- 1046,1110 ----
  		    d_tio.c_cc[VEOL] = deftio.c_cc[VEOL];
  #ifdef VSWTCH
  		    d_tio.c_cc[VSWTCH] = deftio.c_cc[VSWTCH];
! #endif
! #ifdef VEOL2
! 		    d_tio.c_cc[VEOL2] = deftio.c_cc[VEOL2];
! #endif
! #ifdef VLNEXT
! 		    d_tio.c_cc[VLNEXT] = deftio.c_cc[VLNEXT];
! #endif
! #ifdef VWERASE
! 		    d_tio.c_cc[VWERASE] = deftio.c_cc[VWERASE];
! #endif
! #ifdef VREPRINT
! 		    d_tio.c_cc[VREPRINT] = deftio.c_cc[VREPRINT];
! #endif
! #ifdef VRPRNT
! 		    d_tio.c_cc[VRPRNT] = deftio.c_cc[VRPRNT];
! #endif
! #ifdef VDISCARD
! 		    d_tio.c_cc[VDISCARD] = deftio.c_cc[VDISCARD];
! #endif
! #ifdef VFLUSHO
! 		    d_tio.c_cc[VFLUSHO] = deftio.c_cc[VFLUSHO];
! #endif
! #ifdef VSTOP
! 		    d_tio.c_cc[VSTOP] = deftio.c_cc[VSTOP];
! #endif
! #ifdef VSTART
! 		    d_tio.c_cc[VSTART] = deftio.c_cc[VSTART];
! #endif
! #ifdef VSUSP
! 		    d_tio.c_cc[VSUSP] = deftio.c_cc[VSUSP];
! #endif
! #ifdef VDSUSP
! 		    d_tio.c_cc[VDSUSP] = deftio.c_cc[VDSUSP];
! #endif
  		    break;
  		}
  	    }
  	}
! #ifdef TIOCSLTC /* { */
          d_ltc.t_suspc = '\000';		/* t_suspc */
          d_ltc.t_dsuspc = '\000';	/* t_dsuspc */
          d_ltc.t_rprntc = '\377';	/* reserved...*/
          d_ltc.t_flushc = '\377';
          d_ltc.t_werasc = '\377';
          d_ltc.t_lnextc = '\377';
! #endif	/* } TIOCSLTC */
! #ifdef USE_TERMIOS /* { */
! 	d_tio.c_cc[VSUSP] = CSUSP;
  	d_tio.c_cc[VDSUSP] = '\000';
  	d_tio.c_cc[VREPRINT] = '\377';
  	d_tio.c_cc[VDISCARD] = '\377';
  	d_tio.c_cc[VWERASE] = '\377';
  	d_tio.c_cc[VLNEXT] = '\377';
! #endif /* } USE_TERMIOS */
! #ifdef TIOCLSET /* { */
  	d_lmode = 0;
! #endif	/* } TIOCLSET */
! #endif  /* } macII, ATT, CRAY */
! #endif	/* } USE_SYSV_TERMIO */
  
  	/* Init the Toolkit. */
  	XtSetErrorHandler(xt_error);
***************
*** 986,991 ****
--- 1116,1126 ----
  				  application_resources,
  				  XtNumber(application_resources), NULL, 0);
  
+ #ifdef sgi
+ 	if (resource.useLocale)
+ 	    setlocale(LC_ALL,"");
+ #endif
+ 
  	waiting_for_initial_map = resource.wait_for_map;
  
  	/*
***************
*** 1041,1046 ****
--- 1176,1182 ----
  		/* NOTREACHED */
  	     case 'C':
  #if defined(TIOCCONS) || defined(SRIOCSREDIR)
+ #ifndef sgi
  		{
  		    struct stat sbuf;
  
***************
*** 1054,1059 ****
--- 1190,1198 ----
  		    } else
  			Console = FALSE;
  		}
+ #else /* sgi */
+ 		Console = TRUE;
+ #endif /* sgi */
  #endif	/* TIOCCONS */
  		continue;
  	     case 'S':
***************
*** 1222,1227 ****
--- 1361,1367 ----
  	screen->inhibit = inhibit;
  
  #ifdef AIXV3
+ #if OSMAJORVERSION < 4
  	/* In AIXV3, xterms started from /dev/console have CLOCAL set.
  	 * This means we need to clear CLOCAL so that SIGHUP gets sent
  	 * to the slave-pty process when xterm exits. 
***************
*** 1239,1244 ****
--- 1379,1385 ----
  		SysError(ERROR_TIOCSETP);
  	}
  #endif
+ #endif
  #ifdef USE_SYSV_TERMIO
  	if (0 > (mode = fcntl(pty, F_GETFL, 0)))
  		Error();
***************
*** 1318,1324 ****
          if (pty_search(pty) == 0)
  	    return 0;
  #endif /* SYSV && i386 && !SVR4 */
! #ifdef ATT
  	if ((*pty = open ("/dev/ptmx", O_RDWR)) < 0) {
  	    return 1;
  	}
--- 1459,1465 ----
          if (pty_search(pty) == 0)
  	    return 0;
  #endif /* SYSV && i386 && !SVR4 */
! #if defined(ATT) && !defined(sgi)
  	if ((*pty = open ("/dev/ptmx", O_RDWR)) < 0) {
  	    return 1;
  	}
***************
*** 1514,1519 ****
--- 1655,1666 ----
  	SIGNAL_RETURN;
  }
  
+ /*
+  * declared outside USE_HANDSHAKE so HsSysError() callers can use
+  */
+ static int pc_pipe[2];	/* this pipe is used for parent to child transfer */
+ static int cp_pipe[2];	/* this pipe is used for child to parent transfer */
+ 
  #ifdef USE_HANDSHAKE
  typedef enum {		/* c == child, p == parent                        */
  	PTY_BAD,	/* c->p: can't open pty slave for some reason     */
***************
*** 1559,1567 ****
  	exit(error);
  }
  
- static int pc_pipe[2];	/* this pipe is used for parent to child transfer */
- static int cp_pipe[2];	/* this pipe is used for child to parent transfer */
- 
  void first_map_occurred ()
  {
      handshake_t handshake;
--- 1706,1711 ----
***************
*** 1579,1589 ****
  /*
   * temporary hack to get xterm working on att ptys
   */
  void first_map_occurred ()
  {
      return;
  }
- #define HsSysError(a,b)
  #endif /* USE_HANDSHAKE else !USE_HANDSHAKE */
  
  
--- 1723,1741 ----
  /*
   * temporary hack to get xterm working on att ptys
   */
+ void
+ HsSysError(pf, error)
+     int pf;
+     int error;
+ {
+     fprintf(stderr, "%s: fatal pty error %d (errno=%d) on tty %s\n",
+ 	    xterm_name, error, errno, ttydev);
+     exit(error);
+ }
  void first_map_occurred ()
  {
      return;
  }
  #endif /* USE_HANDSHAKE else !USE_HANDSHAKE */
  
  
***************
*** 1708,1718 ****
  		 * Check results and ignore current control terminal if
  		 * necessary.  ENXIO is what is normally returned if there is
  		 * no controlling terminal, but some systems (e.g. SunOS 4.0)
! 		 * seem to return EIO.
  		 */
   		if (tty < 0) {
  			if (tty_got_hung || errno == ENXIO || errno == EIO ||
! 			    errno == ENOTTY) {
  				no_dev_tty = TRUE;
  #ifdef TIOCSLTC
  				ltc = d_ltc;
--- 1860,1870 ----
  		 * Check results and ignore current control terminal if
  		 * necessary.  ENXIO is what is normally returned if there is
  		 * no controlling terminal, but some systems (e.g. SunOS 4.0)
! 		 * seem to return EIO.  Solaris 2.3 is said to return EINVAL.
  		 */
   		if (tty < 0) {
  			if (tty_got_hung || errno == ENXIO || errno == EIO ||
! 			    errno == EINVAL || errno == ENOTTY) {
  				no_dev_tty = TRUE;
  #ifdef TIOCSLTC
  				ltc = d_ltc;
***************
*** 2126,2140 ****
  		    tio.c_cflag &= ~(CBAUD);
  		    tio.c_cflag |= B9600;
  #endif	/* !BAUD_0 */
  		    /* enable signals, canonical processing (erase, kill, etc),
  		    ** echo
  		    */
! 		    tio.c_lflag |= ISIG|ICANON|ECHO;
! 		    /* reset EOL to defalult value */
! 		    tio.c_cc[VEOL] = '@' & 0x3f;		/* '^@'	*/
  		    /* certain shells (ksh & csh) change EOF as well */
! 		    tio.c_cc[VEOF] = 'D' & 0x3f;		/* '^D'	*/
! 
  #define TMODE(ind,var) if (ttymodelist[ind].set) var = ttymodelist[ind].value;
  		    if (override_tty_modes) {
  			/* sysv-specific */
--- 2278,2332 ----
  		    tio.c_cflag &= ~(CBAUD);
  		    tio.c_cflag |= B9600;
  #endif	/* !BAUD_0 */
+ 		    tio.c_cflag &= ~CSIZE;
+ 		    if (screen->input_eight_bits)
+ 			tio.c_cflag |= CS8;
+ 		    else
+ 			tio.c_cflag |= CS7;
  		    /* enable signals, canonical processing (erase, kill, etc),
  		    ** echo
  		    */
! 		    tio.c_lflag |= ISIG|ICANON|ECHO|ECHOE|ECHOK;
! #ifdef ECHOKE
! 		    tio.c_lflag |= ECHOKE|IEXTEN;
! #endif
! #ifdef ECHOCTL
! 		    tio.c_lflag |= ECHOCTL|IEXTEN;
! #endif
! 		    /* reset EOL to default value */
! 		    tio.c_cc[VEOL] = CEOL;			/* '^@' */
  		    /* certain shells (ksh & csh) change EOF as well */
! 		    tio.c_cc[VEOF] = CEOF;			/* '^D' */
! #ifdef VLNEXT
! 		    tio.c_cc[VLNEXT] = CLNEXT;
! #endif
! #ifdef VWERASE
! 		    tio.c_cc[VWERASE] = CWERASE;
! #endif
! #ifdef VREPRINT
! 		    tio.c_cc[VREPRINT] = CRPRNT;
! #endif
! #ifdef VRPRNT
! 		    tio.c_cc[VRPRNT] = CRPRNT;
! #endif
! #ifdef VDISCARD
! 		    tio.c_cc[VDISCARD] = CFLUSH;
! #endif
! #ifdef VFLUSHO
! 		    tio.c_cc[VFLUSHO] = CFLUSH;
! #endif
! #ifdef VSTOP
! 		    tio.c_cc[VSTOP] = CSTOP;
! #endif
! #ifdef VSTART
! 		    tio.c_cc[VSTART] = CSTART;
! #endif
! #ifdef VSUSP
! 		    tio.c_cc[VSUSP] = CSUSP;
! #endif
! #ifdef VDSUSP
! 		    tio.c_cc[VDSUSP] = CDSUSP;
! #endif
  #define TMODE(ind,var) if (ttymodelist[ind].set) var = ttymodelist[ind].value;
  		    if (override_tty_modes) {
  			/* sysv-specific */
***************
*** 2145,2151 ****
  			TMODE (XTTYMODE_eof, tio.c_cc[VEOF]);
  			TMODE (XTTYMODE_eol, tio.c_cc[VEOL]);
  #ifdef VSWTCH
! 			TMODE (XTTYMODE_swtch, d_tio.c_cc[VSWTCH]);
  #endif
  #ifdef TIOCSLTC
  			/* both SYSV and BSD have ltchars */
--- 2337,2373 ----
  			TMODE (XTTYMODE_eof, tio.c_cc[VEOF]);
  			TMODE (XTTYMODE_eol, tio.c_cc[VEOL]);
  #ifdef VSWTCH
! 			TMODE (XTTYMODE_swtch, tio.c_cc[VSWTCH]);
! #endif
! #ifdef VSUSP
! 			TMODE (XTTYMODE_susp, tio.c_cc[VSUSP]);
! #endif
! #ifdef VDSUSP
! 			TMODE (XTTYMODE_dsusp, tio.c_cc[VDSUSP]);
! #endif
! #ifdef VREPRINT
! 			TMODE (XTTYMODE_rprnt, tio.c_cc[VREPRINT]);
! #endif
! #ifdef VRPRNT
! 			TMODE (XTTYMODE_rprnt, tio.c_cc[VRPRNT]);
! #endif
! #ifdef VDISCARD
! 			TMODE (XTTYMODE_flush, tio.c_cc[VDISCARD]);
! #endif
! #ifdef VFLUSHO
! 			TMODE (XTTYMODE_flush, tio.c_cc[VFLUSHO]);
! #endif
! #ifdef VWERASE
! 			TMODE (XTTYMODE_weras, tio.c_cc[VWERASE]);
! #endif
! #ifdef VLNEXT
! 			TMODE (XTTYMODE_lnext, tio.c_cc[VLNEXT]);
! #endif
! #ifdef VSTART
! 			TMODE (XTTYMODE_start, tio.c_cc[VSTART]);
! #endif
! #ifdef VSTOP
! 			TMODE (XTTYMODE_stop, tio.c_cc[VSTOP]);
  #endif
  #ifdef TIOCSLTC
  			/* both SYSV and BSD have ltchars */
***************
*** 2159,2166 ****
  		    }
  #undef TMODE
  
- 		    if (ioctl (tty, TCSETA, &tio) == -1)
- 			    HsSysError(cp_pipe[1], ERROR_TIOCSETP);
  #ifdef TIOCSLTC
  		    if (ioctl (tty, TIOCSLTC, &ltc) == -1)
  			    HsSysError(cp_pipe[1], ERROR_TIOCSETC);
--- 2381,2386 ----
***************
*** 2169,2174 ****
--- 2389,2396 ----
  		    if (ioctl (tty, TIOCLSET, (char *)&lmode) == -1)
  			    HsSysError(cp_pipe[1], ERROR_TIOCLSET);
  #endif	/* TIOCLSET */
+ 		    if (ioctl (tty, TCSETA, &tio) == -1)
+ 			    HsSysError(cp_pipe[1], ERROR_TIOCSETP);
  #else	/* USE_SYSV_TERMIO */
  		    sg.sg_flags &= ~(ALLDELAY | XTABS | CBREAK | RAW);
  		    sg.sg_flags |= ECHO | CRMOD;
***************
*** 2177,2187 ****
  		    sg.sg_ospeed = B9600;
  		    /* reset t_brkc to default value */
  		    tc.t_brkc = -1;
! #ifdef sony
  		    if (screen->input_eight_bits)
  			lmode |= LPASS8;
  		    else
  			lmode &= ~(LPASS8);
  		    jmode &= ~KM_KANJI;
  #endif /* sony */
  
--- 2399,2411 ----
  		    sg.sg_ospeed = B9600;
  		    /* reset t_brkc to default value */
  		    tc.t_brkc = -1;
! #ifdef LPASS8
  		    if (screen->input_eight_bits)
  			lmode |= LPASS8;
  		    else
  			lmode &= ~(LPASS8);
+ #endif
+ #ifdef sony
  		    jmode &= ~KM_KANJI;
  #endif /* sony */
  
***************
*** 2353,2360 ****
--- 2577,2590 ----
  		(void) setutent ();
  		/* set up entry to search for */
  		ptyname = ttydev;
+ #ifndef sgi
  		(void) strncpy(utmp.ut_id,ptyname + strlen(ptyname)-PTYCHARLEN,
  			       sizeof (utmp.ut_id));
+ #else
+ 		(void) strncpy(utmp.ut_id,ptyname + sizeof("/dev/tty")-1,
+ 			       sizeof (utmp.ut_id));
+ 
+ #endif
  		utmp.ut_type = DEAD_PROCESS;
  
  		/* position to entry in utmp file */
***************
*** 2377,2389 ****
  #ifdef HAS_UTMP_UT_HOST
  		(void) strncpy(buf, DisplayString(screen->display),
  			       sizeof(buf));
- #ifndef linux
  	        {
  		    char *disfin = strrchr(buf, ':');
  		    if (disfin)
  			*disfin = '\0';
  		}
- #endif
  		(void) strncpy(utmp.ut_host, buf, sizeof(utmp.ut_host));
  #endif
  		(void) strncpy(utmp.ut_name, pw->pw_name, 
--- 2607,2617 ----
***************
*** 2436,2442 ****
  					       XDisplayString (screen->display),
  					       sizeof(utmp.ut_host));
  #endif
! 				time(&utmp.ut_time);
  				lseek(i, (long)(tslot * sizeof(struct utmp)), 0);
  				write(i, (char *)&utmp, sizeof(struct utmp));
  				close(i);
--- 2664,2671 ----
  					       XDisplayString (screen->display),
  					       sizeof(utmp.ut_host));
  #endif
! 				/* cast needed on Ultrix 4.4 */
! 				time((Time_t*)&utmp.ut_time);
  				lseek(i, (long)(tslot * sizeof(struct utmp)), 0);
  				write(i, (char *)&utmp, sizeof(struct utmp));
  				close(i);
*** -	Fri Jul  7 09:33:15 1995
--- xc/programs/xterm/TekPrsTbl.c	Fri Jul  7 09:33:15 1995
***************
*** 1,5 ****
  /*
!  *	$XConsortium: TekPrsTbl.c,v 1.7 91/05/29 18:06:16 gildea Exp $
   */
  
  
--- 1,5 ----
  /*
!  *	$XConsortium: TekPrsTbl.c,v 1.8 95/06/08 23:20:39 gildea Exp $
   */
  
  
***************
*** 28,34 ****
  
  #include "Tekparse.h"
  
! #if __STDC__
  #define Const const
  #else
  #define Const /**/
--- 28,34 ----
  
  #include "Tekparse.h"
  
! #ifdef __STDC__
  #define Const const
  #else
  #define Const /**/
*** -	Fri Jul  7 09:33:16 1995
--- xc/programs/xterm/VTPrsTbl.c	Fri Jul  7 09:33:16 1995
***************
*** 1,5 ****
  /*
!  *	$XConsortium: VTPrsTbl.c,v 1.9 92/09/15 15:28:28 gildea Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  *	$XConsortium: VTPrsTbl.c,v 1.10 95/06/09 22:17:06 gildea Exp $
   */
  
  /*
***************
*** 27,33 ****
  
  #include "VTparse.h"
  
! #if __STDC__
  #define Const const
  #else
  #define Const /**/
--- 27,33 ----
  
  #include "VTparse.h"
  
! #ifdef __STDC__
  #define Const const
  #else
  #define Const /**/
*** -	Fri Jul  7 09:33:18 1995
--- xc/config/imake/imakemdep.h	Fri Jul  7 09:33:18 1995
***************
*** 1,4 ****
! /* $XConsortium: imakemdep.h,v 1.82 95/01/12 16:27:01 kaleb Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
--- 1,4 ----
! /* $XConsortium: imakemdep.h,v 1.83 95/04/07 19:47:46 kaleb Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
***************
*** 254,260 ****
  	"-D__i386__",
  # endif
  # ifdef __GNUC__
! 	"-traditional"
  # endif
  #endif
  #ifdef M4330
--- 254,260 ----
  	"-D__i386__",
  # endif
  # ifdef __GNUC__
! 	"-traditional",
  # endif
  #endif
  #ifdef M4330
***************
*** 417,423 ****
  	"-D__i386__",
  # endif
  # ifdef __GNUC__
! 	"-traditional"
  # endif
  #endif
  #ifdef Oki
--- 417,423 ----
  	"-D__i386__",
  # endif
  # ifdef __GNUC__
! 	"-traditional",
  # endif
  #endif
  #ifdef Oki
***************
*** 673,678 ****
--- 673,690 ----
  #endif
  #ifdef PC_UX
  	{"PC_UX", "1"},
+ #endif
+ #ifdef sgi
+ 	{"sgi", "1"},
+ #endif
+ #ifdef __sgi
+ 	{"__sgi", "1"},
+ #endif
+ #ifdef __FreeBSD__
+ 	{"__FreeBSD__", "1"},
+ #endif
+ #ifdef __NetBSD__
+ 	{"__NetBSD__", "1"},
  #endif
  	/* add any additional symbols before this line */
  	{NULL, NULL}
*** -	Fri Jul  7 09:33:19 1995
--- xc/config/makedepend/ifparser.c	Fri Jul  7 09:33:19 1995
***************
*** 1,5 ****
  /*
!  * $XConsortium: ifparser.c,v 1.7 94/01/18 21:30:50 rws Exp $
   *
   * Copyright 1992 Network Computing Devices, Inc.
   * 
--- 1,5 ----
  /*
!  * $XConsortium: ifparser.c,v 1.8 95/06/03 00:01:41 gildea Exp $
   *
   * Copyright 1992 Network Computing Devices, Inc.
   * 
***************
*** 160,165 ****
--- 160,167 ----
        case 'd':
  	if (strncmp (cp, "defined", 7) == 0 && !isalnum(cp[7])) {
  	    int paren = 0;
+ 	    int len;
+ 
  	    cp += 7;
  	    SKIPSPACE (cp);
  	    if (*cp == '(') {
***************
*** 167,176 ****
  		cp++;
  	    }
  	    DO (cp = parse_variable (g, cp, &var));
  	    SKIPSPACE (cp);
  	    if (paren && *cp != ')')
  		return CALLFUNC(g, handle_error) (g, cp, ")");
! 	    *valp = (*(g->funcs.eval_defined)) (g, var, cp - var);
  	    return cp + paren;		/* skip the right paren */
  	}
  	/* fall out */
--- 169,179 ----
  		cp++;
  	    }
  	    DO (cp = parse_variable (g, cp, &var));
+ 	    len = cp - var;
  	    SKIPSPACE (cp);
  	    if (paren && *cp != ')')
  		return CALLFUNC(g, handle_error) (g, cp, ")");
! 	    *valp = (*(g->funcs.eval_defined)) (g, var, len);
  	    return cp + paren;		/* skip the right paren */
  	}
  	/* fall out */
*** -	Fri Jul  7 09:33:20 1995
--- xc/config/cf/Imake.tmpl	Fri Jul  7 09:33:20 1995
***************
*** 1,6 ****
  XCOMM ----------------------------------------------------------------------
  XCOMM Makefile generated from IMAKE_TEMPLATE and INCLUDE_IMAKEFILE
! XCOMM $XConsortium: Imake.tmpl,v 1.224 94/12/27 03:57:50 gildea Exp $
  XCOMM
  
  /*
--- 1,6 ----
  XCOMM ----------------------------------------------------------------------
  XCOMM Makefile generated from IMAKE_TEMPLATE and INCLUDE_IMAKEFILE
! XCOMM $XConsortium: Imake.tmpl,v 1.224.1.1 95/06/19 17:51:01 gildea Exp $
  XCOMM
  
  /*
***************
*** 581,586 ****
--- 581,589 ----
  #endif
  #ifndef Malloc0ReturnsNull
  #define Malloc0ReturnsNull NO
+ #endif
+ #ifndef ToolkitStringsABIOptions
+ #define ToolkitStringsABIOptions /**/
  #endif
  #ifndef NdbmDefines
  #if HasNdbm
*** -	Fri Jul  7 09:33:22 1995
--- xc/config/cf/Imake.rules	Fri Jul  7 09:33:22 1995
***************
*** 1,6 ****
  XCOMM -----------------------------------------------------------------------
  XCOMM Imake rules for building libraries, programs, scripts, and data files
! XCOMM rules:  $XConsortium: Imake.rules,v 1.197 94/12/05 19:30:41 gildea Exp $
  
  /*
   *		   MACHINE-INDEPENDENT RULES; DO NOT MODIFY
--- 1,6 ----
  XCOMM -----------------------------------------------------------------------
  XCOMM Imake rules for building libraries, programs, scripts, and data files
! XCOMM rules:  $XConsortium: Imake.rules,v 1.197.1.1 95/06/19 18:01:48 gildea Exp $
  
  /*
   *		   MACHINE-INDEPENDENT RULES; DO NOT MODIFY
***************
*** 290,296 ****
  ProgramTargetName(program.sentinel): deplist				@@\
  	RemoveTargetProgram($@)						@@\
  	$(CCENVSETUP) $(SENTINEL) $(SENTINELOPTIONS) $(CC) -o $@ $(LDOPTIONS) linklist $(EXTRA_LOAD_FLAGS) @@\
! 
  clean clean.sentinel::							@@\
  	RemoveFile(program.sentinel)
  #else
--- 290,296 ----
  ProgramTargetName(program.sentinel): deplist				@@\
  	RemoveTargetProgram($@)						@@\
  	$(CCENVSETUP) $(SENTINEL) $(SENTINELOPTIONS) $(CC) -o $@ $(LDOPTIONS) linklist $(EXTRA_LOAD_FLAGS) @@\
! 									@@\
  clean clean.sentinel::							@@\
  	RemoveFile(program.sentinel)
  #else
*** -	Fri Jul  7 09:33:24 1995
--- xc/config/cf/Library.tmpl	Fri Jul  7 09:33:24 1995
***************
*** 9,15 ****
   * LibName, SoRev, HasSharedData, and optionally HugeLibrary and IncSubdir
   */
  
! XCOMM $XConsortium: Library.tmpl,v 1.32 94/05/14 15:10:41 rws Exp $
  
  #ifndef LibraryCplusplusOptions
  #if DoSharedLib && defined(SharedLibraryCplusplusOptions)
--- 9,15 ----
   * LibName, SoRev, HasSharedData, and optionally HugeLibrary and IncSubdir
   */
  
! XCOMM $XConsortium: Library.tmpl,v 1.34 95/06/16 17:44:51 gildea Exp $
  
  #ifndef LibraryCplusplusOptions
  #if DoSharedLib && defined(SharedLibraryCplusplusOptions)
***************
*** 203,208 ****
--- 203,255 ----
  									@@\
  CenterLoadTarget(debug_src,basename.SRCsuf,NullParameter,$(ALLDEFINES) options)
  #endif /* SpecialCplusplusLibObjectRule */
+ 
+ /*
+  * ToolkitMakeStrings generates a string-table, i.e., a C source
+  * file and the matching header(s), e.g., Xt's StringDefs.c, StringDefs.h,
+  * and Shell.h files; or Motif's XmStrDefs.c and XmStrDefs.h files.
+  *
+  * The 'files' argument is the list of files that will be produced by
+  * this rule, e.g., for Xt they would be "Shell.h StringDefs.c StringDefs.h"
+  * and for Motif they would be "XmStrDefs.c XmStrDefs.h".
+  *
+  * The 'source' argument is the string-list file to be parsed, e.g., in
+  * Xt that would be "util/string.list".  For Motif 2.0 it would be
+  * "../../tools/makestr/xmstring.list", and for Motif-CDE1 it would be
+  * "util/xmstring.list".
+  *
+  * The 'options' argument is passed by the library's Imakefile, see the
+  * Xt Imakefile for an example.  Typically this would be nothing, -intelabi,
+  * or -sparcabi; there are other choices, but these are typical.
+  *
+  * The 'depends' argument names additional files the target files
+  * depend on.  It should name the #ctmpl and #htmpl files from the
+  * 'source' file.
+  *
+  * The 'dest' argument is the C source output file.  For Xt this should
+  * be "StringDefs.c", and for all versions of Motif it would be "XmStrDefs.c"
+  *
+  * Headers are generated and named according to data in the 'source'
+  * file.
+  */
+ 
+ #ifndef ToolkitMakeStrings
+ #define ToolkitMakeStrings(files,source,options,depends,dest)		@@\
+ MAKESTRS = $(CONFIGSRC)/util/makestrs					@@\
+ 									@@\
+ $(MAKESTRS): $(MAKESTRS).c						@@\
+ 	cd $(CONFIGSRC)/util && make makestrs				@@\
+ 									@@\
+ files: $(MAKESTRS) source depends					@@\
+ 	RemoveFiles(files)						@@\
+ 	RunProgram(MAKESTRS,options < source > dest)			@@\
+ 									@@\
+ AllTarget(files)							@@\
+ 									@@\
+ includes:: files							@@\
+ 									@@\
+ depend:: files
+ #endif /* ToolkitMakeStrings */
  
  #ifdef LibName
  
*** -	Fri Jul  7 09:33:25 1995
--- xc/config/cf/FreeBSD.cf	Fri Jul  7 09:33:25 1995
***************
*** 1,4 ****
! XCOMM platform:  $XConsortium: FreeBSD.cf,v 1.4 95/01/05 19:39:23 kaleb Exp $
  
  #define OSName            FreeBSD 1.1
  #define OSVendor          /**/
--- 1,4 ----
! XCOMM platform:  $XConsortium: FreeBSD.cf,v 1.5 95/04/07 19:42:53 kaleb Exp $
  
  #define OSName            FreeBSD 1.1
  #define OSVendor          /**/
***************
*** 42,48 ****
--- 42,52 ----
  #else
  #define OptimizedCDebugFlags -O2
  #endif
+ #if OSMajorVersion < 2
+ #define ServerOSDefines	XFree86ServerOSDefines -DDDXTIME -DXNO_SYSCONF
+ #else
  #define ServerOSDefines	XFree86ServerOSDefines -DDDXTIME
+ #endif
  #define ServerExtraDefines GccGasOption
  
  #define StandardDefines	-DCSRG_BASED
*** -	Fri Jul  7 09:33:25 1995
--- xc/config/cf/NetBSD.cf	Fri Jul  7 09:33:25 1995
***************
*** 1,4 ****
! XCOMM platform:  $XConsortium: NetBSD.cf,v 1.4 95/01/05 19:39:34 kaleb Exp $
  
  #define OSName		NetBSD
  #define	OSVendor	/**/
--- 1,4 ----
! XCOMM platform:  $XConsortium: NetBSD.cf,v 1.5 95/04/07 19:42:55 kaleb Exp $
  
  #define OSName		NetBSD
  #define	OSVendor	/**/
***************
*** 49,55 ****
--- 49,59 ----
  
  #ifdef i386Architecture
  #define OptimizedCDebugFlags	-m486 -O2
+ #if OSMajorVersion < 1
+ #define ServerOSDefines		XFree86ServerOSDefines -DDDXTIME -DXNO_SYSCONF
+ #else
  #define ServerOSDefines		XFree86ServerOSDefines -DDDXTIME
+ #endif
  #else
  #define OptimizedCDebugFlags	-O2
  # ifdef SparcArchitecture
***************
*** 139,146 ****
  #ifndef XsunMonoServer
  #define XsunMonoServer	YES
  #endif
! #ifndef UseRGBTxt
! #define UseRGBTxt	YES
  #endif
  #endif
  
--- 143,150 ----
  #ifndef XsunMonoServer
  #define XsunMonoServer	YES
  #endif
! #ifndef UseRgbTxt
! #define UseRgbTxt	YES
  #endif
  #endif
  
*** -	Fri Jul  7 09:33:26 1995
--- xc/config/cf/Oki.cf	Fri Jul  7 09:33:26 1995
***************
*** 1,4 ****
! XCOMM platform:  $XConsortium: Oki.cf,v 1.12 94/02/19 18:07:47 rws Exp $
  
  #define OSName			Unix System V/860 Release 4.0 Version 3
  XCOMM operating system:  OSName
--- 1,4 ----
! XCOMM platform:  $XConsortium: Oki.cf,v 1.14 95/06/09 20:57:00 gildea Exp $
  
  #define OSName			Unix System V/860 Release 4.0 Version 3
  XCOMM operating system:  OSName
***************
*** 16,21 ****
  #define PatheticCpp		YES
  #define CcCmd			/usr/bin/cc
  #define StandardDefines -DSVR4 -Di860
! #define DefaultCCOptions	-Xc
  #define BuildServer             NO
  #include <sv4Lib.rules>
--- 16,22 ----
  #define PatheticCpp		YES
  #define CcCmd			/usr/bin/cc
  #define StandardDefines -DSVR4 -Di860
! #define DefaultCCOptions	-Xa
  #define BuildServer             NO
+ #define ToolkitStringsABIOptions -intelabi
  #include <sv4Lib.rules>
*** -	Fri Jul  7 09:33:27 1995
--- xc/config/cf/Project.tmpl	Fri Jul  7 09:33:27 1995
***************
*** 1,6 ****
  XCOMM ----------------------------------------------------------------------
  XCOMM X Window System Build Parameters and Rules
! XCOMM $XConsortium: Project.tmpl,v 1.248 95/01/06 19:12:51 gildea Exp $
  
  /***************************************************************************
   *                                                                         *
--- 1,6 ----
  XCOMM ----------------------------------------------------------------------
  XCOMM X Window System Build Parameters and Rules
! XCOMM $XConsortium: Project.tmpl,v 1.249 95/05/23 21:36:40 matt Exp $
  
  /***************************************************************************
   *                                                                         *
***************
*** 71,81 ****
  #define BuildXKBlib		NO	/* not yet a standard part of Xlib */
  #endif
  #ifndef BuildFresco
! #if HasCplusplus 
! #define BuildFresco		YES
! #else
! #define BuildFresco		NO
! #endif
  #endif
  #ifndef InstallLibManPages
  #define InstallLibManPages	YES
--- 71,77 ----
  #define BuildXKBlib		NO	/* not yet a standard part of Xlib */
  #endif
  #ifndef BuildFresco
! #define BuildFresco		NO	/* R6 snapshot is obsolete */
  #endif
  #ifndef InstallLibManPages
  #define InstallLibManPages	YES
*** -	Fri Jul  7 09:33:29 1995
--- xc/config/cf/README	Fri Jul  7 09:33:29 1995
***************
*** 1,4 ****
! $XConsortium: README,v 1.37 94/04/18 17:13:36 gildea Exp $
  
  The easiest way to write an Imakefile is to find another one that does
  something similar and copy/modify it!
--- 1,4 ----
! $XConsortium: README,v 1.37.1.1 95/07/06 13:57:09 kaleb Exp $
  
  The easiest way to write an Imakefile is to find another one that does
  something similar and copy/modify it!
***************
*** 137,143 ****
  	BinDir			directory in which to install programs
  	BuildFontServer		build font server
  	BuildFonts		build pcf fonts
- 	BuildFresco		build Fresco
  	BuildIncRoot		relative path to location of headers in build
  	BuildIncTop		path from build includes directory to top
  	BuildPex		build all PEX-related code
--- 137,142 ----
*** -	Fri Jul  7 09:33:31 1995
--- xc/config/cf/fujitsu.cf	Fri Jul  7 09:33:31 1995
***************
*** 1,4 ****
! XCOMM platform:  $XConsortium: fujitsu.cf,v 1.4 94/09/01 21:05:53 kaleb Exp $
  
  #ifdef SparcArchitecture
  
--- 1,4 ----
! XCOMM platform:  $XConsortium: fujitsu.cf,v 1.5 95/06/19 02:56:37 gildea Exp $
  
  #ifdef SparcArchitecture
  
***************
*** 15,20 ****
--- 15,23 ----
  
  #define SystemV4	   YES
  #define HasSockets         YES
+ #ifndef HasLdRunPath
+ #define HasLdRunPath       YES
+ #endif
  #define BuildServer        NO
  
  #include <sv4Lib.rules>
*** -	Fri Jul  7 09:33:31 1995
--- xc/config/cf/ncr.cf	Fri Jul  7 09:33:31 1995
***************
*** 1,4 ****
! XCOMM platform:  $XConsortium: ncr.cf,v 1.19 95/01/25 16:28:38 kaleb Exp $
  #define OSName			Unix System V Release 4/MP-RAS
  #define OSVendor		NCR
  XCOMM operating system:  OSName
--- 1,4 ----
! XCOMM platform:  $XConsortium: ncr.cf,v 1.21 95/06/09 20:57:00 gildea Exp $
  #define OSName			Unix System V Release 4/MP-RAS
  #define OSVendor		NCR
  XCOMM operating system:  OSName
***************
*** 10,20 ****
  /* Build Flags */
  
  #define StandardDefines		-DSVR4 -DNCR -Di386 -DXML -DXI18N
! #define DefaultCCOptions	-Xc -Hnocopyr -W0,-asm
  #define DefaultCDebugFlags	-O3
  #define AllocateLocalDefines	-DINCLUDE_ALLOCA_H
  #define ServerExtraDefines      -DNO_SECONDARY AllocateLocalDefines XFree86ServerDefines
  #define ServerOSDefines         -DDDXTIME XFree86ServerOSDefines
  
  XCOMM This has not been tested, don't turn it on yet.
  XCOMM #define ExtensionOSDefines	-DXTESTEXT1
--- 10,21 ----
  /* Build Flags */
  
  #define StandardDefines		-DSVR4 -DNCR -Di386 -DXML -DXI18N
! #define DefaultCCOptions	-Xa -Hnocopyr -W0,-asm
  #define DefaultCDebugFlags	-O3
  #define AllocateLocalDefines	-DINCLUDE_ALLOCA_H
  #define ServerExtraDefines      -DNO_SECONDARY AllocateLocalDefines XFree86ServerDefines
  #define ServerOSDefines         -DDDXTIME XFree86ServerOSDefines
+ #define ToolkitStringsABIOptions -intelabi
  
  XCOMM This has not been tested, don't turn it on yet.
  XCOMM #define ExtensionOSDefines	-DXTESTEXT1
*** -	Fri Jul  7 09:33:33 1995
--- xc/config/cf/ibm.cf	Fri Jul  7 09:33:33 1995
***************
*** 1,10 ****
! XCOMM platform:  $XConsortium: ibm.cf,v 1.52 94/06/04 16:44:25 rws Exp $
  
  #ifdef RsArchitecture
  #define OSName		AIX 3.2.5
  #define OSMajorVersion	3
  #define OSMinorVersion	2
  #define OSTeenyVersion	5
  #else
  #ifdef RtArchitecture
  #ifdef AIXArchitecture
--- 1,18 ----
! XCOMM platform:  $XConsortium: ibm.cf,v 1.55.1.1 95/06/30 14:22:43 kaleb Exp $
  
  #ifdef RsArchitecture
+ #ifndef OSName
  #define OSName		AIX 3.2.5
+ #endif
+ #ifndef OSMajorVersion
  #define OSMajorVersion	3
+ #endif
+ #ifndef OSMinorVersion
  #define OSMinorVersion	2
+ #endif
+ #ifndef OSTeenyVersion
  #define OSTeenyVersion	5
+ #endif
  #else
  #ifdef RtArchitecture
  #ifdef AIXArchitecture
***************
*** 29,40 ****
  
  #if OSMajorVersion > 3 || (OSMajorVersion == 3 && OSMinorVersion >= 2)
  #define HasBSD44Sockets		YES
  /*
   * If you do not have threads support installed, put
   * #define HasPosixThreads NO
   * in the BeforeVendorCF section of your site.def.
   */
! #if !defined(HasPosixThreads) && (OSMajorVersion > 3 || (OSMajorVersion == 3 && (OSMinorVersion > 2 || (OSMinorVersion == 2 && OSTeenyVersion > 4))))
  #define HasPosixThreads		YES
  #endif
  #if HasPosixThreads
--- 37,49 ----
  
  #if OSMajorVersion > 3 || (OSMajorVersion == 3 && OSMinorVersion >= 2)
  #define HasBSD44Sockets		YES
+ #define HasPutenv		YES
  /*
   * If you do not have threads support installed, put
   * #define HasPosixThreads NO
   * in the BeforeVendorCF section of your site.def.
   */
! #if !defined(HasPosixThreads) && ((OSMajorVersion == 3 && (OSMinorVersion > 2 || (OSMinorVersion == 2 && OSTeenyVersion > 4))) || (OSMajorVersion == 4 && (OSMinorVersion > 1 || (OSMinorVersion == 1 && OSTeenyVersion > 1))))
  #define HasPosixThreads		YES
  #endif
  #if HasPosixThreads
***************
*** 42,50 ****
  #define ThreadedX		YES
  #define ThreadsLibraries -lpthreads -lc_r
  #endif
! #endif
  
- #define CcCmd xlc
  
  /*
   * For IBM platforms, we must define both the location of the compiler
--- 51,58 ----
  #define ThreadedX		YES
  #define ThreadsLibraries -lpthreads -lc_r
  #endif
! #endif /* OS > 3.2 */
  
  
  /*
   * For IBM platforms, we must define both the location of the compiler
***************
*** 89,104 ****
  #define ExecableScripts		YES
  #define Malloc0ReturnsNull	YES
  #define CppCmd			/usr/lpp/X11/Xamples/util/cpp/cpp
- #define StandardDefines         -DSYSV -DAIXV3 -D_ALL_SOURCE
  #define ExpandManNames		YES
  #define ExtensionOSDefines -DXTESTEXT1
  #define XibmServer 		YES
  #define ibmIncludeSKYWAY	YES
  #define OPERATING_SYSTEM 	AIX /* directory name under server/ddx/ibm/ */
  #define InstallCmd              /usr/ucb/install
  #include <ibmLib.rules>
  
! #else
  
  
  #define UnixCpp /**/
--- 97,126 ----
  #define ExecableScripts		YES
  #define Malloc0ReturnsNull	YES
  #define CppCmd			/usr/lpp/X11/Xamples/util/cpp/cpp
  #define ExpandManNames		YES
  #define ExtensionOSDefines -DXTESTEXT1
+ #define StandardDefines         -DSYSV -DAIXV3 -D_ALL_SOURCE
+ #if OSMajorVersion >= 4
+ #define XawI18nDefines		-DHAS_WCHAR_H -DHAS_ISW_FUNCS
+ #define CcCmd c89		/* full conforming ANSI C w/ ANSI headers */
+  _NULLCMD_ = @ echo
+ #else
  #define XibmServer 		YES
  #define ibmIncludeSKYWAY	YES
+ #define CcCmd xlc
+ #endif
  #define OPERATING_SYSTEM 	AIX /* directory name under server/ddx/ibm/ */
  #define InstallCmd              /usr/ucb/install
  #include <ibmLib.rules>
  
! #ifndef ManKeywordsTarget
! #define ManKeywordsTarget(manpath)					@@\
! man_keywords::								@@\
! 	/usr/lib/makewhatis $(DESTDIR)manpath
! #endif
! 
! 
! #else /* end of RsArchitecture */
  
  
  #define UnixCpp /**/
*** -	Fri Jul  7 09:33:37 1995
--- xc/config/cf/sun.cf	Fri Jul  7 09:33:37 1995
***************
*** 1,26 ****
! XCOMM platform:  $XConsortium: sun.cf,v 1.139 95/01/12 15:30:26 kaleb Exp $
  
  #ifdef SVR4Architecture
  #ifdef i386Architecture
  #define OSName            SunOS 5.1 x86
  XCOMM operating system:  OSName
  #define OSMajorVersion    5
  #define OSMinorVersion    1
  #define OSTeenyVersion    0
  #else
  #define OSName            SunOS 5.3
  XCOMM operating system:  OSName
  #define OSMajorVersion    5
  #define OSMinorVersion    3
  #define OSTeenyVersion    0
  #endif
  #else
  #define OSName            SunOS 4.1.3
  XCOMM operating system:  OSName
  #define OSMajorVersion    4
  #define OSMinorVersion    1
  #define OSTeenyVersion    3
  #endif
  
  /*
   * Compiler setup.  This sun.cf file knows what options to use with 
--- 1,50 ----
! XCOMM platform:  $XConsortium: sun.cf,v 1.139.1.1 95/06/19 18:22:21 gildea Exp $
  
  #ifdef SVR4Architecture
  #ifdef i386Architecture
+ #ifndef OSName
  #define OSName            SunOS 5.1 x86
+ #endif
  XCOMM operating system:  OSName
+ #ifndef OSMajorVersion
  #define OSMajorVersion    5
+ #endif
+ #ifndef OSMinorVersion
  #define OSMinorVersion    1
+ #endif
+ #ifndef	OSTeenyVersion
  #define OSTeenyVersion    0
+ #endif
  #else
+ #ifndef OSName
  #define OSName            SunOS 5.3
+ #endif
  XCOMM operating system:  OSName
+ #ifndef OSMajorVersion
  #define OSMajorVersion    5
+ #endif
+ #ifndef OSMinorVersion
  #define OSMinorVersion    3
+ #endif
+ #ifndef	OSTeenyVersion
  #define OSTeenyVersion    0
  #endif
+ #endif
  #else
+ #ifndef OSName
  #define OSName            SunOS 4.1.3
+ #endif
  XCOMM operating system:  OSName
+ #ifndef OSMajorVersion
  #define OSMajorVersion    4
+ #endif
+ #ifndef OSMinorVersion
  #define OSMinorVersion    1
+ #endif
+ #ifndef	OSTeenyVersion
  #define OSTeenyVersion    3
  #endif
+ #endif
  
  /*
   * Compiler setup.  This sun.cf file knows what options to use with 
***************
*** 152,159 ****
--- 176,185 ----
  #endif
  #ifdef i386Architecture
  #define StandardDefines	  -Dsun -Di386 -DSVR4 -D__i386
+ #define ToolkitStringsABIOptions	-intelabi
  #else
  #define StandardDefines	  -Dsun -DSVR4
+ #define ToolkitStringsABIOptions	-sparcabi
  #endif
  #define ExtraLibraries    -lsocket -lnsl
  #if OSMinorVersion > 1
***************
*** 251,257 ****
  #endif
  #else	/* OSMajorVersion >= 5*/
  #ifndef DefaultCCOptions
! #define DefaultCCOptions -Xc
  #endif
  #endif	
  #endif	
--- 277,283 ----
  #endif
  #else	/* OSMajorVersion >= 5*/
  #ifndef DefaultCCOptions
! #define DefaultCCOptions -Xa
  #endif
  #endif	
  #endif	
*** -	Fri Jul  7 09:33:39 1995
--- xc/config/cf/sunLib.tmpl	Fri Jul  7 09:33:39 1995
***************
*** 1,4 ****
! XCOMM $XConsortium: sunLib.tmpl,v 1.36 94/04/08 19:13:50 rws Exp $
  
  /*
   * SunOS shared library template
--- 1,4 ----
! XCOMM $XConsortium: sunLib.tmpl,v 1.38 95/07/06 14:06:11 kaleb Exp $
  
  /*
   * SunOS shared library template
***************
*** 38,44 ****
  #else				/* else it's Solaris */
  
  #if ThreadedX
! #define SharedX11Reqs -lthread
  #endif
  #define SharedXmuReqs $(LDPRELIB) $(XTOOLLIB) $(XLIB)
  #define FixupLibReferences() /**/
--- 38,46 ----
  #else				/* else it's Solaris */
  
  #if ThreadedX
! #if OSMinorVersion > 3
! #define SharedX11Reqs /**/
! #endif
  #endif
  #define SharedXmuReqs $(LDPRELIB) $(XTOOLLIB) $(XLIB)
  #define FixupLibReferences() /**/
*** -	Fri Jul  7 09:33:39 1995
--- xc/config/cf/svr4.cf	Fri Jul  7 09:33:39 1995
***************
*** 1,4 ****
! XCOMM $XConsortium: svr4.cf,v 1.11 95/01/25 16:32:39 kaleb Exp $
  /*
   * A default OS name
   */
--- 1,4 ----
! XCOMM $XConsortium: svr4.cf,v 1.14 95/06/30 18:21:43 kaleb Exp $
  /*
   * A default OS name
   */
***************
*** 41,57 ****
  
  /* Some stuff that all SVR4s should have */
  
! #define SystemV4	YES
  #ifndef HasLdRunPath
! #define HasLdRunPath	YES
  #endif
! #define HasPoll		YES
  #ifndef SVR4Architecture
  #define SVR4Architecture
  #endif
  #ifndef PatheticCpp
! #define PatheticCpp	YES
  #endif
  
  /*
   * Here are the default paths to use to pick up tools for building.
--- 41,58 ----
  
  /* Some stuff that all SVR4s should have */
  
! #define SystemV4		YES
  #ifndef HasLdRunPath
! #define HasLdRunPath		YES
  #endif
! #define HasPoll			YES
  #ifndef SVR4Architecture
  #define SVR4Architecture
  #endif
  #ifndef PatheticCpp
! #define PatheticCpp		YES
  #endif
+ #define Malloc0ReturnsNull	YES		/* in case -lmalloc used */
  
  /*
   * Here are the default paths to use to pick up tools for building.
***************
*** 88,100 ****
  #ifndef StandardDefines
  #define StandardDefines		-DSVR4 -Di386
  #endif
  #ifndef DefaultCCOptions
  #if HasGcc2
  #if !defined(SunArchitecture)
  #define DefaultCCOptions -ansi
  #endif
  #else
! #define DefaultCCOptions -Xc -Dasm=__asm
  #endif
  #endif
  #ifndef DefaultCDebugFlags
--- 89,104 ----
  #ifndef StandardDefines
  #define StandardDefines		-DSVR4 -Di386
  #endif
+ #ifndef ToolkitStringsABIOptions
+ #define ToolkitStringsABIOptions -intelabi
+ #endif
  #ifndef DefaultCCOptions
  #if HasGcc2
  #if !defined(SunArchitecture)
  #define DefaultCCOptions -ansi
  #endif
  #else
! #define DefaultCCOptions -Xa -Dasm=__asm
  #endif
  #endif
  #ifndef DefaultCDebugFlags
*** -	Fri Jul  7 09:33:40 1995
--- xc/config/cf/sv4Lib.tmpl	Fri Jul  7 09:33:40 1995
***************
*** 1,4 ****
! XCOMM $XConsortium: sv4Lib.tmpl,v 1.19 93/12/03 10:48:36 kaleb Exp $
  
  /*
   * SVR4 shared library template
--- 1,4 ----
! XCOMM $XConsortium: sv4Lib.tmpl,v 1.20 95/07/06 14:06:11 kaleb Exp $
  
  /*
   * SVR4 shared library template
***************
*** 12,15 ****
--- 12,20 ----
  #endif
  #ifndef XawClientLibs
  #define XawClientLibs $(XAWLIB) $(XMULIBONLY) $(XTOOLLIB) $(XLIB)
+ #endif
+ #if ThreadedX
+ #ifndef SharedX11Reqs
+ #define SharedX11Reqs -lthread
+ #endif
  #endif
*** -	Fri Jul  7 09:33:42 1995
--- xc/config/cf/usl.cf	Fri Jul  7 09:33:42 1995
***************
*** 1,4 ****
! XCOMM platform:  $XConsortium: usl.cf,v 1.35 95/01/12 15:37:24 kaleb Exp $
  
  #define OSName			UNIX System V/386 Release 4.2 Version 1.1.1
  XCOMM operating system:  OSName
--- 1,4 ----
! XCOMM platform:  $XConsortium: usl.cf,v 1.37 95/06/30 18:11:39 kaleb Exp $
  
  #define OSName			UNIX System V/386 Release 4.2 Version 1.1.1
  XCOMM operating system:  OSName
***************
*** 7,13 ****
--- 7,22 ----
  #define OSTeenyVersion		1
  
  #define BootstrapCFlags		-DUSL
+ #define StandardDefines		-DUSL -DSVR4 -Di386
  #define NeedWidePrototypes	NO	/* experimental */
  #define ServerExtraDefines	-D__USLC__ XFree86ServerDefines
  #define ServerOSDefines		-DDDXTIME XFree86ServerOSDefines
+ #define ToolkitStringsABIOptions -intelabi
+ #define XawI18nDefines		-DHAS_WCTYPE_H -DHAS_ISW_FUNCS
+ #if OSTeenyVersion > 1
+ #define ExtraLibraries		-lsocket -lnsl -lgen
+ #define ThreadedX		YES
+ #define SystemMTDefines		-D_REENTRANT
+ #define ThreadsLibraries	-lthread
+ #endif
  #include <svr4.cf>
*** -	Fri Jul  7 09:33:44 1995
--- xc/config/cf/x386.cf	Fri Jul  7 09:33:44 1995
***************
*** 1,4 ****
! XCOMM platform:  $XConsortium: x386.cf,v 1.11 93/10/13 15:32:46 rws Exp $
  
  /*****************************************************************************
   *			  Site-specfic parameters                            *
--- 1,4 ----
! XCOMM platform:  $XConsortium: x386.cf,v 1.12 95/06/09 21:28:51 gildea Exp $
  
  /*****************************************************************************
   *			  Site-specfic parameters                            *
***************
*** 143,152 ****
  #if HasGcc
  # define CcCmd 		gcc -ansi -fstrength-reduce -fpcc-struct-return -Di386
  # if HasSharedLibraries
! #  define LibraryCcCmd	cc -Xc -Di386 -Dasm=__asm
  # endif
  #else
! # define CcCmd		cc -Xc -Di386 -Dasm=__asm
  #endif
  
  #include <sv4Lib.rules>
--- 143,152 ----
  #if HasGcc
  # define CcCmd 		gcc -ansi -fstrength-reduce -fpcc-struct-return -Di386
  # if HasSharedLibraries
! #  define LibraryCcCmd	cc -Xa -Di386 -Dasm=__asm
  # endif
  #else
! # define CcCmd		cc -Xa -Di386 -Dasm=__asm
  #endif
  
  #include <sv4Lib.rules>
*** -	Fri Jul  7 09:33:46 1995
--- xc/nls/X11/locale/Compose/iso8859-1	Fri Jul  7 09:33:45 1995
***************
*** 1,4 ****
! # $XConsortium: iso8859-1,v 1.4 94/07/06 15:17:11 kaleb Exp $
  #
  # ISO 8859-1 (Latin1) Compose Sequence
  #
--- 1,4 ----
! # $XConsortium: iso8859-1,v 1.5 95/06/07 18:45:50 kaleb Exp $
  #
  # ISO 8859-1 (Latin1) Compose Sequence
  #
***************
*** 8,82 ****
  # Special Character
  <Multi_key> <plus> <plus>		: "#"	numbersign
  <Multi_key> <apostrophe> <space>	: "'"	apostrophe
  <Multi_key> <A> <A>			: "@"	at
  <Multi_key> <parenleft> <parenleft>	: "["	bracketleft
  <Multi_key> <slash> <slash>		: "\\"	backslash
  <Multi_key> <slash> <less>		: "\\"	backslash
  <Multi_key> <parenright> <parenright>	: "]"	bracketright
  <Multi_key> <asciicircum> <space>	: "^"	asciicircum
  <Multi_key> <greater> <space>		: "^"	asciicirum
  <Multi_key> <grave> <space>		: "`"	grave
  <Multi_key> <parenleft> <minus>		: "{"	braceleft
  <Multi_key> <slash> <asciicircum>	: "|"	bar
  <Multi_key> <V> <L>			: "|"	bar
  <Multi_key> <v> <l>			: "|"	bar
  <Multi_key> <parenright> <minus>	: "}"	braceright
  <Multi_key> <asciitilde> <space>	: "~"	asciitilde
  <Multi_key> <minus> <space>		: "~"	asciitilde
! <Multi_key> <exclam> <exclam>		: "\241"	exclaimdown
  <Multi_key> <c> <slash>			: "\242"	cent
  <Multi_key> <C> <slash>			: "\242"	cent
  <Multi_key> <C> <bar>			: "\242"	cent
  <Multi_key> <c> <bar>			: "\242"	cent
  <Multi_key> <l> <minus>			: "\243"	sterling
  <Multi_key> <L> <minus>			: "\243"	sterling
  <Multi_key> <l> <equal>			: "\243"	sterling
  <Multi_key> <L> <equal>			: "\243"	sterling
  <Multi_key> <y> <minus>			: "\245"	yen
  <Multi_key> <Y> <minus>			: "\245"	yen
  <Multi_key> <y> <equal>			: "\245"	yen
  <Multi_key> <Y> <equal>			: "\245"	yen
  <Multi_key> <s> <o>			: "\247"	section
  <Multi_key> <S> <O>			: "\247"	section
  <Multi_key> <S> <exclam>		: "\247"	section
  <Multi_key> <s> <exclam>		: "\247"	section
  <Multi_key> <S> <0>			: "\247"	section
  <Multi_key> <s> <0>			: "\247"	section
  <Multi_key> <x> <o>			: "\244"	currency
  <Multi_key> <X> <O>			: "\244"	currency
  <Multi_key> <x> <O>			: "\244"	currency
  <Multi_key> <X> <o>			: "\244"	currency
  <Multi_key> <x> <0>			: "\244"	currency
  <Multi_key> <X> <0>			: "\244"	currency
  <Multi_key> <c> <o>			: "\251"	copyright
  <Multi_key> <C> <O>			: "\251"	copyright
  <Multi_key> <c> <O>			: "\251"	copyright
  <Multi_key> <C> <o>			: "\251"	copyright
  <Multi_key> <c> <0>			: "\251"	copyright
  <Multi_key> <C> <0>			: "\251"	copyright
  <Multi_key> <a> <underscore>		: "\252"	ordfeminine
  <Multi_key> <A> <underscore>		: "\252"	ordfeminine
  <Multi_key> <o> <underscore>		: "\272"	masculine
  <Multi_key> <O> <underscore>		: "\272"	masculine
  <Multi_key> <less> <less>		: "\253"	guillemotleft
  <Multi_key> <greater> <greater>		: "\273"	guillemotright
  <Multi_key> <0> <asciicircum>		: "\260"	degree
  <Multi_key> <0> <asterisk>		: "\260"	degree
  <Multi_key> <plus> <minus>		: "\261"	plusminus
  <Multi_key> <slash> <u>			: "\265"	mu
  <Multi_key> <slash> <U>			: "\265"	mu
  <Multi_key> <1> <asciicircum>		: "\271"	onesuperior
  <Multi_key> <S> <1>			: "\271"	onesuperior
  <Multi_key> <s> <1>			: "\271"	onesuperior
  <Multi_key> <2> <asciicircum>		: "\262"	twosuperior
  <Multi_key> <S> <2>			: "\262"	twosuperior
  <Multi_key> <s> <2>			: "\262"	twosuperior
  <Multi_key> <3> <asciicircum>		: "\263"	threesuperior
  <Multi_key> <S> <3>			: "\263"	threesuperior
  <Multi_key> <s> <3>			: "\263"	threesuperior
  <Multi_key> <p> <exclam>		: "\266"	paragraph
  <Multi_key> <P> <exclam>		: "\266"	paragraph
  <Multi_key> <period> <asciicircum>	: "\267"	periodcentered
  <Multi_key> <period> <period>		: "\267"	periodcentered
  <Multi_key> <1> <4>			: "\274"	onequarter
  <Multi_key> <1> <2>			: "\275"	onehalf
--- 8,145 ----
  # Special Character
  <Multi_key> <plus> <plus>		: "#"	numbersign
  <Multi_key> <apostrophe> <space>	: "'"	apostrophe
+ <Multi_key> <space> <apostrophe>	: "'"	apostrophe
  <Multi_key> <A> <A>			: "@"	at
  <Multi_key> <parenleft> <parenleft>	: "["	bracketleft
  <Multi_key> <slash> <slash>		: "\\"	backslash
  <Multi_key> <slash> <less>		: "\\"	backslash
+ <Multi_key> <less> <slash>		: "\\"	backslash
  <Multi_key> <parenright> <parenright>	: "]"	bracketright
  <Multi_key> <asciicircum> <space>	: "^"	asciicircum
+ <Multi_key> <space> <asciicircum>	: "^"	asciicircum
  <Multi_key> <greater> <space>		: "^"	asciicirum
+ <Multi_key> <space> <greater>		: "^"	asciicirum
  <Multi_key> <grave> <space>		: "`"	grave
+ <Multi_key> <space> <grave>		: "`"	grave
  <Multi_key> <parenleft> <minus>		: "{"	braceleft
+ <Multi_key> <minus> <parenleft>		: "{"	braceleft
  <Multi_key> <slash> <asciicircum>	: "|"	bar
+ <Multi_key> <asciicircum> <slash>	: "|"	bar
  <Multi_key> <V> <L>			: "|"	bar
+ <Multi_key> <L> <V>			: "|"	bar
  <Multi_key> <v> <l>			: "|"	bar
+ <Multi_key> <l> <v>			: "|"	bar
  <Multi_key> <parenright> <minus>	: "}"	braceright
+ <Multi_key> <minus> <parenright>	: "}"	braceright
  <Multi_key> <asciitilde> <space>	: "~"	asciitilde
+ <Multi_key> <space> <asciitilde>	: "~"	asciitilde
  <Multi_key> <minus> <space>		: "~"	asciitilde
! <Multi_key> <space> <minus>		: "~"	asciitilde
! <Multi_key> <exclam> <exclam>		: "\241"	exclamdown
  <Multi_key> <c> <slash>			: "\242"	cent
+ <Multi_key> <slash> <c>			: "\242"	cent
  <Multi_key> <C> <slash>			: "\242"	cent
+ <Multi_key> <slash> <C>			: "\242"	cent
  <Multi_key> <C> <bar>			: "\242"	cent
+ <Multi_key> <bar> <C>			: "\242"	cent
  <Multi_key> <c> <bar>			: "\242"	cent
+ <Multi_key> <bar> <c>			: "\242"	cent
  <Multi_key> <l> <minus>			: "\243"	sterling
+ <Multi_key> <minus> <l>			: "\243"	sterling
  <Multi_key> <L> <minus>			: "\243"	sterling
+ <Multi_key> <minus> <L>			: "\243"	sterling
  <Multi_key> <l> <equal>			: "\243"	sterling
+ <Multi_key> <equal> <l>			: "\243"	sterling
  <Multi_key> <L> <equal>			: "\243"	sterling
+ <Multi_key> <equal> <L>			: "\243"	sterling
  <Multi_key> <y> <minus>			: "\245"	yen
+ <Multi_key> <minus> <y>			: "\245"	yen
  <Multi_key> <Y> <minus>			: "\245"	yen
+ <Multi_key> <minus> <Y>			: "\245"	yen
  <Multi_key> <y> <equal>			: "\245"	yen
+ <Multi_key> <equal> <y>			: "\245"	yen
  <Multi_key> <Y> <equal>			: "\245"	yen
+ <Multi_key> <equal> <Y>			: "\245"	yen
  <Multi_key> <s> <o>			: "\247"	section
+ <Multi_key> <o> <s>			: "\247"	section
  <Multi_key> <S> <O>			: "\247"	section
+ <Multi_key> <O> <S>			: "\247"	section
  <Multi_key> <S> <exclam>		: "\247"	section
+ <Multi_key> <exclam> <S>		: "\247"	section
  <Multi_key> <s> <exclam>		: "\247"	section
+ <Multi_key> <exclam> <s>		: "\247"	section
  <Multi_key> <S> <0>			: "\247"	section
+ <Multi_key> <0> <S>			: "\247"	section
  <Multi_key> <s> <0>			: "\247"	section
+ <Multi_key> <0> <s>			: "\247"	section
  <Multi_key> <x> <o>			: "\244"	currency
+ <Multi_key> <o> <x>			: "\244"	currency
  <Multi_key> <X> <O>			: "\244"	currency
+ <Multi_key> <O> <X>			: "\244"	currency
  <Multi_key> <x> <O>			: "\244"	currency
+ <Multi_key> <O> <x>			: "\244"	currency
  <Multi_key> <X> <o>			: "\244"	currency
+ <Multi_key> <o> <X>			: "\244"	currency
  <Multi_key> <x> <0>			: "\244"	currency
+ <Multi_key> <0> <x>			: "\244"	currency
  <Multi_key> <X> <0>			: "\244"	currency
+ <Multi_key> <0> <X>			: "\244"	currency
  <Multi_key> <c> <o>			: "\251"	copyright
+ <Multi_key> <o> <c>			: "\251"	copyright
  <Multi_key> <C> <O>			: "\251"	copyright
+ <Multi_key> <O> <C>			: "\251"	copyright
  <Multi_key> <c> <O>			: "\251"	copyright
+ <Multi_key> <O> <c>			: "\251"	copyright
  <Multi_key> <C> <o>			: "\251"	copyright
+ <Multi_key> <o> <C>			: "\251"	copyright
  <Multi_key> <c> <0>			: "\251"	copyright
+ <Multi_key> <0> <c>			: "\251"	copyright
  <Multi_key> <C> <0>			: "\251"	copyright
+ <Multi_key> <0> <C>			: "\251"	copyright
  <Multi_key> <a> <underscore>		: "\252"	ordfeminine
+ <Multi_key> <underscore> <a>		: "\252"	ordfeminine
  <Multi_key> <A> <underscore>		: "\252"	ordfeminine
+ <Multi_key> <underscore> <A>		: "\252"	ordfeminine
  <Multi_key> <o> <underscore>		: "\272"	masculine
+ <Multi_key> <underscore> <o>		: "\272"	masculine
  <Multi_key> <O> <underscore>		: "\272"	masculine
+ <Multi_key> <underscore> <O>		: "\272"	masculine
  <Multi_key> <less> <less>		: "\253"	guillemotleft
  <Multi_key> <greater> <greater>		: "\273"	guillemotright
  <Multi_key> <0> <asciicircum>		: "\260"	degree
+ <Multi_key> <asciicircum> <0>		: "\260"	degree
  <Multi_key> <0> <asterisk>		: "\260"	degree
+ <Multi_key> <asterisk> <0>		: "\260"	degree
  <Multi_key> <plus> <minus>		: "\261"	plusminus
+ <Multi_key> <minus> <plus>		: "\261"	plusminus
  <Multi_key> <slash> <u>			: "\265"	mu
+ <Multi_key> <u> <slash>			: "\265"	mu
  <Multi_key> <slash> <U>			: "\265"	mu
+ <Multi_key> <U> <slash>			: "\265"	mu
  <Multi_key> <1> <asciicircum>		: "\271"	onesuperior
+ <Multi_key> <asciicircum> <1>		: "\271"	onesuperior
  <Multi_key> <S> <1>			: "\271"	onesuperior
+ <Multi_key> <1> <S>			: "\271"	onesuperior
  <Multi_key> <s> <1>			: "\271"	onesuperior
+ <Multi_key> <1> <s>			: "\271"	onesuperior
  <Multi_key> <2> <asciicircum>		: "\262"	twosuperior
+ <Multi_key> <asciicircum> <2>		: "\262"	twosuperior
  <Multi_key> <S> <2>			: "\262"	twosuperior
+ <Multi_key> <2> <S>			: "\262"	twosuperior
  <Multi_key> <s> <2>			: "\262"	twosuperior
+ <Multi_key> <2> <s>			: "\262"	twosuperior
  <Multi_key> <3> <asciicircum>		: "\263"	threesuperior
+ <Multi_key> <asciicircum> <3>		: "\263"	threesuperior
  <Multi_key> <S> <3>			: "\263"	threesuperior
+ <Multi_key> <3> <S>			: "\263"	threesuperior
  <Multi_key> <s> <3>			: "\263"	threesuperior
+ <Multi_key> <3> <s>			: "\263"	threesuperior
  <Multi_key> <p> <exclam>		: "\266"	paragraph
+ <Multi_key> <exclam> <p>		: "\266"	paragraph
  <Multi_key> <P> <exclam>		: "\266"	paragraph
+ <Multi_key> <exclam> <P>		: "\266"	paragraph
  <Multi_key> <period> <asciicircum>	: "\267"	periodcentered
+ <Multi_key> <asciicircum> <period>	: "\267"	periodcentered
  <Multi_key> <period> <period>		: "\267"	periodcentered
  <Multi_key> <1> <4>			: "\274"	onequarter
  <Multi_key> <1> <2>			: "\275"	onehalf
***************
*** 85,268 ****
  <Multi_key> <space> <space>		: "\240"	nobreakspace
  <Multi_key> <bar> <bar>			: "\246"	brokenbar
  <Multi_key> <exclam> <asciicircum>	: "\246"	brokenbar
  <Multi_key> <V> <B>			: "\246"	brokenbar
  <Multi_key> <v> <b>			: "\246"	brokenbar
  <Multi_key> <minus> <comma>		: "\254"	notsign
  <Multi_key> <minus> <minus>		: "\255"	hyphen
  <Multi_key> <R> <O>			: "\256"	registered
  <Multi_key> <minus> <asciicircum>	: "\257"	macron
  <Multi_key> <underscore> <asciicircum>	: "\257"	macron
  <Multi_key> <underscore> <underscore>	: "\257"	macron
  <Multi_key> <minus> <colon>		: "\367"	division
  <Multi_key> <x> <x>			: "\327"	multiply
  <Multi_key> <apostrophe> <apostrophe>	: "\264"	acute
  <Multi_key> <comma> <comma>		: "\270"	cedilla
  <Multi_key> <quotedbl> <quotedbl>	: "\250"	diaeresis
  # Accented Alphabet
  <Multi_key> <A> <grave>			: "\300"	Agrave
  <Multi_key> <A> <acute>			: "\301"	Aacute
  <Multi_key> <A> <apostrophe>		: "\301"	Aacute
! <Multi_key> <A> <asciicircum>	: "\302"	Acircumflex
  <Multi_key> <A> <greater>		: "\302"	Acircumflex
  <Multi_key> <A> <asciitilde>		: "\303"	Atilde
  <Multi_key> <A> <minus>			: "\303"	Atilde
  <Multi_key> <A> <quotedbl>		: "\304"	Adiaeresis
  <Multi_key> <A> <asterisk>		: "\305"	Aring
  <Multi_key> <A> <E>			: "\306"	AE
  <Multi_key> <a> <grave>			: "\340"	agrave
  <Multi_key> <a> <acute>			: "\341"	aacute
  <Multi_key> <a> <apostrophe>		: "\341"	aacute
! <Multi_key> <a> <asciicircum>	: "\342"	acircumflex
  <Multi_key> <a> <greater>		: "\342"	acircumflex
  <Multi_key> <a> <asciitilde>		: "\343"	atilde
  <Multi_key> <a> <minus>			: "\343"	atilde
  <Multi_key> <a> <quotedbl>		: "\344"	adiaeresis
  <Multi_key> <a> <asterisk>		: "\345"	aring
  <Multi_key> <a> <e>			: "\346"	ae
  <Multi_key> <C> <comma>			: "\307"	Ccedilla
  <Multi_key> <c> <comma>			: "\347"	ccedilla
  <Multi_key> <minus> <D>			: "\320"	ETH
  <Multi_key> <minus> <d>			: "\360"	eth
  <Multi_key> <E> <grave>			: "\310"	Egrave
  <Multi_key> <E> <acute>			: "\311"	Eacute
  <Multi_key> <E> <apostrophe>		: "\311"	Eacute
! <Multi_key> <E> <asciicircum>	: "\312"	Ecircumflex
  <Multi_key> <E> <greater>		: "\312"	Ecircumflex
  <Multi_key> <E> <quotedbl>		: "\313"	Ediaeresis
  <Multi_key> <e> <grave>			: "\350"	egrave
  <Multi_key> <e> <acute>			: "\351"	eacute
  <Multi_key> <e> <apostrophe>		: "\351"	eacute
! <Multi_key> <e> <asciicircum>	: "\352"	ecircumflex
  <Multi_key> <e> <greater>		: "\352"	ecircumflex
  <Multi_key> <e> <quotedbl>		: "\353"	ediaeresis
  <Multi_key> <I> <grave>			: "\314"	Igrave
  <Multi_key> <I> <acute>			: "\315"	Iacute
  <Multi_key> <I> <apostrophe>		: "\315"	Iacute
! <Multi_key> <I> <asciicircum>	: "\316"	Icircumflex
  <Multi_key> <I> <greater>		: "\316"	Icircumflex
  <Multi_key> <I> <quotedbl>		: "\317"	Idiaeresis
  <Multi_key> <i> <grave>			: "\354"	igrave
  <Multi_key> <i> <acute>			: "\355"	iacute
  <Multi_key> <i> <apostrophe>		: "\355"	iacute
! <Multi_key> <i> <asciicircum>	: "\356"	icircumflex
  <Multi_key> <i> <greater>		: "\356"	icircumflex
  <Multi_key> <i> <quotedbl>		: "\357"	idiaeresis
  <Multi_key> <N> <asciitilde>		: "\321"	Ntilde
  <Multi_key> <N> <minus>			: "\321"	Ntilde
  <Multi_key> <n> <asciitilde>		: "\361"	ntilde
  <Multi_key> <n> <minus>			: "\361"	ntilde
  <Multi_key> <O> <grave>			: "\322"	Ograve
  <Multi_key> <O> <acute>			: "\323"	Oacute
  <Multi_key> <O> <apostrophe>		: "\323"	Oacute
! <Multi_key> <O> <asciicircum>	: "\324"	Ocircumflex
  <Multi_key> <O> <greater>		: "\324"	Ocircumflex
  <Multi_key> <O> <asciitilde>		: "\325"	Otilde
  <Multi_key> <O> <minus>			: "\325"	Otilde
  <Multi_key> <O> <quotedbl>		: "\326"	Odiaeresis
  <Multi_key> <O> <slash>			: "\330"	Ooblique
  <Multi_key> <o> <grave>			: "\362"	ograve
  <Multi_key> <o> <acute>			: "\363"	oacute
  <Multi_key> <o> <apostrophe>		: "\363"	oacute
! <Multi_key> <o> <asciicircum>	: "\364"	ocircumflex
  <Multi_key> <o> <greater>		: "\364"	ocircumflex
  <Multi_key> <o> <asciitilde>		: "\365"	otilde
  <Multi_key> <o> <minus>			: "\365"	otilde
  <Multi_key> <o> <quotedbl>		: "\366"	odiaeresis
! <Multi_key> <o> <slash>			: "\370"	ooblique
  <Multi_key> <U> <grave>			: "\331"	Ugrave
  <Multi_key> <U> <acute>			: "\332"	Uacute
  <Multi_key> <U> <apostrophe>		: "\332"	Uacute
! <Multi_key> <U> <asciicircum>	: "\333"	Ucircumflex
  <Multi_key> <U> <greater>		: "\333"	Ucircumflex
  <Multi_key> <U> <quotedbl>		: "\334"	Udiaeresis
  <Multi_key> <u> <grave>			: "\371"	ugrave
  <Multi_key> <u> <acute>			: "\372"	uacute
  <Multi_key> <u> <apostrophe>		: "\372"	uacute
! <Multi_key> <u> <asciicircum>	: "\373"	ucircumflex
  <Multi_key> <u> <greater>		: "\373"	ucircumflex
  <Multi_key> <u> <quotedbl>		: "\374"	udiaeresis
  <Multi_key> <s> <s>			: "\337"	ssharp
  <Multi_key> <T> <H>			: "\336"	THORN
  <Multi_key> <t> <h>			: "\376"	thorn
  <Multi_key> <Y> <acute>			: "\335"	Yacute
  <Multi_key> <Y> <apostrophe>		: "\335"	Yacute
  <Multi_key> <y> <acute>			: "\375"	yacute
  <Multi_key> <y> <apostrophe>		: "\375"	yacute
  <Multi_key> <y> <quotedbl>		: "\377"	ydiaeresis
  #
  # Ctrl<T> Means <Compose>
  # Special Character
  Ctrl<T> <plus> <plus>			: "#"	numbersign
  Ctrl<T> <apostrophe> <space>		: "'"	apostrophe
  Ctrl<T> <A> <A>				: "@"	at
  Ctrl<T> <parenleft> <parenleft>		: "["	bracketleft
  Ctrl<T> <slash> <slash>			: "\\"	backslash
  Ctrl<T> <slash> <less>			: "\\"	backslash
  Ctrl<T> <parenright> <parenright>	: "]"	bracketright
  Ctrl<T> <asciicircum> <space>		: "^"	asciicircum
  Ctrl<T> <greater> <space>		: "^"	asciicirum
  Ctrl<T> <grave> <space>			: "`"	grave
  Ctrl<T> <parenleft> <minus>		: "{"	braceleft
  Ctrl<T> <slash> <asciicircum>		: "|"	bar
  Ctrl<T> <V> <L>				: "|"	bar
  Ctrl<T> <v> <l>				: "|"	bar
  Ctrl<T> <parenright> <minus>		: "}"	braceright
  Ctrl<T> <asciitilde> <space>		: "~"	asciitilde
  Ctrl<T> <minus> <space>			: "~"	asciitilde
! Ctrl<T> <exclam> <exclam>		: "\241"	exclaimdown
  Ctrl<T> <c> <slash>			: "\242"	cent
  Ctrl<T> <C> <slash>			: "\242"	cent
  Ctrl<T> <C> <bar>			: "\242"	cent
  Ctrl<T> <c> <bar>			: "\242"	cent
  Ctrl<T> <l> <minus>			: "\243"	sterling
  Ctrl<T> <L> <minus>			: "\243"	sterling
  Ctrl<T> <l> <equal>			: "\243"	sterling
  Ctrl<T> <L> <equal>			: "\243"	sterling
  Ctrl<T> <y> <minus>			: "\245"	yen
  Ctrl<T> <Y> <minus>			: "\245"	yen
  Ctrl<T> <y> <equal>			: "\245"	yen
  Ctrl<T> <Y> <equal>			: "\245"	yen
  Ctrl<T> <s> <o>				: "\247"	section
  Ctrl<T> <S> <O>				: "\247"	section
  Ctrl<T> <S> <exclam>			: "\247"	section
  Ctrl<T> <s> <exclam>			: "\247"	section
  Ctrl<T> <S> <0>				: "\247"	section
  Ctrl<T> <s> <0>				: "\247"	section
  Ctrl<T> <x> <o>				: "\244"	currency
  Ctrl<T> <X> <O>				: "\244"	currency
  Ctrl<T> <x> <O>				: "\244"	currency
  Ctrl<T> <X> <o>				: "\244"	currency
  Ctrl<T> <x> <0>				: "\244"	currency
  Ctrl<T> <X> <0>				: "\244"	currency
  Ctrl<T> <c> <o>				: "\251"	copyright
  Ctrl<T> <C> <O>				: "\251"	copyright
  Ctrl<T> <c> <O>				: "\251"	copyright
  Ctrl<T> <C> <o>				: "\251"	copyright
  Ctrl<T> <c> <0>				: "\251"	copyright
  Ctrl<T> <C> <0>				: "\251"	copyright
  Ctrl<T> <a> <underscore>		: "\252"	ordfeminine
  Ctrl<T> <A> <underscore>		: "\252"	ordfeminine
  Ctrl<T> <o> <underscore>		: "\272"	masculine
  Ctrl<T> <O> <underscore>		: "\272"	masculine
  Ctrl<T> <less> <less>			: "\253"	guillemotleft
  Ctrl<T> <greater> <greater>		: "\273"	guillemotright
  Ctrl<T> <0> <asciicircum>		: "\260"	degree
  Ctrl<T> <0> <asterisk>			: "\260"	degree
  Ctrl<T> <plus> <minus>			: "\261"	plusminus
  Ctrl<T> <slash> <u>			: "\265"	mu
  Ctrl<T> <slash> <U>			: "\265"	mu
  Ctrl<T> <1> <asciicircum>		: "\271"	onesuperior
  Ctrl<T> <S> <1>				: "\271"	onesuperior
  Ctrl<T> <s> <1>				: "\271"	onesuperior
  Ctrl<T> <2> <asciicircum>		: "\262"	twosuperior
  Ctrl<T> <S> <2>				: "\262"	twosuperior
  Ctrl<T> <s> <2>				: "\262"	twosuperior
  Ctrl<T> <3> <asciicircum>		: "\263"	threesuperior
  Ctrl<T> <S> <3>				: "\263"	threesuperior
  Ctrl<T> <s> <3>				: "\263"	threesuperior
  Ctrl<T> <p> <exclam>			: "\266"	paragraph
  Ctrl<T> <P> <exclam>			: "\266"	paragraph
  Ctrl<T> <period> <asciicircum>		: "\267"	periodcentered
  Ctrl<T> <period> <period>		: "\267"	periodcentered
  Ctrl<T> <1> <4>				: "\274"	onequarter
  Ctrl<T> <1> <2>				: "\275"	onehalf
--- 148,562 ----
  <Multi_key> <space> <space>		: "\240"	nobreakspace
  <Multi_key> <bar> <bar>			: "\246"	brokenbar
  <Multi_key> <exclam> <asciicircum>	: "\246"	brokenbar
+ <Multi_key> <asciicircum> <exclam>	: "\246"	brokenbar
  <Multi_key> <V> <B>			: "\246"	brokenbar
+ <Multi_key> <B> <V>			: "\246"	brokenbar
  <Multi_key> <v> <b>			: "\246"	brokenbar
+ <Multi_key> <b> <v>			: "\246"	brokenbar
  <Multi_key> <minus> <comma>		: "\254"	notsign
+ <Multi_key> <comma> <minus>		: "\254"	notsign
  <Multi_key> <minus> <minus>		: "\255"	hyphen
  <Multi_key> <R> <O>			: "\256"	registered
+ <Multi_key> <O> <R>			: "\256"	registered
  <Multi_key> <minus> <asciicircum>	: "\257"	macron
+ <Multi_key> <asciicircum> <minus>	: "\257"	macron
  <Multi_key> <underscore> <asciicircum>	: "\257"	macron
+ <Multi_key> <asciicircum> <underscore>	: "\257"	macron
  <Multi_key> <underscore> <underscore>	: "\257"	macron
  <Multi_key> <minus> <colon>		: "\367"	division
+ <Multi_key> <colon> <minus>		: "\367"	division
  <Multi_key> <x> <x>			: "\327"	multiply
  <Multi_key> <apostrophe> <apostrophe>	: "\264"	acute
  <Multi_key> <comma> <comma>		: "\270"	cedilla
  <Multi_key> <quotedbl> <quotedbl>	: "\250"	diaeresis
  # Accented Alphabet
  <Multi_key> <A> <grave>			: "\300"	Agrave
+ <Multi_key> <grave> <A>			: "\300"	Agrave
  <Multi_key> <A> <acute>			: "\301"	Aacute
+ <Multi_key> <acute> <A>			: "\301"	Aacute
  <Multi_key> <A> <apostrophe>		: "\301"	Aacute
! <Multi_key> <apostrophe> <A>		: "\301"	Aacute
! <Multi_key> <A> <asciicircum>		: "\302"	Acircumflex
! <Multi_key> <asciicircum> <A>		: "\302"	Acircumflex
  <Multi_key> <A> <greater>		: "\302"	Acircumflex
+ <Multi_key> <greater> <A>		: "\302"	Acircumflex
  <Multi_key> <A> <asciitilde>		: "\303"	Atilde
+ <Multi_key> <asciitilde> <A>		: "\303"	Atilde
  <Multi_key> <A> <minus>			: "\303"	Atilde
+ <Multi_key> <minus> <A>			: "\303"	Atilde
  <Multi_key> <A> <quotedbl>		: "\304"	Adiaeresis
+ <Multi_key> <quotedbl> <A>		: "\304"	Adiaeresis
  <Multi_key> <A> <asterisk>		: "\305"	Aring
+ <Multi_key> <asterisk> <A>		: "\305"	Aring
  <Multi_key> <A> <E>			: "\306"	AE
  <Multi_key> <a> <grave>			: "\340"	agrave
+ <Multi_key> <grave> <a>			: "\340"	agrave
  <Multi_key> <a> <acute>			: "\341"	aacute
+ <Multi_key> <acute> <a>			: "\341"	aacute
  <Multi_key> <a> <apostrophe>		: "\341"	aacute
! <Multi_key> <apostrophe> <a>		: "\341"	aacute
! <Multi_key> <a> <asciicircum>		: "\342"	acircumflex
! <Multi_key> <asciicircum> <a>		: "\342"	acircumflex
  <Multi_key> <a> <greater>		: "\342"	acircumflex
+ <Multi_key> <greater> <a>		: "\342"	acircumflex
  <Multi_key> <a> <asciitilde>		: "\343"	atilde
+ <Multi_key> <asciitilde> <a>		: "\343"	atilde
  <Multi_key> <a> <minus>			: "\343"	atilde
+ <Multi_key> <minus> <a>			: "\343"	atilde
  <Multi_key> <a> <quotedbl>		: "\344"	adiaeresis
+ <Multi_key> <quotedbl> <a>		: "\344"	adiaeresis
  <Multi_key> <a> <asterisk>		: "\345"	aring
+ <Multi_key> <asterisk> <a>		: "\345"	aring
  <Multi_key> <a> <e>			: "\346"	ae
  <Multi_key> <C> <comma>			: "\307"	Ccedilla
+ <Multi_key> <comma> <C>			: "\307"	Ccedilla
  <Multi_key> <c> <comma>			: "\347"	ccedilla
+ <Multi_key> <comma> <c>			: "\347"	ccedilla
  <Multi_key> <minus> <D>			: "\320"	ETH
+ <Multi_key> <D> <minus>			: "\320"	ETH
  <Multi_key> <minus> <d>			: "\360"	eth
+ <Multi_key> <d> <minus>			: "\360"	eth
  <Multi_key> <E> <grave>			: "\310"	Egrave
+ <Multi_key> <grave> <E>			: "\310"	Egrave
  <Multi_key> <E> <acute>			: "\311"	Eacute
+ <Multi_key> <acute> <E>			: "\311"	Eacute
  <Multi_key> <E> <apostrophe>		: "\311"	Eacute
! <Multi_key> <apostrophe> <E>		: "\311"	Eacute
! <Multi_key> <E> <asciicircum>		: "\312"	Ecircumflex
! <Multi_key> <asciicircum> <E>		: "\312"	Ecircumflex
  <Multi_key> <E> <greater>		: "\312"	Ecircumflex
+ <Multi_key> <greater> <E>		: "\312"	Ecircumflex
  <Multi_key> <E> <quotedbl>		: "\313"	Ediaeresis
+ <Multi_key> <quotedbl> <E>		: "\313"	Ediaeresis
  <Multi_key> <e> <grave>			: "\350"	egrave
+ <Multi_key> <grave> <e>			: "\350"	egrave
  <Multi_key> <e> <acute>			: "\351"	eacute
+ <Multi_key> <acute> <e>			: "\351"	eacute
  <Multi_key> <e> <apostrophe>		: "\351"	eacute
! <Multi_key> <apostrophe> <e>		: "\351"	eacute
! <Multi_key> <e> <asciicircum>		: "\352"	ecircumflex
! <Multi_key> <asciicircum> <e>		: "\352"	ecircumflex
  <Multi_key> <e> <greater>		: "\352"	ecircumflex
+ <Multi_key> <greater> <e>		: "\352"	ecircumflex
  <Multi_key> <e> <quotedbl>		: "\353"	ediaeresis
+ <Multi_key> <quotedbl> <e>		: "\353"	ediaeresis
  <Multi_key> <I> <grave>			: "\314"	Igrave
+ <Multi_key> <grave> <I>			: "\314"	Igrave
  <Multi_key> <I> <acute>			: "\315"	Iacute
+ <Multi_key> <acute> <I>			: "\315"	Iacute
  <Multi_key> <I> <apostrophe>		: "\315"	Iacute
! <Multi_key> <apostrophe> <I>		: "\315"	Iacute
! <Multi_key> <I> <asciicircum>		: "\316"	Icircumflex
! <Multi_key> <asciicircum> <I>		: "\316"	Icircumflex
  <Multi_key> <I> <greater>		: "\316"	Icircumflex
+ <Multi_key> <greater> <I>		: "\316"	Icircumflex
  <Multi_key> <I> <quotedbl>		: "\317"	Idiaeresis
+ <Multi_key> <quotedbl> <I>		: "\317"	Idiaeresis
  <Multi_key> <i> <grave>			: "\354"	igrave
+ <Multi_key> <grave> <i>			: "\354"	igrave
  <Multi_key> <i> <acute>			: "\355"	iacute
+ <Multi_key> <acute> <i>			: "\355"	iacute
  <Multi_key> <i> <apostrophe>		: "\355"	iacute
! <Multi_key> <apostrophe> <i>		: "\355"	iacute
! <Multi_key> <i> <asciicircum>		: "\356"	icircumflex
! <Multi_key> <asciicircum> <i>		: "\356"	icircumflex
  <Multi_key> <i> <greater>		: "\356"	icircumflex
+ <Multi_key> <greater> <i>		: "\356"	icircumflex
  <Multi_key> <i> <quotedbl>		: "\357"	idiaeresis
+ <Multi_key> <quotedbl> <i>		: "\357"	idiaeresis
  <Multi_key> <N> <asciitilde>		: "\321"	Ntilde
+ <Multi_key> <asciitilde> <N>		: "\321"	Ntilde
  <Multi_key> <N> <minus>			: "\321"	Ntilde
+ <Multi_key> <minus> <N>			: "\321"	Ntilde
  <Multi_key> <n> <asciitilde>		: "\361"	ntilde
+ <Multi_key> <asciitilde> <n>		: "\361"	ntilde
  <Multi_key> <n> <minus>			: "\361"	ntilde
+ <Multi_key> <minus> <n>			: "\361"	ntilde
  <Multi_key> <O> <grave>			: "\322"	Ograve
+ <Multi_key> <grave> <O>			: "\322"	Ograve
  <Multi_key> <O> <acute>			: "\323"	Oacute
+ <Multi_key> <acute> <O>			: "\323"	Oacute
  <Multi_key> <O> <apostrophe>		: "\323"	Oacute
! <Multi_key> <apostrophe> <O>		: "\323"	Oacute
! <Multi_key> <O> <asciicircum>		: "\324"	Ocircumflex
! <Multi_key> <asciicircum> <O>		: "\324"	Ocircumflex
  <Multi_key> <O> <greater>		: "\324"	Ocircumflex
+ <Multi_key> <greater> <O>		: "\324"	Ocircumflex
  <Multi_key> <O> <asciitilde>		: "\325"	Otilde
+ <Multi_key> <asciitilde> <O>		: "\325"	Otilde
  <Multi_key> <O> <minus>			: "\325"	Otilde
+ <Multi_key> <minus> <O>			: "\325"	Otilde
  <Multi_key> <O> <quotedbl>		: "\326"	Odiaeresis
+ <Multi_key> <quotedbl> <O>		: "\326"	Odiaeresis
  <Multi_key> <O> <slash>			: "\330"	Ooblique
+ <Multi_key> <slash> <O>			: "\330"	Ooblique
  <Multi_key> <o> <grave>			: "\362"	ograve
+ <Multi_key> <grave> <o>			: "\362"	ograve
  <Multi_key> <o> <acute>			: "\363"	oacute
+ <Multi_key> <acute> <o>			: "\363"	oacute
  <Multi_key> <o> <apostrophe>		: "\363"	oacute
! <Multi_key> <apostrophe> <o>		: "\363"	oacute
! <Multi_key> <o> <asciicircum>		: "\364"	ocircumflex
! <Multi_key> <asciicircum> <o>		: "\364"	ocircumflex
  <Multi_key> <o> <greater>		: "\364"	ocircumflex
+ <Multi_key> <greater> <o>		: "\364"	ocircumflex
  <Multi_key> <o> <asciitilde>		: "\365"	otilde
+ <Multi_key> <asciitilde> <o>		: "\365"	otilde
  <Multi_key> <o> <minus>			: "\365"	otilde
+ <Multi_key> <minus> <o>			: "\365"	otilde
  <Multi_key> <o> <quotedbl>		: "\366"	odiaeresis
! <Multi_key> <quotedbl> <o>		: "\366"	odiaeresis
! <Multi_key> <o> <slash>			: "\370"	oslash
! <Multi_key> <slash> <o>			: "\370"	oslash
  <Multi_key> <U> <grave>			: "\331"	Ugrave
+ <Multi_key> <grave> <U>			: "\331"	Ugrave
  <Multi_key> <U> <acute>			: "\332"	Uacute
+ <Multi_key> <acute> <U>			: "\332"	Uacute
  <Multi_key> <U> <apostrophe>		: "\332"	Uacute
! <Multi_key> <apostrophe> <U>		: "\332"	Uacute
! <Multi_key> <U> <asciicircum>		: "\333"	Ucircumflex
! <Multi_key> <asciicircum> <U>		: "\333"	Ucircumflex
  <Multi_key> <U> <greater>		: "\333"	Ucircumflex
+ <Multi_key> <greater> <U>		: "\333"	Ucircumflex
  <Multi_key> <U> <quotedbl>		: "\334"	Udiaeresis
+ <Multi_key> <quotedbl> <U>		: "\334"	Udiaeresis
  <Multi_key> <u> <grave>			: "\371"	ugrave
+ <Multi_key> <grave> <u>			: "\371"	ugrave
  <Multi_key> <u> <acute>			: "\372"	uacute
+ <Multi_key> <acute> <u>			: "\372"	uacute
  <Multi_key> <u> <apostrophe>		: "\372"	uacute
! <Multi_key> <apostrophe> <u>		: "\372"	uacute
! <Multi_key> <u> <asciicircum>		: "\373"	ucircumflex
! <Multi_key> <asciicircum> <u>		: "\373"	ucircumflex
  <Multi_key> <u> <greater>		: "\373"	ucircumflex
+ <Multi_key> <greater> <u>		: "\373"	ucircumflex
  <Multi_key> <u> <quotedbl>		: "\374"	udiaeresis
+ <Multi_key> <quotedbl> <u>		: "\374"	udiaeresis
  <Multi_key> <s> <s>			: "\337"	ssharp
  <Multi_key> <T> <H>			: "\336"	THORN
  <Multi_key> <t> <h>			: "\376"	thorn
  <Multi_key> <Y> <acute>			: "\335"	Yacute
+ <Multi_key> <acute> <Y>			: "\335"	Yacute
  <Multi_key> <Y> <apostrophe>		: "\335"	Yacute
+ <Multi_key> <apostrophe> <Y>		: "\335"	Yacute
  <Multi_key> <y> <acute>			: "\375"	yacute
+ <Multi_key> <acute> <y>			: "\375"	yacute
  <Multi_key> <y> <apostrophe>		: "\375"	yacute
+ <Multi_key> <apostrophe> <y>		: "\375"	yacute
  <Multi_key> <y> <quotedbl>		: "\377"	ydiaeresis
+ <Multi_key> <quotedbl> <y>		: "\377"	ydiaeresis
+ #
+ # dead key accent keysyms
+ # Special Character
+ <dead_circumflex>  <slash>		: "|"	bar
+ <dead_grave> <space>			: "`"	grave
+ <dead_acute> <space>			: "'"	apostrophe
+ <dead_diaeresis> <space>		: "\250"	diaeresis
+ <dead_circumflex> <space>		: "^"	asciicircum
+ <dead_tilde> <space>			: "~"	tilde
+ <dead_grave> <space>			: "`"	grave
+ <dead_acute> <space>			: "'"	apostrophe
+ <dead_circumflex> <0>			: "\260"	degree
+ <dead_circumflex> <1>			: "\271"	onesuperior
+ <dead_circumflex> <2>			: "\262"	twosuperior
+ <dead_circumflex> <3>			: "\263"	threesuperior
+ <dead_circumflex> <period>		: "\267"	periodcentered
+ <dead_circumflex> <exclam>		: "\246"	brokenbar
+ <dead_cedilla> <minus>			: "\254"	notsign
+ <dead_circumflex> <minus>		: "\257"	macron
+ <dead_circumflex> <underscore>		: "\257"	macron
+ <dead_acute> <apostrophe>		: "\264"	acute
+ <dead_cedilla> <comma>			: "\270"	cedilla
+ <dead_diaeresis> <quotedbl>		: "\250"	diaeresis
+ # Accented Alphabet
+ <dead_grave> <A>			: "\300"	Agrave
+ <dead_acute> <A>			: "\301"	Aacute
+ <dead_circumflex> <A>			: "\302"	Acircumflex
+ <dead_tilde> <A>			: "\303"	Atilde
+ <dead_diaeresis> <A>			: "\304"	Adiaeresis
+ <dead_grave> <a>			: "\340"	agrave
+ <dead_acute> <a>			: "\341"	aacute
+ <dead_circumflex> <a>			: "\342"	acircumflex
+ <dead_tilde> <a>			: "\343"	atilde
+ <dead_diaeresis> <a>			: "\344"	adiaeresis
+ <dead_cedilla> <C>			: "\307"	Ccedilla
+ <dead_cedilla> <c>			: "\347"	ccedilla
+ <dead_grave> <E>			: "\310"	Egrave
+ <dead_acute> <E>			: "\311"	Eacute
+ <dead_circumflex> <E>			: "\312"	Ecircumflex
+ <dead_diaeresis> <E>			: "\313"	Ediaeresis
+ <dead_grave> <e>			: "\350"	egrave
+ <dead_acute> <e>			: "\351"	eacute
+ <dead_circumflex> <e>			: "\352"	ecircumflex
+ <dead_diaeresis> <e>			: "\353"	ediaeresis
+ <dead_grave> <I>			: "\314"	Igrave
+ <dead_acute> <I>			: "\315"	Iacute
+ <dead_circumflex> <I>			: "\316"	Icircumflex
+ <dead_diaeresis> <I>			: "\317"	Idiaeresis
+ <dead_grave> <i>			: "\354"	igrave
+ <dead_acute> <i>			: "\355"	iacute
+ <dead_circumflex> <i>			: "\356"	icircumflex
+ <dead_diaeresis> <i>			: "\357"	idiaeresis
+ <dead_tilde> <N>			: "\321"	Ntilde
+ <dead_tilde> <n>			: "\361"	ntilde
+ <dead_grave> <O>			: "\322"	Ograve
+ <dead_acute> <O>			: "\323"	Oacute
+ <dead_circumflex> <O>			: "\324"	Ocircumflex
+ <dead_tilde> <O>			: "\325"	Otilde
+ <dead_diaeresis> <O>			: "\326"	Odiaeresis
+ <dead_grave> <o>			: "\362"	ograve
+ <dead_acute> <o>			: "\363"	oacute
+ <dead_circumflex> <o>			: "\364"	ocircumflex
+ <dead_tilde> <o>			: "\365"	otilde
+ <dead_diaeresis> <o>			: "\366"	odiaeresis
+ <dead_grave> <U>			: "\331"	Ugrave
+ <dead_acute> <U>			: "\332"	Uacute
+ <dead_circumflex> <U>			: "\333"	Ucircumflex
+ <dead_diaeresis> <U>			: "\334"	Udiaeresis
+ <dead_grave> <u>			: "\371"	ugrave
+ <dead_acute> <u>			: "\372"	uacute
+ <dead_circumflex> <u>			: "\373"	ucircumflex
+ <dead_diaeresis> <u>			: "\374"	udiaeresis
+ <dead_acute> <Y>			: "\335"	Yacute
+ <dead_acute> <y>			: "\375"	yacute
+ <dead_diaeresis> <y>			: "\377"	ydiaeresis
  #
  # Ctrl<T> Means <Compose>
  # Special Character
  Ctrl<T> <plus> <plus>			: "#"	numbersign
  Ctrl<T> <apostrophe> <space>		: "'"	apostrophe
+ Ctrl<T> <space> <apostrophe>		: "'"	apostrophe
  Ctrl<T> <A> <A>				: "@"	at
  Ctrl<T> <parenleft> <parenleft>		: "["	bracketleft
  Ctrl<T> <slash> <slash>			: "\\"	backslash
  Ctrl<T> <slash> <less>			: "\\"	backslash
+ Ctrl<T> <less> <slash>			: "\\"	backslash
  Ctrl<T> <parenright> <parenright>	: "]"	bracketright
  Ctrl<T> <asciicircum> <space>		: "^"	asciicircum
+ Ctrl<T> <space> <asciicircum>		: "^"	asciicircum
  Ctrl<T> <greater> <space>		: "^"	asciicirum
+ Ctrl<T> <space> <greater>		: "^"	asciicirum
  Ctrl<T> <grave> <space>			: "`"	grave
+ Ctrl<T> <space> <grave>			: "`"	grave
  Ctrl<T> <parenleft> <minus>		: "{"	braceleft
+ Ctrl<T> <minus> <parenleft>		: "{"	braceleft
  Ctrl<T> <slash> <asciicircum>		: "|"	bar
+ Ctrl<T> <asciicircum> <slash>		: "|"	bar
  Ctrl<T> <V> <L>				: "|"	bar
+ Ctrl<T> <L> <V>				: "|"	bar
  Ctrl<T> <v> <l>				: "|"	bar
+ Ctrl<T> <l> <v>				: "|"	bar
  Ctrl<T> <parenright> <minus>		: "}"	braceright
+ Ctrl<T> <minus> <parenright>		: "}"	braceright
  Ctrl<T> <asciitilde> <space>		: "~"	asciitilde
+ Ctrl<T> <space> <asciitilde>		: "~"	asciitilde
  Ctrl<T> <minus> <space>			: "~"	asciitilde
! Ctrl<T> <space> <minus>			: "~"	asciitilde
! Ctrl<T> <exclam> <exclam>		: "\241"	exclamdown
  Ctrl<T> <c> <slash>			: "\242"	cent
+ Ctrl<T> <slash> <c>			: "\242"	cent
  Ctrl<T> <C> <slash>			: "\242"	cent
+ Ctrl<T> <slash> <C>			: "\242"	cent
  Ctrl<T> <C> <bar>			: "\242"	cent
+ Ctrl<T> <bar> <C>			: "\242"	cent
  Ctrl<T> <c> <bar>			: "\242"	cent
+ Ctrl<T> <bar> <c>			: "\242"	cent
  Ctrl<T> <l> <minus>			: "\243"	sterling
+ Ctrl<T> <minus> <l>			: "\243"	sterling
  Ctrl<T> <L> <minus>			: "\243"	sterling
+ Ctrl<T> <minus> <L>			: "\243"	sterling
  Ctrl<T> <l> <equal>			: "\243"	sterling
+ Ctrl<T> <equal> <l>			: "\243"	sterling
  Ctrl<T> <L> <equal>			: "\243"	sterling
+ Ctrl<T> <equal> <L>			: "\243"	sterling
  Ctrl<T> <y> <minus>			: "\245"	yen
+ Ctrl<T> <minus> <y>			: "\245"	yen
  Ctrl<T> <Y> <minus>			: "\245"	yen
+ Ctrl<T> <minus> <Y>			: "\245"	yen
  Ctrl<T> <y> <equal>			: "\245"	yen
+ Ctrl<T> <equal> <y>			: "\245"	yen
  Ctrl<T> <Y> <equal>			: "\245"	yen
+ Ctrl<T> <equal> <Y>			: "\245"	yen
  Ctrl<T> <s> <o>				: "\247"	section
+ Ctrl<T> <o> <s>				: "\247"	section
  Ctrl<T> <S> <O>				: "\247"	section
+ Ctrl<T> <O> <S>				: "\247"	section
  Ctrl<T> <S> <exclam>			: "\247"	section
+ Ctrl<T> <exclam> <S>			: "\247"	section
  Ctrl<T> <s> <exclam>			: "\247"	section
+ Ctrl<T> <exclam> <s>			: "\247"	section
  Ctrl<T> <S> <0>				: "\247"	section
+ Ctrl<T> <0> <S>				: "\247"	section
  Ctrl<T> <s> <0>				: "\247"	section
+ Ctrl<T> <0> <s>				: "\247"	section
  Ctrl<T> <x> <o>				: "\244"	currency
+ Ctrl<T> <o> <x>				: "\244"	currency
  Ctrl<T> <X> <O>				: "\244"	currency
+ Ctrl<T> <O> <X>				: "\244"	currency
  Ctrl<T> <x> <O>				: "\244"	currency
+ Ctrl<T> <O> <x>				: "\244"	currency
  Ctrl<T> <X> <o>				: "\244"	currency
+ Ctrl<T> <o> <X>				: "\244"	currency
  Ctrl<T> <x> <0>				: "\244"	currency
+ Ctrl<T> <0> <x>				: "\244"	currency
  Ctrl<T> <X> <0>				: "\244"	currency
+ Ctrl<T> <0> <X>				: "\244"	currency
  Ctrl<T> <c> <o>				: "\251"	copyright
+ Ctrl<T> <o> <c>				: "\251"	copyright
  Ctrl<T> <C> <O>				: "\251"	copyright
+ Ctrl<T> <O> <C>				: "\251"	copyright
  Ctrl<T> <c> <O>				: "\251"	copyright
+ Ctrl<T> <O> <c>				: "\251"	copyright
  Ctrl<T> <C> <o>				: "\251"	copyright
+ Ctrl<T> <o> <C>				: "\251"	copyright
  Ctrl<T> <c> <0>				: "\251"	copyright
+ Ctrl<T> <0> <c>				: "\251"	copyright
  Ctrl<T> <C> <0>				: "\251"	copyright
+ Ctrl<T> <0> <C>				: "\251"	copyright
  Ctrl<T> <a> <underscore>		: "\252"	ordfeminine
+ Ctrl<T> <underscore> <a>		: "\252"	ordfeminine
  Ctrl<T> <A> <underscore>		: "\252"	ordfeminine
+ Ctrl<T> <underscore> <A>		: "\252"	ordfeminine
  Ctrl<T> <o> <underscore>		: "\272"	masculine
+ Ctrl<T> <underscore> <o>		: "\272"	masculine
  Ctrl<T> <O> <underscore>		: "\272"	masculine
+ Ctrl<T> <underscore> <O>		: "\272"	masculine
  Ctrl<T> <less> <less>			: "\253"	guillemotleft
  Ctrl<T> <greater> <greater>		: "\273"	guillemotright
  Ctrl<T> <0> <asciicircum>		: "\260"	degree
+ Ctrl<T> <asciicircum> <0>		: "\260"	degree
  Ctrl<T> <0> <asterisk>			: "\260"	degree
+ Ctrl<T> <asterisk> <0>			: "\260"	degree
  Ctrl<T> <plus> <minus>			: "\261"	plusminus
+ Ctrl<T> <minus> <plus>			: "\261"	plusminus
  Ctrl<T> <slash> <u>			: "\265"	mu
+ Ctrl<T> <u> <slash>			: "\265"	mu
  Ctrl<T> <slash> <U>			: "\265"	mu
+ Ctrl<T> <U> <slash>			: "\265"	mu
  Ctrl<T> <1> <asciicircum>		: "\271"	onesuperior
+ Ctrl<T> <asciicircum> <1>		: "\271"	onesuperior
  Ctrl<T> <S> <1>				: "\271"	onesuperior
+ Ctrl<T> <1> <S>				: "\271"	onesuperior
  Ctrl<T> <s> <1>				: "\271"	onesuperior
+ Ctrl<T> <1> <s>				: "\271"	onesuperior
  Ctrl<T> <2> <asciicircum>		: "\262"	twosuperior
+ Ctrl<T> <asciicircum> <2>		: "\262"	twosuperior
  Ctrl<T> <S> <2>				: "\262"	twosuperior
+ Ctrl<T> <2> <S>				: "\262"	twosuperior
  Ctrl<T> <s> <2>				: "\262"	twosuperior
+ Ctrl<T> <2> <s>				: "\262"	twosuperior
  Ctrl<T> <3> <asciicircum>		: "\263"	threesuperior
+ Ctrl<T> <asciicircum> <3>		: "\263"	threesuperior
  Ctrl<T> <S> <3>				: "\263"	threesuperior
+ Ctrl<T> <3> <S>				: "\263"	threesuperior
  Ctrl<T> <s> <3>				: "\263"	threesuperior
+ Ctrl<T> <3> <s>				: "\263"	threesuperior
  Ctrl<T> <p> <exclam>			: "\266"	paragraph
+ Ctrl<T> <exclam> <p>			: "\266"	paragraph
  Ctrl<T> <P> <exclam>			: "\266"	paragraph
+ Ctrl<T> <exclam> <P>			: "\266"	paragraph
  Ctrl<T> <period> <asciicircum>		: "\267"	periodcentered
+ Ctrl<T> <asciicircum> <period>		: "\267"	periodcentered
  Ctrl<T> <period> <period>		: "\267"	periodcentered
  Ctrl<T> <1> <4>				: "\274"	onequarter
  Ctrl<T> <1> <2>				: "\275"	onehalf
***************
*** 271,378 ****
  Ctrl<T> <space> <space>			: "\240"	nobreakspace
  Ctrl<T> <bar> <bar>			: "\246"	brokenbar
  Ctrl<T> <exclam> <asciicircum>		: "\246"	brokenbar
  Ctrl<T> <V> <B>				: "\246"	brokenbar
  Ctrl<T> <v> <b>				: "\246"	brokenbar
  Ctrl<T> <minus> <comma>			: "\254"	notsign
  Ctrl<T> <minus> <minus>			: "\255"	hyphen
  Ctrl<T> <R> <O>				: "\256"	registered
  Ctrl<T> <minus> <asciicircum>		: "\257"	macron
  Ctrl<T> <underscore> <asciicircum>	: "\257"	macron
  Ctrl<T> <underscore> <underscore>	: "\257"	macron
  Ctrl<T> <minus> <colon>			: "\367"	division
  Ctrl<T> <x> <x>				: "\327"	multiply
  Ctrl<T> <apostrophe> <apostrophe>	: "\264"	acute
  Ctrl<T> <comma> <comma>			: "\270"	cedilla
  Ctrl<T> <quotedbl> <quotedbl>		: "\250"	diaeresis
  # Accented Alphabet
  Ctrl<T> <A> <grave>			: "\300"	Agrave
  Ctrl<T> <A> <acute>			: "\301"	Aacute
  Ctrl<T> <A> <apostrophe>		: "\301"	Aacute
  Ctrl<T> <A> <asciicircum>		: "\302"	Acircumflex
  Ctrl<T> <A> <greater>			: "\302"	Acircumflex
  Ctrl<T> <A> <asciitilde>		: "\303"	Atilde
  Ctrl<T> <A> <minus>			: "\303"	Atilde
  Ctrl<T> <A> <quotedbl>			: "\304"	Adiaeresis
  Ctrl<T> <A> <asterisk>			: "\305"	Aring
  Ctrl<T> <A> <E>				: "\306"	AE
  Ctrl<T> <a> <grave>			: "\340"	agrave
  Ctrl<T> <a> <acute>			: "\341"	aacute
  Ctrl<T> <a> <apostrophe>		: "\341"	aacute
  Ctrl<T> <a> <asciicircum>		: "\342"	acircumflex
  Ctrl<T> <a> <greater>			: "\342"	acircumflex
  Ctrl<T> <a> <asciitilde>		: "\343"	atilde
  Ctrl<T> <a> <minus>			: "\343"	atilde
  Ctrl<T> <a> <quotedbl>			: "\344"	adiaeresis
  Ctrl<T> <a> <asterisk>			: "\345"	aring
  Ctrl<T> <a> <e>				: "\346"	ae
  Ctrl<T> <C> <comma>			: "\307"	Ccedilla
  Ctrl<T> <c> <comma>			: "\347"	ccedilla
  Ctrl<T> <minus> <D>			: "\320"	ETH
  Ctrl<T> <minus> <d>			: "\360"	eth
  Ctrl<T> <E> <grave>			: "\310"	Egrave
  Ctrl<T> <E> <acute>			: "\311"	Eacute
  Ctrl<T> <E> <apostrophe>		: "\311"	Eacute
  Ctrl<T> <E> <asciicircum>		: "\312"	Ecircumflex
  Ctrl<T> <E> <greater>			: "\312"	Ecircumflex
  Ctrl<T> <E> <quotedbl>			: "\313"	Ediaeresis
  Ctrl<T> <e> <grave>			: "\350"	egrave
  Ctrl<T> <e> <acute>			: "\351"	eacute
  Ctrl<T> <e> <apostrophe>		: "\351"	eacute
  Ctrl<T> <e> <asciicircum>		: "\352"	ecircumflex
  Ctrl<T> <e> <greater>			: "\352"	ecircumflex
  Ctrl<T> <e> <quotedbl>			: "\353"	ediaeresis
  Ctrl<T> <I> <grave>			: "\314"	Igrave
  Ctrl<T> <I> <acute>			: "\315"	Iacute
  Ctrl<T> <I> <apostrophe>		: "\315"	Iacute
  Ctrl<T> <I> <asciicircum>		: "\316"	Icircumflex
  Ctrl<T> <I> <greater>			: "\316"	Icircumflex
  Ctrl<T> <I> <quotedbl>			: "\317"	Idiaeresis
  Ctrl<T> <i> <grave>			: "\354"	igrave
  Ctrl<T> <i> <acute>			: "\355"	iacute
  Ctrl<T> <i> <apostrophe>		: "\355"	iacute
  Ctrl<T> <i> <asciicircum>		: "\356"	icircumflex
  Ctrl<T> <i> <greater>			: "\356"	icircumflex
  Ctrl<T> <i> <quotedbl>			: "\357"	idiaeresis
  Ctrl<T> <N> <asciitilde>		: "\321"	Ntilde
  Ctrl<T> <N> <minus>			: "\321"	Ntilde
  Ctrl<T> <n> <asciitilde>		: "\361"	ntilde
  Ctrl<T> <n> <minus>			: "\361"	ntilde
  Ctrl<T> <O> <grave>			: "\322"	Ograve
  Ctrl<T> <O> <acute>			: "\323"	Oacute
  Ctrl<T> <O> <apostrophe>		: "\323"	Oacute
  Ctrl<T> <O> <asciicircum>		: "\324"	Ocircumflex
  Ctrl<T> <O> <greater>			: "\324"	Ocircumflex
  Ctrl<T> <O> <asciitilde>		: "\325"	Otilde
  Ctrl<T> <O> <minus>			: "\325"	Otilde
  Ctrl<T> <O> <quotedbl>			: "\326"	Odiaeresis
  Ctrl<T> <O> <slash>			: "\330"	Ooblique
  Ctrl<T> <o> <grave>			: "\362"	ograve
  Ctrl<T> <o> <acute>			: "\363"	oacute
  Ctrl<T> <o> <apostrophe>		: "\363"	oacute
  Ctrl<T> <o> <asciicircum>		: "\364"	ocircumflex
  Ctrl<T> <o> <greater>			: "\364"	ocircumflex
  Ctrl<T> <o> <asciitilde>		: "\365"	otilde
  Ctrl<T> <o> <minus>			: "\365"	otilde
  Ctrl<T> <o> <quotedbl>			: "\366"	odiaeresis
! Ctrl<T> <o> <slash>			: "\370"	ooblique
  Ctrl<T> <U> <grave>			: "\331"	Ugrave
  Ctrl<T> <U> <acute>			: "\332"	Uacute
  Ctrl<T> <U> <apostrophe>		: "\332"	Uacute
  Ctrl<T> <U> <asciicircum>		: "\333"	Ucircumflex
  Ctrl<T> <U> <greater>			: "\333"	Ucircumflex
  Ctrl<T> <U> <quotedbl>			: "\334"	Udiaeresis
  Ctrl<T> <u> <grave>			: "\371"	ugrave
  Ctrl<T> <u> <acute>			: "\372"	uacute
  Ctrl<T> <u> <apostrophe>		: "\372"	uacute
  Ctrl<T> <u> <asciicircum>		: "\373"	ucircumflex
  Ctrl<T> <u> <greater>			: "\373"	ucircumflex
  Ctrl<T> <u> <quotedbl>			: "\374"	udiaeresis
  Ctrl<T> <s> <s>				: "\337"	ssharp
  Ctrl<T> <T> <H>				: "\336"	THORN
  Ctrl<T> <t> <h>				: "\376"	thorn
  Ctrl<T> <Y> <acute>			: "\335"	Yacute
  Ctrl<T> <Y> <apostrophe>		: "\335"	Yacute
  Ctrl<T> <y> <acute>			: "\375"	yacute
  Ctrl<T> <y> <apostrophe>		: "\375"	yacute
  Ctrl<T> <y> <quotedbl>			: "\377"	ydiaeresis
  # End of Sequence Definition
--- 565,765 ----
  Ctrl<T> <space> <space>			: "\240"	nobreakspace
  Ctrl<T> <bar> <bar>			: "\246"	brokenbar
  Ctrl<T> <exclam> <asciicircum>		: "\246"	brokenbar
+ Ctrl<T> <asciicircum> <exclam>		: "\246"	brokenbar
  Ctrl<T> <V> <B>				: "\246"	brokenbar
+ Ctrl<T> <B> <V>				: "\246"	brokenbar
  Ctrl<T> <v> <b>				: "\246"	brokenbar
+ Ctrl<T> <b> <v>				: "\246"	brokenbar
  Ctrl<T> <minus> <comma>			: "\254"	notsign
+ Ctrl<T> <comma> <minus>			: "\254"	notsign
  Ctrl<T> <minus> <minus>			: "\255"	hyphen
  Ctrl<T> <R> <O>				: "\256"	registered
+ Ctrl<T> <O> <R>				: "\256"	registered
  Ctrl<T> <minus> <asciicircum>		: "\257"	macron
+ Ctrl<T> <asciicircum> <minus>		: "\257"	macron
  Ctrl<T> <underscore> <asciicircum>	: "\257"	macron
+ Ctrl<T> <asciicircum> <underscore>	: "\257"	macron
  Ctrl<T> <underscore> <underscore>	: "\257"	macron
  Ctrl<T> <minus> <colon>			: "\367"	division
+ Ctrl<T> <colon> <minus>			: "\367"	division
  Ctrl<T> <x> <x>				: "\327"	multiply
  Ctrl<T> <apostrophe> <apostrophe>	: "\264"	acute
  Ctrl<T> <comma> <comma>			: "\270"	cedilla
  Ctrl<T> <quotedbl> <quotedbl>		: "\250"	diaeresis
  # Accented Alphabet
  Ctrl<T> <A> <grave>			: "\300"	Agrave
+ Ctrl<T> <grave> <A>			: "\300"	Agrave
  Ctrl<T> <A> <acute>			: "\301"	Aacute
+ Ctrl<T> <acute> <A>			: "\301"	Aacute
  Ctrl<T> <A> <apostrophe>		: "\301"	Aacute
+ Ctrl<T> <apostrophe> <A>		: "\301"	Aacute
  Ctrl<T> <A> <asciicircum>		: "\302"	Acircumflex
+ Ctrl<T> <asciicircum> <A>		: "\302"	Acircumflex
  Ctrl<T> <A> <greater>			: "\302"	Acircumflex
+ Ctrl<T> <greater> <A>			: "\302"	Acircumflex
  Ctrl<T> <A> <asciitilde>		: "\303"	Atilde
+ Ctrl<T> <asciitilde> <A>		: "\303"	Atilde
  Ctrl<T> <A> <minus>			: "\303"	Atilde
+ Ctrl<T> <minus> <A>			: "\303"	Atilde
  Ctrl<T> <A> <quotedbl>			: "\304"	Adiaeresis
+ Ctrl<T> <quotedbl> <A>			: "\304"	Adiaeresis
  Ctrl<T> <A> <asterisk>			: "\305"	Aring
+ Ctrl<T> <asterisk> <A>			: "\305"	Aring
  Ctrl<T> <A> <E>				: "\306"	AE
  Ctrl<T> <a> <grave>			: "\340"	agrave
+ Ctrl<T> <grave> <a>			: "\340"	agrave
  Ctrl<T> <a> <acute>			: "\341"	aacute
+ Ctrl<T> <acute> <a>			: "\341"	aacute
  Ctrl<T> <a> <apostrophe>		: "\341"	aacute
+ Ctrl<T> <apostrophe> <a>		: "\341"	aacute
  Ctrl<T> <a> <asciicircum>		: "\342"	acircumflex
+ Ctrl<T> <asciicircum> <a>		: "\342"	acircumflex
  Ctrl<T> <a> <greater>			: "\342"	acircumflex
+ Ctrl<T> <greater> <a>			: "\342"	acircumflex
  Ctrl<T> <a> <asciitilde>		: "\343"	atilde
+ Ctrl<T> <asciitilde> <a>		: "\343"	atilde
  Ctrl<T> <a> <minus>			: "\343"	atilde
+ Ctrl<T> <minus> <a>			: "\343"	atilde
  Ctrl<T> <a> <quotedbl>			: "\344"	adiaeresis
+ Ctrl<T> <quotedbl> <a>			: "\344"	adiaeresis
  Ctrl<T> <a> <asterisk>			: "\345"	aring
+ Ctrl<T> <asterisk> <a>			: "\345"	aring
  Ctrl<T> <a> <e>				: "\346"	ae
  Ctrl<T> <C> <comma>			: "\307"	Ccedilla
+ Ctrl<T> <comma> <C>			: "\307"	Ccedilla
  Ctrl<T> <c> <comma>			: "\347"	ccedilla
+ Ctrl<T> <comma> <c>			: "\347"	ccedilla
  Ctrl<T> <minus> <D>			: "\320"	ETH
+ Ctrl<T> <D> <minus>			: "\320"	ETH
  Ctrl<T> <minus> <d>			: "\360"	eth
+ Ctrl<T> <d> <minus>			: "\360"	eth
  Ctrl<T> <E> <grave>			: "\310"	Egrave
+ Ctrl<T> <grave> <E>			: "\310"	Egrave
  Ctrl<T> <E> <acute>			: "\311"	Eacute
+ Ctrl<T> <acute> <E>			: "\311"	Eacute
  Ctrl<T> <E> <apostrophe>		: "\311"	Eacute
+ Ctrl<T> <apostrophe> <E>		: "\311"	Eacute
  Ctrl<T> <E> <asciicircum>		: "\312"	Ecircumflex
+ Ctrl<T> <asciicircum> <E>		: "\312"	Ecircumflex
  Ctrl<T> <E> <greater>			: "\312"	Ecircumflex
+ Ctrl<T> <greater> <E>			: "\312"	Ecircumflex
  Ctrl<T> <E> <quotedbl>			: "\313"	Ediaeresis
+ Ctrl<T> <quotedbl> <E>			: "\313"	Ediaeresis
  Ctrl<T> <e> <grave>			: "\350"	egrave
+ Ctrl<T> <grave> <e>			: "\350"	egrave
  Ctrl<T> <e> <acute>			: "\351"	eacute
+ Ctrl<T> <acute> <e>			: "\351"	eacute
  Ctrl<T> <e> <apostrophe>		: "\351"	eacute
+ Ctrl<T> <apostrophe> <e>		: "\351"	eacute
  Ctrl<T> <e> <asciicircum>		: "\352"	ecircumflex
+ Ctrl<T> <asciicircum> <e>		: "\352"	ecircumflex
  Ctrl<T> <e> <greater>			: "\352"	ecircumflex
+ Ctrl<T> <greater> <e>			: "\352"	ecircumflex
  Ctrl<T> <e> <quotedbl>			: "\353"	ediaeresis
+ Ctrl<T> <quotedbl> <e>			: "\353"	ediaeresis
  Ctrl<T> <I> <grave>			: "\314"	Igrave
+ Ctrl<T> <grave> <I>			: "\314"	Igrave
  Ctrl<T> <I> <acute>			: "\315"	Iacute
+ Ctrl<T> <acute> <I>			: "\315"	Iacute
  Ctrl<T> <I> <apostrophe>		: "\315"	Iacute
+ Ctrl<T> <apostrophe> <I>		: "\315"	Iacute
  Ctrl<T> <I> <asciicircum>		: "\316"	Icircumflex
+ Ctrl<T> <asciicircum> <I>		: "\316"	Icircumflex
  Ctrl<T> <I> <greater>			: "\316"	Icircumflex
+ Ctrl<T> <greater> <I>			: "\316"	Icircumflex
  Ctrl<T> <I> <quotedbl>			: "\317"	Idiaeresis
+ Ctrl<T> <quotedbl> <I>			: "\317"	Idiaeresis
  Ctrl<T> <i> <grave>			: "\354"	igrave
+ Ctrl<T> <grave> <i>			: "\354"	igrave
  Ctrl<T> <i> <acute>			: "\355"	iacute
+ Ctrl<T> <acute> <i>			: "\355"	iacute
  Ctrl<T> <i> <apostrophe>		: "\355"	iacute
+ Ctrl<T> <apostrophe> <i>		: "\355"	iacute
  Ctrl<T> <i> <asciicircum>		: "\356"	icircumflex
+ Ctrl<T> <asciicircum> <i>		: "\356"	icircumflex
  Ctrl<T> <i> <greater>			: "\356"	icircumflex
+ Ctrl<T> <greater> <i>			: "\356"	icircumflex
  Ctrl<T> <i> <quotedbl>			: "\357"	idiaeresis
+ Ctrl<T> <quotedbl> <i>			: "\357"	idiaeresis
  Ctrl<T> <N> <asciitilde>		: "\321"	Ntilde
+ Ctrl<T> <asciitilde> <N>		: "\321"	Ntilde
  Ctrl<T> <N> <minus>			: "\321"	Ntilde
+ Ctrl<T> <minus> <N>			: "\321"	Ntilde
  Ctrl<T> <n> <asciitilde>		: "\361"	ntilde
+ Ctrl<T> <asciitilde> <n>		: "\361"	ntilde
  Ctrl<T> <n> <minus>			: "\361"	ntilde
+ Ctrl<T> <minus> <n>			: "\361"	ntilde
  Ctrl<T> <O> <grave>			: "\322"	Ograve
+ Ctrl<T> <grave> <O>			: "\322"	Ograve
  Ctrl<T> <O> <acute>			: "\323"	Oacute
+ Ctrl<T> <acute> <O>			: "\323"	Oacute
  Ctrl<T> <O> <apostrophe>		: "\323"	Oacute
+ Ctrl<T> <apostrophe> <O>		: "\323"	Oacute
  Ctrl<T> <O> <asciicircum>		: "\324"	Ocircumflex
+ Ctrl<T> <asciicircum> <O>		: "\324"	Ocircumflex
  Ctrl<T> <O> <greater>			: "\324"	Ocircumflex
+ Ctrl<T> <greater> <O>			: "\324"	Ocircumflex
  Ctrl<T> <O> <asciitilde>		: "\325"	Otilde
+ Ctrl<T> <asciitilde> <O>		: "\325"	Otilde
  Ctrl<T> <O> <minus>			: "\325"	Otilde
+ Ctrl<T> <minus> <O>			: "\325"	Otilde
  Ctrl<T> <O> <quotedbl>			: "\326"	Odiaeresis
+ Ctrl<T> <quotedbl> <O>			: "\326"	Odiaeresis
  Ctrl<T> <O> <slash>			: "\330"	Ooblique
+ Ctrl<T> <slash> <O>			: "\330"	Ooblique
  Ctrl<T> <o> <grave>			: "\362"	ograve
+ Ctrl<T> <grave> <o>			: "\362"	ograve
  Ctrl<T> <o> <acute>			: "\363"	oacute
+ Ctrl<T> <acute> <o>			: "\363"	oacute
  Ctrl<T> <o> <apostrophe>		: "\363"	oacute
+ Ctrl<T> <apostrophe> <o>		: "\363"	oacute
  Ctrl<T> <o> <asciicircum>		: "\364"	ocircumflex
+ Ctrl<T> <asciicircum> <o>		: "\364"	ocircumflex
  Ctrl<T> <o> <greater>			: "\364"	ocircumflex
+ Ctrl<T> <greater> <o>			: "\364"	ocircumflex
  Ctrl<T> <o> <asciitilde>		: "\365"	otilde
+ Ctrl<T> <asciitilde> <o>		: "\365"	otilde
  Ctrl<T> <o> <minus>			: "\365"	otilde
+ Ctrl<T> <minus> <o>			: "\365"	otilde
  Ctrl<T> <o> <quotedbl>			: "\366"	odiaeresis
! Ctrl<T> <quotedbl> <o>			: "\366"	odiaeresis
! Ctrl<T> <o> <slash>			: "\370"	oslash
! Ctrl<T> <slash> <o>			: "\370"	oslash
  Ctrl<T> <U> <grave>			: "\331"	Ugrave
+ Ctrl<T> <grave> <U>			: "\331"	Ugrave
  Ctrl<T> <U> <acute>			: "\332"	Uacute
+ Ctrl<T> <acute> <U>			: "\332"	Uacute
  Ctrl<T> <U> <apostrophe>		: "\332"	Uacute
+ Ctrl<T> <apostrophe> <U>		: "\332"	Uacute
  Ctrl<T> <U> <asciicircum>		: "\333"	Ucircumflex
+ Ctrl<T> <asciicircum> <U>		: "\333"	Ucircumflex
  Ctrl<T> <U> <greater>			: "\333"	Ucircumflex
+ Ctrl<T> <greater> <U>			: "\333"	Ucircumflex
  Ctrl<T> <U> <quotedbl>			: "\334"	Udiaeresis
+ Ctrl<T> <quotedbl> <U>			: "\334"	Udiaeresis
  Ctrl<T> <u> <grave>			: "\371"	ugrave
+ Ctrl<T> <grave> <u>			: "\371"	ugrave
  Ctrl<T> <u> <acute>			: "\372"	uacute
+ Ctrl<T> <acute> <u>			: "\372"	uacute
  Ctrl<T> <u> <apostrophe>		: "\372"	uacute
+ Ctrl<T> <apostrophe> <u>		: "\372"	uacute
  Ctrl<T> <u> <asciicircum>		: "\373"	ucircumflex
+ Ctrl<T> <asciicircum> <u>		: "\373"	ucircumflex
  Ctrl<T> <u> <greater>			: "\373"	ucircumflex
+ Ctrl<T> <greater> <u>			: "\373"	ucircumflex
  Ctrl<T> <u> <quotedbl>			: "\374"	udiaeresis
+ Ctrl<T> <quotedbl> <u>			: "\374"	udiaeresis
  Ctrl<T> <s> <s>				: "\337"	ssharp
  Ctrl<T> <T> <H>				: "\336"	THORN
  Ctrl<T> <t> <h>				: "\376"	thorn
  Ctrl<T> <Y> <acute>			: "\335"	Yacute
+ Ctrl<T> <acute> <Y>			: "\335"	Yacute
  Ctrl<T> <Y> <apostrophe>		: "\335"	Yacute
+ Ctrl<T> <apostrophe> <Y>		: "\335"	Yacute
  Ctrl<T> <y> <acute>			: "\375"	yacute
+ Ctrl<T> <acute> <y>			: "\375"	yacute
  Ctrl<T> <y> <apostrophe>		: "\375"	yacute
+ Ctrl<T> <apostrophe> <y>		: "\375"	yacute
  Ctrl<T> <y> <quotedbl>			: "\377"	ydiaeresis
+ Ctrl<T> <quotedbl> <y>			: "\377"	ydiaeresis
  # End of Sequence Definition
*** -	Fri Jul  7 09:33:49 1995
--- xc/nls/X11/locale/locale.alias	Fri Jul  7 09:33:48 1995
***************
*** 1,4 ****
! #	$XConsortium: locale.alias,v 1.9 94/08/23 18:12:18 kaleb Exp $
  #
  #	This file contains alias name of locale.
  #	Each alias name is described within one line.
--- 1,4 ----
! #	$XConsortium: locale.alias,v 1.11 95/06/07 19:09:09 kaleb Exp $
  #
  #	This file contains alias name of locale.
  #	Each alias name is described within one line.
***************
*** 16,23 ****
  ar_AA		ar_AA.ISO8859-6
  bg		bg_BG.ISO8859-5
  bg_BG		bg_BG.ISO8859-5
! cs		cs_CS.ISO8859-2
! cs_CS		cs_CS.ISO8859-2
  cz		cz_CZ.ISO8859-2
  cz_CZ		cz_CZ.ISO8859-2
  da		da_DK.ISO8859-1
--- 16,24 ----
  ar_AA		ar_AA.ISO8859-6
  bg		bg_BG.ISO8859-5
  bg_BG		bg_BG.ISO8859-5
! cs		cs_CZ.ISO8859-2
! cs_CS		cs_CZ.ISO8859-2
! cs_CS.ISO8859-2	cs_CZ.ISO8859-2
  cz		cz_CZ.ISO8859-2
  cz_CZ		cz_CZ.ISO8859-2
  da		da_DK.ISO8859-1
***************
*** 26,41 ****
  da_DK.88591.en	da_DK.ISO8859-1
  de		de_DE.ISO8859-1
  de_DE		de_DE.ISO8859-1
- De_DE		de_DE.ISO8859-1
- De_DE.IBM-850	de_DE.ISO8859-1
  de_DE.88591	de_DE.ISO8859-1
  de_DE.88591.en	de_DE.ISO8859-1
  GER_DE.8859	de_DE.ISO8859-1
  GER_DE.8859.in	de_DE.ISO8859-1
  de_AT		de_AT.ISO8859-1
  de_CH		de_CH.ISO8859-1
- Du_BE		du_BE.ISO8859-1
- Du_NL		du_NL.ISO8859-1
  el		el_GR.ISO8859-7
  el_GR		el_GR.ISO8859-7
  en		en_US.ISO8859-1
--- 27,38 ----
***************
*** 47,63 ****
  en_AU		en_AU.ISO8859-1
  en_CA		en_CA.ISO8859-1
  en_US		en_US.ISO8859-1
- En_US		en_US.ISO8859-1
  en_US.88591	en_US.ISO8859-1
  en_US.88591.en	en_US.ISO8859-1
- en_US.437	en_US.ISO8859-1
- en_US.646	en_US.ISO8859-1
- en_US.850	en_US.ISO8859-1
  es		es_ES.ISO8859-1
  es_ES		es_ES.ISO8859-1
- Es_ES		es_ES.ISO8859-1
- Sp_SP		es_ES.ISO8859-1
- Es_ES.IBM-850	es_ES.ISO8859-1
  es_ES.88591	es_ES.ISO8859-1
  es_ES.88591.en	es_ES.ISO8859-1
  fi		fi_FI.ISO8859-1
--- 44,53 ----
***************
*** 69,77 ****
  fr_BE.88591	fr_BE.ISO8859-1
  fr_BE.88591.en	fr_BE.ISO8859-1
  fr_CA		fr_CA.ISO8859-1
- Fr_CA		fr_CA.ISO8859-1
- Fr_CF		fr_CF.ISO8859-1
- Fr_CA.IBM-850	fr_CA.ISO8859-1
  fr_CA.88591	fr_CA.ISO8859-1
  fr_CA.88591.en	fr_CA.ISO8859-1
  fr_CH		fr_CH.ISO8859-1
--- 59,64 ----
***************
*** 82,88 ****
  fr_FR.88591.en	fr_FR.ISO8859-1
  FRE_FR.8859	fr_FR.ISO8859-1
  FRE_FR.8859.in	fr_FR.ISO8859-1
- Gr_GR		el_GR.ISO8859-7
  hr		hr_HR.ISO8859-2
  hr_HR		hr_HR.ISO8859-2
  hu		hu_HU.ISO8859-2
--- 69,74 ----
***************
*** 100,108 ****
  ja_JP		ja_JP.eucJP
  ja_JP.ujis	ja_JP.eucJP
  ja_JP.eucJP	ja_JP.eucJP
- Ja_JP		ja_JP.eucJP
  Jp_JP		ja_JP.eucJP
- Jp_JP.IBM-932	ja_JP.eucJP
  ja_JP.AJEC	ja_JP.eucJP
  ja_JP.EUC	ja_JP.eucJP
  ja_JP.ISO-2022-JP	ja_JP.JIS7
--- 86,92 ----
***************
*** 118,130 ****
  mk_MK		mk_MK.ISO8859-5
  nl		nl_NL.ISO8859-1
  nl_BE		nl_BE.ISO8859-1
- Nl_BE		nl_BE.ISO8859-1
- Nl_BE.IBM-850	nl_BE.ISO8859-1
  nl_BE.88591	nl_BE.ISO8859-1
  nl_BE.88591.en	nl_BE.ISO8859-1
  nl_NL		nl_NL.ISO8859-1
- Nl_NL		nl_NL.ISO8859-1
- Nl_NL.IBM-850	nl_NL.ISO8859-1
  nl_NL.88591	nl_NL.ISO8859-1
  nl_NL.88591.en	nl_NL.ISO8859-1
  no		no_NO.ISO8859-1
--- 102,110 ----
***************
*** 135,162 ****
  pl_PL		pl_PL.ISO8859-2
  pt		pt_PT.ISO8859-1
  pt_PT		pt_PT.ISO8859-1
- Pt_PT		pt_PT.ISO8859-1
- Po_PO		pt_PT.ISO8859-1
- Pt_PT.IBM-850	pt_PT.ISO8859-1
  pt_PT.88591	pt_PT.ISO8859-1
  pt_PT.88591.en	pt_PT.ISO8859-1
  ro		ro_RO.ISO8859-2
  ro_RO		ro_RO.ISO8859-2
! ru		ru_SU.ISO8859-5
! ru_SU		ru_SU.ISO8859-5
  sh		sh_YU.ISO8859-2
  sh_YU		sh_YU.ISO8859-2
  sk		sk_SK.ISO8859-2
  sk_SK		sk_SK.ISO8859-2
  sl		sl_CS.ISO8859-2
  sl_CS		sl_CS.ISO8859-2
  sp		sp_YU.ISO8859-5
  sp_YU		sp_YU.ISO8859-5
  sv		sv_SE.ISO8859-1
  sv_SE		sv_SE.ISO8859-1
- Sv_SE		sv_SE.ISO8859-1
- Sv_SV		sv_SE.ISO8859-1
- Sv_SE.IBM-850	sv_SE.ISO8859-1
  sv_SE.88591	sv_SE.ISO8859-1
  sv_SE.88591.en	sv_SE.ISO8859-1
  th_TH		th_TH.TACTIS
--- 115,141 ----
  pl_PL		pl_PL.ISO8859-2
  pt		pt_PT.ISO8859-1
  pt_PT		pt_PT.ISO8859-1
  pt_PT.88591	pt_PT.ISO8859-1
  pt_PT.88591.en	pt_PT.ISO8859-1
  ro		ro_RO.ISO8859-2
  ro_RO		ro_RO.ISO8859-2
! ru		ru_RU.ISO8859-5
! ru_RU		ru_RU.ISO8859-5
! ru_SU		ru_RU.ISO8859-5
! ru_SU.ISO8859-5	ru_RU.ISO8859-5
  sh		sh_YU.ISO8859-2
  sh_YU		sh_YU.ISO8859-2
+ sh_SP		sh_YU.ISO8859-2
  sk		sk_SK.ISO8859-2
  sk_SK		sk_SK.ISO8859-2
  sl		sl_CS.ISO8859-2
  sl_CS		sl_CS.ISO8859-2
+ sl_SI		sl_SI.ISO8859-2
  sp		sp_YU.ISO8859-5
  sp_YU		sp_YU.ISO8859-5
+ sr_SP		sr_SP.ISO8859-2
  sv		sv_SE.ISO8859-1
  sv_SE		sv_SE.ISO8859-1
  sv_SE.88591	sv_SE.ISO8859-1
  sv_SE.88591.en	sv_SE.ISO8859-1
  th_TH		th_TH.TACTIS
***************
*** 167,202 ****
  zh_CN.EUC	zh_CN.eucCN
  zh_TW		zh_TW.eucTW
  zh_TW.EUC	zh_TW.eucTW
! arabic		ar_AA.ISO8859-6
! bulgarian	bg_BG.ISO8859-5
! chinese-s	zh_CN.eucCN
! chinese-t	zh_TW.eucTW
! croatian	hr_HR.ISO8859-2
! czech		cs_CS.ISO8859-2
! danish		da_DK.ISO8859-1
! dutch		nl_BE.ISO8859-1
! finnish		fi_FI.ISO8859-1
! french		fr_CH.ISO8859-1
! german		de_CH.ISO8859-1
! greek		el_GR.ISO8859-7
! hebrew		iw_IL.ISO8859-8
! hungarian	hu_HU.ISO8859-2
! icelandic	is_IS.ISO8859-1
! iso_8859_1	en_US.ISO8859-1
! ISO8859-1	en_US.ISO8859-1
! italian		it_CH.ISO8859-1
! japan		ja_JP.eucJP
! japanese	ja_JP.eucJP
! Japanese-EUC	ja_JP.eucJP
! korean		ko_KR.eucKR
! norwegian	no_NO.ISO8859-1
! polish		pl_PL.ISO8859-2
! portuguese	pt_PT.ISO8859-1
! rumanian	ro_RO.ISO8859-2
! russian		ru_SU.ISO8859-5
! serbocroatian	sh_YU.ISO8859-2
! slovak		sk_SK.ISO8859-2
! slovene		sl_CS.ISO8859-2
! spanish		es_ES.ISO8859-1
! swedish		sv_SE.ISO8859-1
! turkish		tr_TR.ISO8859-9
--- 146,189 ----
  zh_CN.EUC	zh_CN.eucCN
  zh_TW		zh_TW.eucTW
  zh_TW.EUC	zh_TW.eucTW
! # The following locale names are used in HPUX 9.x
! american.iso88591	en_US.ISO8859-1
! arabic.iso88596		ar_AA.ISO8859-6
! bulgarian		bg_BG.ISO8859-5
! c-french.iso88591	fr_CA.ISO8859-1
! chinese-s		zh_CN.eucCN
! chinese-t		zh_TW.eucTW
! croatian		hr_HR.ISO8859-2
! czech			cs_CS.ISO8859-2
! danish.iso88591		da_DK.ISO8859-1
! dutch.iso88591		nl_BE.ISO8859-1
! english.iso88591	en_EN.ISO8859-1
! finnish.iso88591	fi_FI.ISO8859-1
! french.iso88591		fr_CH.ISO8859-1
! german.iso88591		de_CH.ISO8859-1
! greek.iso88597		el_GR.ISO8859-7
! hebrew.iso88598		iw_IL.ISO8859-8
! hungarian		hu_HU.ISO8859-2
! icelandic.iso88591	is_IS.ISO8859-1
! italian.iso88591	it_IT.ISO8859-1
! japanese/euc		ja_JP.eucJP
! korean			ko_KR.eucKR
! norwegian.iso88591	no_NO.ISO8859-1
! polish			pl_PL.ISO8859-2
! portuguese.iso88591	pt_PT.ISO8859-1
! rumanian		ro_RO.ISO8859-2
! russian			ru_SU.ISO8859-5
! serbocroatian		sh_YU.ISO8859-2
! slovak			sk_SK.ISO8859-2
! slovene			sl_CS.ISO8859-2
! spanish.iso88591	es_ES.ISO8859-1
! swedish.iso88591	sv_SE.ISO8859-1
! turkish.iso88599	tr_TR.ISO8859-9
! # Solaris allows "japanese" as well as "ja"
! japanese		ja_JP.eucJP
! # Solaris and SunOS have iso_8859_1 LC_CTYPES to augment LANG=C
! iso_8859_1		en_US.ISO8859-1
! # Other miscellaneous locale names
! ISO8859-1		en_US.ISO8859-1
! japan			ja_JP.eucJP
! Japanese-EUC		ja_JP.eucJP
*** -	Fri Jul  7 09:33:50 1995
--- xc/nls/X11/locale/locale.dir	Fri Jul  7 09:33:50 1995
***************
*** 1,4 ****
! #	$XConsortium: locale.dir,v 1.4 94/03/29 21:46:12 rws Exp $
  #
  #	This file contains locale database file name 
  #	The first word is the locale database file name and
--- 1,4 ----
! #	$XConsortium: locale.dir,v 1.5 95/06/07 18:46:34 kaleb Exp $
  #
  #	This file contains locale database file name 
  #	The first word is the locale database file name and
***************
*** 7,50 ****
  C/XLC_LOCALE	C
  iso8859-6/XLC_LOCALE	ar_AA.ISO8859-6
  iso8859-5/XLC_LOCALE	bg_BG.ISO8859-5
! iso8859-2/XLC_LOCALE	cs_CS.ISO8859-2
  iso8859-1/XLC_LOCALE	da_DK.ISO8859-1
- iso8859-1/XLC_LOCALE	de_DE.ISO8859-1
  iso8859-1/XLC_LOCALE	de_AT.ISO8859-1
  iso8859-1/XLC_LOCALE	de_CH.ISO8859-1
  iso8859-7/XLC_LOCALE 	el_GR.ISO8859-7
- iso8859-1/XLC_LOCALE	en_US.ISO8859-1
- iso8859-1/XLC_LOCALE	en_GB.ISO8859-1
  iso8859-1/XLC_LOCALE	en_AU.ISO8859-1
  iso8859-1/XLC_LOCALE	en_CA.ISO8859-1
  iso8859-1/XLC_LOCALE	es_ES.ISO8859-1
  iso8859-1/XLC_LOCALE	fi_FI.ISO8859-1
- iso8859-1/XLC_LOCALE	fr_FR.ISO8859-1
  iso8859-1/XLC_LOCALE	fr_BE.ISO8859-1
  iso8859-1/XLC_LOCALE	fr_CA.ISO8859-1
  iso8859-1/XLC_LOCALE	fr_CH.ISO8859-1
! iso8859-2/XLC_LOCALE	hr_HR.ISO8859-2
  iso8859-2/XLC_LOCALE	hu_HU.ISO8859-2
  iso8859-1/XLC_LOCALE	is_IS.ISO8859-1
- iso8859-1/XLC_LOCALE	it_IT.ISO8859-1
  iso8859-1/XLC_LOCALE	it_CH.ISO8859-1
  iso8859-8/XLC_LOCALE	iw_IL.ISO8859-8
  ja/XLC_LOCALE		ja_JP.eucJP
  ja.SJIS/XLC_LOCALE	ja_JP.SJIS
  ja.JIS/XLC_LOCALE	ja_JP.JIS7
  ko/XLC_LOCALE		ko_KR.eucKR
  ISO8859-5/XLC_LOCALE	mk_MK.ISO8859-5
- iso8859-1/XLC_LOCALE	nl_NL.ISO8859-1
  iso8859-1/XLC_LOCALE	nl_BE.ISO8859-1
  iso8859-1/XLC_LOCALE	no_NO.ISO8859-1
  iso8859-2/XLC_LOCALE 	pl_PL.ISO8859-2
  iso8859-1/XLC_LOCALE	pt_PT.ISO8859-1
  iso8859-2/XLC_LOCALE	ro_RO.ISO8859-2
! iso8859-5/XLC_LOCALE 	ru_SU.ISO8859-5
  iso8859-2/XLC_LOCALE 	sh_YU.ISO8859-2
  iso8859-2/XLC_LOCALE 	sk_SK.ISO8859-2
  iso8859-2/XLC_LOCALE 	sl_CS.ISO8859-2
  iso8859-5/XLC_LOCALE 	sp_YU.ISO8859-5
  iso8859-1/XLC_LOCALE	sv_SE.ISO8859-1
  iso8859-1/XLC_LOCALE	sv_SE.ISO8859-1
  th_TH/XLC_LOCALE	th_TH.TACTIS
--- 7,53 ----
  C/XLC_LOCALE	C
  iso8859-6/XLC_LOCALE	ar_AA.ISO8859-6
  iso8859-5/XLC_LOCALE	bg_BG.ISO8859-5
! iso8859-2/XLC_LOCALE	cs_CZ.ISO8859-2
! iso8859-2/XLC_LOCALE	cz_CZ.ISO8859-2
  iso8859-1/XLC_LOCALE	da_DK.ISO8859-1
  iso8859-1/XLC_LOCALE	de_AT.ISO8859-1
  iso8859-1/XLC_LOCALE	de_CH.ISO8859-1
+ iso8859-1/XLC_LOCALE	de_DE.ISO8859-1
  iso8859-7/XLC_LOCALE 	el_GR.ISO8859-7
  iso8859-1/XLC_LOCALE	en_AU.ISO8859-1
  iso8859-1/XLC_LOCALE	en_CA.ISO8859-1
+ iso8859-1/XLC_LOCALE	en_GB.ISO8859-1
+ iso8859-1/XLC_LOCALE	en_US.ISO8859-1
  iso8859-1/XLC_LOCALE	es_ES.ISO8859-1
  iso8859-1/XLC_LOCALE	fi_FI.ISO8859-1
  iso8859-1/XLC_LOCALE	fr_BE.ISO8859-1
  iso8859-1/XLC_LOCALE	fr_CA.ISO8859-1
  iso8859-1/XLC_LOCALE	fr_CH.ISO8859-1
! iso8859-1/XLC_LOCALE	fr_FR.ISO8859-1
  iso8859-2/XLC_LOCALE	hu_HU.ISO8859-2
+ iso8859-2/XLC_LOCALE	hr_HR.ISO8859-2
  iso8859-1/XLC_LOCALE	is_IS.ISO8859-1
  iso8859-1/XLC_LOCALE	it_CH.ISO8859-1
+ iso8859-1/XLC_LOCALE	it_IT.ISO8859-1
  iso8859-8/XLC_LOCALE	iw_IL.ISO8859-8
  ja/XLC_LOCALE		ja_JP.eucJP
  ja.SJIS/XLC_LOCALE	ja_JP.SJIS
  ja.JIS/XLC_LOCALE	ja_JP.JIS7
  ko/XLC_LOCALE		ko_KR.eucKR
  ISO8859-5/XLC_LOCALE	mk_MK.ISO8859-5
  iso8859-1/XLC_LOCALE	nl_BE.ISO8859-1
+ iso8859-1/XLC_LOCALE	nl_NL.ISO8859-1
  iso8859-1/XLC_LOCALE	no_NO.ISO8859-1
  iso8859-2/XLC_LOCALE 	pl_PL.ISO8859-2
  iso8859-1/XLC_LOCALE	pt_PT.ISO8859-1
  iso8859-2/XLC_LOCALE	ro_RO.ISO8859-2
! iso8859-5/XLC_LOCALE 	ru_RU.ISO8859-5
  iso8859-2/XLC_LOCALE 	sh_YU.ISO8859-2
  iso8859-2/XLC_LOCALE 	sk_SK.ISO8859-2
  iso8859-2/XLC_LOCALE 	sl_CS.ISO8859-2
+ iso8859-2/XLC_LOCALE 	sl_SI.ISO8859-2
  iso8859-5/XLC_LOCALE 	sp_YU.ISO8859-5
+ iso8859-2/XLC_LOCALE	sr_SP.ISO8859-2
  iso8859-1/XLC_LOCALE	sv_SE.ISO8859-1
  iso8859-1/XLC_LOCALE	sv_SE.ISO8859-1
  th_TH/XLC_LOCALE	th_TH.TACTIS
*** -	Fri Jul  7 09:33:51 1995
--- xc/workInProgress/Imakefile	Fri Jul  7 09:33:51 1995
***************
*** 1,11 ****
! XCOMM $XConsortium: Imakefile,v 1.3 94/12/19 22:28:19 mor Exp $
  
  #define IHaveSubdirs
  #define PassCDebugFlags CDEBUGFLAGS="$(CDEBUGFLAGS)"
- 
- #if BuildFresco
- FRESCODIRS = Fresco Xtf
- #endif
  
  #if BuildLBX
  LBXDIRS = lbx
--- 1,7 ----
! XCOMM $XConsortium: Imakefile,v 1.4 95/05/23 21:38:31 matt Exp $
  
  #define IHaveSubdirs
  #define PassCDebugFlags CDEBUGFLAGS="$(CDEBUGFLAGS)"
  
  #if BuildLBX
  LBXDIRS = lbx
*** -	Fri Jul  7 09:33:52 1995
--- xc/workInProgress/xsm/xsm.c	Fri Jul  7 09:33:52 1995
***************
*** 1,4 ****
! /* $XConsortium: xsm.c,v 1.75 95/01/03 17:23:56 mor Exp $ */
  /******************************************************************************
  
  Copyright (c) 1993  X Consortium
--- 1,4 ----
! /* $XConsortium: xsm.c,v 1.76 95/05/24 20:43:29 mor Exp $ */
  /******************************************************************************
  
  Copyright (c) 1993  X Consortium
***************
*** 74,80 ****
  Status StartSession ();
  void NewConnectionXtProc ();
  Status NewClientProc ();
! void IoErrorHandler ();
  
  /*
   * Extern declarations
--- 74,80 ----
  Status StartSession ();
  void NewConnectionXtProc ();
  Status NewClientProc ();
! void InstallIOErrorHandler ();
  
  /*
   * Extern declarations
***************
*** 153,162 ****
  
  
      /*
!      * Set my own IO error handler.
       */
  
!     IceSetIOErrorHandler (IoErrorHandler);
  
  
      /*
--- 153,163 ----
  
  
      /*
!      * Install an IO error handler.  For an explanation,
!      * see the comments for InstallIOErrorHandler().
       */
  
!     InstallIOErrorHandler ();
  
  
      /*
***************
*** 1033,1039 ****
  
  
  
! static void
  CloseDownClient (client)
  
  ClientRec *client;
--- 1034,1040 ----
  
  
  
! void
  CloseDownClient (client)
  
  ClientRec *client;
***************
*** 1353,1406 ****
  
  
  /*
!  * Install IO error handler.  This will detect clients that break their
!  * connection with the SM unexpectidly.
   */
  
  void
! IoErrorHandler (ice_conn)
  
! IceConn 	ice_conn;
  
  {
!     List *cl;
!     int found = 0;
! 
!     if (verbose)
!     {
! 	printf ("IO error on connection (fd = %d)\n",
! 	    IceConnectionNumber (ice_conn));
! 	printf ("\n");
!     }
! 
!     for (cl = ListFirst (RunningList); cl; cl = ListNext (cl))
!     {
! 	ClientRec *client = (ClientRec *) cl->thing;
! 
! 	if (client->ice_conn == ice_conn)
! 	{
! 	    CloseDownClient (client);
! 	    found = 1;
! 	    break;
! 	}
!     }
! 	 
!     if (!found)
!     {
! 	/*
! 	 * The client must have disconnected before it was added
! 	 * to the session manager's running list (i.e. before the
! 	 * NewClientProc callback was invoked).
! 	 */
! 
! 	IceSetShutdownNegotiation (ice_conn, False);
! 	IceCloseConnection (ice_conn);
!     }
  
  
!     /*
!      * We can't return.  Must do a long jump.
!      */
  
!     longjmp (JumpHere, 1);
! }    
--- 1354,1396 ----
  
  
  /*
!  * The real way to handle IO errors is to check the return status
!  * of IceProcessMessages.  xsm properly does this.
!  *
!  * Unfortunately, a design flaw exists in the ICE library in which
!  * a default IO error handler is invoked if no IO error handler is
!  * installed.  This default handler exits.  We must avoid this.
!  *
!  * To get around this problem, we install an IO error handler that
!  * does a little magic.  Since a previous IO handler might have been
!  * installed, when we install our IO error handler, we do a little
!  * trick to get both the previous IO error handler and the default
!  * IO error handler.  When our IO error handler is called, if the
!  * previous handler is not the default handler, we call it.  This
!  * way, everyone's IO error handler gets called except the stupid
!  * default one which does an exit!
   */
  
+ static IceIOErrorHandler prev_handler;
+ 
  void
! MyIoErrorHandler (ice_conn)
  
! IceConn ice_conn;
  
  {
!     if (prev_handler)
! 	(*prev_handler) (ice_conn);
! }    
  
+ void
+ InstallIOErrorHandler ()
  
! {
!     IceIOErrorHandler default_handler;
  
!     prev_handler = IceSetIOErrorHandler (NULL);
!     default_handler = IceSetIOErrorHandler (MyIoErrorHandler);
!     if (prev_handler == default_handler)
! 	prev_handler = NULL;
! }
*** -	Fri Jul  7 09:33:53 1995
--- xc/workInProgress/xsm/xtwatch.c	Fri Jul  7 09:33:53 1995
***************
*** 1,4 ****
! /* $XConsortium: xtwatch.c,v 1.7 94/04/17 21:15:22 mor Exp $ */
  /******************************************************************************
  
  Copyright (c) 1993  X Consortium
--- 1,4 ----
! /* $XConsortium: xtwatch.c,v 1.8 95/05/24 20:43:29 mor Exp $ */
  /******************************************************************************
  
  Copyright (c) 1993  X Consortium
***************
*** 27,34 ****
--- 27,38 ----
  
  #include <X11/ICE/ICElib.h>
  #include <X11/Intrinsic.h>
+ #include "xsm.h"
  
+ extern void CloseDownClient ();
  
+ 
+ 
  Status
  InitWatchProcs (appContext)
  
***************
*** 77,83 ****
  XtInputId	*id;
  
  {
!     IceConn	ice_conn = (IceConn) client_data;
  
!     IceProcessMessages (ice_conn, NULL, NULL);
  }
--- 81,125 ----
  XtInputId	*id;
  
  {
!     IceConn			ice_conn = (IceConn) client_data;
!     IceProcessMessagesStatus	status;
! 
!     status = IceProcessMessages (ice_conn, NULL, NULL);
  
!     if (status == IceProcessMessagesIOError)
!     {
! 	List *cl;
! 	int found = 0;
! 
! 	if (verbose)
! 	{
! 	    printf ("IO error on connection (fd = %d)\n",
! 	        IceConnectionNumber (ice_conn));
! 	    printf ("\n");
! 	}
! 
! 	for (cl = ListFirst (RunningList); cl; cl = ListNext (cl))
! 	{
! 	    ClientRec *client = (ClientRec *) cl->thing;
! 
! 	    if (client->ice_conn == ice_conn)
! 	    {
! 		CloseDownClient (client);
! 		found = 1;
! 		break;
! 	    }
! 	}
! 	 
! 	if (!found)
! 	{
! 	    /*
! 	     * The client must have disconnected before it was added
! 	     * to the session manager's running list (i.e. before the
! 	     * NewClientProc callback was invoked).
! 	     */
! 
! 	    IceSetShutdownNegotiation (ice_conn, False);
! 	    IceCloseConnection (ice_conn);
! 	}
!     }
  }
*** -	Fri Jul  7 09:33:54 1995
--- xc/workInProgress/xsm/save.c	Fri Jul  7 09:33:54 1995
***************
*** 1,4 ****
! /* $XConsortium: save.c,v 1.19 94/12/30 16:51:59 mor Exp $ */
  /******************************************************************************
  
  Copyright (c) 1993  X Consortium
--- 1,4 ----
! /* $XConsortium: save.c,v 1.20 95/01/26 19:38:10 mor Exp $ */
  /******************************************************************************
  
  Copyright (c) 1993  X Consortium
***************
*** 871,877 ****
  {
      static int first_time = 1;
  
!     if (!help_visible)
      {
  	PopupPopup (savePopup, helpPopup,
  	    True, first_time, 50, 50, "DelSaveHelpWinAction()");
--- 871,883 ----
  {
      static int first_time = 1;
  
!     if (help_visible)
!     {
! 	/* Make sure it is visible */
! 
! 	XMapRaised (XtDisplay (topLevel), XtWindow (helpPopup));
!     }
!     else
      {
  	PopupPopup (savePopup, helpPopup,
  	    True, first_time, 50, 50, "DelSaveHelpWinAction()");
*** -	Fri Jul  7 09:33:55 1995
--- xc/workInProgress/xsm/XSm.ad	Fri Jul  7 09:33:55 1995
***************
*** 1,14 ****
! ! $XConsortium: XSm.ad,v 1.26 94/12/30 16:14:48 mor Exp $
  *chooseSessionPopup*font:		12x24
  *chooseSessionLabel.label:		Session Menu
! *chooseSessionMessageLabel.label:	Press button again to confirm...
  *chooseSessionLoadButton.label:		Load Session
  *chooseSessionDeleteButton.label:	Delete Session
  *chooseSessionFailSafeButton.label:	Default/Fail Safe
  *chooseSessionCancelButton.label:	Cancel
! 
  *chooseSessionLoadButton.background:	light steel blue
  *chooseSessionDeleteButton.background:	light steel blue
  *chooseSessionFailSafeButton.background:light steel blue
  *chooseSessionCancelButton.background:	light steel blue
  
--- 1,16 ----
! ! $XConsortium: XSm.ad,v 1.28 95/05/24 20:43:29 mor Exp $
  *chooseSessionPopup*font:		12x24
  *chooseSessionLabel.label:		Session Menu
! *chooseSessionMessageLabel.label:	Press button again to confirm, or hit Cancel...
  *chooseSessionLoadButton.label:		Load Session
  *chooseSessionDeleteButton.label:	Delete Session
  *chooseSessionFailSafeButton.label:	Default/Fail Safe
  *chooseSessionCancelButton.label:	Cancel
! *chooseSessionBreakLockButton.label:	Break Lock
  *chooseSessionLoadButton.background:	light steel blue
  *chooseSessionDeleteButton.background:	light steel blue
+ *chooseSessionBreakLockButton.background: light steel blue
+ 
  *chooseSessionFailSafeButton.background:light steel blue
  *chooseSessionCancelButton.background:	light steel blue
  
***************
*** 20,25 ****
--- 22,28 ----
  *shutdownDontSave.label:	Immediately
  
  *logPopup.title:		Session Log
+ *logPopup.iconName:		Session Log
  *logOkButton.label:		OK
  *logText.width:			600
  *logText.height:		300
***************
*** 92,103 ****
  
  *chooseSessionListWidget.Translations: #override\n\
  	<Key>Up:	ChooseSessionUp()\n\
  	<Key>Down:	ChooseSessionDown()\n\
  	<Btn1Down>:	Set() ChooseSessionBtn1Down()\n
  
  *chooseSessionLoadButton.Accelerators: #override\n\
  	<Btn1Down>(2+):	set() notify() unset()\n\
! 	<Key>Return:	set() notify() unset()\n
  
  *checkPointButton.Translations: #override\n\
  	<Btn1Up>:	notify() reset()\n
--- 95,111 ----
  
  *chooseSessionListWidget.Translations: #override\n\
  	<Key>Up:	ChooseSessionUp()\n\
+ 	<Key>KP_Up:	ChooseSessionUp()\n\
+ 	Ctrl<Key>P:	ChooseSessionUp()\n\
  	<Key>Down:	ChooseSessionDown()\n\
+ 	<Key>KP_Down:	ChooseSessionDown()\n\
+ 	Ctrl<Key>N:	ChooseSessionDown()\n\
  	<Btn1Down>:	Set() ChooseSessionBtn1Down()\n
  
  *chooseSessionLoadButton.Accelerators: #override\n\
  	<Btn1Down>(2+):	set() notify() unset()\n\
! 	<Key>Return:	set() notify() unset()\n\
! 	<Key>KP_Enter:	set() notify() unset()\n
  
  *checkPointButton.Translations: #override\n\
  	<Btn1Up>:	notify() reset()\n
*** -	Fri Jul  7 09:33:56 1995
--- xc/workInProgress/xsm/log.c	Fri Jul  7 09:33:56 1995
***************
*** 1,4 ****
! /* $XConsortium: log.c,v 1.3 94/12/27 17:44:30 mor Exp $ */
  /******************************************************************************
  
  Copyright (c) 1994  X Consortium
--- 1,4 ----
! /* $XConsortium: log.c,v 1.4 95/01/26 19:38:24 mor Exp $ */
  /******************************************************************************
  
  Copyright (c) 1994  X Consortium
***************
*** 51,57 ****
  {
      static int first_time = 1;
  
!     if (!client_log_visible)
      {
  	PopupPopup (mainWindow, logPopup,
  	    False, first_time, 50, 50, "DelLogWinAction()");
--- 51,63 ----
  {
      static int first_time = 1;
  
!     if (client_log_visible)
!     {
! 	/* Make sure it is visible */
! 
! 	XMapRaised (XtDisplay (topLevel), XtWindow (logPopup));
!     }
!     else
      {
  	PopupPopup (mainWindow, logPopup,
  	    False, first_time, 50, 50, "DelLogWinAction()");
*** -	Fri Jul  7 09:33:57 1995
--- xc/workInProgress/xsm/choose.c	Fri Jul  7 09:33:57 1995
***************
*** 1,4 ****
! /* $XConsortium: choose.c,v 1.22 94/12/30 15:50:31 mor Exp $ */
  /******************************************************************************
  
  Copyright (c) 1993  X Consortium
--- 1,4 ----
! /* $XConsortium: choose.c,v 1.24 95/05/24 20:43:29 mor Exp $ */
  /******************************************************************************
  
  Copyright (c) 1993  X Consortium
***************
*** 55,61 ****
  static Pixel save_message_foreground;
  static Pixel save_message_background;
  
! static int delete_phase = 0;
  
  Widget chooseSessionPopup;
  Widget chooseSessionForm;
--- 55,62 ----
  static Pixel save_message_foreground;
  static Pixel save_message_background;
  
! static int delete_session_phase = 0;
! static int break_lock_phase = 0;
  
  Widget chooseSessionPopup;
  Widget chooseSessionForm;
***************
*** 64,72 ****
  Widget chooseSessionMessageLabel;
  Widget chooseSessionLoadButton;
  Widget chooseSessionDeleteButton;
! #if 0
! Widget chooseSessionForceShutdownButton;
! #endif
  Widget chooseSessionFailSafeButton;
  Widget chooseSessionCancelButton;
  
--- 65,71 ----
  Widget chooseSessionMessageLabel;
  Widget chooseSessionLoadButton;
  Widget chooseSessionDeleteButton;
! Widget chooseSessionBreakLockButton;
  Widget chooseSessionFailSafeButton;
  Widget chooseSessionCancelButton;
  
***************
*** 210,225 ****
  Bool highlight;
  
  {
!     Bool locked = sessionsLocked[number];
  
!     if (highlight)
! 	XawListHighlight (chooseSessionListWidget, number);
  
!     XtSetSensitive (chooseSessionLoadButton, !locked);
!     XtSetSensitive (chooseSessionDeleteButton, !locked);
! #if 0
!     XtSetSensitive (chooseSessionForceShutdownButton, locked);
! #endif
  }
  
  
--- 209,231 ----
  Bool highlight;
  
  {
!     if (number >= 0)
!     {
! 	Bool locked = sessionsLocked[number];
  
! 	if (highlight)
! 	    XawListHighlight (chooseSessionListWidget, number);
  
! 	XtSetSensitive (chooseSessionLoadButton, !locked);
! 	XtSetSensitive (chooseSessionDeleteButton, !locked);
! 	XtSetSensitive (chooseSessionBreakLockButton, locked);
!     }
!     else
!     {
! 	XtSetSensitive (chooseSessionLoadButton, False);
! 	XtSetSensitive (chooseSessionDeleteButton, False);
! 	XtSetSensitive (chooseSessionBreakLockButton, False);
!     }
  }
  
  
***************
*** 231,238 ****
  String *names;
  
  {
      XawListChange (chooseSessionListWidget, names, count, 0, True);
!     SessionSelected (0, True);
  }
  
  
--- 237,255 ----
  String *names;
  
  {
+     int i;
+ 
      XawListChange (chooseSessionListWidget, names, count, 0, True);
! 
!     /*
!      * Highlight the first unlocked session, if any.
!      */
! 
!     for (i = 0; i < sessionNameCount; i++)
! 	if (!sessionsLocked[i])
! 	    break;
! 
!     SessionSelected (i < sessionNameCount ? i : -1, True);
  }
  
  
***************
*** 332,337 ****
--- 349,385 ----
  
  
  static void
+ CheckDeleteCancel ()
+ 
+ {
+     if (delete_session_phase > 0)
+     {
+ 	XtVaSetValues (chooseSessionMessageLabel,
+ 	    XtNforeground, save_message_background,
+             NULL);
+ 
+ 	delete_session_phase = 0;
+     }
+ }
+ 
+ 
+ static void
+ CheckBreakLockCancel ()
+ 
+ {
+     if (break_lock_phase > 0)
+     {
+ 	XtVaSetValues (chooseSessionMessageLabel,
+ 	    XtNforeground, save_message_background,
+             NULL);
+ 
+ 	break_lock_phase = 0;
+     }
+ }
+ 
+ 
+ 
+ static void
  ChooseSessionUp (w, event, params, numParams)
  
  Widget w;
***************
*** 342,347 ****
--- 390,398 ----
  {
      XawListReturnStruct *current;
      
+     CheckDeleteCancel ();
+     CheckBreakLockCancel ();
+ 
      current = XawListShowCurrent (chooseSessionListWidget);
      if (current->list_index > 0)
  	SessionSelected (current->list_index - 1, True);
***************
*** 360,365 ****
--- 411,419 ----
  {
      XawListReturnStruct *current;
      
+     CheckDeleteCancel ();
+     CheckBreakLockCancel ();
+ 
      current = XawListShowCurrent (chooseSessionListWidget);
      if (current->list_index < sessionNameCount - 1)
  	SessionSelected (current->list_index + 1, True);
***************
*** 379,384 ****
--- 433,441 ----
  {
      XawListReturnStruct *current;
  
+     CheckDeleteCancel ();
+     CheckBreakLockCancel ();
+ 
      current = XawListShowCurrent (chooseSessionListWidget);
      SessionSelected (current->list_index, False /* already highlighted */);
      XtFree ((char *) current);
***************
*** 396,401 ****
--- 453,461 ----
  {
      XawListReturnStruct *current;
  
+     CheckDeleteCancel ();
+     CheckBreakLockCancel ();
+ 
      current = XawListShowCurrent (chooseSessionListWidget);
  
      if (!current || !current->string || *(current->string) == '\0')
***************
*** 445,450 ****
--- 505,512 ----
      int longest;
      char *name;
  
+     CheckBreakLockCancel ();
+ 
      current = XawListShowCurrent (chooseSessionListWidget);
  
      if (!current || !(name = current->string) || *name == '\0')
***************
*** 455,463 ****
  	return;
      }
  
!     delete_phase++;
  
!     if (delete_phase == 1)
      {
  	XtVaSetValues (chooseSessionMessageLabel,
  	    XtNforeground, save_message_foreground,
--- 517,525 ----
  	return;
      }
  
!     delete_session_phase++;
  
!     if (delete_session_phase == 1)
      {
  	XtVaSetValues (chooseSessionMessageLabel,
  	    XtNforeground, save_message_foreground,
***************
*** 509,518 ****
  
  		XawListChange (chooseSessionListWidget,
  		    sessionNamesLong, sessionNameCount, longest, True);
  	    }
  	}
  
! 	delete_phase = 0;
      }
  
      XtFree ((char *) current);
--- 571,582 ----
  
  		XawListChange (chooseSessionListWidget,
  		    sessionNamesLong, sessionNameCount, longest, True);
+ 
+ 		SessionSelected (-1, False);
  	    }
  	}
  
! 	delete_session_phase = 0;
      }
  
      XtFree ((char *) current);
***************
*** 520,537 ****
  
  
  
- #if 0
  static void
! ChooseSessionForceShutdownXtProc (w, client_data, callData)
  
  Widget		w;
  XtPointer 	client_data;
  XtPointer 	callData;
  
  {
!     XBell (XtDisplay (topLevel), 0);
  }
- #endif
  
  
  
--- 584,656 ----
  
  
  
  static void
! ChooseSessionBreakLockXtProc (w, client_data, callData)
  
  Widget		w;
  XtPointer 	client_data;
  XtPointer 	callData;
  
  {
!     XawListReturnStruct *current;
!     char *name;
! 
!     CheckDeleteCancel ();
! 
!     current = XawListShowCurrent (chooseSessionListWidget);
! 
!     if (!current || !(name = current->string) || *name == '\0')
!     {
! 	if (current)
! 	    XtFree ((char *) current);
! 	XBell (XtDisplay (topLevel), 0);
! 	return;
!     }
! 
!     break_lock_phase++;
! 
!     if (break_lock_phase == 1)
!     {
! 	XtVaSetValues (chooseSessionMessageLabel,
! 	    XtNforeground, save_message_foreground,
!             NULL);
! 
! 	XBell (XtDisplay (topLevel), 0);
!     }
!     else
!     {
! 	char *id;
! 	int longest;
! 
! 	XtVaSetValues (chooseSessionMessageLabel,
! 	    XtNforeground, save_message_background,
!             NULL);
! 
! 	name = sessionNamesShort[current->list_index];
! 
! 	id = GetLockId (name);
! 
! 	UnlockSession (name);
! 
! 	sessionsLocked[current->list_index] = False;
! 	XtFree ((char *) sessionNamesLong[current->list_index]);
! 	sessionNamesLong[current->list_index] =
! 	    sessionNamesShort[current->list_index];
! 
! 	XtVaGetValues (chooseSessionListWidget,
! 	    XtNlongest, &longest,
! 	    NULL);
! 
! 	XawListChange (chooseSessionListWidget,
! 	    sessionNamesLong, sessionNameCount, longest, True);
! 
! 	SessionSelected (current->list_index, True);
! 
! 	break_lock_phase = 0;
!     }
! 
!     XtFree ((char *) current);
  }
  
  
  
***************
*** 547,552 ****
--- 666,674 ----
       * Pop down choice of sessions, and start the fail safe session.
       */
  
+     CheckDeleteCancel ();
+     CheckBreakLockCancel ();
+ 
      XtPopdown (chooseSessionPopup);
  
      if (session_name)
***************
*** 579,591 ****
  XtPointer 	callData;
  
  {
!     if (delete_phase > 0)
      {
  	XtVaSetValues (chooseSessionMessageLabel,
  	    XtNforeground, save_message_background,
              NULL);
  
! 	delete_phase = 0;
      }
      else
  	EndSession (2);
--- 701,714 ----
  XtPointer 	callData;
  
  {
!     if (delete_session_phase > 0 || break_lock_phase > 0)
      {
  	XtVaSetValues (chooseSessionMessageLabel,
  	    XtNforeground, save_message_background,
              NULL);
  
! 	delete_session_phase = 0;
! 	break_lock_phase = 0;
      }
      else
  	EndSession (2);
***************
*** 664,684 ****
      XtAddCallback (chooseSessionDeleteButton, XtNcallback,
  	ChooseSessionDeleteXtProc, 0);
  
! #if 0
!     chooseSessionForceShutdownButton = XtVaCreateManagedWidget (
! 	"chooseSessionForceShutdownButton",
  	commandWidgetClass, chooseSessionForm,
          XtNfromHoriz, chooseSessionDeleteButton,
          XtNfromVert, chooseSessionMessageLabel,
          NULL);
  
!     XtAddCallback (chooseSessionForceShutdownButton, XtNcallback,
! 	ChooseSessionForceShutdownXtProc, 0);
! #endif
  
      chooseSessionFailSafeButton = XtVaCreateManagedWidget (
  	"chooseSessionFailSafeButton", commandWidgetClass, chooseSessionForm,
!         XtNfromHoriz, chooseSessionDeleteButton,
          XtNfromVert, chooseSessionMessageLabel,
          NULL);
  
--- 787,805 ----
      XtAddCallback (chooseSessionDeleteButton, XtNcallback,
  	ChooseSessionDeleteXtProc, 0);
  
!     chooseSessionBreakLockButton = XtVaCreateManagedWidget (
! 	"chooseSessionBreakLockButton",
  	commandWidgetClass, chooseSessionForm,
          XtNfromHoriz, chooseSessionDeleteButton,
          XtNfromVert, chooseSessionMessageLabel,
          NULL);
  
!     XtAddCallback (chooseSessionBreakLockButton, XtNcallback,
! 	ChooseSessionBreakLockXtProc, 0);
  
      chooseSessionFailSafeButton = XtVaCreateManagedWidget (
  	"chooseSessionFailSafeButton", commandWidgetClass, chooseSessionForm,
!         XtNfromHoriz, chooseSessionBreakLockButton,
          XtNfromVert, chooseSessionMessageLabel,
          NULL);
  
*** -	Fri Jul  7 09:33:58 1995
--- xc/workInProgress/xsm/info.c	Fri Jul  7 09:33:58 1995
***************
*** 1,4 ****
! /* $XConsortium: info.c,v 1.25 95/01/03 18:35:35 mor Exp $ */
  /******************************************************************************
  
  Copyright (c) 1993  X Consortium
--- 1,4 ----
! /* $XConsortium: info.c,v 1.26 95/01/26 19:37:24 mor Exp $ */
  /******************************************************************************
  
  Copyright (c) 1993  X Consortium
***************
*** 241,247 ****
  	    XtNiconName, buffer.bufStart,
  	    NULL);
  
! 	if (!client_prop_visible)
  	{
  	    PopupPopup (mainWindow, clientPropPopup,
  		False, first_time, 50, 150, "DelPropWinAction()");
--- 241,253 ----
  	    XtNiconName, buffer.bufStart,
  	    NULL);
  
! 	if (client_prop_visible)
! 	{
! 	    /* Make sure it is visible */
! 
! 	    XMapRaised (XtDisplay (topLevel), XtWindow (clientPropPopup));
! 	}
! 	else
  	{
  	    PopupPopup (mainWindow, clientPropPopup,
  		False, first_time, 50, 150, "DelPropWinAction()");
***************
*** 739,745 ****
  {
      static int first_time = 1;
  
!     if (!client_info_visible)
      {
  	UpdateClientList ();
  
--- 745,757 ----
  {
      static int first_time = 1;
  
!     if (client_info_visible)
!     {
! 	/* Make sure it is visible */
! 
! 	XMapRaised (XtDisplay (topLevel), XtWindow (clientInfoPopup));
!     }
!     else
      {
  	UpdateClientList ();
  
*** -	Fri Jul  7 09:33:58 1995
--- xc/workInProgress/xsm/lock.c	Fri Jul  7 09:33:58 1995
***************
*** 1,4 ****
! /* $XConsortium: lock.c,v 1.4 94/12/16 17:32:57 mor Exp $ */
  /******************************************************************************
  
  Copyright (c) 1994  X Consortium
--- 1,4 ----
! /* $XConsortium: lock.c,v 1.5 95/05/24 20:43:29 mor Exp $ */
  /******************************************************************************
  
  Copyright (c) 1994  X Consortium
***************
*** 68,74 ****
  	return (0);
  
      if (write_id &&
!         write (fd, networkIds, strlen (networkIds)) != strlen (networkIds))
      {
  	close (fd);
  	return (0);
--- 68,75 ----
  	return (0);
  
      if (write_id &&
!         (write (fd, networkIds, strlen (networkIds)) != strlen (networkIds)) ||
! 	(write (fd, "\n", 1) != 1))
      {
  	close (fd);
  	return (0);
***************
*** 105,110 ****
--- 106,142 ----
  }
  
  
+ char *
+ GetLockId (session_name)
+ 
+ char *session_name;
+ 
+ {
+     char *path;
+     FILE *fp;
+     char lock_file[PATH_MAX];
+     char buf[256];
+     char *ret;
+ 
+     path = GetPath ();
+ 
+     sprintf (lock_file, "%s/.XSMlock-%s", path, session_name);
+ 
+     if ((fp = fopen (lock_file, "r")) == NULL)
+     {
+ 	return (NULL);
+     }
+ 
+     buf[0] = '\0';
+     fscanf (fp, "%s\n", buf);
+     ret = XtNewString (buf);
+ 
+     fclose (fp);
+ 
+     return (ret);
+ }
+ 
+ 
  Bool
  CheckSessionLocked (session_name, get_id, id_ret)
  
***************
*** 114,141 ****
  
  {
      if (get_id)
!     {
! 	char *path;
! 	FILE *fp;
! 	char lock_file[PATH_MAX];
! 	char buf[256];
! 
! 	path = GetPath ();
! 
! 	sprintf (lock_file, "%s/.XSMlock-%s", path, session_name);
! 
! 	if ((fp = fopen (lock_file, "r")) == NULL)
! 	{
! 	    *id_ret = NULL;
! 	    return (0);
! 	}
! 
! 	buf[0] = '\0';
! 	fscanf (fp, "%s\n", buf);
! 	*id_ret = XtNewString (buf);
! 
! 	fclose (fp);
!     }
  
      if (!LockSession (session_name, False))
  	return (1);
--- 146,152 ----
  
  {
      if (get_id)
! 	*id_ret = GetLockId (session_name);
  
      if (!LockSession (session_name, False))
  	return (1);
*** -	Fri Jul  7 09:33:59 1995
--- xc/workInProgress/xsm/lock.h	Fri Jul  7 09:33:59 1995
***************
*** 1,4 ****
! /* $XConsortium: lock.h,v 1.1 94/12/06 14:44:18 mor Exp $ */
  /******************************************************************************
  
  Copyright (c) 1994  X Consortium
--- 1,4 ----
! /* $XConsortium: lock.h,v 1.2 95/05/24 20:43:29 mor Exp $ */
  /******************************************************************************
  
  Copyright (c) 1994  X Consortium
***************
*** 27,31 ****
--- 27,32 ----
  
  extern Status LockSession ();
  extern void UnlockSession ();
+ extern char *GetLockId ();
  extern Bool CheckSessionLocked ();
  extern void UnableToLockSession ();
*** /dev/null	Fri Jul  7 09:34:00 1995
--- xc/workInProgress/Fresco/README	Fri Jul  7 09:34:00 1995
***************
*** 0 ****
--- 1,24 ----
+ $XConsortium: README,v 1.2 95/07/06 14:26:06 kaleb Exp $
+ 
+ The version of Fresco included here is obsolete.  Do not try to build
+ this version of Fresco.
+ 
+ Fresco has moved to a standalone distribution model decoupled from X11 
+ releases to provide more flexibility in how, when, and to whom releases 
+ are made available.
+ 
+ The latest Fresco sources and documentation are available at:
+ 
+ 	http://www.faslab.com/fresco/HomePage.html
+ 	 ftp://ftp.faslab.com/pub/Fresco/
+ 
+ The Fresco mailing list is open to public participation.  
+ 
+ To subscribe to the mailing list, send a message to "requests@x.org" 
+ containing the text "subscribe fresco <address>", where <address> is 
+ optional and defaults to you From: address.
+ 
+ To post to the mailing list, send your posting to "fresco@x.org"
+ 
+     The X Consortium Staff
+     23 May 1995
*** /dev/null	Fri Jul  7 09:34:01 1995
--- xc/workInProgress/Xtf/README	Fri Jul  7 09:34:01 1995
***************
*** 0 ****
--- 1,24 ----
+ $XConsortium: README,v 1.2 95/07/06 14:27:11 kaleb Exp $
+ 
+ The version of Fresco included here is obsolete.  Do not try to build
+ this version of Fresco.
+ 
+ Fresco has moved to a standalone distribution model decoupled from X11 
+ releases to provide more flexibility in how, when, and to whom releases 
+ are made available.
+ 
+ The latest Fresco sources and documentation are available at:
+ 
+ 	http://www.faslab.com/fresco/HomePage.html
+ 	 ftp://ftp.faslab.com/pub/Fresco/
+ 
+ The Fresco mailing list is open to public participation.  
+ 
+ To subscribe to the mailing list, send a message to "requests@x.org" 
+ containing the text "subscribe fresco <address>", where <address> is 
+ optional and defaults to you From: address.
+ 
+ To post to the mailing list, send your posting to "fresco@x.org"
+ 
+     The X Consortium Staff
+     23 May 1995
*** -	Thu May 11 14:12:26 1995
--- xc/workInProgress/lbx/include/extensions/XLbx.h	Thu May 11 14:12:26 1995
***************
*** 1,4 ****
! /* $XConsortium: XLbx.h,v 1.9 94/12/02 02:28:59 mor Exp $ */
  /*
   * $NCDId: @(#)XLbx.h,v 1.21 1994/11/18 20:29:53 lemke Exp $
   *
--- 1,4 ----
! /* $XConsortium: XLbx.h,v 1.10 95/03/21 19:57:12 mor Exp $ */
  /*
   * $NCDId: @(#)XLbx.h,v 1.21 1994/11/18 20:29:53 lemke Exp $
   *
***************
*** 73,79 ****
  #define X_LbxGetImage			34
  
  #define LbxEvent			0
! #define LbxNumberEvents			(LbxEvent + 1)
  
  /* This is always the master client */
  #define LbxMasterClientIndex		0
--- 73,81 ----
  #define X_LbxGetImage			34
  
  #define LbxEvent			0
! #define LbxQuickMotionDeltaEvent	1
! #define LbxMotionDeltaEvent		2
! #define LbxNumberEvents			(LbxMotionDeltaEvent + 1)
  
  /* This is always the master client */
  #define LbxMasterClientIndex		0
*** -	Thu May 11 14:12:27 1995
--- xc/workInProgress/lbx/include/extensions/lbxdeltastr.h	Thu May 11 14:12:27 1995
***************
*** 1,4 ****
! /* $XConsortium: lbxdeltastr.h,v 1.3 94/12/01 20:07:54 mor Exp $ */
  /*
   * $NCDId: @(#)lbxdeltastr.h,v 1.1 1993/12/22 22:23:09 dct Exp $
   *
--- 1,4 ----
! /* $XConsortium: lbxdeltastr.h,v 1.4 95/03/21 19:57:46 mor Exp $ */
  /*
   * $NCDId: @(#)lbxdeltastr.h,v 1.1 1993/12/22 22:23:09 dct Exp $
   *
***************
*** 51,55 ****
--- 51,92 ----
      unsigned short	nextDelta;
      unsigned short	activeDeltas;	/* only needed for outgoing */
  } LBXDeltasRec, *LBXDeltasPtr;
+ 
+ 
+ /*
+  * Motion delta cache
+  */
+ 
+ typedef struct {
+     BYTE swapped;
+     BYTE detail;
+     CARD16 sequenceNumber B16;
+     Time time B32;
+     Window root B32, event B32, child B32;
+     INT16 rootX B16, rootY B16, eventX B16, eventY B16;
+     KeyButMask state B16;
+     BOOL sameScreen;		
+ } lbxMotionCache;
+ 
+ 
+ /*
+  * Motion delta events
+  */
+ 
+ typedef struct {
+     BYTE type;
+     CARD8 deltaTime;
+     INT8 deltaX;
+     INT8 deltaY;
+ } lbxQuickMotionDeltaEvent;
+ 
+ typedef struct {
+     BYTE type;
+     INT8 deltaX;
+     INT8 deltaY;
+     BYTE pad;
+     CARD16 deltaTime B16;
+     CARD16 deltaSequence B16;
+ } lbxMotionDeltaEvent;
  
  #endif /* LBX_DELTA_STRUCT_H */
*** -	Thu May 11 14:12:28 1995
--- xc/workInProgress/lbx/include/extensions/lbxstr.h	Thu May 11 14:12:27 1995
***************
*** 1,4 ****
! /* $XConsortium: lbxstr.h,v 1.8 94/12/01 20:02:04 mor Exp $ */
  /*
   * $NCDId: @(#)lbxstr.h,v 1.25 1994/11/18 20:29:52 lemke Exp $
   *
--- 1,4 ----
! /* $XConsortium: lbxstr.h,v 1.9 95/05/02 18:58:59 mor Exp $ */
  /*
   * $NCDId: @(#)lbxstr.h,v 1.25 1994/11/18 20:29:52 lemke Exp $
   *
***************
*** 201,209 ****
  } xLbxQueryFontReq;
  #define	sz_xLbxQueryFontReq	8
  
  typedef struct {
      BYTE	type;			/* X_Reply */
!     CARD8	pad;
      CARD16	sequenceNumber B16;
      CARD32	length B32;
      CARD32	tag B32;
--- 201,257 ----
  } xLbxQueryFontReq;
  #define	sz_xLbxQueryFontReq	8
  
+ /* an LBX squished charinfo packs the data in a CARD32 as follows */
+ #define	LBX_WIDTH_SHIFT		26
+ #define	LBX_LEFT_SHIFT		20
+ #define	LBX_RIGHT_SHIFT		13
+ #define	LBX_ASCENT_SHIFT	7
+ #define	LBX_DESCENT_SHIFT	0
+ 
+ #define	LBX_WIDTH_BITS		6
+ #define	LBX_LEFT_BITS		6
+ #define	LBX_RIGHT_BITS		7
+ #define	LBX_ASCENT_BITS		6
+ #define	LBX_DESCENT_BITS	7
+ 
+ #define	LBX_WIDTH_MASK		0xfc000000
+ #define	LBX_LEFT_MASK		0x03f00000
+ #define	LBX_RIGHT_MASK		0x000fe000
+ #define	LBX_ASCENT_MASK		0x00001f80
+ #define	LBX_DESCENT_MASK	0x0000007f
+ 
+ #define	LBX_MASK_BITS(val, n)	((unsigned int) ((val) & ((1 << (n)) - 1)))
+ 
+ typedef struct {
+     CARD32	metrics B32;
+ } xLbxCharInfo;
+ 
+ /* note that this is identical to xQueryFontReply except for missing 
+  * first 2 words
+  */
+ typedef struct {
+     xCharInfo minBounds; 
+ /* XXX do we need to leave this gunk? */
+ #ifndef WORD64
+     CARD32 walign1 B32;
+ #endif
+     xCharInfo maxBounds; 
+ #ifndef WORD64
+     CARD32 walign2 B32;
+ #endif
+     CARD16 minCharOrByte2 B16, maxCharOrByte2 B16;
+     CARD16 defaultChar B16;
+     CARD16 nFontProps B16;  /* followed by this many xFontProp structures */
+     CARD8 drawDirection;
+     CARD8 minByte1, maxByte1;
+     BOOL allCharsExist;
+     INT16 fontAscent B16, fontDescent B16;
+     CARD32 nCharInfos B32; /* followed by this many xLbxCharInfo structures */
+ } xLbxFontInfo;
+ 
  typedef struct {
      BYTE	type;			/* X_Reply */
!     CARD8	compression;
      CARD16	sequenceNumber B16;
      CARD32	length B32;
      CARD32	tag B32;
***************
*** 216,223 ****
       * but we hope that it won't be needed, (and it won't fit in 32 bytes
       * with the tag anyways)
       *
!      * if additional data is needed, its sent just like X_QueryFont, with
!      * an xQueryFontReply struct plus the xCharInfos
       */
  } xLbxQueryFontReply;
  #define sz_xLbxQueryFontReply	32
--- 264,270 ----
       * but we hope that it won't be needed, (and it won't fit in 32 bytes
       * with the tag anyways)
       *
!      * if any additional data is needed, its sent in a xLbxFontInfo
       */
  } xLbxQueryFontReply;
  #define sz_xLbxQueryFontReply	32
*** -	Thu May 11 14:12:54 1995
--- xc/workInProgress/lbx/programs/lbxproxy/os/WaitFor.c	Thu May 11 14:12:54 1995
***************
*** 46,52 ****
  
  ******************************************************************/
  
! /* $XConsortium: WaitFor.c,v 1.4 94/04/17 21:17:10 dpw Exp $ */
  
  /*****************************************************************
   * OS Dependent input routines:
--- 46,52 ----
  
  ******************************************************************/
  
! /* $XConsortium: WaitFor.c,v 1.5 95/04/04 20:53:10 dpw Exp $ */
  
  /*****************************************************************
   * OS Dependent input routines:
***************
*** 92,120 ****
  extern void BlockHandler();
  extern void WakeupHandler();
  
- #ifdef apollo
- extern FdSet apInputMask;
- 
- static FdSet LastWriteMask;
- #endif
- 
- #ifdef XTESTEXT1
- /*
-  * defined in xtestext1dd.c
-  */
- extern int playback_on;
- #endif /* XTESTEXT1 */
- 
- struct _OsTimerRec {
-     OsTimerPtr		next;
-     CARD32		expires;
-     OsTimerCallback	callback;
-     pointer		arg;
- };
- 
- static void DoTimer();
- static OsTimerPtr timers;
- 
  /*****************
   * WaitForSomething:
   *     Make the server suspend until there is
--- 92,97 ----
***************
*** 155,190 ****
  	    COPYBITS(ClientsWithInput, clientsReadable);
  	    break;
  	}
- 	if (timers)
- 	    now = GetTimeInMillis();
  	wt = NULL;
- 	if (timers)
- 	{
- 	    while (timers && timers->expires <= now)
- 		DoTimer(timers, now, &timers);
- 	    if (timers)
- 	    {
- 		timeout = timers->expires - now;
- 		waittime.tv_sec = timeout / MILLI_PER_SECOND;
- 		waittime.tv_usec = (timeout % MILLI_PER_SECOND) *
- 		    (1000000 / MILLI_PER_SECOND);
- 		wt = &waittime;
- 	    }
- 	}
  	COPYBITS(AllSockets, LastSelectMask);
- #ifdef apollo
-         COPYBITS(apInputMask, LastWriteMask);
- #endif
  	BlockHandler((pointer)&wt, (pointer)LastSelectMask);
  	if (NewOutputPending)
  	    FlushAllOutput();
- #ifdef XTESTEXT1
- 	/* XXX how does this interact with new write block handling? */
- 	if (playback_on) {
- 	    wt = &waittime;
- 	    XTestComputeWaitTime (&waittime);
- 	}
- #endif /* XTESTEXT1 */
  	/* keep this check close to select() call to minimize race */
  	if (dispatchException)
  	    i = -1;
--- 132,142 ----
***************
*** 195,214 ****
  			(int *)clientsWritable, (int *) NULL, wt);
  	}
  	else
- #ifdef apollo
- 	    i = select (MAXSOCKS, (int *)LastSelectMask,
- 			(int *)LastWriteMask, (int *) NULL, wt);
- #else
  	    i = select (MAXSOCKS, (int *)LastSelectMask,
  			(int *) NULL, (int *) NULL, wt);
- #endif
  	selecterr = errno;
  	WakeupHandler(i, (pointer)LastSelectMask);
- #ifdef XTESTEXT1
- 	if (playback_on) {
- 	    i = XTestProcessInputAction (i, &waittime);
- 	}
- #endif /* XTESTEXT1 */
  	if (i <= 0) /* An error or timeout occurred */
  	{
  
--- 147,156 ----
***************
*** 225,236 ****
  		else if (selecterr != EINTR)
  		    ErrorF("WaitForSomething(): select: errno=%d\n",
  			selecterr);
- 	    if (timers)
- 	    {
- 		now = GetTimeInMillis();
- 		while (timers && timers->expires <= now)
- 		    DoTimer(timers, now, &timers);
- 	    }
  	}
  	else
  	{
--- 167,172 ----
***************
*** 289,416 ****
      return (FALSE);
  }
  #endif
- 
- static void
- DoTimer(timer, now, prev)
-     register OsTimerPtr timer;
-     CARD32 now;
-     OsTimerPtr *prev;
- {
-     CARD32 newTime;
- 
-     *prev = timer->next;
-     timer->next = NULL;
-     newTime = (*timer->callback)(timer, now, timer->arg);
-     if (newTime)
- 	TimerSet(timer, 0, newTime, timer->callback, timer->arg);
- }
- 
- OsTimerPtr
- TimerSet(timer, flags, millis, func, arg)
-     register OsTimerPtr timer;
-     int flags;
-     CARD32 millis;
-     OsTimerCallback func;
-     pointer arg;
- {
-     register OsTimerPtr *prev;
-     CARD32 now = GetTimeInMillis();
- 
-     if (!timer)
-     {
- 	timer = (OsTimerPtr)xalloc(sizeof(struct _OsTimerRec));
- 	if (!timer)
- 	    return NULL;
-     }
-     else
-     {
- 	for (prev = &timers; *prev; prev = &(*prev)->next)
- 	{
- 	    if (*prev == timer)
- 	    {
- 		*prev = timer->next;
- 		if (flags & TimerForceOld)
- 		    (void)(*timer->callback)(timer, now, timer->arg);
- 		break;
- 	    }
- 	}
-     }
-     if (!millis)
- 	return timer;
-     if (!(flags & TimerAbsolute))
- 	millis += now;
-     timer->expires = millis;
-     timer->callback = func;
-     timer->arg = arg;
-     if (millis <= now)
-     {
- 	timer->next = NULL;
- 	millis = (*timer->callback)(timer, now, timer->arg);
- 	if (!millis)
- 	    return timer;
-     }
-     for (prev = &timers;
- 	 *prev && millis > (*prev)->expires;
- 	 prev = &(*prev)->next)
- 	;
-     timer->next = *prev;
-     *prev = timer;
-     return timer;
- }
- 
- Bool
- TimerForce(timer)
-     register OsTimerPtr timer;
- {
-     register OsTimerPtr *prev;
- 
-     for (prev = &timers; *prev; prev = &(*prev)->next)
-     {
- 	if (*prev == timer)
- 	{
- 	    DoTimer(timer, GetTimeInMillis(), prev);
- 	    return TRUE;
- 	}
-     }
-     return FALSE;
- }
- 
- void
- TimerFree(timer)
-     register OsTimerPtr timer;
- {
-     register OsTimerPtr *prev;
- 
-     if (!timer)
- 	return;
-     for (prev = &timers; *prev; prev = &(*prev)->next)
-     {
- 	if (*prev == timer)
- 	{
- 	    *prev = timer->next;
- 	    break;
- 	}
-     }
-     xfree(timer);
- }
- 
- void
- TimerCheck()
- {
-     register CARD32 now = GetTimeInMillis();
- 
-     while (timers && timers->expires <= now)
- 	DoTimer(timers, now, &timers);
- }
- 
- void
- TimerInit()
- {
-     OsTimerPtr timer;
- 
-     while (timer = timers)
-     {
- 	timers = timer->next;
- 	xfree(timer);
-     }
- }
--- 225,227 ----
*** -	Thu May 11 14:12:55 1995
--- xc/workInProgress/lbx/programs/lbxproxy/os/connection.c	Thu May 11 14:12:55 1995
***************
*** 1,4 ****
! /* $XConsortium: connection.c,v 1.6 94/04/17 21:17:12 dpw Exp $ */
  /***********************************************************
  
  Copyright (c) 1987, 1989  X Consortium
--- 1,4 ----
! /* $XConsortium: connection.c,v 1.7 95/04/05 17:30:54 kaleb Exp $ */
  /***********************************************************
  
  Copyright (c) 1987, 1989  X Consortium
***************
*** 1296,1302 ****
  
      for (i=0; i<MAXSOCKS; i++) ConnectionTranslation[i] = 0;
      for (i=0; i<MAXSOCKS; i++) ConnectionOutputTranslation[i] = 0;
! #ifndef X_NOT_POSIX
      lastfdesc = sysconf(_SC_OPEN_MAX) - 1;
  #else
  #ifdef hpux
--- 1296,1305 ----
  
      for (i=0; i<MAXSOCKS; i++) ConnectionTranslation[i] = 0;
      for (i=0; i<MAXSOCKS; i++) ConnectionOutputTranslation[i] = 0;
! #ifdef XNO_SYSCONF
! #undef _SC_OPEN_MAX
! #endif
! #ifdef _SC_OPEN_MAX
      lastfdesc = sysconf(_SC_OPEN_MAX) - 1;
  #else
  #ifdef hpux
*** -	Thu May 11 14:12:56 1995
--- xc/workInProgress/lbx/programs/lbxproxy/os/io.c	Thu May 11 14:12:56 1995
***************
*** 45,51 ****
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: io.c,v 1.4 94/04/17 21:17:13 dpw Exp $ */
  /*****************************************************************
   * i/o functions
   *
--- 45,51 ----
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: io.c,v 1.5 95/04/04 21:39:53 dpw Exp $ */
  /*****************************************************************
   * i/o functions
   *
***************
*** 113,126 ****
  ClientPtr   ReadingClient;
  ClientPtr   WritingClient;
  
- #ifdef LBX
  #define get_req_len(req,cli) (((cli)->swapped ? \
  			      lswaps((req)->length) : (req)->length) << 2)
  
- #else
- #define get_req_len(req,cli) ((cli)->swapped ? \
- 			      lswaps((req)->length) : (req)->length)
- #endif
  
  unsigned long
  StandardRequestLength(req,client,got,partp)
--- 113,121 ----
***************
*** 252,300 ****
      move_header = FALSE;
  #endif
      gotnow = oci->bufcnt + oci->buffer - oci->bufptr;
- #ifdef LBX
      client->requestBuffer = (pointer)oci->bufptr;
      needed = RequestLength (NULL, client, gotnow, &part);
      client->req_len = needed >> 2;
- #else
-     if (gotnow < sizeof(xReq))
-     {
- 	needed = sizeof(xReq);
- 	need_header = TRUE;
-     }
-     else
-     {
- 	request = (xReq *)oci->bufptr;
- 	needed = get_req_len(request, client);
- #ifdef BIGREQS
- 	if (!needed && client->big_requests)
- 	{
- 	    move_header = TRUE;
- 	    if (gotnow < sizeof(xBigReq))
- 	    {
- 		needed = sizeof(xBigReq) >> 2;
- 		need_header = TRUE;
- 	    }
- 	    else
- 		needed = get_big_req_len(request, client);
- 	}
- #endif
- 	client->req_len = needed;
- 	needed <<= 2;
-     }
- #endif	/* LBX */
      if (gotnow < needed
- #ifdef LBX
  	|| part
- #endif
      )
      {
- #ifndef LBX
- 	oci->lenLastReq = 0;
- 	if (needed > MAXBUFSIZE)
- #else
  	if (needed == -1)
- #endif
  	{
  	    YieldControlDeath();
  	    return -1;
--- 247,260 ----
***************
*** 320,333 ****
  	    oci->bufptr = oci->buffer;
  	    oci->bufcnt = gotnow;
  	}
- #ifdef LBX
  	ReadingClient = client;
  	result = (*oc->Read)(fd, oci->buffer + oci->bufcnt, 
  		      oci->size - oci->bufcnt); 
- #else
- 	result = read(fd, oci->buffer + oci->bufcnt, 
- 		      oci->size - oci->bufcnt); 
- #endif
  	if (result <= 0)
  	{
  	    if ((result < 0) && ETEST(errno))
--- 280,288 ----
***************
*** 354,418 ****
  		oci->bufptr = ibuf + oci->bufcnt - gotnow;
  	    }
  	}
- #ifdef LBX
  	client->requestBuffer = (pointer) oci->bufptr;
- #endif
  	if (
- #ifdef LBX
  	    part &&
- #else
- 	    need_header &&
- #endif
  	    gotnow >= needed)
  	{
- #ifdef LBX
  	    needed = RequestLength (NULL, client, gotnow, &part);
  	    client->req_len = needed >> 2;
- #else
- 	    request = (xReq *)oci->bufptr;
- 	    needed = get_req_len(request, client);
- #ifdef BIGREQS
- 	    if (!needed && client->big_requests)
- 	    {
- 		move_header = TRUE;
- 		if (gotnow < sizeof(xBigReq))
- 		    needed = sizeof(xBigReq) >> 2;
- 		else
- 		    needed = get_big_req_len(request, client);
- 	    }
- #endif
- 	    client->req_len = needed;
- 	    needed <<= 2;
- #endif	/* !LBX */
  	}
  	if (gotnow < needed
- #ifdef LBX
  		|| part
- #endif
  	)
  	{
- #ifdef LBX
  	    if (needed == -1)
  	    {
  		YieldControlDeath();
  		return -1;
  	    }
- #endif
  	    YieldControlNoInput();
  	    return 0;
  	}
      }
- #ifndef LBX
-     if (needed == 0)
-     {
- #ifdef BIGREQS
- 	if (client->big_requests)
- 	    needed = sizeof(xBigReq);
- 	else
- #endif
- 	    needed = sizeof(xReq);
-     }
- #endif	/* !LBX */
      oci->lenLastReq = needed;
  
      /*
--- 309,335 ----
***************
*** 422,428 ****
       *  can get into the queue.   
       */
  
- #ifdef LBX
      if (gotnow > needed)
      {
  	request = (xReq *)(oci->bufptr + needed);
--- 339,344 ----
***************
*** 432,460 ****
  	else
  	    YieldControlNoInput();
      }
- #else
-     gotnow -= needed;
-     if (gotnow >= sizeof(xReq)) 
-     {
- 	request = (xReq *)(oci->bufptr + needed);
- 	if (gotnow >= (result = (get_req_len(request, client) << 2))
- #ifdef BIGREQS
- 	    && (result ||
- 		(client->big_requests &&
- 		 (gotnow >= sizeof(xBigReq) &&
- 		  gotnow >= (get_big_req_len(request, client) << 2))))
- #endif
- 	    )
- 	    BITSET(ClientsWithInput, fd);
- 	else
- 	    YieldControlNoInput();
-     }
- #endif	/* !LBX */
      else
      {
- #ifndef LBX
- 	if (!gotnow)
- #endif
  	    AvailableInput = oc;
  	YieldControlNoInput();
      }
--- 348,355 ----
***************
*** 470,478 ****
  	client->req_len -= (sizeof(xBigReq) - sizeof(xReq)) >> 2;
      }
  #endif
- #ifndef LBX
-     client->requestBuffer = (pointer)oci->bufptr;
- #endif
      return needed;
  }
  
--- 365,370 ----
***************
*** 809,823 ****
      int fd = oc->fd;
      register xReq *request;
      int gotnow, needed;
- #ifdef LBX
      Bool part;
- #endif
  
      if (AvailableInput == oc)
  	AvailableInput = (OsCommPtr)NULL;
      oci->lenLastReq = 0;
      gotnow = oci->bufcnt + oci->buffer - oci->bufptr;
- #ifdef LBX
      request = (xReq *)oci->bufptr;
      if (gotnow >= RequestLength (request, client, gotnow, &part) && !part)
      {
--- 701,712 ----
***************
*** 826,862 ****
      }
      else
  	YieldControlNoInput();
- #else
-     if (gotnow < sizeof(xReq))
-     {
- 	YieldControlNoInput();
-     }
-     else
-     {
- 	request = (xReq *)oci->bufptr;
- 	needed = get_req_len(request, client);
- #ifdef BIGREQS
- 	if (!needed && client->big_requests)
- 	{
- 	    oci->bufptr -= sizeof(xBigReq) - sizeof(xReq);
- 	    *(xReq *)oci->bufptr = *request;
- 	    ((xBigReq *)oci->bufptr)->length = client->req_len;
- 	    if (client->swapped)
- 	    {
- 		char n;
- 		swapl(&((xBigReq *)oci->bufptr)->length, n);
- 	    }
- 	}
- #endif
- 	if (gotnow >= (needed << 2))
- 	{
- 	    BITSET(ClientsWithInput, fd);
- 	    YieldControl();
- 	}
- 	else
- 	    YieldControlNoInput();
-     }
- #endif	/* !LBX */
  }
  
      /* lookup table for adding padding bytes to data that is read from
--- 715,720 ----
*** -	Wed Dec 31 19:00:00 1969
--- xc/workInProgress/lbx/programs/lbxproxy/os/osinit.c	Thu May 11 14:12:57 1995
***************
*** 45,51 ****
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: osinit.c,v 1.3 94/04/17 21:17:14 dpw Exp $ */
  
  #include <stdio.h>
  #include "X.h"
--- 45,51 ----
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: osinit.c,v 1.4 95/04/04 21:40:46 dpw Exp $ */
  
  #include <stdio.h>
  #include "X.h"
***************
*** 178,187 ****
  #endif
  	been_here = TRUE;
      }
-     TimerInit();
- #ifdef DDXOSINIT
-     OsVendorInit();
- #endif
      OsInitAllocator();
-     OsInitColors();
  }
--- 178,182 ----
*** -	Thu May 11 14:12:58 1995
--- xc/workInProgress/lbx/programs/lbxproxy/os/Imakefile	Thu May 11 14:12:58 1995
***************
*** 1,9 ****
! XCOMM $XConsortium: Imakefile,v 1.3 94/03/17 19:46:55 dpw Exp $
  
  #include <Server.tmpl>
  
  EXTRA_DEFINES = -DLBX ConnectionFlags $(XDMAUTH_DEFINES) $(RPC_DEFINES) \
!                 $(KRB5_DEFINES)  AllocateLocalDefines
  INCLUDES = -I$(TOP)/include -I$(SERVERSRC)/include -I$(EXTINCSRC) \
             -I$(LIBSRC)/Xau $(KRB5_INCLUDES) $(XDMAUTH_INCLUDES)
      SRCS = connection.c io.c WaitFor.c osinit.c access.c
--- 1,9 ----
! XCOMM $XConsortium: Imakefile,v 1.4 95/04/07 19:42:59 kaleb Exp $
  
  #include <Server.tmpl>
  
  EXTRA_DEFINES = -DLBX ConnectionFlags $(XDMAUTH_DEFINES) $(RPC_DEFINES) \
!                 $(KRB5_DEFINES)  AllocateLocalDefines ServerOSDefines
  INCLUDES = -I$(TOP)/include -I$(SERVERSRC)/include -I$(EXTINCSRC) \
             -I$(LIBSRC)/Xau $(KRB5_INCLUDES) $(XDMAUTH_INCLUDES)
      SRCS = connection.c io.c WaitFor.c osinit.c access.c
*** -	Thu May 11 14:12:59 1995
--- xc/workInProgress/lbx/programs/lbxproxy/os/osdep.h	Thu May 11 14:12:58 1995
***************
*** 45,51 ****
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: osdep.h,v 1.4 94/04/17 21:17:14 dpw Exp $ */
  
  #define BOTIMEOUT 200 /* in milliseconds */
  #define BUFSIZE 4096
--- 45,51 ----
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: osdep.h,v 1.5 95/04/04 20:53:46 dpw Exp $ */
  
  #define BOTIMEOUT 200 /* in milliseconds */
  #define BUFSIZE 4096
***************
*** 215,223 ****
      int size;
      unsigned char *buf;
      int count;
- #ifdef LBX
      Bool nocompress;
- #endif
  } ConnectionOutput, *ConnectionOutputPtr;
  
  #ifdef K5AUTH
--- 215,221 ----
***************
*** 240,246 ****
  #endif
      CARD32 conn_time;		/* timestamp if not established, else 0  */
      struct _XtransConnInfo *trans_conn; /* transport connection object */
- #ifdef LBX
      ConnectionOutputPtr ofirst;
      ConnectionOutputPtr olast;
      void (*Close) ();
--- 238,243 ----
***************
*** 249,270 ****
      int  (*flushClient) ();
      void (*compressOff) ();
      void (*compressOn) ();
- #endif
  } OsCommRec, *OsCommPtr;
  
- #ifdef LBX
  #define FlushClient(who, oc, extraBuf, extraCount) \
      (*((OsCommPtr)((who)->osPrivate))->flushClient)(who, oc, extraBuf, extraCount)
- #else
- extern int FlushClient(
- #if NeedFunctionPrototypes
-     ClientPtr /*who*/,
-     OsCommPtr /*oc*/,
-     char* /*extraBuf*/,
-     int /*extraCount*/
- #endif
- );
- #endif
  
  extern void FreeOsBuffers(
  #if NeedFunctionPrototypes
--- 246,255 ----
*** -	Thu May 11 14:13:07 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/colormap.h	Thu May 11 14:13:07 1995
***************
*** 1,4 ****
! /* $XConsortium: colormap.h,v 1.5 94/03/27 13:36:38 dpw Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
--- 1,4 ----
! /* $XConsortium: colormap.h,v 1.6 95/04/25 20:35:13 dpw Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
***************
*** 42,48 ****
                  vgreen;		/* visual */
  }           RGBEntryRec, *RGBEntryPtr;
  
! typedef unsigned long Pixel;
  
  extern RGBEntryPtr FindColorName();
  extern Bool AddColorName();
--- 42,48 ----
                  vgreen;		/* visual */
  }           RGBEntryRec, *RGBEntryPtr;
  
! typedef CARD32 Pixel;
  
  extern RGBEntryPtr FindColorName();
  extern Bool AddColorName();
*** -	Thu May 11 14:13:08 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/dispatch.c	Thu May 11 14:13:08 1995
***************
*** 1,4 ****
! /* $XConsortium: dispatch.c,v 1.7 94/12/01 20:47:30 mor Exp $ */
  /*
   * $NCDOr: dispatch.c,v 1.2 1993/11/19 21:28:48 keithp Exp keithp $
   * $NCDId: @(#)dispatch.c,v 1.27 1994/11/18 20:35:09 lemke Exp $
--- 1,4 ----
! /* $XConsortium: dispatch.c,v 1.8 95/04/04 20:59:24 dpw Exp $ */
  /*
   * $NCDOr: dispatch.c,v 1.2 1993/11/19 21:28:48 keithp Exp keithp $
   * $NCDId: @(#)dispatch.c,v 1.27 1994/11/18 20:35:09 lemke Exp $
***************
*** 110,116 ****
  #endif
  	    isItTimeToYield = FALSE;
   
-             requestingClient = client;
  	    while (!isItTimeToYield)
  	    {
  		/* now, finally, deal with client requests */
--- 110,115 ----
***************
*** 131,139 ****
--- 130,140 ----
  		client->requestLogIndex++;
  #endif
                  LBXSequenceNumber(client)++;
+ #ifdef NOTDEF
  		if (result > (MAX_REQUEST_SIZE << 2))
  		    result = BadLength;
  		else
+ #endif
  		    result = (* client->requestVector[MAJOROP])(client);
  	    
  #ifdef NOTDEF
*** -	Wed Dec 31 19:00:00 1969
--- xc/workInProgress/lbx/programs/lbxproxy/di/globals.c	Thu May 11 14:13:08 1995
***************
*** 46,52 ****
  
  ********************************************************/
  
! /* $XConsortium: globals.c,v 1.4 94/04/17 21:17:17 dpw Exp $ */
  /* $NCDId: @(#)globals.c,v 1.3 1994/03/24 17:54:39 lemke Exp $ */
    
  #include "X.h"
--- 46,52 ----
  
  ********************************************************/
  
! /* $XConsortium: globals.c,v 1.5 95/04/04 21:00:43 dpw Exp $ */
  /* $NCDId: @(#)globals.c,v 1.3 1994/03/24 17:54:39 lemke Exp $ */
    
  #include "X.h"
***************
*** 61,79 ****
  ClientPtr  serverClient;
  int  currentMaxClients;   /* current size of clients array */
  
- unsigned long globalSerialNumber = 0;
  unsigned long serverGeneration = 0;
  
- ClientPtr requestingClient;	/* XXX this should be obsolete now, remove? */
- 
- TimeStamp currentTime;
- TimeStamp lastDeviceEventTime;
- 
  CARD32 TimeOutValue = DEFAULT_TIMEOUT * MILLI_PER_SECOND;
- 
- char *defaultDisplayClass = "foo";
- 
- Bool	terminateAtReset;
- 
- char *display;
- 
--- 61,66 ----
*** -	Wed Dec 31 19:00:00 1969
--- xc/workInProgress/lbx/programs/lbxproxy/di/init.c	Thu May 11 14:13:09 1995
***************
*** 23,32 ****
   * Author:  Keith Packard, Network Computing Devices
   */
  
!  /* $XConsortium: init.c,v 1.4 94/02/17 15:27:11 dpw Exp $ */
  
  /* Hook up to an X server and set up a multiplexing LBX encoded connection */
  
  #include <X11/Xlib.h>
  
  int  lbxMajor, lbxMinor;
--- 23,38 ----
   * Author:  Keith Packard, Network Computing Devices
   */
  
!  /* $XConsortium: init.c,v 1.6 95/04/25 20:35:13 dpw Exp $ */
  
  /* Hook up to an X server and set up a multiplexing LBX encoded connection */
  
+ /* lbxproxy source files are compiled with -D_XSERVER64 on 64 bit machines.
+  * For the most part, this is appropriate.  However, for this file it
+  * is not, because we make Xlib calls here.
+  */
+ #undef _XSERVER64
+ 
  #include <X11/Xlib.h>
  
  int  lbxMajor, lbxMinor;
***************
*** 44,53 ****
      if (!dpy)
  	return -1;
      
!     if (!XLbxQueryExtension (dpy, requestp, eventp, errorp))
  	return -1;
!     if (!XLbxQueryVersion (dpy, &lbxMajor, &lbxMinor))
  	return -1;
      /* yuck.  Guess at the request number; 1 XFreeGC per screen and 1 XSync */
  #if R5Xlib
      /*  XXX This works for R5 Xlib.  The else block works for R6 Xlib.
--- 50,63 ----
      if (!dpy)
  	return -1;
      
!     if (!XLbxQueryExtension (dpy, requestp, eventp, errorp)) {
! 	ErrorF("X server doesn't have LBX extension\n");
  	return -1;
!     }
!     if (!XLbxQueryVersion (dpy, &lbxMajor, &lbxMinor)) {
! 	ErrorF("LBX extension query failed\n");
  	return -1;
+     }
      /* yuck.  Guess at the request number; 1 XFreeGC per screen and 1 XSync */
  #if R5Xlib
      /*  XXX This works for R5 Xlib.  The else block works for R6 Xlib.
*** -	Thu May 11 14:13:10 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/lbxdata.h	Thu May 11 14:13:10 1995
***************
*** 1,4 ****
! /* $XConsortium: lbxdata.h,v 1.9 94/12/01 20:49:17 mor Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
--- 1,4 ----
! /* $XConsortium: lbxdata.h,v 1.10 95/05/02 19:00:56 mor Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
***************
*** 185,190 ****
--- 185,193 ----
      XID         tag;
      int         tagtype;
      union {
+ 	struct _query_font {
+ 	    int         compression;
+ 	}           query_font;
  	struct _modmap {
  	    int         keyspermod;
  	}           modmap;
*** -	Thu May 11 14:13:11 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/lbxfuncs.c	Thu May 11 14:13:11 1995
***************
*** 19,28 ****
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
!  * $NCDId: @(#)lbxfuncs.c,v 1.40 1994/11/18 20:39:18 lemke Exp $
   */
  
! /* $XConsortium: lbxfuncs.c,v 1.7 94/12/01 20:50:00 mor Exp $ */
  
  /*
   * top level LBX request & reply handling
--- 19,28 ----
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
!  * $NCDId: @(#)lbxfuncs.c,v 1.43 1995/03/09 00:54:06 lemke Exp $
   */
  
! /* $XConsortium: lbxfuncs.c,v 1.11 95/05/11 17:36:00 mor Exp $ */
  
  /*
   * top level LBX request & reply handling
***************
*** 37,43 ****
   * out.
   *
   * requests copy out interesting stuff and then swap so original data
!  * is left alone as much as possible
   *
   * replied data is copied yet again before swapping because the data
   * may be stored as a tag result and we don't want to change that.
--- 37,44 ----
   * out.
   *
   * requests copy out interesting stuff and then swap so original data
!  * is left alone as much as possible.  note that the length field
!  * is *not* swapped
   *
   * replied data is copied yet again before swapping because the data
   * may be stored as a tag result and we don't want to change that.
***************
*** 345,369 ****
      Atom        atom;
      char       *s;
      xGetAtomNameReply *reply;
!     int         len;
      ReplyStuffPtr nr;
  
      reply = (xGetAtomNameReply *) data;
  
!     if ((reply->length << 2) > MAX_ATOM_LENGTH)
! 	return FALSE;
  
!     len = (reply->length << 2) + sizeof(xGetAtomNameReply);
  
      s = data + sizeof(xGetAtomNameReply);
  
-     len -= sizeof(xGetAtomNameReply);
      nr = GetMatchingReply(client, reply->sequenceNumber);
      assert(nr);
      atom = nr->request_info.lbxatom.atom;
  
      /* make sure it gets stuffed in the DB */
!     (void) LbxMakeAtom(s, len, atom, TRUE);
      return TRUE;
  }
  
--- 346,374 ----
      Atom        atom;
      char       *s;
      xGetAtomNameReply *reply;
!     CARD16	len;
      ReplyStuffPtr nr;
+     char	n;
  
      reply = (xGetAtomNameReply *) data;
  
!     len = reply->nameLength;
! 
!     if (client->swapped) {
! 	swaps(&len, n);
!     }
  
!     if (len > MAX_ATOM_LENGTH)
! 	return FALSE;
  
      s = data + sizeof(xGetAtomNameReply);
  
      nr = GetMatchingReply(client, reply->sequenceNumber);
      assert(nr);
      atom = nr->request_info.lbxatom.atom;
  
      /* make sure it gets stuffed in the DB */
!     (void) LbxMakeAtom(s, (unsigned) len, atom, TRUE);
      return TRUE;
  }
  
***************
*** 514,520 ****
  	IncrementPixel(client, cmap, pent);
  
  	/* must tell server to bump refcnt */
! 	SendIncrementPixel(client, req->cmap, pent->pixel);
  
  	reply.type = X_Reply;
  	reply.length = 0;
--- 519,525 ----
  	IncrementPixel(client, cmap, pent);
  
  	/* must tell server to bump refcnt */
! 	SendIncrementPixel(client, cmap, pent->pixel);
  
  	reply.type = X_Reply;
  	reply.length = 0;
***************
*** 811,826 ****
      Colormap    cmap;
      Bool        freepix = FALSE;
      char        n;
  
      req = (xFreeColorsReq *) data;
      mask = req->planeMask;
      cmap = req->cmap;
  
      if (client->swapped) {
  	swapl(&cmap, n);
  	swapl(&mask, n);
      }
!     num = ((req->length << 2) - sizeof(xFreeColorsReq)) >> 2;
  
      if (client->swapped) {
  	pixels = (Pixel *) ALLOCATE_LOCAL(num * sizeof(Pixel));
--- 816,834 ----
      Colormap    cmap;
      Bool        freepix = FALSE;
      char        n;
+     CARD16	len;
  
      req = (xFreeColorsReq *) data;
      mask = req->planeMask;
      cmap = req->cmap;
+     len = req->length;
  
      if (client->swapped) {
  	swapl(&cmap, n);
  	swapl(&mask, n);
+ 	swaps(&len, n);
      }
!     num = ((len << 2) - sizeof(xFreeColorsReq)) >> 2;
  
      if (client->swapped) {
  	pixels = (Pixel *) ALLOCATE_LOCAL(num * sizeof(Pixel));
***************
*** 1178,1183 ****
--- 1186,1294 ----
      }
  }
  
+ static INT16
+ unpack_val(val, mask, sft, bts)
+     CARD32      val;
+     CARD32      mask;
+     int         sft,
+                 bts;
+ {
+     CARD32      tmpl;
+     CARD16      utmp;
+     INT16       sval;
+ 
+     /* get the proper value */
+     utmp = (val & mask) >> sft;
+     /* push the sign bit to the right spot */
+     utmp <<= (16 - bts);
+     /* cast it so sign bit takes effect */
+     sval = (INT16) utmp;
+     /* shift back down */
+     sval >>= (16 - bts);
+ 
+     return sval;
+ }
+ 
+ int
+ UnsquishFontInfo(compression, fdata, dlen, qfr)
+     int	compression;
+     xLbxFontInfo	*fdata;
+     int		dlen;
+     pointer	*qfr;
+ {
+     int         len,
+                 hlen,
+                 junklen = sizeof(BYTE) * 2 + sizeof(CARD16) + sizeof(CARD32);
+     char *t;
+     pointer	ndata;
+     int         nchars;
+     int         i;
+     xCharInfo  *maxb,
+                *minb;
+     xQueryFontReply *new;
+     xLbxCharInfo *lci,
+                 tlci;
+     xCharInfo  *ci;
+     CARD16       attrs;
+ 
+     maxb = &fdata->maxBounds;
+     minb = &fdata->minBounds;
+ 
+     nchars = fdata->nCharInfos;
+     hlen = sizeof(xQueryFontReply) + fdata->nFontProps * sizeof(xFontProp);
+     len = hlen + nchars * sizeof(xCharInfo);
+ 
+     new = (xQueryFontReply *) xalloc(len);
+     *qfr = (pointer) new;
+ 
+     if (!new)			/* XXX bad stuff... */
+ 	return 0;
+ 
+     /* copy the header & props parts */
+     t = (char *) new;
+     t += junklen;
+     if (compression) {
+ 	bcopy((char *) fdata, (char *) t, hlen - junklen);
+     } else {
+ 	bcopy((char *) fdata, (char *) t, len - junklen);
+ 	return len;
+     }
+ 
+     attrs = maxb->attributes;
+ 
+     t = (char *) fdata;
+     t += hlen - junklen;
+     lci = (xLbxCharInfo *) t;
+ 
+     t = (char *) new;
+     t += hlen;
+     ci = (xCharInfo *) t;
+ 
+     /* now expand the chars */
+     for (i = 0; i < nchars; i++, lci++, ci++) {
+ 	if (lci->metrics == 0) {
+ 	    /* empty char */
+ 	    ci->characterWidth = ci->leftSideBearing = ci->rightSideBearing =
+ 		ci->ascent = ci->descent = ci->attributes = 0;
+ 	} else {
+ 	    ci->characterWidth =
+ 	        unpack_val(lci->metrics, LBX_WIDTH_MASK,
+ 		       LBX_WIDTH_SHIFT, LBX_WIDTH_BITS);
+ 	    ci->leftSideBearing = unpack_val(lci->metrics, LBX_LEFT_MASK,
+ 					 LBX_LEFT_SHIFT, LBX_LEFT_BITS);
+ 	    ci->rightSideBearing = unpack_val(lci->metrics, LBX_RIGHT_MASK,
+ 					  LBX_RIGHT_SHIFT, LBX_RIGHT_BITS);
+ 	    ci->ascent = unpack_val(lci->metrics, LBX_ASCENT_MASK,
+ 				LBX_ASCENT_SHIFT, LBX_ASCENT_BITS);
+ 	    ci->descent = unpack_val(lci->metrics, LBX_DESCENT_MASK,
+ 				 LBX_DESCENT_SHIFT, LBX_DESCENT_BITS);
+ 	    ci->attributes = attrs;
+ 	}
+     }
+ 
+     return len;
+ }
+ 
  
  static Bool
  get_queryfont_reply(client, data)
***************
*** 1185,1192 ****
      char       *data;
  {
      xLbxQueryFontReply *rep;
!     int         len;
!     pointer     tag_data;
      TagData     td;
      ReplyStuffPtr nr;
      QueryTagRec qt;
--- 1296,1305 ----
      char       *data;
  {
      xLbxQueryFontReply *rep;
!     int         len,
!                 sqlen;
!     pointer     tag_data,
!                 sqtag_data;
      TagData     td;
      ReplyStuffPtr nr;
      QueryTagRec qt;
***************
*** 1209,1238 ****
  	    queryfont_full++;
  #endif
  
! 	    tag_data = (pointer) &rep[1];
! 	    len = rep->length << 2;
  	    if (client->swapped) {
! 		SwapFont((xQueryFontReply *) tag_data, FALSE);
  	    }
! 	    if (!TagStoreData(global_cache, tag, len,
! 			      LbxTagTypeFont, tag_data)) {
  		/* tell server we lost it */
  		SendInvalidateTag(client, tag);
  	    }
  	} else {
  	    td = TagGetTag(global_cache, tag);
  	    if (!td) {
  		/* lost data -- ask again for tag value */
  
  		qt.tag = tag;
  		qt.tagtype = LbxTagTypeFont;
  		QueryTag(client, &qt);
  
  		/* XXX what is the right way to stack Queries? */
  		return TRUE;
  	    }
! 	    len = td->size;
! 	    tag_data = td->tdata;
  
  #ifdef LBX_STATS
  	    queryfont_tag++;
--- 1322,1364 ----
  	    queryfont_full++;
  #endif
  
! 	    sqtag_data = (pointer) &rep[1];
! 	    sqlen = rep->length << 2;
  	    if (client->swapped) {
! 		LbxSwapFontInfo(sqtag_data, rep->compression);
  	    }
! 
! 	    /*
! 	     * store squished version of data, since that's what comes through
! 	     * through QueryTag
! 	     */
! 	    if (!TagStoreData(global_cache, tag, sqlen,
! 				      LbxTagTypeFont, sqtag_data)) {
  		/* tell server we lost it */
  		SendInvalidateTag(client, tag);
  	    }
+ 	    len = UnsquishFontInfo(rep->compression, sqtag_data, sqlen,
+ 							&tag_data);
+ 	    if (!len)
+ 	    	goto fetch_tag;
  	} else {
  	    td = TagGetTag(global_cache, tag);
  	    if (!td) {
+ 	fetch_tag:
  		/* lost data -- ask again for tag value */
  
  		qt.tag = tag;
  		qt.tagtype = LbxTagTypeFont;
+ 		qt.typedata.query_font.compression = rep->compression;
  		QueryTag(client, &qt);
  
  		/* XXX what is the right way to stack Queries? */
  		return TRUE;
  	    }
! 	    sqlen = td->size;
! 	    sqtag_data = td->tdata;
! 	    len = UnsquishFontInfo(rep->compression, sqtag_data, sqlen,
! 						&tag_data);
  
  #ifdef LBX_STATS
  	    queryfont_tag++;
***************
*** 1246,1260 ****
  #endif
  
  	/* server didn't send us a tag for some reason -- just pass on data */
! 	tag_data = (pointer) &rep[1];
  	if (client->swapped) {
! 	    SwapFont((xQueryFontReply *) tag_data, FALSE);
  	}
! 	len = rep->length << 2;
      }
  
      FinishQueryFontReply(client, rep->sequenceNumber, len, tag_data);
  
      return TRUE;
  }
  
--- 1372,1389 ----
  #endif
  
  	/* server didn't send us a tag for some reason -- just pass on data */
! 	sqtag_data = (pointer) &rep[1];
  	if (client->swapped) {
! 	    LbxSwapFontInfo(sqtag_data, FALSE);
  	}
! 	sqlen = rep->length << 2;
! 	len = UnsquishFontInfo(rep->compression, sqtag_data, sqlen, &tag_data);
      }
  
      FinishQueryFontReply(client, rep->sequenceNumber, len, tag_data);
  
+     xfree(tag_data);		/* free unsquished version */
+ 
      return TRUE;
  }
  
***************
*** 1452,1458 ****
  	    LBXCanDelayReply(client) = TRUE;
  	else
  	    LBXCanDelayReply(client) = FALSE;
!     } else {	/* always true if cacheable, so we get a chance to write */
  	LBXCanDelayReply(client) = TRUE;
      }
      	
--- 1581,1588 ----
  	    LBXCanDelayReply(client) = TRUE;
  	else
  	    LBXCanDelayReply(client) = FALSE;
!     } else {			/* always true if cacheable, so we get a
! 				 * chance to write */
  	LBXCanDelayReply(client) = TRUE;
      }
      	
***************
*** 1543,1552 ****
  				 * have an error, so eat it */
  	break;
      }
!     if (client->swapped) {
! 	swaps(&minor_code, n);
!     }
!     err->minorCode = minor_code;
      return retval;
  }
  
--- 1673,1680 ----
  				 * have an error, so eat it */
  	break;
      }
!     err->majorCode = minor_code;    /* err->majorCode is CARD8, don't swap */
!     err->minorCode = 0;
      return retval;
  }
  
***************
*** 1608,1617 ****
  		get_tagged_setup_reply(client, (char *) reply);
  		return FALSE;
  	    } else {
  		if (client->swapped) {
  		    SwapConnectionInfo((xConnSetup *) & prefix[1]);
  		}
! 		GetConnectionInfo(client, (xConnSetup *) & prefix[1], NULL);
  	    }
  	}
  	return TRUE;
--- 1736,1754 ----
  		get_tagged_setup_reply(client, (char *) reply);
  		return FALSE;
  	    } else {
+ 		CARD16 majorVer = prefix->majorVersion,
+ 		       minorVer = prefix->minorVersion;
+ 
  		if (client->swapped) {
  		    SwapConnectionInfo((xConnSetup *) & prefix[1]);
+ 		    swaps (&majorVer, n);
+ 		    swaps (&minorVer, n);
  		}
! 
! 		FinishSetupReply (client, reply->length << 2,
! 		    &prefix[1], NULL, majorVer, minorVer);
! 
! 		return FALSE;
  	    }
  	}
  	return TRUE;
***************
*** 1650,1658 ****
  			/* error for proxy -- eat it */
  			ret = FALSE;
  		    }
! 		}
! 		/* handle extension error */
  		HandleExtensionError(client, err);
  		RemoveReply(client, nr);
  	    }
  	}
--- 1787,1796 ----
  			/* error for proxy -- eat it */
  			ret = FALSE;
  		    }
! 		} else {
! 		    /* error in core X or other extension */
  		HandleExtensionError(client, err);
+ 		}
  		RemoveReply(client, nr);
  	    }
  	}
*** -	Thu May 11 14:13:15 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/stubs.c	Thu May 11 14:13:14 1995
***************
*** 1,4 ****
! /* $XConsortium: stubs.c,v 1.6 94/12/01 20:45:10 mor Exp $ */
  /*
   * $NCDOr: stubs.c,v 1.1 1993/11/16 17:58:49 keithp Exp keithp $
   * $NCDId: @(#)stubs.c,v 1.16 1994/11/18 20:35:22 lemke Exp $
--- 1,4 ----
! /* $XConsortium: stubs.c,v 1.7 95/04/04 21:08:31 dpw Exp $ */
  /*
   * $NCDOr: stubs.c,v 1.1 1993/11/16 17:58:49 keithp Exp keithp $
   * $NCDId: @(#)stubs.c,v 1.16 1994/11/18 20:35:22 lemke Exp $
***************
*** 33,46 ****
  #include "keysymdef.h"
  
  
- AbortDDX ()
- {
- }
- 
- OsInitColors ()
- {
- }
- 
  extern int  lbxDebug;
  extern int  lbxTagCacheSize;
  extern Bool lbxUseTags;
--- 33,38 ----
***************
*** 50,56 ****
  extern Bool lbxDoShortCircuiting;
  extern Bool lbxDoLbxGfx;
  
! ddxProcessArgument (argc, argv, i)
      char    **argv;
  {
      if (strcmp (argv[i], "-debug") == 0)
--- 42,48 ----
  extern Bool lbxDoShortCircuiting;
  extern Bool lbxDoLbxGfx;
  
! proxyProcessArgument (argc, argv, i)
      char    **argv;
  {
      if (strcmp (argv[i], "-debug") == 0)
***************
*** 117,146 ****
      return 0;
  }
  
  CheckMemory ()
  {
  }
  
- void
- CopyISOLatin1Lowered(dest, source, length)
-     register unsigned char *dest, *source;
-     int length;
- {
-     register int i;
- 
-     for (i = 0; i < length; i++, source++, dest++)
-     {
- 	if ((*source >= XK_A) && (*source <= XK_Z))
- 	    *dest = *source + (XK_a - XK_A);
- 	else if ((*source >= XK_Agrave) && (*source <= XK_Odiaeresis))
- 	    *dest = *source + (XK_agrave - XK_Agrave);
- 	else if ((*source >= XK_Ooblique) && (*source <= XK_Thorn))
- 	    *dest = *source + (XK_oslash - XK_Ooblique);
- 	else
- 	    *dest = *source;
-     }
-     *dest = '\0';
- }
  
  typedef struct _BlockHandler {
      void    (*BlockHandler)();
--- 109,120 ----
      return 0;
  }
  
+ #ifndef MEMBUG
  CheckMemory ()
  {
  }
+ #endif
  
  
  typedef struct _BlockHandler {
      void    (*BlockHandler)();
***************
*** 455,458 ****
      pointer         call_data;
  {
  }
- 
--- 429,431 ----
*** -	Thu May 11 14:13:17 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/utils.c	Thu May 11 14:13:17 1995
***************
*** 45,51 ****
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: utils.c,v 1.9 94/12/01 20:42:36 mor Exp $ */
  /* $NCDId: @(#)utils.c,v 1.8 1994/11/16 02:27:25 lemke Exp $ */
  
  #include "Xos.h"
--- 45,51 ----
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: utils.c,v 1.10 95/04/04 21:09:29 dpw Exp $ */
  /* $NCDId: @(#)utils.c,v 1.8 1994/11/16 02:27:25 lemke Exp $ */
  
  #include "Xos.h"
***************
*** 246,253 ****
  
      for ( i = 1; i < argc; i++ )
      {
! 	/* call ddx first, so it can peek/override if it wants */
!         if(skip = ddxProcessArgument(argc, argv, i))
  	{
  	    i += (skip - 1);
  	}
--- 246,253 ----
  
      for ( i = 1; i < argc; i++ )
      {
! 	/* do proxy-specific stuff first */
!         if(skip = proxyProcessArgument(argc, argv, i))
  	{
  	    i += (skip - 1);
  	}
*** -	Thu May 11 14:13:18 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/wire.c	Thu May 11 14:13:18 1995
***************
*** 1,4 ****
! /* $XConsortium: wire.c,v 1.9 94/12/01 20:51:38 mor Exp $ */
  /*
   * $NCDOr: wire.c,v 1.1 1994/10/18 17:43:32 keithp Exp keithp $
   * $NCDId: @(#)wire.c,v 1.44 1994/11/18 20:39:50 lemke Exp $
--- 1,4 ----
! /* $XConsortium: wire.c,v 1.11 95/04/04 21:11:20 dpw Exp $ */
  /*
   * $NCDOr: wire.c,v 1.1 1994/10/18 17:43:32 keithp Exp keithp $
   * $NCDId: @(#)wire.c,v 1.44 1994/11/18 20:39:50 lemke Exp $
***************
*** 43,48 ****
--- 43,51 ----
  
  extern int  NewOutputPending;
  
+ static lbxMotionCache _motionCache;
+ static lbxMotionCache *motionCache = &_motionCache;
+ 
  #ifdef LBX_STATS
  extern int  delta_out_total;
  extern int  delta_out_attempts;
***************
*** 539,544 ****
--- 542,555 ----
  	*partp = FALSE;
  	return req->length << 2;
      }
+     if (req->reqType == server->lbxEvent + LbxQuickMotionDeltaEvent) {
+ 	*partp = FALSE;
+ 	return 4;
+     }
+     if (req->reqType == server->lbxEvent + LbxMotionDeltaEvent) {
+ 	*partp = FALSE;
+ 	return 8;
+     }
      if (client->awaitingSetup) {
  	if (gotnow < 8) {
  	    *partp = TRUE;
***************
*** 568,573 ****
--- 579,585 ----
      XServerPtr  server = servers[sc->lbxIndex];
      ClientPtr   client = server->recv;
      int         len;
+     int		lbxEventCode;
      Bool        part;
      Bool        cacheable = (server->initialized) ? TRUE : FALSE;
  
***************
*** 606,611 ****
--- 618,624 ----
  	       rep->generic.data1 == LbxSwitchEvent) {
  	cacheable = FALSE;
      }
+ 
      /* stick in delta buffer before LBX code modified things */
      if (cacheable && DELTA_CACHEABLE(&server->indeltas, len)) {
  
***************
*** 615,656 ****
  
  	LBXAddDeltaIn(&server->indeltas, (char *) rep, len);
      }
!     if (rep->generic.type != server->lbxEvent) {
! 	if (!client->awaitingSetup && rep->generic.type == X_Reply) {
! 	    /*
! 	     * Xlib never sends more than one request after a synchronous one
! 	     * (XGetWindowAttributes)
! 	     */
! 	    if (rep->generic.sequenceNumber != client->sequence &&
! 		    rep->generic.sequenceNumber != client->sequence - 1) {
! 		DBG(DBG_CLIENT, (stderr, "sequence number mismatch %d != %d\n",
! 				 rep->generic.sequenceNumber,
! 				 client->sequence));
! 	    }
! 	}
! 	len = RequestLength(rep, sc, 8, &part);
! 	DBG(DBG_IO, (stderr, "upstream %d len %d\n", client->index, len));
! 	if (client->index == 0) {
! 	    ServerReply(server, rep);
! 	} else {
! 	    if (!client->clientGone) {
! 		xEvent      ev;
! 		char       *rp;
! 
! 		if (!client->awaitingSetup &&
! 			UnsquishEvent(rep, &ev, &len)) {
! 		    rp = (char *) &ev;
! 		} else {
! 		    rp = (char *) rep;
! 		}
! 		if (DoLBXReply(client, (char *) rp, len))
! 		    WriteToClient(client, len, rp);
! 		/* flush out any delayed replies that follow this one */
! 		FlushDelayedReply(client, rep->generic.sequenceNumber + 1);
! 	    }
! 	    client->awaitingSetup = FALSE;
! 	}
!     } else {
  	len = sizeof(xLbxEvent);
  	lbx = (xLbxEvent *) rep;
  	switch (lbx->lbxType) {
--- 628,634 ----
  
  	LBXAddDeltaIn(&server->indeltas, (char *) rep, len);
      }
!     if (rep->generic.type == server->lbxEvent) {
  	len = sizeof(xLbxEvent);
  	lbx = (xLbxEvent *) rep;
  	switch (lbx->lbxType) {
***************
*** 686,691 ****
--- 664,855 ----
  	    DBG(DBG_CLIENT, (stderr, "listen to all clients\n"));
  	    LbxListenToAllClients();
  	    break;
+ 	}
+ 
+     } else if ((lbxEventCode = rep->generic.type - server->lbxEvent) &&
+ 	lbxEventCode == LbxQuickMotionDeltaEvent ||
+ 	lbxEventCode == LbxMotionDeltaEvent) {
+ 
+ 	/*
+ 	 * We use the motion delta event to generate a real MotionNotify event.
+ 	 *
+ 	 * The motion cache contains the last motion event we got from
+ 	 * the server.
+ 	 *
+ 	 * The following are always stored in the cache in the proxy's
+ 	 * byte order:
+ 	 *     sequenceNumber, time, rootX, rootY, eventX, eventY
+ 	 * This is because when constructing the MotionNotify event using
+ 	 * the delta event, we must do arithmetic in the proxy's byte order.
+ 	 *
+ 	 * The following are stored in the byte order of the latest client
+ 	 * receiving a motion event (indicated by motionCache->swapped):
+ 	 *     root, event, child, state
+ 	 * The assumption is that a client will receive a series of motion
+ 	 * events, and we don't want to unnecessarily swap these fields.
+ 	 * If the next motion event goes to a client with a byte order
+ 	 * different from the previous client, we will have to swap these
+ 	 * fields.
+ 	 */
+ 
+ 	if (!client->clientGone) {
+ 	    lbxQuickMotionDeltaEvent *qmev = (lbxQuickMotionDeltaEvent *) rep;
+ 	    lbxMotionDeltaEvent *mev = (lbxMotionDeltaEvent *) rep;
+ 	    xEvent ev;
+ 	    char *rp = (char *) &ev;
+ 	    Bool quick = (lbxEventCode == LbxQuickMotionDeltaEvent);
+ 
+ 	    if (motionCache->swapped != client->swapped)
+ 	    {
+ 		int n;
+ 
+ 		swapl (&motionCache->root, n);
+ 		swapl (&motionCache->event, n);
+ 		swapl (&motionCache->child, n);
+ 		swaps (&motionCache->state, n);
+ 
+ 		motionCache->swapped = !motionCache->swapped;
+ 	    }
+ 
+ 	    ev.u.u.type = MotionNotify;
+ 	    ev.u.u.detail = motionCache->detail;
+ 	    ev.u.keyButtonPointer.root = motionCache->root;
+ 	    ev.u.keyButtonPointer.event = motionCache->event;
+ 	    ev.u.keyButtonPointer.child = motionCache->child;
+ 	    ev.u.keyButtonPointer.state = motionCache->state;
+ 	    ev.u.keyButtonPointer.sameScreen = motionCache->sameScreen;
+ 
+ 	    if (quick)
+ 	    {
+ 		ev.u.u.sequenceNumber = motionCache->sequenceNumber;
+ 		ev.u.keyButtonPointer.time = motionCache->time +
+ 		    qmev->deltaTime;
+ 		ev.u.keyButtonPointer.rootX = motionCache->rootX +
+ 		    qmev->deltaX;
+ 		ev.u.keyButtonPointer.rootY = motionCache->rootY +
+ 		    qmev->deltaY;
+ 		ev.u.keyButtonPointer.eventX = motionCache->eventX +
+ 		    qmev->deltaX;
+ 		ev.u.keyButtonPointer.eventY = motionCache->eventY +
+ 		    qmev->deltaY;
+ 	    }
+ 	    else
+ 	    {
+ 		ev.u.u.sequenceNumber = motionCache->sequenceNumber +
+ 		    mev->deltaSequence;
+ 		ev.u.keyButtonPointer.time = motionCache->time +
+ 		    mev->deltaTime;
+ 		ev.u.keyButtonPointer.rootX = motionCache->rootX +
+ 		    mev->deltaX;
+ 		ev.u.keyButtonPointer.rootY = motionCache->rootY +
+ 		    mev->deltaY;
+ 		ev.u.keyButtonPointer.eventX = motionCache->eventX +
+ 		    mev->deltaX;
+ 		ev.u.keyButtonPointer.eventY = motionCache->eventY +
+ 		    mev->deltaY;
+ 	    }
+ 
+ 	    motionCache->sequenceNumber = ev.u.u.sequenceNumber;
+ 	    motionCache->time = ev.u.keyButtonPointer.time;
+ 	    motionCache->rootX = ev.u.keyButtonPointer.rootX;
+ 	    motionCache->rootY = ev.u.keyButtonPointer.rootY;
+ 	    motionCache->eventX = ev.u.keyButtonPointer.eventX;
+ 	    motionCache->eventY = ev.u.keyButtonPointer.eventY;
+ 
+ 	    if (client->swapped)
+ 	    {
+ 		int n;
+ 		swaps (&ev.u.keyButtonPointer.rootX, n);
+ 		swaps (&ev.u.keyButtonPointer.rootY, n);
+ 		swaps (&ev.u.keyButtonPointer.eventX, n);
+ 		swaps (&ev.u.keyButtonPointer.eventY, n);
+ 		swaps (&ev.u.u.sequenceNumber, n);
+ 		swapl (&ev.u.keyButtonPointer.time, n);
+ 	    }
+ 
+ 	    len = 32;
+ 
+ 	    if (DoLBXReply(client, (char *) rp, len))
+ 		WriteToClient(client, len, rp);
+ 	    /* flush out any delayed replies that follow this one */
+ 	    FlushDelayedReply(client, rep->generic.sequenceNumber + 1);
+ 	}
+ 
+     } else {
+ 	if (!client->awaitingSetup && rep->generic.type == X_Reply) {
+ 	    /*
+ 	     * Xlib never sends more than one request after a synchronous one
+ 	     * (XGetWindowAttributes)
+ 	     */
+ #ifdef bogus
+ /* this produces a lot of bad messages, and probably no good ones */
+ 	    if (rep->generic.sequenceNumber != client->sequence &&
+ 		    rep->generic.sequenceNumber != client->sequence - 1) {
+ 		DBG(DBG_CLIENT, (stderr, "sequence number mismatch %d != %d\n",
+ 				 rep->generic.sequenceNumber,
+ 				 client->sequence));
+ 	    }
+ #endif
+ 	}
+ 	len = RequestLength(rep, sc, 8, &part);
+ 	DBG(DBG_IO, (stderr, "upstream %d len %d\n", client->index, len));
+ 	if (client->index == 0) {
+ 	    ServerReply(server, rep);
+ 	} else {
+ 	    if (!client->clientGone) {
+ 		xEvent      ev;
+ 		char       *rp;
+ 
+ 		if (!client->awaitingSetup &&
+ 			UnsquishEvent(rep, &ev, &len)) {
+ 		    rp = (char *) &ev;
+ 		} else {
+ 		    rp = (char *) rep;
+ 		}
+ 
+ 		if (rep->generic.type == MotionNotify) {
+ 		    xEvent *mev = (xEvent *) rp;
+ 
+ 		    motionCache->swapped = client->swapped;
+ 		    motionCache->detail = mev->u.u.detail;
+ 		    motionCache->root = mev->u.keyButtonPointer.root;
+ 		    motionCache->event = mev->u.keyButtonPointer.event;
+ 		    motionCache->child = mev->u.keyButtonPointer.child;
+ 		    motionCache->state = mev->u.keyButtonPointer.state;
+ 		    motionCache->sameScreen=mev->u.keyButtonPointer.sameScreen;
+ 
+ 		    if (client->swapped)
+ 		    {
+ 			cpswaps (mev->u.keyButtonPointer.rootX,
+ 			    motionCache->rootX);
+ 			cpswaps (mev->u.keyButtonPointer.rootY,
+ 			    motionCache->rootY);
+ 			cpswaps (mev->u.keyButtonPointer.eventX,
+ 			    motionCache->eventX);
+ 			cpswaps (mev->u.keyButtonPointer.eventY,
+ 			    motionCache->eventY);
+ 			cpswaps (mev->u.u.sequenceNumber,
+ 			    motionCache->sequenceNumber);
+ 			cpswapl (mev->u.keyButtonPointer.time,
+ 			    motionCache->time);
+ 		    }
+ 		    else
+ 		    {
+ 			motionCache->rootX = mev->u.keyButtonPointer.rootX;
+ 			motionCache->rootY = mev->u.keyButtonPointer.rootY;
+ 			motionCache->eventX = mev->u.keyButtonPointer.eventX;
+ 			motionCache->eventY = mev->u.keyButtonPointer.eventY;
+ 			motionCache->sequenceNumber = mev->u.u.sequenceNumber;
+ 			motionCache->time = mev->u.keyButtonPointer.time;
+ 		    }
+ 		}
+ 
+ 		if (DoLBXReply(client, (char *) rp, len))
+ 		    WriteToClient(client, len, rp);
+ 		/* flush out any delayed replies that follow this one */
+ 		FlushDelayedReply(client, rep->generic.sequenceNumber + 1);
+ 	    }
+ 	    client->awaitingSetup = FALSE;
  	}
      }
  
*** -	Thu May 11 14:13:20 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/props.c	Thu May 11 14:13:20 1995
***************
*** 1,4 ****
! /* $XConsortium: props.c,v 1.6 94/12/01 20:42:57 mor Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
--- 1,4 ----
! /* $XConsortium: props.c,v 1.7 95/05/11 17:38:33 mor Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
***************
*** 389,411 ****
  	    ptd.data = (pointer) &rep[1];
  	    if (!propTagStoreData(tag, len, client->swapped, &ptd)) {
  		/* tell server we lost it */
! 		SendInvalidateTag(client, rep->tag);
  	    }
  	} else {
  
  	    ptdp = (PropertyTagDataPtr) TagGetData(prop_cache, tag);
  	    if (!ptdp) {
  		/* lost data -- ask again for tag value */
  
  		qt.tag = tag;
  		qt.tagtype = LbxTagTypeProperty;
! 		qt.typedata.getprop.offset = nr->request_info.lbxgetprop.offset;
! 		qt.typedata.getprop.length = nr->request_info.lbxgetprop.length;
  		qt.typedata.getprop.ptd = ptd;
  		QueryTag(client, &qt);
  
  		/* XXX what is the right way to stack Queries? */
  		return TRUE;
  	    }
  
  #ifdef LBX_STATS
--- 389,422 ----
  	    ptd.data = (pointer) &rep[1];
  	    if (!propTagStoreData(tag, len, client->swapped, &ptd)) {
  		/* tell server we lost it */
! 		SendInvalidateTag(client, tag);
  	    }
  	} else {
  
  	    ptdp = (PropertyTagDataPtr) TagGetData(prop_cache, tag);
+ 
  	    if (!ptdp) {
  		/* lost data -- ask again for tag value */
  
  		qt.tag = tag;
  		qt.tagtype = LbxTagTypeProperty;
! 		qt.typedata.getprop.offset =
! 		    nr->request_info.lbxgetprop.offset;
! 		qt.typedata.getprop.length =
! 		    nr->request_info.lbxgetprop.length;
  		qt.typedata.getprop.ptd = ptd;
  		QueryTag(client, &qt);
  
  		/* XXX what is the right way to stack Queries? */
  		return TRUE;
+ 
+ 	    } else if (client->swapped) {
+ 		/*
+ 		 * Make a copy, because we will need to swap the property data
+ 		 * and we don't want to alter the tag database.
+ 		 */
+ 		pdata = (pointer) ALLOCATE_LOCAL(ptdp->length);
+ 		bcopy((char *) ptdp->data, (char *) pdata, ptdp->length);
  	    }
  
  #ifdef LBX_STATS
*** -	Thu May 11 14:13:21 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/gfx.c	Thu May 11 14:13:21 1995
***************
*** 1,4 ****
! /* $XConsortium: gfx.c,v 1.13 94/12/01 20:55:35 mor Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
--- 1,4 ----
! /* $XConsortium: gfx.c,v 1.14 95/04/04 21:12:01 dpw Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
***************
*** 749,761 ****
      if (bytes == 0)
  	goto bail;
      /* copy the text elements */
!     bcopy((char *) &stuff[1], after + bytes, stuff->nChars);
      FinishLBXRequest(client, REQ_PASSTHROUGH);
      newreq->reqType = server->lbxReq;
      newreq->lbxReqType = stuff->reqType == X_ImageText8 ? X_LbxImageText8 : X_LbxImageText16;
      newreq->nChars = stuff->nChars;
      GFX_SET_DRAWABLE_AND_GC;
!     len = ((after + bytes + stuff->nChars) - ((char *) newreq));
      extra = pad[len & 3];
      bzero(((char *) newreq) + len, extra);
      len += extra;
--- 749,762 ----
      if (bytes == 0)
  	goto bail;
      /* copy the text elements */
!     bcopy((char *) &stuff[1], after + bytes, len - sz_xImageTextReq);
!     bytes += len - sz_xImageTextReq;
      FinishLBXRequest(client, REQ_PASSTHROUGH);
      newreq->reqType = server->lbxReq;
      newreq->lbxReqType = stuff->reqType == X_ImageText8 ? X_LbxImageText8 : X_LbxImageText16;
      newreq->nChars = stuff->nChars;
      GFX_SET_DRAWABLE_AND_GC;
!     len = ((after + bytes) - ((char *) newreq));
      extra = pad[len & 3];
      bzero(((char *) newreq) + len, extra);
      len += extra;
*** -	Thu May 11 14:13:22 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/lbxutil.c	Thu May 11 14:13:21 1995
***************
*** 1,4 ****
! /* $XConsortium: lbxutil.c,v 1.6 94/12/01 20:52:12 mor Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
--- 1,4 ----
! /* $XConsortium: lbxutil.c,v 1.8 95/05/03 19:07:53 mor Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
***************
*** 356,362 ****
  	    SwapLongs((CARD32 *) tdata, len / 4);
  	    break;
  	case LbxTagTypeFont:
! 	    SwapFont((xQueryFontReply *) tdata, FALSE);
  	    break;
  	case LbxTagTypeConnInfo:
  	    SwapConnectionInfo((xConnSetup *) tdata);
--- 356,363 ----
  	    SwapLongs((CARD32 *) tdata, len / 4);
  	    break;
  	case LbxTagTypeFont:
! 	    LbxSwapFontInfo((xQueryFontReply *) tdata,
! 		qtp->typedata.query_font.compression);
  	    break;
  	case LbxTagTypeConnInfo:
  	    SwapConnectionInfo((xConnSetup *) tdata);
***************
*** 391,399 ****
  			  qtp->typedata.keymap.count,
  			  tdata);
  	break;
!     case LbxTagTypeFont:
  	FinishQueryFontReply(client, rep->sequenceNumber, len, tdata);
  	break;
      case LbxTagTypeConnInfo:
  	FinishSetupReply(client, len, tdata,
  			 qtp->typedata.setup.changes,
--- 392,407 ----
  			  qtp->typedata.keymap.count,
  			  tdata);
  	break;
!     case LbxTagTypeFont: {
! 	int	sqlen = len;
! 	pointer	sqdata = tdata;
! 
! 	len =  UnsquishFontInfo(qtp->typedata.query_font.compression,
! 				sqdata, sqlen, &tdata);
! 	/* XXX may have nasty problem if unsquish fails */
  	FinishQueryFontReply(client, rep->sequenceNumber, len, tdata);
  	break;
+ 	}
      case LbxTagTypeConnInfo:
  	FinishSetupReply(client, len, tdata,
  			 qtp->typedata.setup.changes,
*** -	Wed Dec 31 19:00:00 1969
--- xc/workInProgress/lbx/programs/lbxproxy/di/swap.h	Thu May 11 14:13:23 1995
***************
*** 1,5 ****
  /*
!  * $XConsortium: swap.h,v 1.3 94/12/01 20:41:41 mor Exp $
   *
   * Copyright 1994 Network Computing Devices, Inc.
   *
--- 1,5 ----
  /*
!  * $XConsortium: swap.h,v 1.5 95/05/02 19:07:49 mor Exp $
   *
   * Copyright 1994 Network Computing Devices, Inc.
   *
***************
*** 56,62 ****
--- 56,64 ----
  extern void SwapModmapReply();
  extern void SwapKeymapReply();
  extern void SwapFont();
+ extern void LbxSwapFontInfo();
  extern void SwapGetImageReply();
+ extern void SwapQueryExtensionReply();
  
  extern void WriteSConnectionInfo();
  
*** -	Thu May 11 14:13:23 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/swaprep.c	Thu May 11 14:13:23 1995
***************
*** 1,5 ****
  /*
!  * $XConsortium: swaprep.c,v 1.3 94/12/01 20:53:19 mor Exp $
   *
   * Copyright 1994 Network Computing Devices, Inc.
   *
--- 1,5 ----
  /*
!  * $XConsortium: swaprep.c,v 1.5 95/05/02 19:26:01 mor Exp $
   *
   * Copyright 1994 Network Computing Devices, Inc.
   *
***************
*** 315,328 ****
  }
  
  void
! SwapGetImageReply (rep)
      xGetImageReply *rep;
  {
      char n;
  
!     swaps (&rep->sequenceNumber, n);
!     swapl (&rep->length, n);
!     swapl (&rep->visual, n);
  }
  
  static void
--- 315,338 ----
  }
  
  void
! SwapGetImageReply(rep)
      xGetImageReply *rep;
  {
      char n;
  
!     swaps(&rep->sequenceNumber, n);
!     swapl(&rep->length, n);
!     swapl(&rep->visual, n);
! }
! 
! void
! SwapQueryExtensionReply(rep)
!     xQueryExtensionReply	*rep;
! {
!     char n;
! 
!     swaps(&rep->sequenceNumber, n);
!     swapl(&rep->length, n);
  }
  
  static void
***************
*** 356,361 ****
--- 366,388 ----
      swapl(&pr->nCharInfos, n);
  }
  
+ static void
+ SwapLbxFontInfo(pr)
+     xLbxFontInfo *pr;
+ {
+     register char n;
+ 
+     swaps(&pr->minCharOrByte2, n);
+     swaps(&pr->maxCharOrByte2, n);
+     swaps(&pr->defaultChar, n);
+     swaps(&pr->nFontProps, n);
+     swaps(&pr->fontAscent, n);
+     swaps(&pr->fontDescent, n);
+     SwapCharInfo(&pr->minBounds);
+     SwapCharInfo(&pr->maxBounds);
+     swapl(&pr->nCharInfos, n);
+ }
+ 
  /* native flag specifies whether its usable and we're trying
   * to swap it for external use
   */
***************
*** 393,396 ****
--- 420,458 ----
      pxci = (xCharInfo *) pby;
      for (i = 0; i < nchars; i++, pxci++)
  	SwapCharInfo(pxci);
+ }
+ 
+ void
+ LbxSwapFontInfo(pr, compressed)
+     xLbxFontInfo *pr;
+     Bool	compressed;
+ {
+     unsigned    i;
+     xCharInfo  *pxci;
+     unsigned    nchars,
+                 nprops;
+     char       *pby;
+     register char n;
+ 
+     SwapLbxFontInfo(pr);
+     nchars = pr->nCharInfos;
+     nprops = pr->nFontProps;
+     pby = (char *) &pr[1];
+     /*
+      * Font properties are an atom and either an int32 or a CARD32, so they
+      * are always 2 4 byte values
+      */
+     for (i = 0; i < nprops; i++) {
+ 	swapl(pby, n);
+ 	pby += 4;
+ 	swapl(pby, n);
+ 	pby += 4;
+     }
+     pxci = (xCharInfo *) pby;
+     if (!compressed) {
+ 	for (i = 0; i < nchars; i++, pxci++)
+ 	    SwapCharInfo(pxci);
+     } else {
+ 	SwapLongs((CARD32 *) pxci, nchars);
+     }
  }
*** -	Thu May 11 14:13:25 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/extensions.c	Thu May 11 14:13:24 1995
***************
*** 1,4 ****
! /* $XConsortium: extensions.c,v 1.1 94/12/01 20:39:01 mor Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
--- 1,4 ----
! /* $XConsortium: extensions.c,v 1.2 95/04/04 21:15:16 dpw Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
***************
*** 419,424 ****
--- 419,427 ----
      crep.major_opcode = reply->major_opcode;
      crep.first_event = reply->first_event;
      crep.first_error = reply->first_error;
+     if (client->swapped) {
+ 	SwapQueryExtensionReply(&crep);
+     }
      WriteToClient(client, sizeof(xQueryExtensionReply), (char *) &crep);
  
      return TRUE;
*** -	Thu May 11 14:13:26 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/options.c	Thu May 11 14:13:26 1995
***************
*** 1,4 ****
! /* $XConsortium: options.c,v 1.1 94/12/01 20:39:01 mor Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
--- 1,4 ----
! /* $XConsortium: options.c,v 1.2 95/04/04 21:41:07 dpw Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
***************
*** 150,155 ****
--- 150,156 ----
  	preply += len;
  	replylen -= len;
      }
+     return 0;
  }
  
  struct deltaOpt {
*** -	Thu May 11 14:13:33 1995
--- xc/workInProgress/lbx/programs/Xserver/lbx/lbxmain.c	Thu May 11 14:13:33 1995
***************
*** 1,4 ****
! /* $XConsortium: lbxmain.c,v 1.14 94/12/01 20:30:50 mor Exp $ */
  /*
   * $NCDId: @(#)lbxmain.c,v 1.61 1994/11/18 20:32:36 lemke Exp $
   * $NCDOr: lbxmain.c,v 1.4 1993/12/06 18:47:18 keithp Exp keithp $
--- 1,4 ----
! /* $XConsortium: lbxmain.c,v 1.20 95/05/11 17:44:13 mor Exp $ */
  /*
   * $NCDId: @(#)lbxmain.c,v 1.61 1994/11/18 20:32:36 lemke Exp $
   * $NCDOr: lbxmain.c,v 1.4 1993/12/06 18:47:18 keithp Exp keithp $
***************
*** 91,96 ****
--- 91,97 ----
  static unsigned char LbxReqCode;
  int 	LbxEventCode;
  static int BadLbxClientCode;
+ static int	nextFreeProxyID = 1;
  
  extern int  LzwWriteV (), LzwRead ();
  extern void LzwCompressOn (), LzwCompressOff ();
***************
*** 107,117 ****
--- 108,130 ----
  extern ClientPtr	ReadingClient, WritingClient;
  
  #ifndef NDEBUG
+ /*
  int lbxDebug = DBG_CLIENT|DBG_SWITCH;
+ */
+ int lbxDebug = 0;
  
  #define LbxSequence(i)	lbxClients[i]->client->sequence
  #endif
  
+ #define ABS(_x) ((_x) < 0.0 ? -(_x) : (_x))
+ 
+ /*
+  * XXX - The motion cache should be per-proxy.  But at the time this
+  *       code was written, the LBX SI did not have per-proxy data.
+  */
+ 
+ static lbxMotionCache *motionCache;
+ 
  void
  LbxExtensionInit()
  {
***************
*** 120,125 ****
--- 133,139 ----
      lbxBlockHandlerCount = 0;
      lbxCompressWorkProcCount = 0;
      proxyList = NULL;
+     nextFreeProxyID = 1;
      if ((extEntry = AddExtension(LBXNAME, LbxNumberEvents, LbxNumberErrors,
  				 ProcLbxDispatch, SProcLbxDispatch,
  				 LbxResetProc, StandardMinorOpcode)))
***************
*** 129,134 ****
--- 143,150 ----
  	BadLbxClientCode = extEntry->errorBase;
  	EventSwapVector[LbxEventCode] = SLbxEvent;
          LbxDixInit();
+ 	motionCache = (lbxMotionCache *) xalloc (sizeof (lbxMotionCache));
+ 	bzero (motionCache, sizeof (lbxMotionCache));
      }
  }
  
***************
*** 137,142 ****
--- 153,159 ----
  LbxResetProc (extEntry)
  ExtensionEntry	*extEntry;
  {
+    xfree(motionCache);
     LbxResetTags();
  }
  
***************
*** 207,214 ****
      else
      {
  	xReply    *reply = (xReply *) buf;
  
- 	lbxClient->reply_remaining = LbxEventLength(proxy, (xEvent *) buf);
  	if (reply->generic.type == X_Reply) {
  	    int   len = reply->generic.length;
  	    int	  n;
--- 224,238 ----
      else
      {
  	xReply    *reply = (xReply *) buf;
+ 	xEvent	  *ev = (xEvent *) buf;
+ 
+ 	if (ev->u.u.type == LbxEventCode + LbxQuickMotionDeltaEvent)
+ 	    lbxClient->reply_remaining = 4;
+ 	else if (ev->u.u.type == LbxEventCode + LbxMotionDeltaEvent)
+ 	    lbxClient->reply_remaining = 8;
+ 	else
+ 	    lbxClient->reply_remaining = LbxSquishedEventLength (proxy, ev);
  
  	if (reply->generic.type == X_Reply) {
  	    int   len = reply->generic.length;
  	    int	  n;
***************
*** 400,406 ****
  		if (proxy->curSend->awaiting_setup) {
  		    swaps(&csp->length, n);
  		} else {
! 		    swapl(&buf->length, n);
  		}
  	    }
  	    if (proxy->curSend->awaiting_setup)
--- 424,434 ----
  		if (proxy->curSend->awaiting_setup) {
  		    swaps(&csp->length, n);
  		} else {
! 		    if (buf->type != LbxEventCode + LbxQuickMotionDeltaEvent &&
! 			buf->type != LbxEventCode + LbxMotionDeltaEvent)
! 		    {
! 			swapl(&buf->length, n);
! 		    }
  		}
  	    }
  	    if (proxy->curSend->awaiting_setup)
***************
*** 924,940 ****
   * have to copy data off into pending buffer 
   */
  void
! LbxResetCurrentRequest(client)
      ClientPtr	client;
  {
      LbxClientPtr lbxClient = LbxClient(client);
-     LbxProxyPtr proxy;
-     xReq       *req = (xReq *) client->requestBuffer;
  
      if (lbxClient) {
! 	proxy = lbxClient->proxy;
! 	AppendFakeRequest(client, client->requestBuffer, req->length * 4);
! 
  	++proxy->curRecv->reqs_pending;
  	if (!proxy->curRecv->input_blocked) {
  	    proxy->curRecv->input_blocked = TRUE;
--- 952,966 ----
   * have to copy data off into pending buffer 
   */
  void
! LbxResetCurrentRequest(client, len)
      ClientPtr	client;
+     int		len;
  {
      LbxClientPtr lbxClient = LbxClient(client);
  
      if (lbxClient) {
! 	LbxProxyPtr proxy = lbxClient->proxy;
! 	AppendFakeRequest(client, client->requestBuffer, len);
  	++proxy->curRecv->reqs_pending;
  	if (!proxy->curRecv->input_blocked) {
  	    proxy->curRecv->input_blocked = TRUE;
***************
*** 962,967 ****
--- 988,1138 ----
  	lbxClient->bytes_in_reply -= sizeof(xEvent);
  	return Success;
      }
+ 
+     if (ev->u.u.type == MotionNotify) {
+ 	/*
+ 	 * Check if we can generate a motion delta event.
+ 	 *
+ 	 * The motion cache contains the last motion event the server sent.
+ 	 *
+ 	 * The following are always stored in the cache in the server's
+ 	 * byte order:
+ 	 *     sequenceNumber, time, rootX, rootY, eventX, eventY
+ 	 * This is because when determining if we can do a delta, all
+ 	 * arithmetic must be done using the server's byte order.
+ 	 *
+ 	 * The following are stored in the byte order of the latest client
+ 	 * receiving a motion event (indicated by motionCache->swapped):
+ 	 *     root, event, child, state
+ 	 * These fields do not need to be stored in the server's byte order
+ 	 * because we only use the '==' operator on them.
+ 	 */
+ 
+ 	Bool motionDeltaGenerated = 0;
+ 	Bool swapCache;
+ 	xEvent tev, *sev;
+ 
+ 	if (!lbxClient->client->swapped)
+ 	{
+ 	    swapCache = motionCache->swapped;
+ 	    sev = ev;
+ 	}
+ 	else
+ 	{
+ 	    swapCache = !motionCache->swapped;
+ 	    sev = &tev;
+ 	    cpswaps (ev->u.keyButtonPointer.rootX,
+ 	        sev->u.keyButtonPointer.rootX);
+ 	    cpswaps (ev->u.keyButtonPointer.rootY,
+ 		sev->u.keyButtonPointer.rootY);
+ 	    cpswaps (ev->u.keyButtonPointer.eventX,
+ 		sev->u.keyButtonPointer.eventX);
+ 	    cpswaps (ev->u.keyButtonPointer.eventY,
+ 		sev->u.keyButtonPointer.eventY);
+ 	    cpswaps (ev->u.u.sequenceNumber,
+ 		sev->u.u.sequenceNumber);
+ 	    cpswapl (ev->u.keyButtonPointer.time,
+ 		sev->u.keyButtonPointer.time);
+ 	}
+ 
+ 	if (swapCache)
+ 	{
+ 	    int n;
+ 
+ 	    swapl (&motionCache->root, n);
+ 	    swapl (&motionCache->event, n);
+ 	    swapl (&motionCache->child, n);
+ 	    swaps (&motionCache->state, n);
+ 
+ 	    motionCache->swapped = !motionCache->swapped;
+ 	}
+ 
+ 	if (ev->u.u.detail == motionCache->detail &&
+ 	    ev->u.keyButtonPointer.root == motionCache->root &&
+ 	    ev->u.keyButtonPointer.event == motionCache->event &&
+ 	    ev->u.keyButtonPointer.child == motionCache->child &&
+ 	    ev->u.keyButtonPointer.state == motionCache->state &&
+ 	    ev->u.keyButtonPointer.sameScreen == motionCache->sameScreen) {
+ 
+ 	    int root_delta_x =
+ 		sev->u.keyButtonPointer.rootX - motionCache->rootX;
+ 	    int root_delta_y =
+ 		sev->u.keyButtonPointer.rootY - motionCache->rootY;
+ 	    int event_delta_x =
+ 		sev->u.keyButtonPointer.eventX - motionCache->eventX;
+ 	    int event_delta_y =
+ 		sev->u.keyButtonPointer.eventY - motionCache->eventY;
+ 	    unsigned long sequence_delta =
+ 		sev->u.u.sequenceNumber - motionCache->sequenceNumber;
+ 	    unsigned long time_delta =
+ 		sev->u.keyButtonPointer.time - motionCache->time;
+ 
+ 	    if (root_delta_x == event_delta_x && ABS(event_delta_x) <= 128 &&
+ 		root_delta_y == event_delta_y && ABS(event_delta_y) <= 128) {
+ 
+ 		if (sequence_delta == 0 && time_delta <= 256) {
+ 
+ 		    lbxQuickMotionDeltaEvent *mev =
+ 			(lbxQuickMotionDeltaEvent *) evbuf;
+ 
+ 		    mev->type = LbxEventCode + LbxQuickMotionDeltaEvent;
+ 		    mev->deltaTime = time_delta;
+ 		    mev->deltaX = event_delta_x;
+ 		    mev->deltaY = event_delta_y;
+ 
+ 		    len = 4;
+ 		    bp = evbuf;
+ 
+ 		    motionDeltaGenerated = 1;
+ 
+ 		} else if (sequence_delta <= 65536 && time_delta <= 65536) {
+ 
+ 		    lbxMotionDeltaEvent *mev = (lbxMotionDeltaEvent *) evbuf;
+ 
+ 		    mev->type = LbxEventCode + LbxMotionDeltaEvent;
+ 		    mev->deltaTime = time_delta;
+ 		    mev->deltaSequence = sequence_delta;
+ 		    mev->deltaX = event_delta_x;
+ 		    mev->deltaY = event_delta_y;
+ 
+ 		    if (proxy->lbxClients[0]->client->swapped)
+ 		    {
+ 			int n;
+ 			swaps (&mev->deltaTime, n);
+ 			swaps (&mev->deltaSequence, n);
+ 		    }
+ 
+ 		    len = 8;
+ 		    bp = evbuf;
+ 
+ 		    motionDeltaGenerated = 1;
+ 		}
+ 	    }
+ 	}
+ 
+ 	motionCache->sequenceNumber = sev->u.u.sequenceNumber;
+ 	motionCache->time = sev->u.keyButtonPointer.time;
+ 	motionCache->rootX = sev->u.keyButtonPointer.rootX;
+ 	motionCache->rootY = sev->u.keyButtonPointer.rootY;
+ 	motionCache->eventX = sev->u.keyButtonPointer.eventX;
+ 	motionCache->eventY = sev->u.keyButtonPointer.eventY;
+ 
+ 	if (motionDeltaGenerated) {
+ 	    lbxClient->bytes_in_reply -= sizeof(xEvent);
+ 	    lbxAnyOutputPending = TRUE;
+ 
+ 	    return (*lbxClient->uncompressedWriteToClient) (client, len, bp);
+ 	}
+ 	else {
+ 	    motionCache->detail = ev->u.u.detail;
+ 	    motionCache->root = ev->u.keyButtonPointer.root;
+ 	    motionCache->event = ev->u.keyButtonPointer.event;
+ 	    motionCache->child = ev->u.keyButtonPointer.child;
+ 	    motionCache->state = ev->u.keyButtonPointer.state;
+ 	    motionCache->sameScreen = ev->u.keyButtonPointer.sameScreen;
+ 	}
+     }
+ 
      if (proxy->dosquishing) {
  	len = LbxSquishEvent(proxy, ev, evbuf);
  	bp = evbuf;
***************
*** 1103,1108 ****
--- 1274,1281 ----
  #ifdef notused
      client->public.requestLength = LbxRequestLength;
  #endif
+     lbxClient->gfx_buffer = (pointer) NULL;
+     lbxClient->gb_size = 0;
      return TRUE;
  }
  
***************
*** 1130,1135 ****
--- 1303,1309 ----
      --proxy->numClients;
      proxy->lbxClients[lbxClient->index] = 0;
      lbxClients[client->index] = 0;
+     xfree(lbxClient->gfx_buffer);
      client->public.writeToClient = lbxClient->writeToClient;
      client->public.readRequest = lbxClient->readRequest;
      xfree (lbxClient);
***************
*** 1155,1160 ****
--- 1329,1336 ----
  	    break;
  	}
      }
+     if (proxy->pid < nextFreeProxyID)
+ 	nextFreeProxyID = proxy->pid;
      xfree (proxy);
  }
  
***************
*** 1256,1261 ****
--- 1432,1465 ----
      return writev(fd, iov, iovcnt);
  }
  
+ static int
+ NextProxyID()
+ {
+     LbxProxyPtr proxy = proxyList;
+     int         id;
+     Bool        hit;
+ 
+     if (!proxy) {
+ 	nextFreeProxyID = 1;
+ 	return nextFreeProxyID++;
+     }
+     for (id = 0; id < MAX_NUM_PROXIES; id++) {
+ 	hit = FALSE;
+ 	while (proxy) {
+ 	    if (proxy->pid == id) {
+ 		hit = TRUE;
+ 		break;
+ 	    }
+ 	    proxy = proxy->next;
+ 	}
+ 	if (!hit) {
+ 	    nextFreeProxyID = id;
+ 	    return id;
+ 	}
+     }
+     return -1;
+ }
+ 
  int
  ProcLbxStartProxy(client)
      register ClientPtr	client;
***************
*** 1277,1284 ****
  	return BadAlloc;
      bzero(proxy, sizeof (LbxProxyRec));
      proxy->next = proxyList;
!     proxy->pid = client->index;	/* XXX have to be sure this doesn't go over
!     				 * MAX_NUM_PROXIES */
      proxyList = proxy;
  
      /*
--- 1481,1491 ----
  	return BadAlloc;
      bzero(proxy, sizeof (LbxProxyRec));
      proxy->next = proxyList;
!     proxy->pid = NextProxyID();
!     if (proxy->pid < 0) {	/* too many proxies */
! 	LbxFreeProxy(proxy);
! 	return BadAlloc;
!     }
      proxyList = proxy;
  
      /*
***************
*** 1451,1463 ****
      LbxSwitchRecv (proxy, proxy->lbxClients[stuff->client]);
      return Success;
  }
!     
  int
  ProcLbxNewClient(client)
      register ClientPtr client;
  {
      REQUEST(xLbxNewClientReq);
!     ClientPtr	    newClient, AllocNewConnection ();
      LbxProxyPtr	    proxy = LbxMaybeProxy(client);
      LbxClientPtr    newLbxClient;
      int		    c;
--- 1658,1670 ----
      LbxSwitchRecv (proxy, proxy->lbxClients[stuff->client]);
      return Success;
  }
! 
  int
  ProcLbxNewClient(client)
      register ClientPtr client;
  {
      REQUEST(xLbxNewClientReq);
!     ClientPtr	    newClient;
      LbxProxyPtr	    proxy = LbxMaybeProxy(client);
      LbxClientPtr    newLbxClient;
      int		    c;
***************
*** 1476,1486 ****
  	return BadAlloc;
      bcopy ((char *)&stuff[1], setupbuf, len);
  
!     newClient = AllocNewConnection (
! #ifndef NCD	/* R6-ism */
!     ClientTransportObject(client),
! #endif
! 				    ClientConnectionNumber (client), 
  				    LbxRead, LbxWritev, LbxCloseClient);
      if (!newClient)
  	return BadAlloc;
--- 1683,1689 ----
  	return BadAlloc;
      bcopy ((char *)&stuff[1], setupbuf, len);
  
!     newClient = AllocPiggybackConnection (client,
  				    LbxRead, LbxWritev, LbxCloseClient);
      if (!newClient)
  	return BadAlloc;
***************
*** 1519,1527 ****
  	reason = "Protocol version mismatch";
      else
  	reason = ClientAuthorized(client,
! 				  (unsigned short)prefix->nbytesAuthProto,
  				  auth_proto,
! 				  (unsigned short)prefix->nbytesAuthString,
  				  auth_string);
      /*
       * if auth protocol does some magic, fall back through to the
--- 1722,1730 ----
  	reason = "Protocol version mismatch";
      else
  	reason = ClientAuthorized(client,
! 				  prefix->nbytesAuthProto,
  				  auth_proto,
! 				  prefix->nbytesAuthString,
  				  auth_string);
      /*
       * if auth protocol does some magic, fall back through to the
*** -	Thu May 11 14:13:34 1995
--- xc/workInProgress/lbx/programs/Xserver/lbx/lbxdix.c	Thu May 11 14:13:34 1995
***************
*** 1,4 ****
! /* $XConsortium: lbxdix.c,v 1.7 94/12/01 20:29:36 mor Exp $ */
  /*
   * Copyright 1993 Network Computing Devices, Inc.
   *
--- 1,4 ----
! /* $XConsortium: lbxdix.c,v 1.8 95/05/02 19:39:39 mor Exp $ */
  /*
   * Copyright 1993 Network Computing Devices, Inc.
   *
***************
*** 426,437 ****
      }
  }
  
  int
  LbxQueryFont(client)
      ClientPtr   client;
  {
!     xQueryFontReply *reply,
!                *sreply = NULL;
      xLbxQueryFontReply lbxrep;
      FontPtr     pFont;
      register GC *pGC;
--- 426,560 ----
      }
  }
  
+ /* counts number of bits needed to hold value */
+ static int
+ _bitsize(val)
+     int         val;
+ {
+     int         bits = 1;  /* always need one for sign bit */
+ 
+     if (val == 0)
+ 	return (bits);
+ 
+     if (val < 0) {
+ 	val = -val;
+     }
+     while (val) {
+ 	bits++;
+ 	val >>= 1;
+     }
+ 
+     return bits;
+ 
+ }
+ 
+ /*
+  * squashes the font (if possible), returning the new length and
+  * a pointer to the new data (which has been allocated).  if it can't
+  * squish, it just returns a 0 and the data is sent in raw form.
+  */
+ int  _lbx_fi_junklen = sizeof(BYTE) * 2 + sizeof(CARD16) + sizeof(CARD32);
+ 
+ static int
+ squish_font_info(qfr, rlen, sqrep)
+     xQueryFontReply *qfr;
+     int         rlen;
+     xLbxFontInfo **sqrep;
+ {
+     int         len,
+                 hlen;
+     xLbxFontInfo *new;
+     xCharInfo  *minb,
+                *maxb,
+ 		*ci,
+                 bbox;
+     int         i;
+     char	*t;
+     xLbxCharInfo *chars;
+     int	num_chars;
+ 
+     num_chars = qfr->nCharInfos;
+ 
+     if (num_chars == 0)
+ 	return 0;
+ 
+     minb = &qfr->minBounds;
+     maxb = &qfr->maxBounds;
+     /*
+      * first do the quick check -- if the attribute fields aren't all the
+      * same, punt
+      */
+ 
+     if (minb->attributes != maxb->attributes)
+ 	return 0;
+ 
+ #define	compute(field)	\
+     bbox.field = max(_bitsize(minb->field), _bitsize(maxb->field))
+ 
+     compute(characterWidth);
+     compute(leftSideBearing);
+     compute(rightSideBearing);
+     compute(ascent);
+     compute(descent);
+ 
+ #undef compute
+ 
+     /* make sure it fits */
+     if (!((bbox.characterWidth <= LBX_WIDTH_BITS) &&
+ 	  (bbox.leftSideBearing <= LBX_LEFT_BITS) &&
+ 	  (bbox.rightSideBearing <= LBX_RIGHT_BITS) &&
+ 	  (bbox.ascent <= LBX_ASCENT_BITS) &&
+ 	  (bbox.descent <= LBX_DESCENT_BITS))) {
+ 	return 0;
+     }
+ 
+     hlen = sizeof(xLbxFontInfo) + qfr->nFontProps * sizeof(xFontProp);
+ 
+     len = hlen + (num_chars * sizeof(xLbxCharInfo));
+ 
+     new = (xLbxFontInfo *) xalloc(len);
+     if (!new)
+ 	return 0;
+ 
+     /* gross hack to avoid copying all the fields */
+     t = (char *) qfr;
+     t += _lbx_fi_junklen;
+ 
+     /* copy all but the char infos */
+     bcopy((char *) t, (char *) new, hlen);
+ 
+     t = (char *) new;
+     t += hlen;
+     chars = (xLbxCharInfo *) t;
+ 
+     t = (char *) qfr;
+     t += sizeof(xQueryFontReply) + qfr->nFontProps * sizeof(xFontProp);
+     ci = (xCharInfo *) t;
+ 
+     /* now copy & pack the charinfos */
+     for (i = 0; i < num_chars; i++, chars++, ci++) {
+ 	chars->metrics = 0;
+ 	chars->metrics |= (LBX_MASK_BITS(ci->characterWidth, LBX_WIDTH_BITS)
+ 			   << LBX_WIDTH_SHIFT);
+ 	chars->metrics |= (LBX_MASK_BITS(ci->leftSideBearing, LBX_LEFT_BITS)
+ 			   << LBX_LEFT_SHIFT);
+ 	chars->metrics |= (LBX_MASK_BITS(ci->rightSideBearing, LBX_RIGHT_BITS)
+ 			   << LBX_RIGHT_SHIFT);
+ 	chars->metrics |= (LBX_MASK_BITS(ci->ascent, LBX_ASCENT_BITS)
+ 			   << LBX_ASCENT_SHIFT);
+ 	chars->metrics |= (LBX_MASK_BITS(ci->descent, LBX_DESCENT_BITS)
+ 			   << LBX_DESCENT_SHIFT);
+     }
+ 
+     *sqrep = new;
+     return len;
+ }
+ 
  int
  LbxQueryFont(client)
      ClientPtr   client;
  {
!     xQueryFontReply *reply;
      xLbxQueryFontReply lbxrep;
      FontPtr     pFont;
      register GC *pGC;
***************
*** 441,446 ****
--- 564,572 ----
      TagData     td = NULL;
      XID         tid;
      FontTagInfoPtr ftip;
+     int         sqlen = 0;
+     xLbxFontInfo *sqrep,
+                *sreply = NULL;
  
      REQUEST(xLbxQueryFontReq);
  
***************
*** 483,492 ****
  	free_data = TRUE;
  	send_data = TRUE;
  	QueryFont(pFont, reply, nprotoxcistructs);
      } else {			/* just get data from tag */
  	ftip = (FontTagInfoPtr) td->tdata;
! 	reply = ftip->replydata;
! 	rlength = ftip->size;
      }
  
      if (!td) {
--- 609,633 ----
  	free_data = TRUE;
  	send_data = TRUE;
  	QueryFont(pFont, reply, nprotoxcistructs);
+ 
+ 	sqlen = squish_font_info(reply, rlength, &sqrep);
+ 	if (!sqlen) {		/* if it failed to squish, send it raw */
+ 	    char *t;
+ 
+ 	    lbxrep.compression = 0;
+ 
+ 	    sqlen = rlength - _lbx_fi_junklen;
+ 	    t = (char *) reply;
+ 	    sqrep = (xLbxFontInfo *) (t + _lbx_fi_junklen);
+ 	} else {
+ 	    lbxrep.compression = 1;
+ 	    xfree(reply);	/* no longer needed */
+ 	}
      } else {			/* just get data from tag */
  	ftip = (FontTagInfoPtr) td->tdata;
! 	sqrep = ftip->fontinfo;
! 	sqlen = ftip->size;
! 	lbxrep.compression = ftip->compression;
      }
  
      if (!td) {
***************
*** 499,512 ****
  	    FontSetPrivate(pFont, lbx_font_private, (pointer) td);
  	    ftip = (FontTagInfoPtr) td->tdata;
  	    ftip->pfont = pFont;
! 	    ftip->size = rlength;
! 	    ftip->replydata = reply;
  	    free_data = FALSE;
  	} else {
  	    xfree(ftip);
  	}
      }
      if (td) {
  	TagMarkProxy(td->tid, LbxProxyID(client));
  	lbxrep.tag = td->tid;
      } else {
--- 640,656 ----
  	    FontSetPrivate(pFont, lbx_font_private, (pointer) td);
  	    ftip = (FontTagInfoPtr) td->tdata;
  	    ftip->pfont = pFont;
! 	    ftip->size = sqlen;
! 	    ftip->fontinfo = sqrep;
! 	    ftip->compression = lbxrep.compression;
  	    free_data = FALSE;
  	} else {
  	    xfree(ftip);
  	}
      }
      if (td) {
+ 	if (!TagProxyMarked(td->tid, LbxProxyID(client)))
+ 	    send_data = TRUE;
  	TagMarkProxy(td->tid, LbxProxyID(client));
  	lbxrep.tag = td->tid;
      } else {
***************
*** 517,523 ****
      lbxrep.type = X_Reply;
      lbxrep.sequenceNumber = client->sequence;
      if (send_data)
! 	lbxrep.length = rlength >> 2;
      else
  	lbxrep.length = 0;
  
--- 661,667 ----
      lbxrep.type = X_Reply;
      lbxrep.sequenceNumber = client->sequence;
      if (send_data)
! 	lbxrep.length = sqlen >> 2;
      else
  	lbxrep.length = 0;
  
***************
*** 527,544 ****
  	swaps(&lbxrep.sequenceNumber, n);
  	swapl(&lbxrep.length, n);
  	swapl(&lbxrep.tag, n);
! 	sreply = (xQueryFontReply *) ALLOCATE_LOCAL(rlength);
  	if (!sreply)
  	    return BadAlloc;
! 	bcopy((char *) reply, (char *) sreply, rlength);
! 	SwapFont((xQueryFontReply *) sreply, TRUE);
! 	reply = sreply;
      }
      WriteToClient(client, sizeof(xLbxQueryFontReply), (char *) &lbxrep);
      if (send_data)
! 	WriteToClient(client, rlength, reply);
      if (free_data)
! 	xfree(reply);
      if (sreply)
  	DEALLOCATE_LOCAL(sreply);
      return (client->noClientException);
--- 671,688 ----
  	swaps(&lbxrep.sequenceNumber, n);
  	swapl(&lbxrep.length, n);
  	swapl(&lbxrep.tag, n);
! 	sreply = (xLbxFontInfo *) ALLOCATE_LOCAL(sqlen);
  	if (!sreply)
  	    return BadAlloc;
! 	bcopy((char *) sqrep, (char *) sreply, sqlen);
! 	LbxSwapFontInfo(sreply, lbxrep.compression);
! 	sqrep = sreply;
      }
      WriteToClient(client, sizeof(xLbxQueryFontReply), (char *) &lbxrep);
      if (send_data)
! 	WriteToClient(client, sqlen, sqrep);
      if (free_data)
! 	xfree(sqrep);
      if (sreply)
  	DEALLOCATE_LOCAL(sreply);
      return (client->noClientException);
***************
*** 569,574 ****
--- 713,719 ----
      unsigned long size;
      pointer     data;
      pointer     sdata = NULL;
+     int         compression;
  
      td = TagGetTag(tag);
  
***************
*** 582,588 ****
  	if (td->data_type == LbxTagTypeFont) {
  	    ftip = (FontTagInfoPtr) td->tdata;
  	    size = ftip->size;
! 	    data = (pointer) ftip->replydata;
  	} else if (td->data_type == LbxTagTypeProperty) {
  	    size = td->size;
  	    data = td->tdata;
--- 727,734 ----
  	if (td->data_type == LbxTagTypeFont) {
  	    ftip = (FontTagInfoPtr) td->tdata;
  	    size = ftip->size;
! 	    data = (pointer) ftip->fontinfo;
! 	    compression = ftip->compression;
  	} else if (td->data_type == LbxTagTypeProperty) {
  	    size = td->size;
  	    data = td->tdata;
***************
*** 608,614 ****
  	    SwapLongs((CARD32 *) sdata, rep.real_length / 4);
  	    break;
  	case LbxTagTypeFont:
! 	    SwapFont((xQueryFontReply *) sdata, TRUE);
  	    break;
  	case LbxTagTypeProperty:
  	    switch (td->data_format) {
--- 754,760 ----
  	    SwapLongs((CARD32 *) sdata, rep.real_length / 4);
  	    break;
  	case LbxTagTypeFont:
! 	    LbxSwapFontInfo((xQueryFontReply *) sdata, compression);
  	    break;
  	case LbxTagTypeProperty:
  	    switch (td->data_format) {
*** -	Wed Dec 31 19:00:00 1969
--- xc/workInProgress/lbx/programs/Xserver/lbx/lbxtags.c	Thu May 11 14:13:34 1995
***************
*** 1,4 ****
! /* $XConsortium: lbxtags.c,v 1.5 94/03/27 13:11:47 dpw Exp $ */
  /*
   * Copyright 1993 Network Computing Devices, Inc.
   *
--- 1,4 ----
! /* $XConsortium: lbxtags.c,v 1.6 95/05/02 19:36:04 mor Exp $ */
  /*
   * Copyright 1993 Network Computing Devices, Inc.
   *
***************
*** 49,61 ****
  {
      TagData     td = (TagData) data;
      FontTagInfoPtr	ftip;
  
      /* some types need to be freed, others are shared */
      if (td->data_type == LbxTagTypeFont) {
  	/* remove any back links */
  	ftip = (FontTagInfoPtr) td->tdata;
  	FontSetPrivate(ftip->pfont, lbx_font_private, (pointer) 0);
! 	xfree(ftip->replydata);
  	xfree(ftip);
      }
      xfree(data);
--- 49,66 ----
  {
      TagData     td = (TagData) data;
      FontTagInfoPtr	ftip;
+     char *t;
+     extern int	_lbx_fi_junklen;
  
      /* some types need to be freed, others are shared */
      if (td->data_type == LbxTagTypeFont) {
  	/* remove any back links */
  	ftip = (FontTagInfoPtr) td->tdata;
  	FontSetPrivate(ftip->pfont, lbx_font_private, (pointer) 0);
! 	t = (char *) ftip->fontinfo;
! 	if (!ftip->compression)	/* points to xQueryFont, so back up to it */
! 	    t -= _lbx_fi_junklen;
! 	xfree(t);
  	xfree(ftip);
      }
      xfree(data);
*** -	Wed Dec 31 19:00:00 1969
--- xc/workInProgress/lbx/programs/Xserver/lbx/lbxserve.h	Thu May 11 14:13:35 1995
***************
*** 1,4 ****
! /* $XConsortium: lbxserve.h,v 1.5 94/12/01 20:28:45 mor Exp $ */
  /*
   * $NCDId: @(#)lbxserve.h,v 1.17 1994/11/18 20:32:38 lemke Exp $
   * $NCDOr: lbxserve.h,v 1.1 1993/12/06 18:47:18 keithp Exp $
--- 1,4 ----
! /* $XConsortium: lbxserve.h,v 1.6 95/04/04 21:21:49 dpw Exp $ */
  /*
   * $NCDId: @(#)lbxserve.h,v 1.17 1994/11/18 20:32:38 lemke Exp $
   * $NCDOr: lbxserve.h,v 1.1 1993/12/06 18:47:18 keithp Exp $
***************
*** 25,36 ****
--- 25,39 ----
   * Author:  Keith Packard, Network Computing Devices
   */
  
+ #ifndef _LBXSERVE_H_
+ #define _LBXSERVE_H_
  /* XXX only handles one LBX connection right now */
  #include "lbxdeltastr.h"
  #define _XLBX_SERVER_
  #include "lbxstr.h"
  
  #define MAX_LBX_CLIENTS	MAXCLIENTS
+ #define	MAX_NUM_PROXIES	8
  
  typedef struct _LbxClient *LbxClientPtr;
  typedef struct _LbxProxy *LbxProxyPtr;
***************
*** 52,57 ****
--- 55,62 ----
      int         (*uncompressedWriteToClient) ();
      Drawable	drawableCache[GFX_CACHE_SIZE];
      GContext	gcontextCache[GFX_CACHE_SIZE];
+     pointer	gfx_buffer;	/* tmp buffer for unpacking gfx requests */
+     unsigned long	gb_size;
  }           LbxClientRec;
  
  typedef struct _LbxProxy {
***************
*** 91,93 ****
--- 96,99 ----
  
  extern void LbxDixInit();
  extern LbxProxyPtr LbxPidToProxy();
+ #endif				/* _LBXSERVE_H_ */
*** -	Thu May 11 14:13:36 1995
--- xc/workInProgress/lbx/programs/Xserver/lbx/lbxtags.h	Thu May 11 14:13:36 1995
***************
*** 1,4 ****
! /* $XConsortium: lbxtags.h,v 1.4 94/03/27 13:13:40 dpw Exp $ */
  /*
   * Copyright 1993 Network Computing Devices, Inc.
   *
--- 1,4 ----
! /* $XConsortium: lbxtags.h,v 1.5 95/04/04 21:23:52 dpw Exp $ */
  /*
   * Copyright 1993 Network Computing Devices, Inc.
   *
***************
*** 25,38 ****
  
  #ifndef _LBXTAGS_H_
  #define _LBXTAGS_H_
  
  #include	"os.h"
  #include	"opaque.h"
  #include	"resource.h"
  #include	"X.h"
  #include	"Xproto.h"
- 
- #define	MAX_NUM_PROXIES	8	/* XXX should be elsewhere */
  
  typedef struct _tagdata {
      XID         tid;
--- 25,37 ----
  
  #ifndef _LBXTAGS_H_
  #define _LBXTAGS_H_
+ #include	"lbxserve.h"
  
  #include	"os.h"
  #include	"opaque.h"
  #include	"resource.h"
  #include	"X.h"
  #include	"Xproto.h"
  
  typedef struct _tagdata {
      XID         tid;
*** -	Thu May 11 14:13:37 1995
--- xc/workInProgress/lbx/programs/Xserver/lbx/lbxgfx.c	Thu May 11 14:13:36 1995
***************
*** 1,4 ****
! /* $XConsortium: lbxgfx.c,v 1.13 94/12/01 20:32:26 mor Exp $ */
  /*
   * Copyright 1993 Network Computing Devices, Inc.
   *
--- 1,4 ----
! /* $XConsortium: lbxgfx.c,v 1.14 95/04/04 21:25:44 dpw Exp $ */
  /*
   * Copyright 1993 Network Computing Devices, Inc.
   *
***************
*** 461,466 ****
--- 461,485 ----
      return (*ProcVector[X_CopyPlane])(client);
  }
  
+ static pointer
+ get_gfx_buffer(client, len)
+     ClientPtr	client;
+     int		len;
+ {
+     LbxClientPtr    lbxClient = LbxClient(client);
+     pointer	tmp;
+ 
+     /* XXX should probably shrink this sucker too */
+     if (len > lbxClient->gb_size) {
+ 	tmp = (pointer) xrealloc(lbxClient->gfx_buffer, len);
+ 	if (!tmp)
+ 	    return (pointer) NULL;
+ 	lbxClient->gfx_buffer = tmp;
+ 	lbxClient->gb_size = len;
+     }
+     return lbxClient->gfx_buffer;
+ }
+ 
  int
  LbxDecodePolyText (client)
      ClientPtr	client;
***************
*** 474,481 ****
      GContext		gc;
      
      GFX_GET_DRAWABLE_AND_GC(xLbxPolyTextReq, in, len);
!     if ((xreq = (xPolyTextReq *) 
! 	    xalloc (sizeof (xPolyTextReq) + len)) == NULL)
  	return BadAlloc;
      xreq->reqType = stuff->lbxReqType == X_LbxPolyText8? X_PolyText8 : X_PolyText16;
      xreq->drawable = drawable;
--- 493,500 ----
      GContext		gc;
      
      GFX_GET_DRAWABLE_AND_GC(xLbxPolyTextReq, in, len);
!     xreq = (xPolyTextReq *) get_gfx_buffer(client, sizeof (xPolyTextReq) + len);
!     if (!xreq)
  	return BadAlloc;
      xreq->reqType = stuff->lbxReqType == X_LbxPolyText8? X_PolyText8 : X_PolyText16;
      xreq->drawable = drawable;
***************
*** 501,510 ****
      int			retval;
      Drawable		drawable;
      GContext		gc;
!     
      GFX_GET_DRAWABLE_AND_GC(xLbxImageTextReq, in, len);
!     if ((xreq = (xImageTextReq *) 
! 	    xalloc (sizeof (xImageTextReq) + len)) == NULL)
  	return BadAlloc;
      xreq->reqType = stuff->lbxReqType == X_LbxImageText8? X_ImageText8 : X_ImageText16;
      xreq->drawable = drawable;
--- 520,529 ----
      int			retval;
      Drawable		drawable;
      GContext		gc;
! 
      GFX_GET_DRAWABLE_AND_GC(xLbxImageTextReq, in, len);
!     xreq = (xImageTextReq *) get_gfx_buffer(client, sizeof (xImageTextReq) + len);
!     if (!xreq)
  	return BadAlloc;
      xreq->reqType = stuff->lbxReqType == X_LbxImageText8? X_ImageText8 : X_ImageText16;
      xreq->drawable = drawable;
***************
*** 513,520 ****
      pos = in;
      DECODE_SHORT(in, xreq->x);
      DECODE_SHORT(in, xreq->y);
!     bcopy (in, (char *) (xreq + 1), stuff->nChars);
!     client->req_len = xreq->length = (sizeof (xImageTextReq) + stuff->nChars + 3) >> 2;
      client->requestBuffer = (pointer) xreq;
      return (*ProcVector[xreq->reqType])(client);
  }
--- 532,540 ----
      pos = in;
      DECODE_SHORT(in, xreq->x);
      DECODE_SHORT(in, xreq->y);
!     len -= (in - pos);
!     bcopy (in, (char *) (xreq + 1), len);
!     client->req_len = xreq->length = (sizeof (xImageTextReq) + len) >> 2;
      client->requestBuffer = (pointer) xreq;
      return (*ProcVector[xreq->reqType])(client);
  }
*** -	Thu May 11 14:13:37 1995
--- xc/workInProgress/lbx/programs/Xserver/lbx/lbxprop.c	Thu May 11 14:13:37 1995
***************
*** 1,4 ****
! /* $XConsortium: lbxprop.c,v 1.7 94/12/01 20:29:09 mor Exp $ */
  /*
   * Copyright 1993 Network Computing Devices, Inc.
   *
--- 1,4 ----
! /* $XConsortium: lbxprop.c,v 1.8 95/05/11 17:44:13 mor Exp $ */
  /*
   * Copyright 1993 Network Computing Devices, Inc.
   *
***************
*** 60,67 ****
      ClientPtr   client;
      PropertyPtr pProp;
  {
!     LbxQueryTagData(client, pProp->owner_pid, pProp->tag_id, LbxTagTypeProperty, pProp);
!     LbxResetCurrentRequest(client);
      client->sequence--;
  
  /* XXX this won't work too well went done to a proxy client.
--- 60,106 ----
      ClientPtr   client;
      PropertyPtr pProp;
  {
!     LbxClientPtr lbxClient = LbxClient(client);
!     xReq *req = (xReq *) client->requestBuffer;
!     int len = req->length * 4;
! 
!     LbxQueryTagData(client, pProp->owner_pid,
! 	pProp->tag_id, LbxTagTypeProperty, pProp);
! 
!     if (lbxClient) {
! 	/*
! 	 * Before we reset the request, we must make sure
! 	 * it is in the client's byte order.
! 	 */
! 
! 	ClientPtr masterClient =
! 	    lbxClient->proxy->lbxClients[LbxMasterClientIndex]->client;
! 
! 	if (client->swapped != masterClient->swapped) {
! 	    if (req->reqType == X_ChangeProperty) {
! 		register char n;
! 		xChangePropertyReq *stuff = (xChangePropertyReq *) req;
! 		swaps(&stuff->length, n);
! 		swapl(&stuff->window, n);
! 		swapl(&stuff->property, n);
! 		swapl(&stuff->type, n);
! 		swapl(&stuff->nUnits, n);
! 		switch ( stuff->format ) {
! 		case 8 :
! 		    break;
! 		case 16:
! 		    SwapRestS(stuff);
! 		    break;
! 		case 32:
! 		    SwapRestL(stuff);
! 		    break;
! 		}
! 	    }
! 	}
!     }
! 
!     LbxResetCurrentRequest(client, len);
! 
      client->sequence--;
  
  /* XXX this won't work too well went done to a proxy client.
*** -	Wed Dec 31 19:00:00 1969
--- xc/workInProgress/lbx/programs/Xserver/lbx/lbxdata.h	Thu May 11 14:13:38 1995
***************
*** 1,4 ****
! /* $XConsortium: lbxdata.h,v 1.3 94/03/08 20:42:32 dpw Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
--- 1,4 ----
! /* $XConsortium: lbxdata.h,v 1.4 95/05/02 19:37:25 mor Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
***************
*** 28,33 ****
--- 28,35 ----
  #define NEED_REPLIES
  #include "X.h"
  #include "Xproto.h"
+ #define _XLBX_SERVER_
+ #include "lbxstr.h"
  #include "dixfontstr.h"
  
  extern int  lbx_font_private;
***************
*** 35,41 ****
  typedef struct _fonttaginfo {
      FontPtr     pfont;
      unsigned long size;
!     xQueryFontReply *replydata;
  }           FontTagInfoRec, *FontTagInfoPtr;
  
  #endif				/* _LBXDATA_H_ */
--- 37,44 ----
  typedef struct _fonttaginfo {
      FontPtr     pfont;
      unsigned long size;
!     int         compression;
!     xLbxFontInfo *fontinfo;
  }           FontTagInfoRec, *FontTagInfoPtr;
  
  #endif				/* _LBXDATA_H_ */
*** -	Thu May 11 14:13:40 1995
--- xc/workInProgress/lbx/programs/Xserver/lbx/lbxswap.c	Thu May 11 14:13:40 1995
***************
*** 1,4 ****
! /* $XConsortium: lbxswap.c,v 1.4 94/12/01 20:31:47 mor Exp $ */
  /*
   * $NCDId: @(#)lbxswap.c,v 1.7 1994/11/18 20:32:42 lemke Exp $
   * $NCDOr: lbxmain.c,v 1.4 1993/12/06 18:47:18 keithp Exp keithp $
--- 1,4 ----
! /* $XConsortium: lbxswap.c,v 1.5 95/05/02 19:38:05 mor Exp $ */
  /*
   * $NCDId: @(#)lbxswap.c,v 1.7 1994/11/18 20:32:42 lemke Exp $
   * $NCDOr: lbxmain.c,v 1.4 1993/12/06 18:47:18 keithp Exp keithp $
***************
*** 706,709 ****
--- 706,753 ----
      cpswapl(pcsp->tag, cspT.tag);
  
      (void)WriteToClient(pClient, sizeof(cspT), (char *) &cspT);
+ }
+ 
+ void
+ LbxSwapFontInfo(pr, compressed)
+     xLbxFontInfo	*pr;
+     Bool	compressed;
+ {
+     unsigned    i;
+     xCharInfo  *pxci;
+     unsigned    nchars,
+                 nprops;
+     char       *pby;
+     register char n;
+ 
+     nchars = pr->nCharInfos;
+     nprops = pr->nFontProps;
+     swaps(&pr->minCharOrByte2, n);
+     swaps(&pr->maxCharOrByte2, n);
+     swaps(&pr->defaultChar, n);
+     swaps(&pr->nFontProps, n);
+     swaps(&pr->fontAscent, n);
+     swaps(&pr->fontDescent, n);
+     SwapCharInfo(&pr->minBounds);
+     SwapCharInfo(&pr->maxBounds);
+     swapl(&pr->nCharInfos, n);
+ 
+     pby = (char *) &pr[1];
+     /*
+      * Font properties are an atom and either an int32 or a CARD32, so they
+      * are always 2 4 byte values
+      */
+     for (i = 0; i < nprops; i++) {
+ 	swapl(pby, n);
+ 	pby += 4;
+ 	swapl(pby, n);
+ 	pby += 4;
+     }
+     if (!compressed) {
+ 	pxci = (xCharInfo *) pby;
+ 	for (i = 0; i < nchars; i++, pxci++)
+ 	    SwapCharInfo(pxci);
+     } else {
+     	SwapLongs((CARD32 *) pby, nchars);
+     }
  }
*** -	Thu May 11 14:13:41 1995
--- xc/workInProgress/lbx/programs/Xserver/lbx/lbxsquish.c	Thu May 11 14:13:41 1995
***************
*** 1,4 ****
! /* $XConsortium: lbxsquish.c,v 1.1 94/12/01 20:27:29 mor Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
--- 1,4 ----
! /* $XConsortium: lbxsquish.c,v 1.2 95/03/21 20:01:56 mor Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
***************
*** 34,40 ****
  
  /* handles server-side protocol squishing */
  
! LbxEventLength(proxy, ev)
      LbxProxyPtr	proxy;
      xEvent     *ev;
  {
--- 34,40 ----
  
  /* handles server-side protocol squishing */
  
! LbxSquishedEventLength(proxy, ev)
      LbxProxyPtr	proxy;
      xEvent     *ev;
  {
***************
*** 215,221 ****
  {
      int         len;
  
!     len = LbxEventLength(proxy, ev);
  
      /* repack if necessary */
      if (len != sizeof(xEvent)) {
--- 215,221 ----
  {
      int         len;
  
!     len = LbxSquishedEventLength(proxy, ev);
  
      /* repack if necessary */
      if (len != sizeof(xEvent)) {
