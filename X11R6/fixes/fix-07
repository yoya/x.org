                      Release 6 Public Patch #07
                             X Consortium

To apply this patch:

cd to the top of the source tree (to the directory containing the "xc"
and "contrib" subdirectories) and do:
        patch -p -s < ThisFile
Patch will work silently unless an error occurs.  If you want to
watch patch do its thing, leave out the "-s" argument to patch.

Next, from the same top-level directory do:
	rm -f xc/workInProgress/lbx/lib/lbxutil/lzw/lbxbuf.h
	rm -f xc/workInProgress/lbx/lib/lbxutil/lzw/lbxbufstr.h
	rm -f xc/workInProgress/lbx/lib/lbxutil/lzw/lbxlzw.h

If you wish to build LBX, read xc/workInProgress/lbx/README.

Finally, to rebuild, cd to the "xc" subdirectory and do:
        make Everything >& every.log

This patch creates the following new files:
    xc/programs/Xserver/os/lbxio.c
    xc/workInProgress/lbx/include/extensions/lbximage.h
    xc/workInProgress/lbx/include/extensions/lbxbuf.h
    xc/workInProgress/lbx/include/extensions/lbxbufstr.h
    xc/workInProgress/lbx/include/extensions/lbxlzw.h
    xc/workInProgress/lbx/include/extensions/lbxopts.h
    xc/workInProgress/lbx/lib/lbxutil/image/Imakefile
    xc/workInProgress/lbx/lib/lbxutil/image/misc.c
    xc/workInProgress/lbx/lib/lbxutil/image/efaxg42d.c
    xc/workInProgress/lbx/lib/lbxutil/image/epackbits.c
    xc/workInProgress/lbx/lib/lbxutil/image/dfaxg42d.c
    xc/workInProgress/lbx/lib/lbxutil/image/dpackbits.c
    xc/workInProgress/lbx/lib/lbxutil/image/lbxfax.h
    xc/workInProgress/lbx/lib/lbxutil/image/mkg3states.c
    xc/workInProgress/lbx/lib/lbxutil/image/lbxbwcodes.h
    xc/workInProgress/lbx/programs/lbxproxy/di/extensions.c
    xc/workInProgress/lbx/programs/lbxproxy/di/lbxext.h
    xc/workInProgress/lbx/programs/lbxproxy/di/options.c
    xc/workInProgress/lbx/programs/lbxproxy/di/proxyopts.h
    xc/workInProgress/lbx/programs/lbxproxy/di/unsquish.c
    xc/workInProgress/lbx/programs/Xserver/lbx/lbxexts.c
    xc/workInProgress/lbx/programs/Xserver/lbx/lbxopts.c
    xc/workInProgress/lbx/programs/Xserver/lbx/lbxsquish.c
    xc/workInProgress/lbx/programs/Xserver/lbx/lbxsrvopts.h
If you are using a symbolic link tree, you will need to create new links.

This patch updates the low bandwidth X (LBX) sample implementation
with many new features.  LBX is still work in progress, and the
protocol implemented is not yet an X Consortium standard.
In addition, this patch contains the following fixes:

config: support for LaTeX documents
config: preliminary work to better support XFree86
xtrans: XLOCAL parsing bug introduced in public-patch-6

Prereq: public-patch-6

*** -	Wed Jan  18 17:24:10 1995
--- xc/bug-report	Mon Jan  9 17:24:10 1995
***************
*** 3,9 ****
  
       VERSION:
  
! R6, public-patch-6
  [X Consortium public patches edit this line to indicate the patch level]
  
       CLIENT MACHINE and OPERATING SYSTEM:
--- 3,9 ----
  
       VERSION:
  
! R6, public-patch-7
  [X Consortium public patches edit this line to indicate the patch level]
  
       CLIENT MACHINE and OPERATING SYSTEM:
*** -	Thu Jan 19 16:44:04 1995
--- xc/programs/Xserver/Imakefile	Thu Jan 19 16:44:03 1995
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile,v 1.184 94/05/09 13:16:03 dpw Exp $
  /*
   * Server Master Makefile
   */
--- 1,4 ----
! XCOMM $XConsortium: Imakefile,v 1.184.1.1 95/01/19 21:43:21 gildea Exp $
  /*
   * Server Master Makefile
   */
***************
*** 46,51 ****
--- 46,57 ----
        XKBEXT = xkb/libxkb.a
        XKBDIR = xkb
  #endif
+ #if BuildLBX
+          LBXEXT = $(TOP)/workInProgress/lbx/programs/Xserver/lbx/liblbx.a \
+                   $(TOP)/workInProgress/lbx/lib/lbxutil/liblbxutil.a
+         LBXDIRS = $(TOP)/workInProgress/lbx/programs/Xserver/lbx \
+                   $(TOP)/workInProgress/lbx/lib/lbxutil
+ #endif
  #ifdef SiteExtensionLibs
       SITEEXTS = SiteExtensionLibs
  #endif
***************
*** 53,60 ****
       SITEEXTDIRS = SiteExtensionDirs
  #endif
  
!       OTHEREXTS = Xext/libext.a $(XKBEXT) $(XINPUTEXT) $(XIEEXT) $(SITEEXTS)
!         EXTDIRS = Xext $(XKBDIR) $(XIDIR) $(XIEDIR) $(PEXDIR) $(SITEEXTDIRS)
       EXTENSIONS = $(OTHEREXTS) $(PEXLIBS)
           XAULIB = $(XAUTHSRC)/libXau.a
         XDMCPLIB = $(XDMCPLIBSRC)/libXdmcp.a
--- 59,68 ----
       SITEEXTDIRS = SiteExtensionDirs
  #endif
  
!       OTHEREXTS = Xext/libext.a $(XKBEXT) $(XINPUTEXT) $(XIEEXT) \
!                   $(LBXEXT) $(SITEEXTS)
!         EXTDIRS = Xext $(XKBDIR) $(XIDIR) $(XIEDIR) $(PEXDIR) \
!                   $(LBXDIRS) $(SITEEXTDIRS)
       EXTENSIONS = $(OTHEREXTS) $(PEXLIBS)
           XAULIB = $(XAUTHSRC)/libXau.a
         XDMCPLIB = $(XDMCPLIBSRC)/libXdmcp.a
*** -	Wed Jan 18 17:19:14 1995
--- xc/programs/Xserver/include/dix.h	Wed Jan 18 17:19:14 1995
***************
*** 45,51 ****
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: dix.h,v 1.80 94/04/17 20:25:36 dpw Exp $ */
  
  #ifndef DIX_H
  #define DIX_H
--- 45,51 ----
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: dix.h,v 1.82 94/12/02 19:15:52 mor Exp $ */
  
  #ifndef DIX_H
  #define DIX_H
***************
*** 170,180 ****
  #ifdef LBX
  typedef struct _ClientPublic {
      int             (*writeToClient) ();
      unsigned long   (*requestLength) ();
      int             (*readRequest)();
  } ClientPublicRec, *ClientPublicPtr;
  
! #define WriteToClient(client,buf,len)   (((client)->public.writeToClient)(client,buf,len))
  #define ReadRequestFromClient(client)   ((client)->public.readRequest(client))
  #define RequestLength(r,client,g,p)           (*(client)->public.requestLength) (r,client,g,p)
  #endif /* LBX */
--- 170,182 ----
  #ifdef LBX
  typedef struct _ClientPublic {
      int             (*writeToClient) ();
+     int             (*uncompressedWriteToClient) ();
      unsigned long   (*requestLength) ();
      int             (*readRequest)();
  } ClientPublicRec, *ClientPublicPtr;
  
! #define WriteToClient(client,len,buf)   (((client)->public.writeToClient)(client,len,buf))
! #define UncompressedWriteToClient(client,len,buf)   (((client)->public.uncompressedWriteToClient)(client,len,buf))
  #define ReadRequestFromClient(client)   ((client)->public.readRequest(client))
  #define RequestLength(r,client,g,p)           (*(client)->public.requestLength) (r,client,g,p)
  #endif /* LBX */
*** -	Wed Jan 18 17:19:16 1995
--- xc/programs/Xserver/dix/extension.c	Wed Jan 18 17:19:15 1995
***************
*** 45,51 ****
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: extension.c,v 1.53 94/04/17 20:26:35 dpw Exp $ */
  
  #include "X.h"
  #define NEED_REPLIES
--- 45,51 ----
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: extension.c,v 1.54 94/12/02 16:30:12 mor Exp $ */
  
  #include "X.h"
  #define NEED_REPLIES
***************
*** 143,148 ****
--- 143,151 ----
          ext->errorBase = 0;
          ext->errorLast = 0;
      }
+ #ifdef LBX
+     (void) LbxAddExtension(name, ext->base, ext->eventBase, ext->errorBase);
+ #endif
      return(ext);
  }
  
***************
*** 164,170 ****
--- 167,177 ----
      strcpy(name,  alias);
      ext->aliases[ext->num_aliases] = name;
      ext->num_aliases++;
+ #ifdef LBX
+     return LbxAddExtensionAlias(ext->index, alias);
+ #else
      return TRUE;
+ #endif
  }
  
  unsigned short
***************
*** 193,198 ****
--- 200,209 ----
  CloseDownExtensions()
  {
      register int i,j;
+ 
+ #ifdef LBX
+     LbxCloseDownExtensions();
+ #endif
  
      for (i = NumExtensions - 1; i >= 0; i--)
      {
*** -	Wed Jan 18 17:19:17 1995
--- xc/programs/Xserver/os/Imakefile	Wed Jan 18 17:19:17 1995
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile,v 1.76 94/04/07 18:13:51 erik Exp $
  #include <Server.tmpl>
  
  /*
--- 1,4 ----
! XCOMM $XConsortium: Imakefile,v 1.77 94/12/02 19:22:00 mor Exp $
  #include <Server.tmpl>
  
  /*
***************
*** 51,65 ****
     SOCK_DEFINES = -DBSD44SOCKETS
  #endif
  
  BOOTSTRAPCFLAGS = 
             SRCS = WaitFor.c access.c connection.c io.c oscolor.c \
                    osinit.c utils.c auth.c mitauth.c $(XDMAUTHSRCS) \
   		  $(RPCSRCS) $(KRB5SRCS) xdmcp.c decompress.c OtherSources \
!  		  transport.c
             OBJS = WaitFor.o access.o connection.o io.o oscolor.o \
                    osinit.o utils.o auth.o mitauth.o $(XDMAUTHOBJS) \
   		  $(RPCOBJS) $(KRB5OBJS) xdmcp.o decompress.o OtherObjects \
!  		  transport.o
  
  #if SpecialMalloc
       MEM_DEFINES = -DSPECIAL_MALLOC
--- 51,73 ----
     SOCK_DEFINES = -DBSD44SOCKETS
  #endif
  
+ #if BuildLBX
+    LBX_SRCS = lbxio.c
+    LBX_OBJS = lbxio.o
+ #else
+    LBX_SRCS =
+    LBX_OBJS =
+ #endif
+ 
  BOOTSTRAPCFLAGS = 
             SRCS = WaitFor.c access.c connection.c io.c oscolor.c \
                    osinit.c utils.c auth.c mitauth.c $(XDMAUTHSRCS) \
   		  $(RPCSRCS) $(KRB5SRCS) xdmcp.c decompress.c OtherSources \
!  		  transport.c $(LBX_SRCS)
             OBJS = WaitFor.o access.o connection.o io.o oscolor.o \
                    osinit.o utils.o auth.o mitauth.o $(XDMAUTHOBJS) \
   		  $(RPCOBJS) $(KRB5OBJS) xdmcp.o decompress.o OtherObjects \
!  		  transport.o $(LBX_OBJS)
  
  #if SpecialMalloc
       MEM_DEFINES = -DSPECIAL_MALLOC
*** -	Wed Jan 18 17:19:18 1995
--- xc/programs/Xserver/os/connection.c	Wed Jan 18 17:19:18 1995
***************
*** 1,4 ****
! /* $XConsortium: connection.c,v 1.188 94/06/02 11:36:56 mor Exp $ */
  /***********************************************************
  
  Copyright (c) 1987, 1989  X Consortium
--- 1,4 ----
! /* $XConsortium: connection.c,v 1.190 94/11/08 20:47:43 mor Exp $ */
  /***********************************************************
  
  Copyright (c) 1987, 1989  X Consortium
***************
*** 66,72 ****
  #include "X.h"
  #include "Xproto.h"
  #include <X11/Xtrans.h>
- #include <sys/param.h>
  #include <errno.h>
  #ifdef X_NOT_STDC_ENV
  extern int errno;
--- 66,71 ----
***************
*** 206,211 ****
--- 205,211 ----
  #ifdef LBX
  extern int  StandardReadRequestFromClient();
  extern int  StandardWriteToClient ();
+ extern int  UncompressWriteToClient ();
  extern unsigned long  StandardRequestLength ();
  extern int  StandardFlushClient ();
  #endif
***************
*** 589,594 ****
--- 589,595 ----
      }
      client->public.readRequest = StandardReadRequestFromClient;
      client->public.writeToClient = StandardWriteToClient;
+     client->public.uncompressedWriteToClient = UncompressWriteToClient;
      client->public.requestLength = StandardRequestLength;
      return client;
  }
*** -	Wed Jan 18 17:19:20 1995
--- xc/programs/Xserver/os/io.c	Wed Jan 18 17:19:19 1995
***************
*** 1,4 ****
--- 1,5 ----
  /***********************************************************
+ /***********************************************************
  
  Copyright (c) 1987, 1989  X Consortium
  
***************
*** 45,51 ****
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: io.c,v 1.88 94/04/17 20:27:00 dpw Exp $ */
  /*****************************************************************
   * i/o functions
   *
--- 46,52 ----
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: io.c,v 1.90 94/12/02 17:33:26 mor Exp $ */
  /*****************************************************************
   * i/o functions
   *
***************
*** 61,67 ****
  #endif
  #include "Xmd.h"
  #include <errno.h>
- #include <sys/param.h>
  #include <sys/uio.h>
  #include "X.h"
  #include "Xproto.h"
--- 62,67 ----
***************
*** 93,129 ****
  #endif
  extern Bool NewOutputPending;
  extern Bool AnyClientsWriteBlocked;
! static Bool CriticalOutputPending;
! static int timesThisConnection = 0;
! static ConnectionInputPtr FreeInputs = (ConnectionInputPtr)NULL;
! static ConnectionOutputPtr FreeOutputs = (ConnectionOutputPtr)NULL;
! static OsCommPtr AvailableInput = (OsCommPtr)NULL;
  
! static ConnectionInputPtr AllocateInputBuffer(
  #if NeedFunctionPrototypes
      void
  #endif
  );
  static ConnectionOutputPtr AllocateOutputBuffer(
  #if NeedFunctionPrototypes
      void
  #endif
  );
- #ifdef LBX
- static ConnectionOutputPtr AllocateUncompBuffer();
- #endif
  
  #ifdef LBX
! ClientPtr   ReadingClient;
! ClientPtr   WritingClient;
! 
! #define get_req_len(req,cli) (((cli)->swapped ? \
! 			      lswaps((req)->length) : (req)->length) << 2)
  
- #else
  #define get_req_len(req,cli) ((cli)->swapped ? \
  			      lswaps((req)->length) : (req)->length)
- #endif
  
  #ifdef LBX
  StandardRequestLength(req,client,got,partp)
--- 93,122 ----
  #endif
  extern Bool NewOutputPending;
  extern Bool AnyClientsWriteBlocked;
!  Bool CriticalOutputPending;
!  int timesThisConnection = 0;
!  ConnectionInputPtr FreeInputs = (ConnectionInputPtr)NULL;
!  ConnectionOutputPtr FreeOutputs = (ConnectionOutputPtr)NULL;
!  OsCommPtr AvailableInput = (OsCommPtr)NULL;
  
! extern ConnectionInputPtr AllocateInputBuffer(
  #if NeedFunctionPrototypes
      void
  #endif
  );
+ 
  static ConnectionOutputPtr AllocateOutputBuffer(
  #if NeedFunctionPrototypes
      void
  #endif
  );
  
  #ifdef LBX
! extern ClientPtr   WritingClient;
! #endif
  
  #define get_req_len(req,cli) ((cli)->swapped ? \
  			      lswaps((req)->length) : (req)->length)
  
  #ifdef LBX
  StandardRequestLength(req,client,got,partp)
***************
*** 141,147 ****
  	*partp = TRUE;
  	return sizeof (xReq);
      }
!     len = get_req_len(req,client);
      if (len > MAXBUFSIZE)
      {
  	*partp = TRUE;
--- 134,140 ----
  	*partp = TRUE;
  	return sizeof (xReq);
      }
!     len = get_req_len(req,client) << 2;
      if (len > MAXBUFSIZE)
      {
  	*partp = TRUE;
***************
*** 217,226 ****
      int result;
      register xReq *request;
      Bool need_header;
- #ifdef LBX
-     int	nextneeds;
-     Bool part;
- #endif
  #ifdef BIGREQS
      Bool move_header;
  #endif
--- 210,215 ----
***************
*** 258,277 ****
  	oc->input = oci;
      }
      oci->bufptr += oci->lenLastReq;
- #ifdef LBX
-     oci->lenLastReq = 0;
- #endif
  
      need_header = FALSE;
  #ifdef BIGREQS
      move_header = FALSE;
  #endif
      gotnow = oci->bufcnt + oci->buffer - oci->bufptr;
- #ifdef LBX
-     client->requestBuffer = (pointer)oci->bufptr;
-     needed = RequestLength (NULL, client, gotnow, &part);
-     client->req_len = needed >> 2;
- #else
      if (gotnow < sizeof(xReq))
      {
  	needed = sizeof(xReq);
--- 247,258 ----
***************
*** 297,315 ****
  	client->req_len = needed;
  	needed <<= 2;
      }
! #endif	/* LBX */
!     if (gotnow < needed
! #ifdef LBX
! 	|| part
! #endif
!     )
      {
- #ifndef LBX
  	oci->lenLastReq = 0;
  	if (needed > MAXBUFSIZE)
- #else
- 	if (needed == -1)
- #endif
  	{
  	    YieldControlDeath();
  	    return -1;
--- 278,287 ----
  	client->req_len = needed;
  	needed <<= 2;
      }
!     if (gotnow < needed)
      {
  	oci->lenLastReq = 0;
  	if (needed > MAXBUFSIZE)
  	{
  	    YieldControlDeath();
  	    return -1;
***************
*** 348,361 ****
  	    YieldControlDeath();
  	    return -1;
  	}
- #ifdef LBX
- 	ReadingClient = client;
- 	result = (*oc->Read)(fd, oci->buffer + oci->bufcnt, 
- 		      oci->size - oci->bufcnt); 
- #else
  	result = _XSERVTransRead(trans_conn, oci->buffer + oci->bufcnt, 
  		      oci->size - oci->bufcnt); 
- #endif
  	if (result <= 0)
  	{
  	    if ((result < 0) && ETEST(errno))
--- 320,327 ----
***************
*** 382,402 ****
  		oci->bufptr = ibuf + oci->bufcnt - gotnow;
  	    }
  	}
! #ifdef LBX
! 	client->requestBuffer = (pointer) oci->bufptr;
! #endif
! 	if (
! #ifdef LBX
! 	    part &&
! #else
! 	    need_header &&
! #endif
! 	    gotnow >= needed)
  	{
- #ifdef LBX
- 	    needed = RequestLength (NULL, client, gotnow, &part);
- 	    client->req_len = needed >> 2;
- #else
  	    request = (xReq *)oci->bufptr;
  	    needed = get_req_len(request, client);
  #ifdef BIGREQS
--- 348,355 ----
  		oci->bufptr = ibuf + oci->bufcnt - gotnow;
  	    }
  	}
! 	if (need_header && gotnow >= needed)
  	{
  	    request = (xReq *)oci->bufptr;
  	    needed = get_req_len(request, client);
  #ifdef BIGREQS
***************
*** 411,436 ****
  #endif
  	    client->req_len = needed;
  	    needed <<= 2;
- #endif	/* !LBX */
  	}
! 	if (gotnow < needed
! #ifdef LBX
! 		|| part
! #endif
! 	)
  	{
- #ifdef LBX
- 	    if (needed == -1)
- 	    {
- 		YieldControlDeath();
- 		return -1;
- 	    }
- #endif
  	    YieldControlNoInput();
  	    return 0;
  	}
      }
- #ifndef LBX
      if (needed == 0)
      {
  #ifdef BIGREQS
--- 364,376 ----
  #endif
  	    client->req_len = needed;
  	    needed <<= 2;
  	}
! 	if (gotnow < needed)
  	{
  	    YieldControlNoInput();
  	    return 0;
  	}
      }
      if (needed == 0)
      {
  #ifdef BIGREQS
***************
*** 440,446 ****
  #endif
  	    needed = sizeof(xReq);
      }
- #endif	/* !LBX */
      oci->lenLastReq = needed;
  
      /*
--- 380,385 ----
***************
*** 450,466 ****
       *  can get into the queue.   
       */
  
- #ifdef LBX
-     if (gotnow > needed)
-     {
- 	request = (xReq *)(oci->bufptr + needed);
- 	nextneeds = RequestLength (request, client, gotnow - needed, &part);
- 	if (gotnow >= needed + nextneeds && !part)
- 	    BITSET(ClientsWithInput, fd);
- 	else
- 	    YieldControlNoInput();
-     }
- #else
      gotnow -= needed;
      if (gotnow >= sizeof(xReq)) 
      {
--- 389,394 ----
***************
*** 477,488 ****
  	else
  	    YieldControlNoInput();
      }
- #endif	/* !LBX */
      else
      {
- #ifndef LBX
  	if (!gotnow)
- #endif
  	    AvailableInput = oc;
  	YieldControlNoInput();
      }
--- 405,413 ----
***************
*** 498,611 ****
  	client->req_len -= (sizeof(xBigReq) - sizeof(xReq)) >> 2;
      }
  #endif
- #ifndef LBX
      client->requestBuffer = (pointer)oci->bufptr;
- #endif
      return needed;
  }
  
- #ifdef LBX
- Bool
- SwitchClientInput (to, check)
-     ClientPtr to;
-     ClientPtr check;
- {
-     OsCommPtr ocTo = (OsCommPtr) to->osPrivate;
-     ConnectionInputPtr	ociTo = ocTo->input;
-     
-     ConnectionTranslation[ocTo->fd] = to->index;
-     YieldControl();
-     CheckPendingClientInput (check);
-     return TRUE;
- }
- 
- SwitchClientOutput (from, to)
-     ClientPtr	from, to;
- {
-     OsCommPtr ocFrom = (OsCommPtr) from->osPrivate;
-     OsCommPtr ocTo = (OsCommPtr) to->osPrivate;
-     ConnectionOutputPtr	ocoFrom = ocFrom->output;
-     ConnectionOutputPtr	ocoTo = ocTo->output;
-     
-     ConnectionOutputTranslation[ocTo->fd] = to->index;
-     if (PendingClientOutput (to))
-     {
- 	NewOutputPending = TRUE;
- 	BITSET(OutputPending, ocTo->fd);
-     }
- }
- 
- int
- PendingClientOutput (client)
-     ClientPtr	client;
- {
-     OsCommPtr oc = (OsCommPtr) client->osPrivate;
-     ConnectionOutputPtr	oco = oc->output;
-     
-     return (oco && oco->count != 0) || oc->ofirst;
- }
- 
- int
- CheckPendingClientInput (client)
-     ClientPtr	client;
- {
-     OsCommPtr oc = (OsCommPtr)client->osPrivate;
-     register ConnectionInputPtr oci = oc->input;
-     xReq    *request;
-     int	    gotnow;
-     int	    needed;
-     Bool    part;
-     
-     if (!oci)
- 	return 0;
-     needed = oci->lenLastReq;
-     gotnow = oci->bufcnt + oci->buffer - oci->bufptr;
-     request = (xReq *) (oci->bufptr + needed);
-     if (gotnow >= needed + RequestLength(request, client, gotnow - needed, &part) && !part)
-     {
- 	BITSET(ClientsWithInput, oc->fd);
- 	return 1;
-     }
-     return 0;
- }
- 
- void
- MarkConnectionWriteBlocked (client)
-     ClientPtr	client;
- {
-     OsCommPtr oc = (OsCommPtr)client->osPrivate;
- 
-     BITSET(ClientsWriteBlocked, oc->fd);
-     AnyClientsWriteBlocked = TRUE;
- }
- 
- int
- BytesInClientBuffer (client)
-     ClientPtr	client;
- {
-     OsCommPtr oc = (OsCommPtr)client->osPrivate;
-     register ConnectionInputPtr oci = oc->input;
- 
-     if (!oci)
- 	return 0;
-     return oci->bufcnt + oci->buffer - (oci->bufptr + oci->lenLastReq);
- }
- 
- SkipInClientBuffer (client, nbytes, lenLastReq)
-     ClientPtr	client;
-     int		nbytes;
-     int		lenLastReq;
- {
-     OsCommPtr oc = (OsCommPtr)client->osPrivate;
-     register ConnectionInputPtr oci = oc->input;
- 
-     if (!oci)
- 	return;
-     oci->bufptr += nbytes;
-     oci->lenLastReq = lenLastReq;
- }
- #endif	/* LBX */
- 
  /*****************************************************************
   * InsertFakeRequest
   *    Splice a consed up (possibly partial) request in as the next request.
--- 423,432 ----
***************
*** 692,772 ****
      return(TRUE);
  }
  
- #ifdef LBX
- /*****************************************************************
-  * AppendFakeRequest
-  *    Append a (possibly partial) request in as the last request.
-  *
-  **********************/
-  
- Bool
- AppendFakeRequest (client, data, count)
-     ClientPtr client;
-     char *data;
-     int count;
- {
-     OsCommPtr oc = (OsCommPtr)client->osPrivate;
-     register ConnectionInputPtr oco = oc->input;
-     int fd = oc->fd;
-     register xReq *request;
-     register int gotnow, moveup;
-     Bool part;
- 
- #ifdef NOTDEF
-     /* can't do this as the data may actually be coming from this buffer! */
-     if (AvailableInput)
-     {
- 	if (AvailableInput != oc)
- 	{
- 	    register ConnectionInputPtr aci = AvailableInput->input;
- 	    if (aci->size > BUFWATERMARK)
- 	    {
- 		xfree(aci->buffer);
- 		xfree(aci);
- 	    }
- 	    else
- 	    {
- 		aci->next = FreeInputs;
- 		FreeInputs = aci;
- 	    }
- 	    AvailableInput->input = (ConnectionInputPtr)NULL;
- 	}
- 	AvailableInput = (OsCommPtr)NULL;
-     }
- #endif
-     if (!oco)
-     {
- 	if (oco = FreeInputs)
- 	    FreeInputs = oco->next;
- 	else if (!(oco = AllocateInputBuffer()))
- 	    return FALSE;
- 	oc->input = oco;
-     }
-     oco->bufptr += oco->lenLastReq;
-     oco->lenLastReq = 0;
-     gotnow = oco->bufcnt + oco->buffer - oco->bufptr;
-     if ((gotnow + count) > oco->size)
-     {
- 	char *ibuf;
- 
- 	ibuf = (char *)xrealloc(oco->buffer, gotnow + count);
- 	if (!ibuf)
- 	    return(FALSE);
- 	oco->size = gotnow + count;
- 	oco->buffer = ibuf;
- 	oco->bufptr = ibuf;
-     }
-     bcopy(data, oco->bufptr + gotnow, count);
-     oco->bufcnt += count;
-     gotnow += count;
-     if (gotnow >= RequestLength (oco->bufptr, client, gotnow, &part) && !part)
- 	BITSET(ClientsWithInput, fd);
-     else
- 	YieldControlNoInput();
-     return(TRUE);
- }
- #endif	/* LBX */
- 
  /*****************************************************************
   * ResetRequestFromClient
   *    Reset to reexecute the current request, and yield.
--- 513,518 ----
***************
*** 1038,1125 ****
      return extraCount; /* return only the amount explicitly requested */
  }
  
- #ifdef LBX
- static int
- ExpandOutputBuffer(oco, len)
-     ConnectionOutputPtr oco;
-     int len;
- {
-     unsigned char *obuf;
- 
-     obuf = (unsigned char *)xrealloc(oco->buf, len + BUFSIZE);
-     if (!obuf)
-     {
- 	oco->count = 0;
- 	return(-1);
-     }
-     oco->size = len + BUFSIZE;
-     oco->buf = obuf;
-     return 0;
- }
- 
- int
- LbxFlushClient(who, oc, extraBuf, extraCount)
-     ClientPtr who;
-     OsCommPtr oc;
-     char *extraBuf;
-     int extraCount; /* do not modify... returned below */
- {
-     ConnectionOutputPtr nextbuf;
-     register ConnectionOutputPtr oco;
-     int retval = extraCount;
- 
-     if (!oc->ofirst) {
- 	return StandardFlushClient(who, oc, extraBuf, extraCount);
-     }
- 
-     if (oco = oc->output) {
- 	oc->olast->next = oco;
- 	oc->olast = oco;
-     }
- 
-     oco = oc->ofirst;
-     do {
- 	Bool nocomp = oco->nocompress;
- 	nextbuf = (oco != oc->olast) ? oco->next : NULL;
- 	oc->output = oco;
- 	if (nocomp)
- 	    (*oc->compressOff)(oc->fd);
- 	if (oc->olast == oco) {
- 	    StandardFlushClient(who, oc, extraBuf, extraCount);
- 	    extraCount = 0;
- 	}
- 	else
- 	    StandardFlushClient(who, oc, (char *)NULL, 0);
- 	if (nocomp)
- 	    (*oc->compressOn)(oc->fd);
- 	if (oc->output != (ConnectionOutputPtr) NULL) {
- 	    oc->output = (ConnectionOutputPtr) NULL;
- 	    break;
- 	}
-     } while (oco = nextbuf);
-     oc->ofirst = oco;
- 
-     /*
-      * If we didn't get a chance to flush the extraBuf above, then
-      * we need to buffer it here.
-      */
-     if (extraCount) {
- 	int newlen = oco->count + extraCount + padlength[extraCount & 3];
- 	oco = oc->olast;
- 	if (ExpandOutputBuffer(oco, newlen) < 0) {
- 	    _XSERVTransClose(oc->trans_conn);
- 	    oc->trans_conn = NULL;
- 	    MarkClientException(who);
- 	    return(-1);
- 	}
- 	bcopy(extraBuf, (char *)oco->buf + oco->count, extraCount);
- 	oco->count = newlen;
-     }
- 
-     return retval;
- }
- #endif
- 
   /********************
   * FlushAllOutput()
   *    Flush all clients with output.  However, if some client still
--- 784,789 ----
***************
*** 1253,1318 ****
      return(count);
  }
  
! #ifdef LBX
! int
! UncompressWriteToClient (who, count, buf)
!     ClientPtr who;
!     char *buf;
!     int count;
! {
!     OsCommPtr oc = (OsCommPtr)who->osPrivate;
!     register ConnectionOutputPtr oco;
!     int paddedLen = count + padlength[count & 3];
! 
!     if (!count)
! 	return(0);
! 
!     if (oco = oc->output) {
! 	/*
! 	 * we're currently filling a buffer, and it must be compressible,
! 	 * so put it on the queue
! 	 */
! 	if (oc->ofirst) {
! 	    oc->olast->next = oco;
! 	    oc->olast = oco;
! 	}
! 	else {
! 	    oc->ofirst = oc->olast = oco;
! 	}
! 	oco = oc->output = (ConnectionOutputPtr)NULL;
!     }
!     else if (oc->ofirst) {
! 	oco = oc->olast;
! 	if (!oco->nocompress || ((oco->count + paddedLen) > oco->size))
! 	    oco = (ConnectionOutputPtr)NULL;
!     }
! 
!     if (!oco) {
! 	if (!(oco = AllocateUncompBuffer(paddedLen))) {
! 	    _XSERVTransClose(oc->trans_conn);
! 	    oc->trans_conn = NULL;
! 	    MarkClientException(who);
! 	    return -1;
! 	}
!     }
!     bcopy(buf, (char *)oco->buf + oco->count, count);
!     oco->count += paddedLen;
! 
!     if (oc->ofirst) {
! 	oc->olast->next = oco;
! 	oc->olast = oco;
!     }
!     else {
! 	oc->ofirst = oc->olast = oco;
!     }
! 
!     NewOutputPending = TRUE;
!     BITSET(OutputPending, oc->fd);
!     return(count);
! }
! #endif
! 
! static ConnectionInputPtr
  AllocateInputBuffer()
  {
      register ConnectionInputPtr oci;
--- 917,923 ----
      return(count);
  }
  
! ConnectionInputPtr
  AllocateInputBuffer()
  {
      register ConnectionInputPtr oci;
***************
*** 1354,1384 ****
  #endif
      return oco;
  }
- 
- #ifdef LBX
- static ConnectionOutputPtr
- AllocateUncompBuffer(count)
-     int count;
- {
-     register ConnectionOutputPtr oco;
-     int len = (count > BUFSIZE) ? count : BUFSIZE;
- 
-     oco = (ConnectionOutputPtr)xalloc(sizeof(ConnectionOutput));
-     if (!oco)
- 	return (ConnectionOutputPtr)NULL;
-     oco->buf = (unsigned char *) xalloc(len);
-     if (!oco->buf)
-     {
- 	xfree(oco);
- 	return (ConnectionOutputPtr)NULL;
-     }
-     oco->size = len;
-     oco->count = 0;
-     oco->nocompress = TRUE;
-     return oco;
- }
- 
- #endif
  
  void
  FreeOsBuffers(oc)
--- 959,964 ----
*** /dev/null	Wed Jan 18 17:19:21 1995
--- xc/programs/Xserver/os/lbxio.c	Wed Jan 18 17:19:21 1995
***************
*** 0 ****
--- 1,649 ----
+ /***********************************************************
+ Copyright 1987, 1989 by Digital Equipment Corporation, Maynard, Massachusetts,
+ and the Massachusetts Institute of Technology, Cambridge, Massachusetts.
+ 
+                         All Rights Reserved
+ 
+ Permission to use, copy, modify, and distribute this software and its 
+ documentation for any purpose and without fee is hereby granted, 
+ provided that the above copyright notice appear in all copies and that
+ both that copyright notice and this permission notice appear in 
+ supporting documentation, and that the names of Digital or MIT not be
+ used in advertising or publicity pertaining to distribution of the
+ software without specific, written prior permission.  
+ 
+ DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+ DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+ WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ SOFTWARE.
+ 
+ ******************************************************************/
+ /* $XConsortium: lbxio.c,v 1.2 94/12/02 17:33:49 mor Exp $ */
+ /*****************************************************************
+  * i/o functions
+  *
+  *   WriteToClient, ReadRequestFromClient
+  *   InsertFakeRequest, ResetCurrentRequest
+  *
+  *****************************************************************/
+ 
+ #include <stdio.h>
+ #include <X11/Xtrans.h>
+ #ifdef X_NOT_STDC_ENV
+ extern int errno;
+ #endif
+ #include "Xmd.h"
+ #include <errno.h>
+ #include <sys/param.h>
+ #include <sys/uio.h>
+ #include "X.h"
+ #include "Xproto.h"
+ #include "os.h"
+ #include "osdep.h"
+ #include "opaque.h"
+ #include "dixstruct.h"
+ #include "misc.h"
+ 
+ /* check for both EAGAIN and EWOULDBLOCK, because some supposedly POSIX
+  * systems are broken and return EWOULDBLOCK when they should return EAGAIN
+  */
+ #if defined(EAGAIN) && defined(EWOULDBLOCK)
+ #define ETEST(err) (err == EAGAIN || err == EWOULDBLOCK)
+ #else
+ #ifdef EAGAIN
+ #define ETEST(err) (err == EAGAIN)
+ #else
+ #define ETEST(err) (err == EWOULDBLOCK)
+ #endif
+ #endif
+ 
+ extern FdSet ClientsWithInput, IgnoredClientsWithInput, AllClients;
+ extern FdSet ClientsWriteBlocked;
+ extern FdSet OutputPending;
+ extern int ConnectionTranslation[];
+ extern int ConnectionOutputTranslation[];
+ extern Bool NewOutputPending;
+ extern Bool AnyClientsWriteBlocked;
+ extern Bool CriticalOutputPending;
+ extern int timesThisConnection;
+ extern ConnectionInputPtr FreeInputs;
+ extern ConnectionOutputPtr FreeOutputs;
+ extern OsCommPtr AvailableInput;
+ 
+ extern ConnectionInputPtr AllocateInputBuffer(
+ #if NeedFunctionPrototypes
+     void
+ #endif
+ );
+ 
+ static ConnectionOutputPtr AllocateUncompBuffer();
+ 
+ ClientPtr   ReadingClient;
+ ClientPtr   WritingClient;
+ 
+ #define get_req_len(req,cli) (((cli)->swapped ? \
+ 			      lswaps((req)->length) : (req)->length) << 2)
+ 
+ #define MAX_TIMES_PER         10
+ 
+ /*****************************************************************
+  * ReadRequestFromClient
+  *    Returns one request in client->requestBuffer.  Return status is:
+  *
+  *    > 0  if  successful, specifies length in bytes of the request
+  *    = 0  if  entire request is not yet available
+  *    < 0  if  client should be terminated
+  *
+  *    The request returned must be contiguous so that it can be
+  *    cast in the dispatcher to the correct request type.  Because requests
+  *    are variable length, ReadRequestFromClient() must look at the first 4
+  *    bytes of a request to determine the length (the request length is
+  *    always the 3rd and 4th bytes of the request).  
+  *
+  *    Note: in order to make the server scheduler (WaitForSomething())
+  *    "fair", the ClientsWithInput mask is used.  This mask tells which
+  *    clients have FULL requests left in their buffers.  Clients with
+  *    partial requests require a read.  Basically, client buffers
+  *    are drained before select() is called again.  But, we can't keep
+  *    reading from a client that is sending buckets of data (or has
+  *    a partial request) because others clients need to be scheduled.
+  *****************************************************************/
+ 
+ #define YieldControl()				\
+         { isItTimeToYield = TRUE;		\
+ 	  timesThisConnection = 0; }
+ #define YieldControlNoInput()			\
+         { YieldControl();			\
+ 	  BITCLEAR(ClientsWithInput, fd); }
+ #define YieldControlDeath()			\
+         { timesThisConnection = 0; }
+ 
+ int
+ LBXReadRequestFromClient(client)
+     ClientPtr client;
+ {
+     OsCommPtr oc = (OsCommPtr)client->osPrivate;
+     register ConnectionInputPtr oci = oc->input;
+     int fd = oc->fd;
+     XtransConnInfo trans_conn = oc->trans_conn;
+     register int gotnow, needed;
+     int result;
+     register xReq *request;
+     Bool need_header;
+     int	nextneeds;
+     Bool part;
+ #ifdef BIGREQS
+     Bool move_header;
+ #endif
+ 
+     if (AvailableInput)
+     {
+ 	if (AvailableInput != oc)
+ 	{
+ 	    register ConnectionInputPtr aci = AvailableInput->input;
+ 	    if (aci->size > BUFWATERMARK)
+ 	    {
+ 		xfree(aci->buffer);
+ 		xfree(aci);
+ 	    }
+ 	    else
+ 	    {
+ 		aci->next = FreeInputs;
+ 		FreeInputs = aci;
+ 	    }
+ 	    AvailableInput->input = (ConnectionInputPtr)NULL;
+ 	}
+ 	AvailableInput = (OsCommPtr)NULL;
+     }
+     if (!oci)
+     {
+ 	if (oci = FreeInputs)
+ 	{
+ 	    FreeInputs = oci->next;
+ 	}
+ 	else if (!(oci = AllocateInputBuffer()))
+ 	{
+ 	    YieldControlDeath();
+ 	    return -1;
+ 	}
+ 	oc->input = oci;
+     }
+     oci->bufptr += oci->lenLastReq;
+     oci->lenLastReq = 0;
+ 
+     need_header = FALSE;
+ #ifdef BIGREQS
+     move_header = FALSE;
+ #endif
+     gotnow = oci->bufcnt + oci->buffer - oci->bufptr;
+     client->requestBuffer = (pointer)oci->bufptr;
+     needed = RequestLength (NULL, client, gotnow, &part);
+     client->req_len = needed >> 2;
+     if (gotnow < needed || part)
+     {
+ 	if (needed == -1)
+ 	{
+ 	    YieldControlDeath();
+ 	    return -1;
+ 	}
+ 	if ((gotnow == 0) ||
+ 	    ((oci->bufptr - oci->buffer + needed) > oci->size))
+ 	{
+ 	    if ((gotnow > 0) && (oci->bufptr != oci->buffer))
+ 		memmove(oci->buffer, oci->bufptr, gotnow);
+ 	    if (needed > oci->size)
+ 	    {
+ 		char *ibuf;
+ 
+ 		ibuf = (char *)xrealloc(oci->buffer, needed);
+ 		if (!ibuf)
+ 		{
+ 		    YieldControlDeath();
+ 		    return -1;
+ 		}
+ 		oci->size = needed;
+ 		oci->buffer = ibuf;
+ 	    }
+ 	    oci->bufptr = oci->buffer;
+ 	    oci->bufcnt = gotnow;
+ 	}
+ 	/*  XXX this is a workaround.  This function is sometimes called
+ 	 *  after the trans_conn has been freed.  In this case trans_conn
+ 	 *  will be null.  Really ought to restructure things so that we
+ 	 *  never get here in those circumstances.
+ 	 */
+ 	if (!trans_conn)
+ 	{
+ 	    /*  treat as if an error occured on the read, which is what
+ 	     *  used to happen
+ 	     */
+ 	    YieldControlDeath();
+ 	    return -1;
+ 	}
+ 	ReadingClient = client;
+ #ifndef XTRANS
+ 	result = (*oc->Read)(fd, oci->buffer + oci->bufcnt, 
+ 		      oci->size - oci->bufcnt); 
+ #else
+ 	result = _XSERVTransRead(trans_conn, oci->buffer + oci->bufcnt, 
+ 		      oci->size - oci->bufcnt); 
+ #endif
+ 	if (result <= 0)
+ 	{
+ 	    if ((result < 0) && ETEST(errno))
+ 	    {
+ 		YieldControlNoInput();
+ 		return 0;
+ 	    }
+ 	    YieldControlDeath();
+ 	    return -1;
+ 	}
+ 	oci->bufcnt += result;
+ 	gotnow += result;
+ 	/* free up some space after huge requests */
+ 	if ((oci->size > BUFWATERMARK) &&
+ 	    (oci->bufcnt < BUFSIZE) && (needed < BUFSIZE))
+ 	{
+ 	    char *ibuf;
+ 
+ 	    ibuf = (char *)xrealloc(oci->buffer, BUFSIZE);
+ 	    if (ibuf)
+ 	    {
+ 		oci->size = BUFSIZE;
+ 		oci->buffer = ibuf;
+ 		oci->bufptr = ibuf + oci->bufcnt - gotnow;
+ 	    }
+ 	}
+ 	client->requestBuffer = (pointer) oci->bufptr;
+ 	if (part && gotnow >= needed)
+ 	{
+ 	    needed = RequestLength (NULL, client, gotnow, &part);
+ 	    client->req_len = needed >> 2;
+ 	}
+ 	if (gotnow < needed || part)
+ 	{
+ 	    if (needed == -1)
+ 	    {
+ 		YieldControlDeath();
+ 		return -1;
+ 	    }
+ 	    YieldControlNoInput();
+ 	    return 0;
+ 	}
+     }
+     oci->lenLastReq = needed;
+ 
+     /*
+      *  Check to see if client has at least one whole request in the
+      *  buffer.  If there is only a partial request, treat like buffer
+      *  is empty so that select() will be called again and other clients
+      *  can get into the queue.   
+      */
+ 
+     if (gotnow > needed)
+     {
+ 	request = (xReq *)(oci->bufptr + needed);
+ 	nextneeds = RequestLength (request, client, gotnow - needed, &part);
+ 	if (gotnow >= needed + nextneeds && !part)
+ 	    BITSET(ClientsWithInput, fd);
+ 	else
+ 	    YieldControlNoInput();
+     }
+     else
+     {
+ 	AvailableInput = oc;
+ 	YieldControlNoInput();
+     }
+     if (++timesThisConnection >= MAX_TIMES_PER)
+ 	YieldControl();
+ #ifdef BIGREQS
+     if (move_header)
+     {
+ 	request = (xReq *)oci->bufptr;
+ 	oci->bufptr += (sizeof(xBigReq) - sizeof(xReq));
+ 	*(xReq *)oci->bufptr = *request;
+ 	oci->lenLastReq -= (sizeof(xBigReq) - sizeof(xReq));
+ 	client->req_len -= (sizeof(xBigReq) - sizeof(xReq)) >> 2;
+     }
+ #endif
+     return needed;
+ }
+ 
+ Bool
+ SwitchClientInput (to, check)
+     ClientPtr to;
+     ClientPtr check;
+ {
+     OsCommPtr ocTo = (OsCommPtr) to->osPrivate;
+     ConnectionInputPtr	ociTo = ocTo->input;
+     
+     ConnectionTranslation[ocTo->fd] = to->index;
+     YieldControl();
+     CheckPendingClientInput (check);
+     return TRUE;
+ }
+ 
+ SwitchClientOutput (from, to)
+     ClientPtr	from, to;
+ {
+     OsCommPtr ocFrom = (OsCommPtr) from->osPrivate;
+     OsCommPtr ocTo = (OsCommPtr) to->osPrivate;
+     ConnectionOutputPtr	ocoFrom = ocFrom->output;
+     ConnectionOutputPtr	ocoTo = ocTo->output;
+     
+     ConnectionOutputTranslation[ocTo->fd] = to->index;
+     if (PendingClientOutput (to))
+     {
+ 	NewOutputPending = TRUE;
+ 	BITSET(OutputPending, ocTo->fd);
+     }
+ }
+ 
+ int
+ PendingClientOutput (client)
+     ClientPtr	client;
+ {
+     OsCommPtr oc = (OsCommPtr) client->osPrivate;
+     ConnectionOutputPtr	oco = oc->output;
+     
+     return (oco && oco->count != 0) || oc->ofirst;
+ }
+ 
+ int
+ CheckPendingClientInput (client)
+     ClientPtr	client;
+ {
+     OsCommPtr oc = (OsCommPtr)client->osPrivate;
+     register ConnectionInputPtr oci = oc->input;
+     xReq    *request;
+     int	    gotnow;
+     int	    needed;
+     Bool    part;
+     
+     if (!oci)
+ 	return 0;
+     needed = oci->lenLastReq;
+     gotnow = oci->bufcnt + oci->buffer - oci->bufptr;
+     request = (xReq *) (oci->bufptr + needed);
+     if (gotnow >= needed + RequestLength(request, client, gotnow - needed, &part) && !part)
+     {
+ 	BITSET(ClientsWithInput, oc->fd);
+ 	return 1;
+     }
+     return 0;
+ }
+ 
+ void
+ MarkConnectionWriteBlocked (client)
+     ClientPtr	client;
+ {
+     OsCommPtr oc = (OsCommPtr)client->osPrivate;
+ 
+     BITSET(ClientsWriteBlocked, oc->fd);
+     AnyClientsWriteBlocked = TRUE;
+ }
+ 
+ int
+ BytesInClientBuffer (client)
+     ClientPtr	client;
+ {
+     OsCommPtr oc = (OsCommPtr)client->osPrivate;
+     register ConnectionInputPtr oci = oc->input;
+ 
+     if (!oci)
+ 	return 0;
+     return oci->bufcnt + oci->buffer - (oci->bufptr + oci->lenLastReq);
+ }
+ 
+ SkipInClientBuffer (client, nbytes, lenLastReq)
+     ClientPtr	client;
+     int		nbytes;
+     int		lenLastReq;
+ {
+     OsCommPtr oc = (OsCommPtr)client->osPrivate;
+     register ConnectionInputPtr oci = oc->input;
+ 
+     if (!oci)
+ 	return;
+     oci->bufptr += nbytes;
+     oci->lenLastReq = lenLastReq;
+ }
+ 
+ /*****************************************************************
+  * AppendFakeRequest
+  *    Append a (possibly partial) request in as the last request.
+  *
+  **********************/
+  
+ Bool
+ AppendFakeRequest (client, data, count)
+     ClientPtr client;
+     char *data;
+     int count;
+ {
+     OsCommPtr oc = (OsCommPtr)client->osPrivate;
+     register ConnectionInputPtr oco = oc->input;
+     int fd = oc->fd;
+     register xReq *request;
+     register int gotnow, moveup;
+     Bool part;
+ 
+ #ifdef NOTDEF
+     /* can't do this as the data may actually be coming from this buffer! */
+     if (AvailableInput)
+     {
+ 	if (AvailableInput != oc)
+ 	{
+ 	    register ConnectionInputPtr aci = AvailableInput->input;
+ 	    if (aci->size > BUFWATERMARK)
+ 	    {
+ 		xfree(aci->buffer);
+ 		xfree(aci);
+ 	    }
+ 	    else
+ 	    {
+ 		aci->next = FreeInputs;
+ 		FreeInputs = aci;
+ 	    }
+ 	    AvailableInput->input = (ConnectionInputPtr)NULL;
+ 	}
+ 	AvailableInput = (OsCommPtr)NULL;
+     }
+ #endif
+     if (!oco)
+     {
+ 	if (oco = FreeInputs)
+ 	    FreeInputs = oco->next;
+ 	else if (!(oco = AllocateInputBuffer()))
+ 	    return FALSE;
+ 	oc->input = oco;
+     }
+     oco->bufptr += oco->lenLastReq;
+     oco->lenLastReq = 0;
+     gotnow = oco->bufcnt + oco->buffer - oco->bufptr;
+     if ((gotnow + count) > oco->size)
+     {
+ 	char *ibuf;
+ 
+ 	ibuf = (char *)xrealloc(oco->buffer, gotnow + count);
+ 	if (!ibuf)
+ 	    return(FALSE);
+ 	oco->size = gotnow + count;
+ 	oco->buffer = ibuf;
+ 	oco->bufptr = ibuf;
+     }
+     bcopy(data, oco->bufptr + gotnow, count);
+     oco->bufcnt += count;
+     gotnow += count;
+     if (gotnow >= RequestLength (oco->bufptr, client, gotnow, &part) && !part)
+ 	BITSET(ClientsWithInput, fd);
+     else
+ 	YieldControlNoInput();
+     return(TRUE);
+ }
+ 
+ static int
+ ExpandOutputBuffer(oco, len)
+     ConnectionOutputPtr oco;
+     int len;
+ {
+     unsigned char *obuf;
+ 
+     obuf = (unsigned char *)xrealloc(oco->buf, len + BUFSIZE);
+     if (!obuf)
+     {
+ 	oco->count = 0;
+ 	return(-1);
+     }
+     oco->size = len + BUFSIZE;
+     oco->buf = obuf;
+     return 0;
+ }
+ 
+     /* lookup table for adding padding bytes to data that is read from
+     	or written to the X socket.  */
+ static int padlength[4] = {0, 3, 2, 1};
+ 
+ int
+ LbxFlushClient(who, oc, extraBuf, extraCount)
+     ClientPtr who;
+     OsCommPtr oc;
+     char *extraBuf;
+     int extraCount; /* do not modify... returned below */
+ {
+     ConnectionOutputPtr nextbuf;
+     register ConnectionOutputPtr oco;
+     int retval = extraCount;
+ 
+     if (!oc->ofirst) {
+ 	return StandardFlushClient(who, oc, extraBuf, extraCount);
+     }
+ 
+     if (oco = oc->output) {
+ 	oc->olast->next = oco;
+ 	oc->olast = oco;
+     }
+ 
+     oco = oc->ofirst;
+     do {
+ 	Bool nocomp = oco->nocompress;
+ 	nextbuf = (oco != oc->olast) ? oco->next : NULL;
+ 	oc->output = oco;
+ 	if (nocomp)
+ 	    (*oc->compressOff)(oc->fd);
+ 	if (oc->olast == oco) {
+ 	    StandardFlushClient(who, oc, extraBuf, extraCount);
+ 	    extraCount = 0;
+ 	}
+ 	else
+ 	    StandardFlushClient(who, oc, (char *)NULL, 0);
+ 	if (nocomp)
+ 	    (*oc->compressOn)(oc->fd);
+ 	if (oc->output != (ConnectionOutputPtr) NULL) {
+ 	    oc->output = (ConnectionOutputPtr) NULL;
+ 	    break;
+ 	}
+     } while (oco = nextbuf);
+     oc->ofirst = oco;
+ 
+     /*
+      * If we didn't get a chance to flush the extraBuf above, then
+      * we need to buffer it here.
+      */
+     if (extraCount) {
+ 	int newlen = oco->count + extraCount + padlength[extraCount & 3];
+ 	oco = oc->olast;
+ 	if (ExpandOutputBuffer(oco, newlen) < 0) {
+ 	    _XSERVTransClose(oc->trans_conn);
+ 	    oc->trans_conn = NULL;
+ 	    MarkClientException(who);
+ 	    return(-1);
+ 	}
+ 	bcopy(extraBuf, (char *)oco->buf + oco->count, extraCount);
+ 	oco->count = newlen;
+     }
+ 
+     return retval;
+ }
+ 
+ int
+ UncompressWriteToClient (who, count, buf)
+     ClientPtr who;
+     char *buf;
+     int count;
+ {
+     OsCommPtr oc = (OsCommPtr)who->osPrivate;
+     register ConnectionOutputPtr oco;
+     int paddedLen = count + padlength[count & 3];
+ 
+     if (!count)
+ 	return(0);
+ 
+     if (oco = oc->output) {
+ 	/*
+ 	 * we're currently filling a buffer, and it must be compressible,
+ 	 * so put it on the queue
+ 	 */
+ 	if (oc->ofirst) {
+ 	    oc->olast->next = oco;
+ 	    oc->olast = oco;
+ 	}
+ 	else {
+ 	    oc->ofirst = oc->olast = oco;
+ 	}
+ 	oco = oc->output = (ConnectionOutputPtr)NULL;
+     }
+     else if (oc->ofirst) {
+ 	oco = oc->olast;
+ 	if (!oco->nocompress || ((oco->count + paddedLen) > oco->size))
+ 	    oco = (ConnectionOutputPtr)NULL;
+     }
+ 
+     if (!oco) {
+ 	if (!(oco = AllocateUncompBuffer(paddedLen))) {
+ 	    _XSERVTransClose(oc->trans_conn);
+ 	    oc->trans_conn = NULL;
+ 	    MarkClientException(who);
+ 	    return -1;
+ 	}
+     }
+     bcopy(buf, (char *)oco->buf + oco->count, count);
+     oco->count += paddedLen;
+ 
+     if (oc->ofirst) {
+ 	oc->olast->next = oco;
+ 	oc->olast = oco;
+     }
+     else {
+ 	oc->ofirst = oc->olast = oco;
+     }
+ 
+     NewOutputPending = TRUE;
+     BITSET(OutputPending, oc->fd);
+     return(count);
+ }
+ 
+ static ConnectionOutputPtr
+ AllocateUncompBuffer(count)
+     int count;
+ {
+     register ConnectionOutputPtr oco;
+     int len = (count > BUFSIZE) ? count : BUFSIZE;
+ 
+     oco = (ConnectionOutputPtr)xalloc(sizeof(ConnectionOutput));
+     if (!oco)
+ 	return (ConnectionOutputPtr)NULL;
+     oco->buf = (unsigned char *) xalloc(len);
+     if (!oco->buf)
+     {
+ 	xfree(oco);
+ 	return (ConnectionOutputPtr)NULL;
+     }
+     oco->size = len;
+     oco->count = 0;
+     oco->nocompress = TRUE;
+     return oco;
+ }
*** -	Wed Jan 18 17:19:23 1995
--- xc/config/makedepend/include.c	Wed Jan 18 17:19:22 1995
***************
*** 1,4 ****
! /* $XConsortium: include.c,v 1.16 94/04/17 20:10:34 gildea Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
--- 1,4 ----
! /* $XConsortium: include.c,v 1.17 94/12/05 19:33:08 gildea Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
***************
*** 118,124 ****
  }
  
  /*
!  * Ocaisionally, pathnames are created that look like ../x/../y
   * Any of the 'x/..' sequences within the name can be eliminated.
   * (but only if 'x' is not a symbolic link!!)
   */
--- 118,124 ----
  }
  
  /*
!  * Occasionally, pathnames are created that look like .../x/../y
   * Any of the 'x/..' sequences within the name can be eliminated.
   * (but only if 'x' is not a symbolic link!!)
   */
***************
*** 150,173 ****
  	*cp = NULL;
  
  	/*
! 	 * Now copy the path, removing all 'x/..' components.
  	 */
  	cp = components;
- 	component_copied = FALSE;
  	while(*cp) {
! 		if (!isdot(*cp) && !isdotdot(*cp) && isdotdot(*(cp+1))) {
! 			if (issymbolic(newpath, *cp))
! 				goto dont_remove;
! 			cp++;
  		} else {
! 		dont_remove:
! 			if (component_copied)
! 				*to++ = '/';
! 			component_copied = TRUE;
! 			for (from = *cp; *from; )
! 				*to++ = *from++;
! 			*to = '\0';
  		}
  		cp++;
  	}
  	*to++ = '\0';
--- 150,186 ----
  	*cp = NULL;
  
  	/*
! 	 * Recursively remove all 'x/..' component pairs.
  	 */
  	cp = components;
  	while(*cp) {
! 		if (!isdot(*cp) && !isdotdot(*cp) && isdotdot(*(cp+1))
! 		    && !issymbolic(newpath, *cp))
! 		{
! 		    char **fp = cp + 2;
! 		    char **tp = cp;
! 
! 		    do 
! 			*tp++ = *fp; /* move all the pointers down */
! 		    while (*fp++);
! 		    if (cp != components)
! 			cp--;	/* go back and check for nested ".." */
  		} else {
! 		    cp++;
  		}
+ 	}
+ 	/*
+ 	 * Concatenate the remaining path elements.
+ 	 */
+ 	cp = components;
+ 	component_copied = FALSE;
+ 	while(*cp) {
+ 		if (component_copied)
+ 			*to++ = '/';
+ 		component_copied = TRUE;
+ 		for (from = *cp; *from; )
+ 			*to++ = *from++;
+ 		*to = '\0';
  		cp++;
  	}
  	*to++ = '\0';
*** -	Wed Jan 18 17:19:24 1995
--- xc/config/cf/Imake.tmpl	Wed Jan 18 17:19:24 1995
***************
*** 1,6 ****
! XCOMM -----------------------------------------------------------------------
  XCOMM Makefile generated from IMAKE_TEMPLATE and INCLUDE_IMAKEFILE
! XCOMM $XConsortium: Imake.tmpl,v 1.220 94/08/30 17:25:36 matt Exp $
  XCOMM
  
  /*
--- 1,6 ----
! XCOMM ----------------------------------------------------------------------
  XCOMM Makefile generated from IMAKE_TEMPLATE and INCLUDE_IMAKEFILE
! XCOMM $XConsortium: Imake.tmpl,v 1.224 94/12/27 03:57:50 gildea Exp $
  XCOMM
  
  /*
***************
*** 188,193 ****
--- 188,196 ----
  #ifndef HasKrb5
  #define HasKrb5			NO      /* if you have Kerberos V5 */
  #endif
+ #ifndef HasLatex
+ #define HasLatex		YES
+ #endif
  #ifndef HasShm
  #if SystemV || SystemV4
  #define HasShm			YES
***************
*** 692,697 ****
--- 695,706 ----
  #ifndef EqnCmd
  #define EqnCmd eqn
  #endif
+ #ifndef DvipsCmd
+ #define DvipsCmd dvips
+ #endif
+ #ifndef LatexCmd
+ #define LatexCmd latex
+ #endif
  #if HasSentinel
  #ifndef SentinelCmd
  #define SentinelCmd sentinel
***************
*** 732,738 ****
--- 741,751 ----
  #define LibManSuffix	3		/* use just one tab or cpp will die */
  #endif
  #ifndef FileManSuffix
+ #if SystemV || SystemV4 || defined(OSF1Architecture)
  #define FileManSuffix	4		/* use just one tab or cpp will die */
+ #else
+ #define FileManSuffix	5		/* use just one tab or cpp will die */
+ #endif
  #endif
  #ifndef ExpandManNames
  #if SystemV
***************
*** 837,842 ****
--- 850,859 ----
           MSMACROS = MsMacros
                TBL = TblCmd
                EQN = EqnCmd
+ #if HasLatex
+             DVIPS = DvipsCmd
+             LATEX = LatexCmd
+ #endif
  #if HasSentinel
           SENTINEL = SentinelCmd
    SENTINELOPTIONS = SentinelOptions
***************
*** 1060,1065 ****
--- 1077,1083 ----
  
  InstallSubdirs($(SUBDIRS))
  InstallManSubdirs($(SUBDIRS))
+ InstallLinkKitSubdirs($(SUBDIRS))
  CleanSubdirs($(SUBDIRS))
  TagSubdirs($(SUBDIRS))
  MakefileSubdirs($(SUBDIRS))
***************
*** 1074,1079 ****
--- 1092,1100 ----
  
  install.man::
  	@echo "install.man in $(CURRENT_DIR) done"
+ 
+ install.linkkit::
+ 	@echo "install.linkkit in $(CURRENT_DIR) done"
  
  Makefiles::
  
*** -	Wed Jan 18 17:19:26 1995
--- xc/config/cf/Project.tmpl	Wed Jan 18 17:19:26 1995
***************
*** 1,15 ****
! XCOMM -----------------------------------------------------------------------
  XCOMM X Window System Build Parameters and Rules
! XCOMM $XConsortium: Project.tmpl,v 1.244 94/08/17 18:57:34 matt Exp $
  
! /****************************************************************************
!  *                                                                          *
!  *                            DEFAULT DEFINITONS                            *
!  *                                                                          *
!  * The following section contains defaults for things that can              *
!  * overridden in the various *.cf and site.def files.  DO NOT EDIT!         *
!  *                                                                          *
!  ***************************************************************************/
  
  #define ProjectX		6	/* do *not* change this line */
  
--- 1,15 ----
! XCOMM ----------------------------------------------------------------------
  XCOMM X Window System Build Parameters and Rules
! XCOMM $XConsortium: Project.tmpl,v 1.248 95/01/06 19:12:51 gildea Exp $
  
! /***************************************************************************
!  *                                                                         *
!  *                            DEFAULT DEFINITONS                           *
!  *                                                                         *
!  * The following section contains defaults for things that can             *
!  * overridden in the various *.cf and site.def files.  DO NOT EDIT!        *
!  *                                                                         *
!  **************************************************************************/
  
  #define ProjectX		6	/* do *not* change this line */
  
***************
*** 203,216 ****
  #define XkbDefines /**/
  #endif
  #endif
  #ifndef BigReqDefines
  #define BigReqDefines -DBIGREQS
  #endif
  #ifndef SitePervasiveExtensionDefines
  #define SitePervasiveExtensionDefines /**/
  #endif
  #ifndef PervasiveExtensionDefines
! #define PervasiveExtensionDefines -DSHAPE XInputDefines XkbDefines SitePervasiveExtensionDefines
  #endif
  #ifndef SiteExtensionDefines
  #define SiteExtensionDefines /**/
--- 203,227 ----
  #define XkbDefines /**/
  #endif
  #endif
+ #ifndef LbxDefines
+ #if BuildLBX
+ #define LbxDefines -DLBX
+ #else
+ #define LbxDefines /**/
+ #endif
+ #endif
  #ifndef BigReqDefines
+ #if !BuildLBX
  #define BigReqDefines -DBIGREQS
+ #else
+ #define BigReqDefines /**/	/* LBX doesn't work with BIG-REQUESTS yet */
+ #endif
  #endif
  #ifndef SitePervasiveExtensionDefines
  #define SitePervasiveExtensionDefines /**/
  #endif
  #ifndef PervasiveExtensionDefines
! #define PervasiveExtensionDefines -DSHAPE XInputDefines XkbDefines LbxDefines SitePervasiveExtensionDefines
  #endif
  #ifndef SiteExtensionDefines
  #define SiteExtensionDefines /**/
***************
*** 1081,1083 ****
--- 1092,1116 ----
  clean::									@@\
  	$(RM) index.troff index.pageno file.idx.nPS file.idx.PS
  #endif
+ 
+ #ifndef MakeLatexDoc
+ #if HasLatex
+ #define MakeLatexDoc(file,src)	 					@@\
+ all:: file.PS								@@\
+ 									@@\
+ file.dvi: src	  							@@\
+ 	$(LATEX) src							@@\
+ 									@@\
+ file.PS: file.dvi							@@\
+ 	$(DVIPS) -o file.nPS file && $(MV) file.nPS $@			@@\
+ 									@@\
+ clean:: 								@@\
+ 	RemoveFiles(file.nPS file.PS file.dvi file.log)			@@\
+ 	RemoveFiles(file.aux file.toc file.lof file.lot)
+ #else /* HasLatex */
+ #define MakeLatexDoc(file,src)	 					@@\
+ all::									@@\
+ file.PS: src								@@\
+ 	@echo "cannot make file.PS: no latex on this system"; exit 1
+ #endif /* HasLatex (else) */
+ #endif /* MakeLatexDoc */
*** -	Wed Jan 18 17:19:28 1995
--- xc/config/cf/Imake.rules	Wed Jan 18 17:19:27 1995
***************
*** 1,6 ****
  XCOMM -----------------------------------------------------------------------
  XCOMM Imake rules for building libraries, programs, scripts, and data files
! XCOMM rules:  $XConsortium: Imake.rules,v 1.194 94/08/30 17:25:36 matt Exp $
  
  /*
   *		   MACHINE-INDEPENDENT RULES; DO NOT MODIFY
--- 1,6 ----
  XCOMM -----------------------------------------------------------------------
  XCOMM Imake rules for building libraries, programs, scripts, and data files
! XCOMM rules:  $XConsortium: Imake.rules,v 1.197 94/12/05 19:30:41 gildea Exp $
  
  /*
   *		   MACHINE-INDEPENDENT RULES; DO NOT MODIFY
***************
*** 776,781 ****
--- 776,804 ----
  	RanLibrary($(RANLIBINSTFLAGS) $(DESTDIR)dest/LibraryTargetName(libname))
  #endif /* InstallLibrary */
  
+ 
+ /*
+  * InstallLinkKitLibrary - rule to install Link Kit library.
+  *                         (only used for XFree86). This is a no-op
+  *                         rule so that Imakefiles on non-XFree86 systems
+  *                         continue to build Makefiles correctly.
+  */
+ #ifndef InstallLinkKitLibrary
+ #define InstallLinkKitLibrary(lib,dir)
+ #endif
+ 
+ 
+ /*
+  * InstallLinkKitNamedLibrary - rule to install Link Kit library.
+  *                         (only used for XFree86). This is a no-op
+  *                         rule so that Imakefiles on non-XFree86 systems
+  *                         continue to build Makefiles correctly.
+  */
+ #ifndef InstallLinkKitNamedLibrary
+ #define InstallLinkKitNamedLibrary(lib,dlib,dir)
+ #endif
+ 
+ 
  /*
   * MergeIntoInstalledLibrary - generate rules to merge one library into another
   */
***************
*** 864,869 ****
--- 887,903 ----
  
  
  /*
+  * InstallLinkKitNonExecFile - rule for installing server Link Kit files.
+  *                         (only used for XFree86). This is a no-op
+  *                         rule so that Imakefiles on non-XFree86 systems
+  *                         continue to build Makefiles correctly.
+  */
+ #ifndef InstallLinkKitNonExecFile
+ #define InstallLinkKitNonExecFile(file,dir)
+ #endif
+ 
+ 
+ /*
   * InstallNonExec - generate rules to install a data file, but does not
   * try to create the destination directory (deprecated)
   */
***************
*** 1777,1782 ****
--- 1811,1827 ----
  
  
  /*
+  * InstallLinkKitSubdirs - generate rules to recursively install server Link
+  *                         Kit (only used for XFree86). This is a no-op
+  *                         rule so that Imakefiles on non-XFree86 systems
+  *                         continue to build Makefiles correctly.
+  */
+ #ifndef InstallLinkKitSubdirs
+ #define InstallLinkKitSubdirs(dirs)
+ #endif
+ 
+ 
+ /*
   * CleanSubdirs - generate rules to recursively clean out garbage files.
   */
  #ifndef NamedCleanSubdirs
***************
*** 1850,1861 ****
  		*) curdir=$(CURRENT_DIR)/ ;; \				@@\
  		esac; \							@@\
  		echo "making Makefiles in $$curdir$$i..."; \		@@\
! 		case "$$i" in \						@@\
  		*/?*/?*/?*)	newtop=../../../..;; \			@@\
  		*/?*/?*)	newtop=../../..;; \			@@\
  		*/?*)		newtop=../..;; \			@@\
  		*)		newtop=..;; \				@@\
  		esac; \							@@\
  		case "$(TOP)" in \					@@\
  		/?*) imaketop=$(TOP) \					@@\
  		     imakeprefix= ;; \					@@\
--- 1895,1921 ----
  		*) curdir=$(CURRENT_DIR)/ ;; \				@@\
  		esac; \							@@\
  		echo "making Makefiles in $$curdir$$i..."; \		@@\
! 		itmp="$$i" \						@@\
! 		curtmp="$(CURRENT_DIR)" \				@@\
! 		toptmp=""; \						@@\
! 		case "$$itmp" in \					@@\
! 		    ../?*) \ 						@@\
! 			while echo "$$itmp" | grep '^../' > /dev/null;\	@@\
! 			  do \						@@\
! 			     toptmp="/`basename $$curtmp`$$toptmp"; \	@@\
! 			     curtmp="`dirname $$curtmp`"; \		@@\
! 			     itmp="`echo $$itmp | sed 's;../;;'`"; \	@@\
! 			  done \					@@\
! 		    ;; \						@@\
! 		esac; \							@@\
! 		case "$$itmp" in \					@@\
! 		*/?*/?*/?*/?*)	newtop=../../../../..;; \		@@\
  		*/?*/?*/?*)	newtop=../../../..;; \			@@\
  		*/?*/?*)	newtop=../../..;; \			@@\
  		*/?*)		newtop=../..;; \			@@\
  		*)		newtop=..;; \				@@\
  		esac; \							@@\
+ 		newtop="$$newtop$$toptmp"; \				@@\
  		case "$(TOP)" in \					@@\
  		/?*) imaketop=$(TOP) \					@@\
  		     imakeprefix= ;; \					@@\
*** -	Thu Jan 19 16:01:37 1995
--- xc/lib/xtrans/Xtranslcl.c	Thu Jan 19 16:01:37 1995
***************
*** 1,4 ****
! /* $XConsortium: Xtranslcl.c,v 1.20 94/12/12 20:14:30 mor Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
--- 1,4 ----
! /* $XConsortium: Xtranslcl.c,v 1.21 95/01/19 18:06:04 mor Exp $ */
  /*
  
  Copyright (c) 1993, 1994  X Consortium
***************
*** 1771,1779 ****
  	
  	typetocheck=workingXLOCAL;
  	workingXLOCAL=strchr(workingXLOCAL,':');
! 	if (!workingXLOCAL)
! 	    return NULL;
! 	if(*workingXLOCAL)
  	    *workingXLOCAL++='\0';
  	
  	for(i=0;i<NUMTRANSPORTS;i++)
--- 1771,1777 ----
  	
  	typetocheck=workingXLOCAL;
  	workingXLOCAL=strchr(workingXLOCAL,':');
! 	if(workingXLOCAL && *workingXLOCAL)
  	    *workingXLOCAL++='\0';
  	
  	for(i=0;i<NUMTRANSPORTS;i++)
*** -	Thu Jan 19 15:57:22 1995
--- xc/workInProgress/Imakefile	Thu Jan 19 15:57:22 1995
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile,v 1.1 94/04/07 16:50:10 rws Exp $
  
  #define IHaveSubdirs
  #define PassCDebugFlags CDEBUGFLAGS="$(CDEBUGFLAGS)"
--- 1,4 ----
! XCOMM $XConsortium: Imakefile,v 1.3 94/12/19 22:28:19 mor Exp $
  
  #define IHaveSubdirs
  #define PassCDebugFlags CDEBUGFLAGS="$(CDEBUGFLAGS)"
***************
*** 7,13 ****
  FRESCODIRS = Fresco Xtf
  #endif
  
! SUBDIRS = $(FRESCODIRS) xsm
  
  MakeSubdirs($(SUBDIRS))
  DependSubdirs($(SUBDIRS))
--- 7,17 ----
  FRESCODIRS = Fresco Xtf
  #endif
  
! #if BuildLBX
! LBXDIRS = lbx
! #endif
! 
! SUBDIRS = $(FRESCODIRS) $(LBXDIRS) xsm
  
  MakeSubdirs($(SUBDIRS))
  DependSubdirs($(SUBDIRS))
*** -	Wed Jan 18 13:05:00 1995
--- xc/workInProgress/lbx/README	Wed Jan 18 13:05:00 1995
***************
*** 1,3 ****
--- 1,5 ----
+ $XConsortium: README,v 1.2 95/01/06 19:12:51 gildea Exp $
+ 
  				Low Bandwidth X
  				     (LBX)
  
***************
*** 108,141 ****
  
  				  Building LBX
  
! To use it, you need both an R6 Xserver and the lbxproxy.  The easiest
! way to build it is to add these 5 lines to $(TOP)/config/cf/site.def:
  
- #define SitePervasiveExtensionDefines -DLBX
- #define SiteExtensionLibs $(TOP)/workInProgress/lbx/programs/Xserver/lbx/liblbx.a $(TOP)/workInProgress/lbx/lib/lbxutil/liblbxutil.a
- #define SiteExtensionDirs $(TOP)/workInProgress/lbx/lib/Xext $(TOP)/workInProgress/lbx/programs/Xserver/lbx
- #define BigReqDefines /**/
  #define	BuildLBX YES
  
! Next, from the $(TOP)/workInProgress directory, remake the Makefiles:
  
!     %  cd ../workInProgress
      %  make Makefile
!     %  make Makefiles SUBDIRS=lbx
!     %  cd lbx
      %  make includes
      %  make depend
  
! Then, rebuild the X server:
  
!     %  cd ../../programs/Xserver
!     %  make clean
      %  make Makefile
!     %  make Makefiles
      %  make includes
      %  make depend
      %  make
- 
  
  
  				     Usage
--- 110,142 ----
  
  				  Building LBX
  
! To use it, you need both an R6 Xserver and the lbxproxy.
! 
! Add this line to $(TOP)/config/cf/site.def:
  
  #define	BuildLBX YES
  
! You may then do a "make World" or "make Everything" at top level.
  
! To rebuild just the X server:
! 
!     %  cd programs/Xserver
!     %  make clean
      %  make Makefile
!     %  make Makefiles
      %  make includes
      %  make depend
+     %  make
  
! To build lbxproxy:
  
!     %  cd workInProgress
      %  make Makefile
!     %  make Makefiles SUBDIRS=lbx
!     %  cd lbx
      %  make includes
      %  make depend
      %  make
  
  
  				     Usage
*** -	Wed Jan 18 13:05:08 1995
--- xc/workInProgress/lbx/include/extensions/XLbx.h	Wed Jan 18 13:05:08 1995
***************
*** 1,6 ****
! /* $XConsortium: XLbx.h,v 1.5 94/03/27 11:43:37 dpw Exp $ */
  /*
!  * $NCDId: @(#)XLbx.h,v 1.17 1994/03/24 01:26:07 dct Exp $
   *
   * Copyright 1992 Network Computing Devices
   *
--- 1,6 ----
! /* $XConsortium: XLbx.h,v 1.9 94/12/02 02:28:59 mor Exp $ */
  /*
!  * $NCDId: @(#)XLbx.h,v 1.21 1994/11/18 20:29:53 lemke Exp $
   *
   * Copyright 1992 Network Computing Devices
   *
***************
*** 29,34 ****
--- 29,39 ----
  
  #include <X11/Xfuncproto.h>
  
+ /*
+  * NOTE:  any changes or additions to the opcodes needs to be reflected
+  * in the lbxCacheable array in Xserver/lbx/lbxmain.c
+  */
+  
  #define X_LbxQueryVersion		0
  #define X_LbxStartProxy			1
  #define X_LbxStopProxy			2
***************
*** 56,61 ****
--- 61,77 ----
  #define	X_LbxGetProperty		24
  #define	X_LbxTagData			25
  
+ #define X_LbxCopyArea			26
+ #define X_LbxCopyPlane			27
+ #define X_LbxPolyText8			28
+ #define X_LbxPolyText16			29
+ #define X_LbxImageText8			30
+ #define X_LbxImageText16		31
+ 
+ #define X_LbxQueryExtension		32
+ #define X_LbxPutImage			33
+ #define X_LbxGetImage			34
+ 
  #define LbxEvent			0
  #define LbxNumberEvents			(LbxEvent + 1)
  
***************
*** 74,79 ****
--- 90,100 ----
  /* Lbx compression schemes */
  #define LbxCompressNone			0
  #define LbxCompressLZW			1
+ 
+ /* Lbx image compression methods */
+ #define LbxImageCompressNone		0
+ #define LbxImageCompressPackBits	1
+ #define LbxImageCompressFaxG42D		2
  
  #define BadLbxClient			0
  #define LbxNumberErrors			(BadLbxClient + 1)
*** -	Wed Jan 18 13:05:10 1995
--- xc/workInProgress/lbx/include/extensions/lbxdeltastr.h	Wed Jan 18 13:05:10 1995
***************
*** 1,3 ****
--- 1,4 ----
+ /* $XConsortium: lbxdeltastr.h,v 1.3 94/12/01 20:07:54 mor Exp $ */
  /*
   * $NCDId: @(#)lbxdeltastr.h,v 1.1 1993/12/22 22:23:09 dct Exp $
   *
*** -	Wed Jan 18 13:05:12 1995
--- xc/workInProgress/lbx/include/extensions/lbxstr.h	Wed Jan 18 13:05:11 1995
***************
*** 1,6 ****
! /* $XConsortium: lbxstr.h,v 1.5 94/03/27 11:43:24 dpw Exp $ */
  /*
!  * $NCDId: @(#)lbxstr.h,v 1.19 1994/03/22 18:22:47 lemke Exp $
   *
   * Copyright 1992 Network Computing Devices
   *
--- 1,6 ----
! /* $XConsortium: lbxstr.h,v 1.8 94/12/01 20:02:04 mor Exp $ */
  /*
!  * $NCDId: @(#)lbxstr.h,v 1.25 1994/11/18 20:29:52 lemke Exp $
   *
   * Copyright 1992 Network Computing Devices
   *
***************
*** 32,38 ****
  #define LBXNAME "LBX"
  
  #define LBX_MAJOR_VERSION	0	/* current version numbers */
! #define LBX_MINOR_VERSION	0
  
  typedef struct {
      CARD8	byteOrder;
--- 32,38 ----
  #define LBXNAME "LBX"
  
  #define LBX_MAJOR_VERSION	0	/* current version numbers */
! #define LBX_MINOR_VERSION	1
  
  typedef struct {
      CARD8	byteOrder;
***************
*** 78,88 ****
      CARD8	reqType;	/* always LbxReqCode */
      CARD8	lbxReqType;	/* always X_LbxStartProxy */
      CARD16	length B16;
-     CARD16	deltaN B16;	/* size of delta cache */
-     CARD16	deltaMaxLen B16;/* max length of messages in delta cache */
-     CARD32	comptype B32;	/* LbxCompressNone etc */
  } xLbxStartProxyReq;
! #define sz_xLbxStartProxyReq	    12
  
  typedef struct _LbxStopProxy {
      CARD8	reqType;	/* always LbxReqCode */
--- 78,85 ----
      CARD8	reqType;	/* always LbxReqCode */
      CARD8	lbxReqType;	/* always X_LbxStartProxy */
      CARD16	length B16;
  } xLbxStartProxyReq;
! #define sz_xLbxStartProxyReq	    4
  
  typedef struct _LbxStopProxy {
      CARD8	reqType;	/* always LbxReqCode */
***************
*** 324,341 ****
  } xLbxInvalidateTagReq;
  #define	sz_xLbxInvalidateTagReq	8
  
  /* Following used for LbxPolyPoint, LbxPolyLine, LbxPolySegment,
     LbxPolyRectangle, LbxPolyArc, LbxPolyFillRectangle and LbxPolyFillArc */
  
  typedef struct _LbxPolyPoint {
      CARD8	reqType;	/* always LbxReqCode */
      CARD8	lbxReqType;
      CARD16	length B16;
!     Drawable	drawable B32;
!     GContext	gc B32;
      CARD8	padBytes;
  } xLbxPolyPointReq;
! #define sz_xLbxPolyPointReq	13
  
  typedef xLbxPolyPointReq xLbxPolyLineReq;
  typedef xLbxPolyPointReq xLbxPolySegmentReq;
--- 321,395 ----
  } xLbxInvalidateTagReq;
  #define	sz_xLbxInvalidateTagReq	8
  
+ typedef struct _LbxPutImage {
+     CARD8	reqType;	/* always LbxReqCode */
+     CARD8	lbxReqType;	/* always X_LbxPutImage */
+     CARD16	lbxLength B16;
+     CARD16	xLength B16;
+     CARD8	compressionMethod;
+     CARD8	format;
+     Drawable	drawable B32;
+     GContext	gc B32;
+     CARD16	width B16, height B16;
+     INT16	dstX B16, dstY B16;
+     CARD8	depth;
+     CARD8	leftPad;
+     CARD8	padBytes;
+ } xLbxPutImageReq;
+ #define sz_xLbxPutImageReq	27
+ 
+ typedef struct {
+     CARD8	reqType;	/* always LbxReqCode */
+     CARD8	lbxReqType;	/* always X_LbxGetImage */
+     CARD16	length B16;
+     Drawable	drawable B32;
+     INT16	x B16, y B16;
+     CARD16	width B16, height B16;
+     CARD32	planeMask B32;
+     CARD8	format;
+     CARD8	pad1;
+     CARD16	pad2 B16;
+ } xLbxGetImageReq;    
+ 
+ #define sz_xLbxGetImageReq 24
+ 
+ typedef struct {
+     BYTE type;			/* X_Reply */
+     CARD8 depth;
+     CARD16 sequenceNumber B16;
+     CARD32 lbxLength B32;
+     CARD32 xLength B32;
+     VisualID visual B32;
+     CARD8 compressionMethod;
+     CARD8 pad1;
+     CARD16 pad2 B16;
+     CARD32 pad3 B32;
+     CARD32 pad4 B32;
+     CARD32 pad5 B32;
+ } xLbxGetImageReply;
+ 
+ #define sz_xLbxGetImageReply 32
+   
  /* Following used for LbxPolyPoint, LbxPolyLine, LbxPolySegment,
     LbxPolyRectangle, LbxPolyArc, LbxPolyFillRectangle and LbxPolyFillArc */
  
+ #define GFX_CACHE_SIZE  15
+ 
+ #define GFXdCacheEnt(e)	    ((e) & 0xf)
+ #define GFXgCacheEnt(e)	    (((e) >> 4) & 0xf)
+ #define GFXCacheEnts(d,g)   (((d) & 0xf) | (((g) & 0xf) << 4))
+ 
+ #define GFXCacheNone   0xf
+ 
  typedef struct _LbxPolyPoint {
      CARD8	reqType;	/* always LbxReqCode */
      CARD8	lbxReqType;
      CARD16	length B16;
!     CARD8	cacheEnts;
      CARD8	padBytes;
  } xLbxPolyPointReq;
! 
! #define sz_xLbxPolyPointReq	6
  
  typedef xLbxPolyPointReq xLbxPolyLineReq;
  typedef xLbxPolyPointReq xLbxPolySegmentReq;
***************
*** 344,366 ****
  typedef xLbxPolyPointReq xLbxPolyFillRectangleReq;
  typedef xLbxPolyPointReq xLbxPolyFillArcReq;
  
! #define sz_xLbxPolyLineReq		13
! #define sz_xLbxPolySegmentReq		13
! #define sz_xLbxPolyRectangleReq		13
! #define sz_xLbxPolyArcReq		13
! #define sz_xLbxPolyFillRectangleReq	13
! #define sz_xLbxPolyFillArc		13
  
  typedef struct _LbxFillPoly {
      CARD8	reqType;	/* always LbxReqCode */
      CARD8	lbxReqType;
      CARD16	length B16;
!     Drawable	drawable B32;
!     GContext	gc B32;
      BYTE	shape;
      CARD8	padBytes;
  } xLbxFillPolyReq;
! #define sz_xLbxFillPolyReq	14
  
  typedef struct {
      CARD8       offset;
--- 398,475 ----
  typedef xLbxPolyPointReq xLbxPolyFillRectangleReq;
  typedef xLbxPolyPointReq xLbxPolyFillArcReq;
  
! #define sz_xLbxPolyLineReq		sz_xLbxPolyPointReq
! #define sz_xLbxPolySegmentReq		sz_xLbxPolyPointReq
! #define sz_xLbxPolyRectangleReq		sz_xLbxPolyPointReq
! #define sz_xLbxPolyArcReq		sz_xLbxPolyPointReq
! #define sz_xLbxPolyFillRectangleReq	sz_xLbxPolyPointReq
! #define sz_xLbxPolyFillArc		sz_xLbxPolyPointReq
  
  typedef struct _LbxFillPoly {
      CARD8	reqType;	/* always LbxReqCode */
      CARD8	lbxReqType;
      CARD16	length B16;
!     CARD8	cacheEnts;
      BYTE	shape;
      CARD8	padBytes;
  } xLbxFillPolyReq;
! #define sz_xLbxFillPolyReq	7
! 
! typedef struct _LbxCopyArea {
!     CARD8	reqType;	/* always LbxReqCode */
!     CARD8	lbxReqType;
!     CARD16	length B16;
!     CARD8	srcCache;	/* source drawable */
!     CARD8	cacheEnts;	/* dest drawable and gc */
!     /* followed by encoded src x, src y, dst x, dst y, width, height */
! } xLbxCopyAreaReq;
!     
! #define sz_xLbxCopyAreaReq  6
! 
! typedef struct _LbxCopyPlane {
!     CARD8	reqType;	/* always LbxReqCode */
!     CARD8	lbxReqType;
!     CARD16	length B16;
!     CARD32	bitPlane B32;
!     CARD8	srcCache;	/* source drawable */
!     CARD8	cacheEnts;	/* dest drawable and gc */
!     /* followed by encoded src x, src y, dst x, dst y, width, height */
! } xLbxCopyPlaneReq;
!     
! #define sz_xLbxCopyPlaneReq  10
! 
! typedef struct _LbxPolyText {
!     CARD8	reqType;	/* always LbxReqCode */
!     CARD8	lbxReqType;
!     CARD16	length B16;
!     CARD8	cacheEnts;
!     /* followed by encoded src x, src y coordinates and text elts */
! } xLbxPolyTextReq;
! 
! #define sz_xLbxPolyTextReq  5
! 
! typedef xLbxPolyTextReq xLbxPolyText8Req;
! typedef xLbxPolyTextReq xLbxPolyText16Req;
!     
! #define sz_xLbxPolyTextReq	5
! #define sz_xLbxPolyText8Req	5
! #define sz_xLbxPolyText16Req	5
! 
! typedef struct _LbxImageText {
!     CARD8	reqType;	/* always LbxReqCode */
!     CARD8	lbxReqType;
!     CARD16	length B16;
!     CARD8	cacheEnts;
!     CARD8	nChars;
!     /* followed by encoded src x, src y coordinates and string */
! } xLbxImageTextReq;
!     
! typedef xLbxImageTextReq xLbxImageText8Req;
! typedef xLbxImageTextReq xLbxImageText16Req;
!     
! #define sz_xLbxImageTextReq	6
! #define sz_xLbxImageText8Req	6
! #define sz_xLbxImageText16Req	6
  
  typedef struct {
      CARD8       offset;
***************
*** 368,388 ****
  } xLbxDiffItem;
  #define sz_xLbxDiffItem    2
  
- 
  typedef struct {
      BYTE	type;		/* X_Reply */
!     CARD8	unused;
      CARD16	sequenceNumber B16;
!     CARD32	length B32;	/* addition scheme-specific data follows */
!     CARD16	deltaN B16;	/* delta cache size */
!     CARD16	deltaMaxLen B16;/* max. length of messages in delta cache */
!     CARD32	comptype B32;	/* LbxCompressNone etc */
      CARD32	pad0 B32;
      CARD32	pad1 B32;
      CARD32	pad2 B32;
      CARD32	pad3 B32;
  } xLbxStartReply;
  #define sz_xLbxStartReply	32
  
  typedef struct _LbxEvent {
      BYTE	type;		/* always eventBase + LbxEvent */
--- 477,524 ----
  } xLbxDiffItem;
  #define sz_xLbxDiffItem    2
  
  typedef struct {
      BYTE	type;		/* X_Reply */
!     CARD8	nOpts;
      CARD16	sequenceNumber B16;
!     CARD32	length B32;
!     CARD32	optDataStart B32;
      CARD32	pad0 B32;
      CARD32	pad1 B32;
      CARD32	pad2 B32;
      CARD32	pad3 B32;
+     CARD32	pad4 B32;
+     CARD32	pad5 B32;
  } xLbxStartReply;
  #define sz_xLbxStartReply	32
+ #define sz_xLbxStartReplyHdr	8
+ 
+ typedef struct _LbxQueryExtension {
+     CARD8	reqType;	/* always LbxReqCode */
+     CARD8	lbxReqType;	/* always X_LbxQueryExtension */
+     CARD16	length B16;
+     CARD32	nbytes B32;
+ } xLbxQueryExtensionReq;
+ #define	sz_xLbxQueryExtensionReq	8
+ 
+ typedef struct {
+     BYTE	type;			/* X_Reply */
+     CARD8	numReqs;
+     CARD16	sequenceNumber B16;
+     CARD32	length B32;
+     BOOL	present;
+     CARD8	major_opcode;
+     CARD8	first_event;
+     CARD8	first_error;
+     CARD32	pad0 B32;
+     CARD32	pad1 B32;
+     CARD32	pad2 B32;
+     CARD32	pad3 B32;
+     CARD32	pad4 B32;
+ 
+     /* reply & event generating requests */
+ } xLbxQueryExtensionReply;
+ #define sz_xLbxQueryExtensionReply	32
  
  typedef struct _LbxEvent {
      BYTE	type;		/* always eventBase + LbxEvent */
***************
*** 397,402 ****
--- 533,571 ----
      CARD32	pad4 B32;
  } xLbxEvent;
  #define sz_xLbxEventEvent	32
+ 
+ /* squished X event sizes.  If these change, be sure to update lbxquish.c
+  * and unsquish.c appropriately
+  */
+ 
+ #define	lbxsz_KeyButtonEvent		32
+ #define	lbxsz_EnterLeaveEvent		32
+ #define	lbxsz_FocusEvent		12
+ #define	lbxsz_KeymapEvent		32
+ #define	lbxsz_ExposeEvent		20
+ #define	lbxsz_GfxExposeEvent		24
+ #define	lbxsz_NoExposeEvent		12
+ #define	lbxsz_VisibilityEvent		12
+ #define	lbxsz_CreateNotifyEvent		24
+ #define	lbxsz_DestroyNotifyEvent	12
+ #define	lbxsz_UnmapNotifyEvent		16
+ #define	lbxsz_MapNotifyEvent		16
+ #define	lbxsz_MapRequestEvent		12
+ #define	lbxsz_ReparentEvent		24
+ #define	lbxsz_ConfigureNotifyEvent	28
+ #define	lbxsz_ConfigureRequestEvent	28
+ #define	lbxsz_GravityEvent		16
+ #define	lbxsz_ResizeRequestEvent	12
+ #define	lbxsz_CirculateEvent		20
+ #define	lbxsz_PropertyEvent		20
+ #define	lbxsz_SelectionClearEvent	20
+ #define	lbxsz_SelectionRequestEvent	28
+ #define	lbxsz_SelectionNotifyEvent	24
+ #define	lbxsz_ColormapEvent		16
+ #define	lbxsz_MappingNotifyEvent	8
+ #define	lbxsz_ClientMessageEvent	32
+ 
+ #define	lbxsz_UnknownEvent		32
  
  #ifndef NDEBUG
  
*** /dev/null	Wed Jan 18 13:05:14 1995
--- xc/workInProgress/lbx/include/extensions/lbximage.h	Wed Jan 18 13:05:14 1995
***************
*** 0 ****
--- 1,76 ----
+ /* $XConsortium: lbximage.h,v 1.2 94/11/29 19:16:42 mor Exp $ */
+ 
+ /******************************************************************************
+ 
+ Copyright (c) 1994  X Consortium
+ 
+ Permission is hereby granted, free of charge, to any person obtaining a copy
+ of this software and associated documentation files (the "Software"), to deal
+ in the Software without restriction, including without limitation the rights
+ to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ copies of the Software, and to permit persons to whom the Software is
+ furnished to do so, subject to the following conditions:
+ 
+ The above copyright notice and this permission notice shall be included in
+ all copies or substantial portions of the Software.
+ 
+ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+ X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ 
+ Except as contained in this notice, the name of the X Consortium shall not be
+ used in advertising or otherwise to promote the sale, use or other dealings
+ in this Software without prior written authorization from the X Consortium.
+ 
+ ******************************************************************************/
+ 
+ extern int LbxImageEncodePackBits (
+ #if NeedFunctionPrototypes
+ char *			/* inbuf */,
+ char *			/* outbuf */,
+ int			/* outbufSize */,
+ int			/* num_scan_lines */,
+ int			/* scan_line_size */,
+ int *			/* bytesCompressed */
+ #endif
+ );
+ 
+ extern int LbxImageEncodeFaxG42D (
+ #if NeedFunctionPrototypes
+ unsigned char *		/* inbuf */,
+ unsigned char *		/* outbuf */,
+ int			/* outbufSize */,
+ int			/* image_bytes */,
+ int			/* pixels_per_line */,
+ int			/* reverse_bits */,
+ int *			/* bytesCompressed */
+ #endif
+ );
+ 
+ extern int LbxImageDecodePackBits (
+ #if NeedFunctionPrototypes
+ char *			/* inbuf */,
+ char *			/* outbuf */,
+ int			/* num_scan_lines */,
+ int			/* scan_line_size */
+ #endif
+ );
+ 
+ extern int LbxImageDecodeFaxG42D (
+ #if NeedFunctionPrototypes
+ unsigned char *		/* inbuf */,
+ unsigned char *		/* outbuf */,
+ int			/* image_bytes */,
+ int			/* pixels_per_line */,
+ int			/* reverse_bits */
+ #endif
+ );
+ 
+ 
+ #define LBX_IMAGE_COMPRESS_SUCCESS		0
+ #define LBX_IMAGE_COMPRESS_UNSUPPORTED_FORMAT	1
+ #define LBX_IMAGE_COMPRESS_BAD_MALLOC		2
+ #define LBX_IMAGE_COMPRESS_NOT_WORTH_IT		3
*** /dev/null	Mon Jan 23 16:31:52 1995
--- xc/workInProgress/lbx/include/extensions/lbxbuf.h	Mon Jan 23 16:31:52 1995
***************
*** 0 ****
--- 1,46 ----
+ /* $XConsortium: lbxbuf.h,v 1.5 95/01/23 21:25:52 gildea Exp $ */
+ /*
+  * Copyright 1988, 1989, 1990, 1994 Network Computing Devices, Inc.
+  *
+  * Permission to use, copy, modify, distribute, and sell this software and
+  * its documentation for any purpose is hereby granted without fee, provided
+  * that the above copyright notice appear in all copies and that both that
+  * copyright notice and this permission notice appear in supporting
+  * documentation, and that the name Network Computing Devices, Inc. not be
+  * used in advertising or publicity pertaining to distribution of this 
+  * software without specific, written prior permission.
+  * 
+  * THIS SOFTWARE IS PROVIDED `AS-IS'.  NETWORK COMPUTING DEVICES, INC.,
+  * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT
+  * LIMITATION ALL IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
+  * PARTICULAR PURPOSE, OR NONINFRINGEMENT.  IN NO EVENT SHALL NETWORK
+  * COMPUTING DEVICES, INC., BE LIABLE FOR ANY DAMAGES WHATSOEVER, INCLUDING
+  * SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES, INCLUDING LOSS OF USE,
+  * DATA, OR PROFITS, EVEN IF ADVISED OF THE POSSIBILITY THEREOF, AND
+  * REGARDLESS OF WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE,
+  * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+  * SOFTWARE.
+  * 
+  * $NCDId: @(#)lbxbuf.h,v 1.1 1994/02/16 18:57:32 lemke Exp $
+  */
+ 
+ #ifndef _BUFFER_H_
+ #define _BUFFER_H_
+ 
+ #define INBUFFER_SIZE		(1 << 13)	/* 8K */
+ #define OUTBUFFER_SIZE		(1 << 12)	/* 4K */
+ 
+ #ifndef TRUE
+ #define TRUE    1
+ #endif
+ #ifndef FALSE
+ #define FALSE   0
+ #endif
+ 
+ typedef struct _lzwbuffer  *LzwBufferPtr;
+ 
+ extern int  InitLzwBuffer();
+ extern void FreeLzwBuffer();
+ extern char *ReserveOutBuf();
+ 
+ #endif	/* _BUFFER_H_ */
*** /dev/null	Mon Jan 23 16:31:53 1995
--- xc/workInProgress/lbx/include/extensions/lbxbufstr.h	Mon Jan 23 16:31:53 1995
***************
*** 0 ****
--- 1,44 ----
+ /* $XConsortium: lbxbufstr.h,v 1.6 95/01/23 21:25:52 gildea Exp $ */
+ /*
+  * Copyright 1988, 1989, 1990, 1994 Network Computing Devices, Inc.
+  *
+  * Permission to use, copy, modify, distribute, and sell this software and
+  * its documentation for any purpose is hereby granted without fee, provided
+  * that the above copyright notice appear in all copies and that both that
+  * copyright notice and this permission notice appear in supporting
+  * documentation, and that the name Network Computing Devices, Inc. not be
+  * used in advertising or publicity pertaining to distribution of this 
+  * software without specific, written prior permission.
+  * 
+  * THIS SOFTWARE IS PROVIDED `AS-IS'.  NETWORK COMPUTING DEVICES, INC.,
+  * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT
+  * LIMITATION ALL IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
+  * PARTICULAR PURPOSE, OR NONINFRINGEMENT.  IN NO EVENT SHALL NETWORK
+  * COMPUTING DEVICES, INC., BE LIABLE FOR ANY DAMAGES WHATSOEVER, INCLUDING
+  * SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES, INCLUDING LOSS OF USE,
+  * DATA, OR PROFITS, EVEN IF ADVISED OF THE POSSIBILITY THEREOF, AND
+  * REGARDLESS OF WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE,
+  * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+  * SOFTWARE.
+  * 
+  * $NCDId: @(#)lbxbufstr.h,v 1.1 1994/02/16 18:57:42 lemke Exp $
+  */
+ #ifndef _BUFFERSTR_H_
+ #define _BUFFERSTR_H_
+ 
+ #include	"lbxbuf.h"
+ 
+ /*
+  * LZW Input/Output buffer
+  */
+ typedef struct _lzwbuffer {
+ 	char 	*bufbase;
+ 	char	*bufend;
+ 	char	*bufptr;
+ 	int  	bufcnt;
+ } LzwBuffer;
+ 
+ #define BYTES_AVAIL(inbuf, len)	\
+ 	(((inbuf)->bufcnt >= (len)) ? (inbuf)->bufptr : NULL)
+ 
+ #endif	/* _BUFFERSTR_H_ */
*** /dev/null	Mon Jan 23 16:31:55 1995
--- xc/workInProgress/lbx/include/extensions/lbxlzw.h	Mon Jan 23 16:31:55 1995
***************
*** 0 ****
--- 1,52 ----
+ /* $XConsortium: lbxlzw.h,v 1.4 94/12/01 20:07:54 mor Exp $ */
+ /*
+  * $NCDId: @(#)lzw.h,v 1.2 1994/01/17 20:59:50 dct Exp $
+  *
+  * Copyright 1993 Network Computing Devices
+  *
+  * Permission to use, copy, modify, distribute, and sell this software and its
+  * documentation for any purpose is hereby granted without fee, provided that
+  * the above copyright notice appear in all copies and that both that
+  * copyright notice and this permission notice appear in supporting
+  * documentation, and that the name of NCD. not be used in advertising or
+  * publicity pertaining to distribution of the software without specific,
+  * written prior permission.  NCD. makes no representations about the
+  * suitability of this software for any purpose.  It is provided "as is"
+  * without express or implied warranty.
+  *
+  * NCD. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL NCD.
+  * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
+  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  *
+  * Author:  Dale Tonogai, Network Computing Devices
+  */
+ 
+ #ifndef _LZW_H_
+ #define _LZW_H_
+ 
+ #define LZW_STRCOMP_OPT		"lzw"
+ #define LZW_STRCOMP_OPT_LEN	3
+ 
+ #define LZW_PACKET_HDRLEN	2
+ #define LZW_MAX_DATALEN		0xfff
+ #define LZW_MAX_PLAIN		270
+ #define LZW_MAX_OUTLEN		(LZW_MAX_PLAIN << 1)
+ 
+ #define LZW_COMPRESS_FLAG	0x80
+ #define LZW_DATALEN_MASK	0x0f
+ 
+ #define LZW_PUT_PKTHDR(p, len, compflag) \
+     { \
+ 	(p)[0] = ((unsigned)(len)) >> 8 | ((compflag) ? LZW_COMPRESS_FLAG : 0);\
+ 	(p)[1] = (len) & 0xff; \
+     }
+ 
+ #define LZW_GET_DATALEN(p) \
+ 	((((unsigned)((p)[0] & LZW_DATALEN_MASK)) << 8) | (unsigned)(p)[1])
+ 
+ #define LZW_COMPRESSED(p) ((p)[0] & LZW_COMPRESS_FLAG)
+ 
+ #endif /* _LZW_H_ */
*** /dev/null	Wed Jan 18 13:05:25 1995
--- xc/workInProgress/lbx/include/extensions/lbxopts.h	Wed Jan 18 13:05:23 1995
***************
*** 0 ****
--- 1,73 ----
+ /* $XConsortium: lbxopts.h,v 1.1 94/12/01 20:04:44 mor Exp $ */
+ /*
+  * Copyright 1994 Network Computing Devices, Inc.
+  *
+  * Permission to use, copy, modify, distribute, and sell this software and
+  * its documentation for any purpose is hereby granted without fee, provided
+  * that the above copyright notice appear in all copies and that both that
+  * copyright notice and this permission notice appear in supporting
+  * documentation, and that the name Network Computing Devices, Inc. not be
+  * used in advertising or publicity pertaining to distribution of this
+  * software without specific, written prior permission.
+  *
+  * THIS SOFTWARE IS PROVIDED `AS-IS'.  NETWORK COMPUTING DEVICES, INC.,
+  * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT
+  * LIMITATION ALL IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
+  * PARTICULAR PURPOSE, OR NONINFRINGEMENT.  IN NO EVENT SHALL NETWORK
+  * COMPUTING DEVICES, INC., BE LIABLE FOR ANY DAMAGES WHATSOEVER, INCLUDING
+  * SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES, INCLUDING LOSS OF USE, DATA,
+  * OR PROFITS, EVEN IF ADVISED OF THE POSSIBILITY THEREOF, AND REGARDLESS OF
+  * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
+  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  *
+  * $NCDId: @(#)lbxopts.h,v 1.1 1994/09/15 22:46:03 dct Exp $
+  */
+ 
+ #ifndef _LBX_OPTS_H_
+ #define _LBX_OPTS_H_
+ 
+ /*
+  * Negotiable configuration options
+  */
+ #define LBX_OPT_DELTA_PROXY		0
+ #define LBX_OPT_DELTA_SERVER		1
+ #define LBX_OPT_STREAM_COMP		2
+ #define LBX_OPT_BITMAP_COMP		3
+ #define LBX_OPT_PIXMAP_COMP		4
+ #define LBX_OPT_MSG_COMP		5	/* aka "squishing" */
+ #define LBX_OPT_ENCRYPT			6	/* ???? */
+ #define LBX_OPT_EXTENSION		255
+ 
+ /*
+  * Length fields are encoded in 1 or 3 bytes
+  */
+ #define LBX_OPT_SMALLLEN_SIZE		1
+ #define LBX_OPT_BIGLEN_SIZE		3
+ #define LBX_OPT_BIGLEN_MIN		256
+ 
+ #define LBX_OPT_DECODE_LEN(p, len, size) \
+     if ((p)[0]) { \
+ 	(len) = (p)[0]; \
+ 	(size) = LBX_OPT_SMALLLEN_SIZE; \
+     } \
+     else { \
+ 	(len) = LBX_OPT_BIGLEN_MIN + (p)[1] << 8 | (p)[2]; \
+ 	(size) = LBX_OPT_BIGLEN_SIZE; \
+     }
+ 
+ /*
+  * Option header lengths
+  */
+ #define LBX_OPT_SMALLHDR_LEN		(1 + LBX_OPT_SMALLLEN_SIZE)
+ #define LBX_OPT_BIGHDR_LEN		(1 + LBX_OPT_BIGLEN_SIZE)
+ 
+ /*
+  * Delta compression parameters
+  */
+ #define LBX_OPT_DELTA_REQLEN		6
+ #define LBX_OPT_DELTA_REPLYLEN		2
+ #define LBX_OPT_DELTA_NCACHE_DFLT	16
+ #define LBX_OPT_DELTA_MSGLEN_MIN	32
+ #define LBX_OPT_DELTA_MSGLEN_DFLT	64
+ 
+ #endif /* _LBX_OPTS_H_ */
*** -	Wed Jan 18 13:05:34 1995
--- xc/workInProgress/lbx/lib/Xext/Imakefile	Wed Jan 18 13:05:34 1995
***************
*** 1,13 ****
! XCOMM $XConsortium: Imakefile,v 1.1 94/04/13 18:05:48 rws Exp $
! #define DoNormalLib NormalLibXext
! #define DoSharedLib SharedLibXext
! #define DoDebugLib DebugLibXext
! #define DoProfileLib ProfileLibXext
  #define LibName lbxXext
- #define SoRev SOXEXTREV
  #define LibHeaders NO
- 
- #include <Threads.tmpl>
  
  #ifdef SharedXextReqs
  REQUIREDLIBS = SharedXextReqs
--- 1,9 ----
! XCOMM $XConsortium: Imakefile,v 1.3 94/12/06 22:02:25 mor Exp $
! #include <Threads.tmpl>
! 
! #define DoNormalLib YES
  #define LibName lbxXext
  #define LibHeaders NO
  
  #ifdef SharedXextReqs
  REQUIREDLIBS = SharedXextReqs
*** -	Wed Jan 18 13:05:39 1995
--- xc/workInProgress/lbx/lib/lbxutil/Imakefile	Wed Jan 18 13:05:39 1995
***************
*** 1,11 ****
! XCOMM $XConsortium: Imakefile,v 1.3 94/02/17 15:19:37 dpw Exp $
  #include <Server.tmpl>
  
  #define	IHaveSubdirs
  
! SUBDIRS = lzw delta
! OBJS = lzw/?*.o delta/?*.o
! DONES = lzw/DONE delta/DONE
  
  #undef _LinkBuildLibrary
  #define _LinkBuildLibrary(lib) LinkBuildLibrary(lib)
--- 1,11 ----
! XCOMM $XConsortium: Imakefile,v 1.4 94/09/13 17:22:05 mor Exp $
  #include <Server.tmpl>
  
  #define	IHaveSubdirs
  
! SUBDIRS = lzw delta image
! OBJS = lzw/?*.o delta/?*.o image/?*.o
! DONES = lzw/DONE delta/DONE image/DONE
  
  #undef _LinkBuildLibrary
  #define _LinkBuildLibrary(lib) LinkBuildLibrary(lib)
*** /dev/null	Wed Jan 18 13:05:45 1995
--- xc/workInProgress/lbx/lib/lbxutil/image/Imakefile	Wed Jan 18 13:05:43 1995
***************
*** 0 ****
--- 1,32 ----
+ XCOMM $XConsortium: Imakefile,v 1.3 95/01/17 18:20:04 mor Exp $
+ 
+ #include <Library.tmpl>
+ 
+ SRCS = dfaxg42d.c dpackbits.c efaxg42d.c epackbits.c misc.c
+ 
+ OBJS = dfaxg42d.o dpackbits.o efaxg42d.o epackbits.o misc.o
+ 
+ INCLUDES = -I$(INCLUDESRC) -I$(EXTINCSRC) -I$(SERVERSRC)/include -I../../../include/extensions
+ 
+ SubdirLibraryRule($(OBJS))
+ NormalLibraryObjectRule()
+ NormalLintTarget($(SRCS))
+ 
+ MKG3STATES = ./mkg3states
+ 
+ g3states.h : mkg3states.c
+ 	RemoveFiles($@ ProgramTargetName(mkg3states))
+ 	-HostLinkRule(mkg3states, $(CFLAGS),mkg3states.c,$(LDLIBS))
+ 	RunProgram(MKG3STATES,> g3_states_h)
+ 	$(MV) g3_states_h $@
+ 	RemoveFiles(ProgramTargetName(mkg3states) g3_states_h)
+ 
+ includes:: g3states.h
+ 
+ depend:: g3states.h
+ 
+ clean::
+ 	RemoveFiles(g3_states_h g3states.h ProgramTargetName(mkg3states))
+ 
+ DependTarget()
+ 
*** /dev/null	Wed Jan 18 13:05:46 1995
--- xc/workInProgress/lbx/lib/lbxutil/image/misc.c	Wed Jan 18 13:05:46 1995
***************
*** 0 ****
--- 1,216 ----
+ /* $XConsortium: misc.c,v 1.2 94/11/22 22:24:46 mor Exp $ */
+ /*
+  * Copyright (c) 1988, 1989, 1990, 1991, 1992 Sam Leffler
+  * Copyright (c) 1991, 1992 Silicon Graphics, Inc.
+  *
+  * Permission to use, copy, modify, distribute, and sell this software and 
+  * its documentation for any purpose is hereby granted without fee, provided
+  * that (i) the above copyright notices and this permission notice appear in
+  * all copies of the software and related documentation, and (ii) the names of
+  * Sam Leffler and Silicon Graphics may not be used in any advertising or
+  * publicity relating to the software without the specific, prior written
+  * permission of Sam Leffler and Silicon Graphics.
+  * 
+  * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
+  * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
+  * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
+  * 
+  * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
+  * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
+  * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+  * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
+  * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
+  * OF THIS SOFTWARE.
+  */
+ 
+ /*
+  * This module contains utilities for image compression used
+  * by the LBX server and proxy.
+  */
+ 
+ static unsigned char zeroruns[256] = {
+     8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,	/* 0x00 - 0x0f */
+     3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,	/* 0x10 - 0x1f */
+     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,	/* 0x20 - 0x2f */
+     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,	/* 0x30 - 0x3f */
+     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	/* 0x40 - 0x4f */
+     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	/* 0x50 - 0x5f */
+     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	/* 0x60 - 0x6f */
+     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	/* 0x70 - 0x7f */
+     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x80 - 0x8f */
+     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x90 - 0x9f */
+     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0xa0 - 0xaf */
+     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0xb0 - 0xbf */
+     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0xc0 - 0xcf */
+     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0xd0 - 0xdf */
+     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0xe0 - 0xef */
+     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0xf0 - 0xff */
+ };
+ 
+ static unsigned char oneruns[256] = {
+     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x00 - 0x0f */
+     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x10 - 0x1f */
+     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x20 - 0x2f */
+     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x30 - 0x3f */
+     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x40 - 0x4f */
+     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x50 - 0x5f */
+     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x60 - 0x6f */
+     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x70 - 0x7f */
+     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	/* 0x80 - 0x8f */
+     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	/* 0x90 - 0x9f */
+     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	/* 0xa0 - 0xaf */
+     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	/* 0xb0 - 0xbf */
+     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,	/* 0xc0 - 0xcf */
+     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,	/* 0xd0 - 0xdf */
+     3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,	/* 0xe0 - 0xef */
+     4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 7, 8,	/* 0xf0 - 0xff */
+ };
+ 
+ 
+ static unsigned char BitRevTable[256] = {
+     0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
+     0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
+     0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
+     0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
+     0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
+     0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
+     0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
+     0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
+     0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
+     0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
+     0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
+     0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
+     0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
+     0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
+     0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
+     0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
+     0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
+     0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
+     0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
+     0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
+     0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
+     0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
+     0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
+     0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
+     0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
+     0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
+     0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
+     0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
+     0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
+     0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
+     0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
+     0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff
+ };
+ 
+ 
+ /*
+  * Find a span of ones or zeros using the supplied table.  The byte-aligned
+  * start of the bit string is supplied along with the start+end bit indices.
+  * The table gives the number of consecutive ones or zeros starting from the
+  * msb and is indexed by byte value.
+  */
+ 
+ static int
+ findspan (bpp, bs, be, tab)
+ 
+ unsigned char **bpp;
+ int bs, be;
+ register unsigned char *tab;
+ 
+ {
+     register unsigned char *bp = *bpp;
+     register int bits = be - bs;
+     register int n, span;
+ 
+     /*
+      * Check partial byte on lhs.
+      */
+ 
+     if (bits > 0 && (n = (bs & 7)))
+     {
+ 	span = tab[(*bp << n) & 0xff];
+ 
+ 	if (span > 8 - n)	/* table value too generous */
+ 	    span = 8 - n;
+ 	if (span > bits)	/* constrain span to bit range */
+ 	    span = bits;
+ 	if (n+span < 8)		/* doesn't extend to edge of byte */
+ 	    goto done;
+ 
+ 	bits -= span;
+ 	bp++;
+     }
+     else
+ 	span = 0;
+ 
+     /*
+      * Scan full bytes for all 1's or all 0's.
+      */
+ 
+     while (bits >= 8)
+     {
+ 	n = tab[*bp];
+ 	span += n;
+ 	bits -= n;
+ 	if (n < 8)		/* end of run */
+ 	    goto done;
+ 	bp++;
+     }
+ 
+     /*
+      * Check partial byte on rhs.
+      */
+ 
+     if (bits > 0)
+     {
+ 	n = tab[*bp];
+ 	span += (n > bits ? bits : n);
+     }
+ 
+ done:
+ 
+     *bpp = bp;
+     return (span);
+ }
+ 
+ /*
+  * Return the offset of the next bit in the range [bs..be] that is different
+  * from the specified color.  The end, be, is returned if no such bit exists.
+  */
+ 
+ int
+ LbxImageFindDiff (cp, bs, be, color)
+ 
+ unsigned char *cp;
+ int bs, be, color;
+ 
+ {
+     cp += bs >> 3;			/* adjust byte offset */
+     return (bs + findspan (&cp, bs, be, color ? oneruns : zeroruns));
+ }
+ 
+ 
+ 
+ 
+ LbxReverseBits (cp, n)
+ 
+ register unsigned char *cp;
+ register int n;
+ 
+ {
+     for (; n > 8; n -= 8)
+     {
+ 	cp[0] = BitRevTable[cp[0]];
+ 	cp[1] = BitRevTable[cp[1]];
+ 	cp[2] = BitRevTable[cp[2]];
+ 	cp[3] = BitRevTable[cp[3]];
+ 	cp[4] = BitRevTable[cp[4]];
+ 	cp[5] = BitRevTable[cp[5]];
+ 	cp[6] = BitRevTable[cp[6]];
+ 	cp[7] = BitRevTable[cp[7]];
+ 	cp += 8;
+     }
+ 
+     while (n-- > 0)
+ 	*cp = BitRevTable[*cp], cp++;
+ }
*** /dev/null	Wed Jan 18 13:05:50 1995
--- xc/workInProgress/lbx/lib/lbxutil/image/efaxg42d.c	Wed Jan 18 13:05:48 1995
***************
*** 0 ****
--- 1,338 ----
+ /* $XConsortium: efaxg42d.c,v 1.4 95/01/17 18:15:58 mor Exp $ */
+ /*
+  * Copyright (c) 1988, 1989, 1990, 1991, 1992 Sam Leffler
+  * Copyright (c) 1991, 1992 Silicon Graphics, Inc.
+  *
+  * Permission to use, copy, modify, distribute, and sell this software and 
+  * its documentation for any purpose is hereby granted without fee, provided
+  * that (i) the above copyright notices and this permission notice appear in
+  * all copies of the software and related documentation, and (ii) the names of
+  * Sam Leffler and Silicon Graphics may not be used in any advertising or
+  * publicity relating to the software without the specific, prior written
+  * permission of Sam Leffler and Silicon Graphics.
+  * 
+  * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
+  * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
+  * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
+  * 
+  * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
+  * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
+  * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+  * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
+  * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
+  * OF THIS SOFTWARE.
+  */
+ 
+ #include "lbxfax.h"
+ #include "lbximage.h"
+ #include "lbxbwcodes.h"
+ 
+ /*
+  * -------------------------------------------------------------------------
+  *              FAX G42D encoding for 1 bit images
+  * -------------------------------------------------------------------------
+  */
+ 
+ static short sp_data, sp_bit;
+ 
+ static tableentry horizcode =
+     { 3, 0x1 };		/* 001 */
+ 
+ static tableentry passcode =
+     { 4, 0x1 };		/* 0001 */
+ 
+ static tableentry vcodes[7] = {
+     { 7, 0x03 },	/* 0000 011 */
+     { 6, 0x03 },	/* 0000 11 */
+     { 3, 0x03 },	/* 011 */
+     { 1, 0x1 },		/* 1 */
+     { 3, 0x2 },		/* 010 */
+     { 6, 0x02 },	/* 0000 10 */
+     { 7, 0x02 }		/* 0000 010 */
+ };
+ 
+ typedef struct {
+     unsigned char *bufStart;
+     unsigned char *bufPtr;
+     int bufSize;
+     int bytesLeft;
+ } Buffer;
+ 
+ 
+ 
+ /*
+  * Flush bits to output buffer.
+  */
+ 
+ static int
+ flushbits (outbuf)
+ 
+ Buffer *outbuf;
+ 
+ {
+     if (outbuf->bytesLeft > 0)
+     {
+ 	*(outbuf->bufPtr++) = sp_data;
+ 	outbuf->bytesLeft--;
+ 
+ 	sp_data = 0;
+ 	sp_bit = 8;
+ 
+ 	return (1);
+     }
+     else
+ 	return (0);
+ }
+ 
+ 
+ /*
+  * Write a variable-length bit-value to the output stream.  Values are
+  * assumed to be at most 16 bits.
+  */
+ 
+ static int
+ putbits (bits, length, outbuf)
+ 
+ unsigned int bits;
+ unsigned int length;
+ Buffer *outbuf;
+ 
+ {
+     static int mask[9] =
+         {0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff};
+ 
+     while (length > sp_bit)
+     {
+ 	sp_data |= bits >> (length - sp_bit);
+ 	length -= sp_bit;
+ 	if (!flushbits (outbuf))
+ 	    return (0);
+     }
+ 
+     sp_data |= (bits & mask[length]) << (sp_bit - length);
+     sp_bit -= length;
+ 
+     if (sp_bit == 0)
+     {
+ 	if (!flushbits (outbuf))
+ 	    return (0);
+     }
+ 
+     return (1);
+ }
+ 
+ 
+ /*
+  * Write a code to the output stream.
+  */
+ 
+ static int
+ putcode (te, outbuf)
+ 
+ tableentry *te;
+ Buffer *outbuf;
+ 
+ {
+     return (putbits (te->code, te->length, outbuf));
+ }
+ 
+ 
+ /*
+  * Write the sequence of codes that describes the specified span of
+  * zero's or one's.  The appropriate table that holds the make-up and
+  * terminating codes is supplied.
+  */
+ 
+ static int
+ putspan (span, tab, outbuf)
+ 
+ int span;
+ tableentry *tab;
+ Buffer *outbuf;
+ 
+ {
+     while (span >= 2624)
+     {
+ 	tableentry *te = &tab[63 + (2560 >> 6)];
+ 	if (!putcode (te, outbuf))
+ 	    return (0);
+ 	span -= te->runlen;
+     }
+ 
+     if (span >= 64)
+     {
+ 	tableentry *te = &tab[63 + (span >> 6)];
+ 	if (!putcode (te, outbuf))
+ 	    return (0);
+ 	span -= te->runlen;
+     }
+ 
+     if (!putcode (&tab[span], outbuf))
+ 	return (0);
+ 
+     return (1);
+ }
+ 
+ 
+ 
+ #define	PIXEL(buf,ix)	((((buf)[(ix)>>3]) >> (7-((ix)&7))) & 1)
+ 
+ static int
+ EncodeFaxG42D (inbuf, refline, bits, outbuf)
+ 
+ unsigned char *inbuf;
+ unsigned char *refline;
+ int bits;
+ Buffer *outbuf;
+ 
+ {
+     short white = 1;
+     int a0 = 0;
+     int a1 = (PIXEL (inbuf, 0) != white ?
+ 	0 : LbxImageFindDiff (inbuf, 0, bits, white));
+     int b1 = (PIXEL (refline, 0) != white ?
+ 	0 : LbxImageFindDiff (refline, 0, bits, white));
+     int a2, b2;
+ 
+     for (;;)
+     {
+ 	b2 = LbxImageFindDiff (refline, b1, bits, PIXEL (refline, b1));
+ 	if (b2 >= a1)
+ 	{
+ 	    int d = b1 - a1;
+ 	    if (!(-3 <= d && d <= 3))
+ 	    {
+ 		/* horizontal mode */
+ 
+ 		a2 = LbxImageFindDiff (inbuf, a1, bits, PIXEL (inbuf, a1));
+ 		if (!putcode (&horizcode, outbuf))
+ 		    return (0);
+ 
+ 		if (a0 + a1 == 0 || PIXEL (inbuf, a0) == white)
+ 		{
+ 		    if (!putspan(a1 - a0, TIFFFaxWhiteCodes, outbuf))
+ 			return (0);
+ 		    if (!putspan(a2 - a1, TIFFFaxBlackCodes, outbuf))
+ 			return (0);
+ 		}
+ 		else
+ 		{
+ 		    if (!putspan (a1 - a0, TIFFFaxBlackCodes, outbuf))
+ 			return (0);
+ 		    if (!putspan (a2 - a1, TIFFFaxWhiteCodes, outbuf))
+ 			return (0);
+ 		}
+ 
+ 		a0 = a2;
+ 	    }
+ 	    else
+ 	    {
+ 		/* vertical mode */
+ 
+ 		if (!putcode (&vcodes[d+3], outbuf))
+ 		    return (0);
+ 		a0 = a1;
+ 	    }
+ 	}
+ 	else
+ 	{
+ 	    /* pass mode */
+ 
+ 	    if (!putcode (&passcode, outbuf))
+ 		return (0);
+ 	    a0 = b2;
+ 	}
+ 
+ 	if (a0 >= bits)
+ 	    break;
+ 
+ 	a1 = LbxImageFindDiff (inbuf, a0, bits, PIXEL (inbuf, a0));
+ 	b1 = LbxImageFindDiff (refline, a0, bits, !PIXEL (inbuf, a0));
+ 	b1 = LbxImageFindDiff (refline, b1, bits, PIXEL (inbuf, a0));
+     }
+ 
+     return (1);
+ }
+ 
+ 
+ int
+ LbxImageEncodeFaxG42D (inbuf, outbuf, outbufSize,
+     image_bytes, pixels_per_line, reverse_bits, bytesCompressed)
+ 
+ unsigned char *inbuf;
+ unsigned char *outbuf;
+ int outbufSize;
+ int image_bytes;
+ int pixels_per_line;
+ int reverse_bits;
+ int *bytesCompressed;
+ 
+ {
+     int bytes_per_scanline = ROUNDUP ((float) pixels_per_line / 8.0);
+     int padded_bytes_per_scanline = (bytes_per_scanline % 4) ?
+ 	bytes_per_scanline + (4 - bytes_per_scanline % 4) : bytes_per_scanline;
+     unsigned char *refline, *refptr;
+     unsigned char *save_inbuf = inbuf;
+     int bytes_left = image_bytes;
+     Buffer OutBuf;
+     int status, i;
+ 
+     OutBuf.bufStart = OutBuf.bufPtr = outbuf;
+     OutBuf.bufSize = OutBuf.bytesLeft = outbufSize;
+ 
+     if (!(refline = (unsigned char *) malloc (bytes_per_scanline + 1)))
+ 	return (LBX_IMAGE_COMPRESS_BAD_MALLOC);
+ 
+     refptr = refline + 1;
+ 
+     for (i = 0; i < bytes_per_scanline + 1; i++)
+ 	refline[i] = 0xff;
+ 
+     if (reverse_bits)
+ 	LbxReverseBits (inbuf, image_bytes);
+ 
+     sp_bit = 8;
+     sp_data = 0;
+ 
+     while (bytes_left > 0)
+     {
+ 	if (!(status = EncodeFaxG42D (inbuf, refptr,
+ 	    pixels_per_line, &OutBuf)))
+ 	{
+ 	    goto bad;
+ 	}
+ 
+ 	memcpy (refptr, inbuf, bytes_per_scanline);
+ 
+ 	inbuf += padded_bytes_per_scanline;
+ 	bytes_left -= padded_bytes_per_scanline;
+     }
+ 
+     status = putbits (EOL, 12, &OutBuf);
+     if (status)
+ 	status = putbits (EOL, 12, &OutBuf);
+     if (status && sp_bit != 8)
+     {
+ 	status = flushbits (&OutBuf);
+     }
+ 
+  bad:
+ 
+     free ((char *) refline);
+ 
+     /* put the bits back the way they were */
+     if (reverse_bits)
+ 	LbxReverseBits (save_inbuf, image_bytes);
+ 
+     if (status)
+     {
+ 	*bytesCompressed = OutBuf.bufPtr - OutBuf.bufStart;
+ 
+ 	if (OutBuf.bytesLeft > 0)
+ 	    return (LBX_IMAGE_COMPRESS_SUCCESS);
+ 	else
+ 	    return (LBX_IMAGE_COMPRESS_NOT_WORTH_IT);
+     }
+     else
+ 	return (LBX_IMAGE_COMPRESS_NOT_WORTH_IT);
+ }
*** /dev/null	Wed Jan 18 13:05:55 1995
--- xc/workInProgress/lbx/lib/lbxutil/image/epackbits.c	Wed Jan 18 13:05:53 1995
***************
*** 0 ****
--- 1,205 ----
+ /* $XConsortium: epackbits.c,v 1.1 94/11/08 19:54:40 mor Exp $ */
+ /*
+  * Copyright (c) 1988, 1989, 1990, 1991, 1992 Sam Leffler
+  * Copyright (c) 1991, 1992 Silicon Graphics, Inc.
+  *
+  * Permission to use, copy, modify, distribute, and sell this software and 
+  * its documentation for any purpose is hereby granted without fee, provided
+  * that (i) the above copyright notices and this permission notice appear in
+  * all copies of the software and related documentation, and (ii) the names of
+  * Sam Leffler and Silicon Graphics may not be used in any advertising or
+  * publicity relating to the software without the specific, prior written
+  * permission of Sam Leffler and Silicon Graphics.
+  * 
+  * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
+  * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
+  * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
+  * 
+  * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
+  * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
+  * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+  * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
+  * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
+  * OF THIS SOFTWARE.
+  */
+ 
+ #include "lbximage.h"
+ 
+ /*
+  * -------------------------------------------------------------------------
+  *              PackBits encoding for 8 bit color images
+  * -------------------------------------------------------------------------
+  */
+ 
+ #define PutByte(byte,bufptr,bytesLeft) \
+ { \
+     if (*bytesLeft < 1) {\
+          *outbuf = outptr; \
+          return (0); \
+     } \
+     *bufptr++ = byte; \
+     (*bytesLeft)--; \
+ }
+     
+ 
+ static int
+ EncodePackBits (inbuf, numPixels, outbuf, bytesLeft)
+ 
+ char *inbuf;
+ int numPixels;
+ char **outbuf;
+ int *bytesLeft;
+ 
+ {
+     register int pixelsLeft = numPixels;
+     register char *outptr = *outbuf;
+     register char *lastliteral;
+     register int n, b;
+     enum { BASE, LITERAL, RUN, LITERAL_RUN } state;
+     int slop;
+ 
+     state = BASE;
+     lastliteral = 0;
+ 
+     while (pixelsLeft > 0)
+     {
+ 	/*
+ 	 * Find the longest string of identical bytes.
+ 	 */
+ 
+ 	b = *inbuf++, pixelsLeft--, n = 1;
+ 	for (; pixelsLeft > 0 && b == *inbuf; pixelsLeft--, inbuf++)
+ 	    n++;
+ 
+     again:
+ 
+ 	switch (state)
+ 	{
+ 	case BASE:		/* initial state, set run/literal */
+ 	    if (n > 1)
+ 	    {
+ 		state = RUN;
+ 
+ 		if (n > 128)
+ 		{
+ 		    PutByte (-127, outptr, bytesLeft);
+ 		    PutByte (b, outptr, bytesLeft);
+ 		    n -= 128;
+ 		    goto again;
+ 		}
+ 
+ 		PutByte (-(n-1), outptr, bytesLeft);
+ 		PutByte (b, outptr, bytesLeft);
+ 	    }
+ 	    else
+ 	    {
+ 		lastliteral = outptr;
+ 		PutByte (0, outptr, bytesLeft);
+ 		PutByte (b, outptr, bytesLeft);
+ 		state = LITERAL;
+ 	    }
+ 
+ 	    break;
+ 
+ 	case LITERAL:		/* last object was literal string */
+ 	    if (n > 1)
+ 	    {
+ 		state = LITERAL_RUN;
+ 
+ 		if (n > 128)
+ 		{
+ 		    PutByte (-127, outptr, bytesLeft);
+ 		    PutByte (b, outptr, bytesLeft);
+ 		    n -= 128;
+ 		    goto again;
+ 		}
+ 
+ 		    PutByte (-(n-1), outptr, bytesLeft); /* encode run */
+ 		    PutByte (b, outptr, bytesLeft);
+ 	    }
+ 	    else
+ 	    {			/* extend literal */
+ 		if (++(*lastliteral) == 127)
+ 		    state = BASE;
+ 		PutByte (b, outptr, bytesLeft);
+ 	    }
+ 
+ 	    break;
+ 
+ 	case RUN:		/* last object was run */
+ 	    if (n > 1)
+ 	    {
+ 		if (n > 128)
+ 		{
+ 		    PutByte (-127, outptr, bytesLeft);
+ 		    PutByte (b, outptr, bytesLeft);
+ 		    n -= 128;
+ 		    goto again;
+ 		}
+ 		PutByte (-(n-1), outptr, bytesLeft);
+ 		PutByte (b, outptr, bytesLeft);
+ 	    }
+ 	    else
+ 	    {
+ 		lastliteral = outptr;
+ 		PutByte (0, outptr, bytesLeft);
+ 		PutByte (b, outptr, bytesLeft);
+ 		state = LITERAL;
+ 	    }
+ 
+ 	    break;
+ 
+ 	case LITERAL_RUN:	/* literal followed by a run */
+ 	    /*
+ 	     * Check to see if previous run should
+ 	     * be converted to a literal, in which
+ 	     * case we convert literal-run-literal
+ 	     * to a single literal.
+ 	     */
+ 
+ 	    if (n == 1 && outptr[-2] == (char)-1 && *lastliteral < 126)
+ 	    {
+ 		state = (((*lastliteral) += 2) == 127 ? BASE : LITERAL);
+ 		outptr[-2] = outptr[-1];	/* replicate */
+ 	    }
+ 	    else
+ 		state = RUN;
+ 	    goto again;
+ 	}
+     }
+ 
+     *outbuf = outptr;
+ 
+     return (1);
+ }
+ 
+ 
+ int
+ LbxImageEncodePackBits (inbuf, outbuf, outbufSize,
+     num_scan_lines, scan_line_size, bytesCompressed)
+ 
+ char *inbuf;
+ char *outbuf;
+ int outbufSize;
+ int num_scan_lines;
+ int scan_line_size;
+ int *bytesCompressed;
+ 
+ {
+     char *outbuf_start = outbuf;
+     int padded_scan_line_size = (scan_line_size % 4) ?
+ 	scan_line_size + (4 - scan_line_size % 4) : scan_line_size;
+     int bytesLeft = outbufSize;
+ 
+     while (num_scan_lines > 0)
+     {
+ 	if (!EncodePackBits (inbuf, scan_line_size, &outbuf, &bytesLeft))
+ 	    return (LBX_IMAGE_COMPRESS_NOT_WORTH_IT);
+ 
+ 	inbuf += padded_scan_line_size;
+ 	num_scan_lines--;
+     }
+ 
+     *bytesCompressed = outbuf - outbuf_start;
+     return (LBX_IMAGE_COMPRESS_SUCCESS);
+ }
*** /dev/null	Wed Jan 18 13:05:59 1995
--- xc/workInProgress/lbx/lib/lbxutil/image/dfaxg42d.c	Wed Jan 18 13:05:58 1995
***************
*** 0 ****
--- 1,434 ----
+ /* $XConsortium: dfaxg42d.c,v 1.4 94/11/29 19:15:16 mor Exp $ */
+ /*
+  * Copyright (c) 1988, 1989, 1990, 1991, 1992 Sam Leffler
+  * Copyright (c) 1991, 1992 Silicon Graphics, Inc.
+  *
+  * Permission to use, copy, modify, distribute, and sell this software and 
+  * its documentation for any purpose is hereby granted without fee, provided
+  * that (i) the above copyright notices and this permission notice appear in
+  * all copies of the software and related documentation, and (ii) the names of
+  * Sam Leffler and Silicon Graphics may not be used in any advertising or
+  * publicity relating to the software without the specific, prior written
+  * permission of Sam Leffler and Silicon Graphics.
+  * 
+  * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
+  * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
+  * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
+  * 
+  * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
+  * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
+  * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+  * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
+  * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
+  * OF THIS SOFTWARE.
+  */
+ 
+ #include <X11/Xfuncs.h>
+ #include "g3states.h"
+ #include "lbxfax.h"
+ #include "lbximage.h"
+ 
+ /*
+  * -------------------------------------------------------------------------
+  *              FAX G42D decoding for 1 bit images
+  * -------------------------------------------------------------------------
+  */
+ 
+ static short sp_data, sp_bit;
+ 
+ 
+ /*
+  * Fetch a byte from the input stream
+  */
+ 
+ static unsigned char
+ fetchByte (inbuf)
+ 
+ unsigned char **inbuf;
+ 
+ {
+     unsigned char byte = **inbuf;
+     (*inbuf)++;
+     return (byte);
+ }
+ 
+ 
+ /*
+  * Decode a run of white.
+  */
+ 
+ static int
+ decode_white_run (inbuf)
+ 
+ unsigned char **inbuf;
+ 
+ {
+     short state = sp_bit;
+     short action;
+     int runlen = 0;
+ 
+     for (;;)
+     {
+ 	if (sp_bit == 0)
+ 	{
+ 	nextbyte:
+ 	    sp_data = fetchByte (inbuf);
+ 	}
+ 
+ 	action = TIFFFax1DAction[state][sp_data];
+ 	state = TIFFFax1DNextState[state][sp_data];
+ 	if (action == ACT_INCOMP)
+ 	    goto nextbyte;
+ 	if (action == ACT_INVALID)
+ 	    return (G3CODE_INVALID);
+ 	if (action == ACT_EOL)
+ 	    return (G3CODE_EOL);
+ 	sp_bit = state;
+ 	action = RUNLENGTH(action - ACT_WRUNT);
+ 	runlen += action;
+ 	if (action < 64)
+ 	    return (runlen);
+     }
+ }
+ 
+ 
+ /*
+  * Decode a run of black.
+  */
+ 
+ static int
+ decode_black_run (inbuf)
+ 
+ unsigned char **inbuf;
+ 
+ {
+     short state = sp_bit + 8;
+     short action;
+     int runlen = 0;
+ 
+     for (;;)
+     {
+ 	if (sp_bit == 0)
+ 	{
+ 	nextbyte:
+ 	    sp_data = fetchByte (inbuf);
+ 	}
+ 
+ 	action = TIFFFax1DAction[state][sp_data];
+ 	state = TIFFFax1DNextState[state][sp_data];
+ 	if (action == ACT_INCOMP)
+ 	    goto nextbyte;
+ 	if (action == ACT_INVALID)
+ 	    return (G3CODE_INVALID);
+ 	if (action == ACT_EOL)
+ 	    return (G3CODE_EOL);
+ 	sp_bit = state;
+ 	action = RUNLENGTH(action - ACT_BRUNT);
+ 	runlen += action;
+ 	if (action < 64)
+ 	    return (runlen);
+ 	state += 8;
+     }
+ }
+ 
+ 
+ /*
+  * Return the next uncompressed mode code word.
+  */
+ 
+ static int
+ decode_uncomp_code (inbuf)
+ 
+ unsigned char **inbuf;
+ 
+ {
+     short code;
+ 
+     do {
+ 	if (sp_bit == 0 || sp_bit > 7)
+ 	    sp_data = fetchByte (inbuf);
+ 
+ 	code = TIFFFaxUncompAction[sp_bit][sp_data];
+ 	sp_bit = TIFFFaxUncompNextState[sp_bit][sp_data];
+     } while (code == ACT_INCOMP);
+ 
+     return (code);
+ }
+ 
+ 
+ /*
+  * Fill a span with ones.
+  */
+ 
+ static void
+ fillspan (cp, x, count)
+ 
+ register char *cp;
+ register int x, count;
+ 
+ {
+     static unsigned char masks[] =
+         { 0, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff };
+ 
+     if (count <= 0)
+ 	return;
+ 
+     cp += x>>3;
+ 
+     if (x &= 7)
+     {
+ 	/* align to byte boundary */
+ 
+ 	if (count < 8 - x) {
+ 	    *cp++ |= masks[count] >> x;
+ 	    return;
+ 	}
+ 
+ 	*cp++ |= 0xff >> x;
+ 	count -= 8 - x;
+     }
+ 
+     while (count >= 8)
+     {
+ 	*cp++ = 0xff;
+ 	count -= 8;
+     }
+ 
+     *cp |= masks[count];
+ }
+ 
+ 
+ /*
+  * Return the next bit in the input stream.  This is
+  * used to extract 2D tag values and the color tag
+  * at the end of a terminating uncompressed data code.
+  */
+ 
+ static int
+ nextbit (inbuf)
+ 
+ unsigned char **inbuf;
+ 
+ {
+     static unsigned char bitMask[8] =
+         { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };
+     int bit;
+ 
+     if (sp_bit == 0)
+ 	sp_data = fetchByte (inbuf);
+ 
+     bit = sp_data & bitMask[sp_bit];
+ 
+     if (++(sp_bit) > 7)
+ 	sp_bit = 0;
+ 
+     return (bit);
+ }
+ 
+ 
+ static int
+ DecodeFaxG42D (inbuf, refline, pixels_per_line, outbuf)
+ 
+ unsigned char **inbuf;
+ unsigned char *refline;
+ int pixels_per_line;
+ unsigned char *outbuf;
+ 
+ {
+     int a0 = -1;
+     int b1, b2;
+     int run1, run2;		/* for horizontal mode */
+     short mode;
+     short color = 1;
+ 
+     do {
+ 	if (sp_bit == 0 || sp_bit > 7)
+ 	    sp_data = fetchByte (inbuf);
+ 
+ 	mode = TIFFFax2DMode[sp_bit][sp_data];
+ 	sp_bit = TIFFFax2DNextState[sp_bit][sp_data];
+ 
+ 	switch (mode)
+ 	{
+ 	case MODE_NULL:
+ 	    break;
+ 
+ 	case MODE_PASS:
+ 	    b2 = LbxImageFindDiff (refline, a0, pixels_per_line, !color);
+ 	    b1 = LbxImageFindDiff (refline, b2, pixels_per_line, color);
+ 	    b2 = LbxImageFindDiff (refline, b1, pixels_per_line, !color);
+ 
+ 	    if (color)
+ 	    {
+ 		if (a0 < 0)
+ 		    a0 = 0;
+ 		fillspan ((char *) outbuf, a0, b2 - a0);
+ 	    }
+ 
+ 	    a0 = b2;
+ 	    break;
+ 
+ 	case MODE_HORIZ:
+ 	    if (color == 1)
+ 	    {
+ 		run1 = decode_white_run (inbuf);
+ 		run2 = decode_black_run (inbuf);
+ 	    }
+ 	    else
+ 	    {
+ 		run1 = decode_black_run (inbuf);
+ 		run2 = decode_white_run (inbuf);
+ 	    }
+ 
+ 	    /*
+ 	     * Do the appropriate fill.  Note that we exit this logic with
+ 	     * the same color that we enter with since we do 2 fills.  This
+ 	     * explains the somewhat obscure logic below.
+ 	     */
+ 
+ 	    if (a0 < 0)
+ 		a0 = 0;
+ 	    if (a0 + run1 > pixels_per_line)
+ 		run1 = pixels_per_line - a0;
+ 	    if (color)
+ 		fillspan ((char *) outbuf, a0, run1);
+ 	    a0 += run1;
+ 	    if (a0 + run2 > pixels_per_line)
+ 		run2 = pixels_per_line - a0;
+ 	    if (!color)
+ 		fillspan ((char *) outbuf, a0, run2);
+ 	    a0 += run2;
+ 	    break;
+ 
+ 	case MODE_VERT_V0:
+ 	case MODE_VERT_VR1:
+ 	case MODE_VERT_VR2:
+ 	case MODE_VERT_VR3:
+ 	case MODE_VERT_VL1:
+ 	case MODE_VERT_VL2:
+ 	case MODE_VERT_VL3:
+ 	    b2 = LbxImageFindDiff (refline, a0, pixels_per_line, !color);
+ 	    b1 = LbxImageFindDiff (refline, b2, pixels_per_line, color);
+ 	    b1 += mode - MODE_VERT_V0;
+ 
+ 	    if (color)
+ 	    {
+ 		if (a0 < 0)
+ 		    a0 = 0;
+ 		fillspan ((char *) outbuf, a0, b1 - a0);
+ 	    }
+ 
+ 	    color = !color;
+ 	    a0 = b1;
+ 	    break;
+ 
+ 	case MODE_UNCOMP:
+ 	    /*
+ 	     * Uncompressed mode: select from the special set of code words.
+ 	     */
+ 
+ 	    if (a0 < 0)
+ 		a0 = 0;
+ 	    do
+ 	    {
+ 		mode = decode_uncomp_code (inbuf);
+ 		switch (mode)
+ 		{
+ 		case UNCOMP_RUN1:
+ 		case UNCOMP_RUN2:
+ 		case UNCOMP_RUN3:
+ 		case UNCOMP_RUN4:
+ 		case UNCOMP_RUN5:
+ 		    run1 = mode - UNCOMP_RUN0;
+ 		    fillspan ((char *) outbuf, a0+run1-1, 1);
+ 		    a0 += run1;
+ 		    break;
+ 
+ 		case UNCOMP_RUN6:
+ 		    a0 += 5;
+ 		    break;
+ 
+ 		case UNCOMP_TRUN0:
+ 		case UNCOMP_TRUN1:
+ 		case UNCOMP_TRUN2:
+ 		case UNCOMP_TRUN3:
+ 		case UNCOMP_TRUN4:
+ 
+ 		    run1 = mode - UNCOMP_TRUN0;
+ 		    a0 += run1;
+ 		    color = nextbit (inbuf) ? 0 : 1;
+ 		    break;
+ 
+ 		case UNCOMP_INVALID:
+ 		    goto bad;
+ 
+ 		case UNCOMP_EOF:
+ 		    return (0);
+ 		}
+ 	    } while (mode < UNCOMP_EXIT);
+ 	    break;
+ 
+ 	case MODE_ERROR_1:
+ 	    /* fall thru... */
+ 	case MODE_ERROR:
+ 	    goto bad;
+ 
+ 	default:
+ 	    return (0);
+ 	}
+ 
+     } while (a0 < pixels_per_line);
+ 
+ bad:
+     return (a0 >= pixels_per_line);
+ }
+ 
+ 
+ int
+ LbxImageDecodeFaxG42D (inbuf, outbuf, image_bytes,
+ 	pixels_per_line, reverse_bits)
+ 
+ unsigned char *inbuf;
+ unsigned char *outbuf;
+ int image_bytes;
+ int pixels_per_line;
+ int reverse_bits;
+ 
+ {
+     int bytes_per_scanline = ROUNDUP ((float) pixels_per_line / 8.0);
+     int padded_bytes_per_scanline = (bytes_per_scanline % 4) ?
+         bytes_per_scanline + (4 - bytes_per_scanline % 4) : bytes_per_scanline;
+     unsigned char *refline, *refptr;
+     unsigned char *outbuf_start = outbuf;
+     int bytes_left = image_bytes;
+     int i;
+ 
+     refline = (unsigned char *) malloc (bytes_per_scanline + 1);
+     refptr = refline + 1;
+ 
+     for (i = 0; i < bytes_per_scanline + 1; i++)
+ 	refline[i] = 0xff;
+ 
+     bzero (outbuf, image_bytes);
+ 
+     sp_bit = 0;
+     sp_data = 0;
+ 
+     while (bytes_left > 0)
+     {
+ 	if (!DecodeFaxG42D (&inbuf, refptr, pixels_per_line, outbuf))
+ 	    return (0);
+ 
+ 	memcpy (refptr, outbuf, bytes_per_scanline);
+ 
+ 	outbuf += padded_bytes_per_scanline;
+ 	bytes_left -= padded_bytes_per_scanline;
+     }
+ 
+     free ((char *) refline);
+ 
+     if (reverse_bits)
+ 	LbxReverseBits (outbuf_start, image_bytes);
+ 
+     return (outbuf - outbuf_start);
+ }
*** /dev/null	Wed Jan 18 13:06:02 1995
--- xc/workInProgress/lbx/lib/lbxutil/image/dpackbits.c	Wed Jan 18 13:06:01 1995
***************
*** 0 ****
--- 1,102 ----
+ /* $XConsortium: dpackbits.c,v 1.1 94/11/08 19:55:07 mor Exp $ */
+ /*
+  * Copyright (c) 1988, 1989, 1990, 1991, 1992 Sam Leffler
+  * Copyright (c) 1991, 1992 Silicon Graphics, Inc.
+  *
+  * Permission to use, copy, modify, distribute, and sell this software and 
+  * its documentation for any purpose is hereby granted without fee, provided
+  * that (i) the above copyright notices and this permission notice appear in
+  * all copies of the software and related documentation, and (ii) the names of
+  * Sam Leffler and Silicon Graphics may not be used in any advertising or
+  * publicity relating to the software without the specific, prior written
+  * permission of Sam Leffler and Silicon Graphics.
+  * 
+  * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
+  * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
+  * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
+  * 
+  * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
+  * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
+  * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+  * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
+  * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
+  * OF THIS SOFTWARE.
+  */
+ 
+ #include "lbximage.h"
+ 
+ /*
+  * -------------------------------------------------------------------------
+  *              PackBits decoding for 8 bit color images
+  * -------------------------------------------------------------------------
+  */
+ 
+ static void
+ DecodePackBits (inbuf, numPixels, outbuf)
+ 
+ char **inbuf;
+ int numPixels;
+ char *outbuf;
+ 
+ {
+     register char *inptr = *inbuf;
+     register int n, b;
+ 
+     while (numPixels > 0)
+     {
+ 	n = (int) *inptr++;
+ 
+ 	/* Watch out for compilers that don't sign extend chars... */
+ 
+ 	if (n >= 128)
+ 	    n -= 256;
+ 
+ 	if (n < 0)
+ 	{
+ 	    /* replicate next byte -n+1 times */
+ 
+ 	    if (n == -128)	/* nop */
+ 		continue;
+ 
+ 	    n = -n + 1;
+ 	    numPixels -= n;
+ 	    for (b = *inptr++; n-- > 0;)
+ 		*outbuf++ = b;
+ 	}
+ 	else
+ 	{
+ 	    /* copy next n+1 bytes literally */
+ 
+ 	    memcpy (outbuf, inptr, ++n);
+ 	    outbuf += n; numPixels -= n;
+ 	    inptr += n;
+ 	}
+     }
+ 
+     *inbuf = inptr;
+ }
+ 
+ 
+ int
+ LbxImageDecodePackBits (inbuf, outbuf, num_scan_lines, scan_line_size)
+ 
+ char *inbuf;
+ char *outbuf;
+ int num_scan_lines;
+ int scan_line_size;
+ 
+ {
+     char *outbuf_start = outbuf;
+     int padded_scan_line_size = (scan_line_size % 4) ?
+ 	scan_line_size + (4 - scan_line_size % 4) : scan_line_size;
+     int scan_line = 0;
+ 
+     while (num_scan_lines > 0)
+     {
+ 	DecodePackBits (&inbuf, scan_line_size, outbuf);
+ 	outbuf += padded_scan_line_size;
+ 	num_scan_lines--;
+     }
+ 
+     return (outbuf - outbuf_start);
+ }
*** /dev/null	Wed Jan 18 13:06:05 1995
--- xc/workInProgress/lbx/lib/lbxutil/image/lbxfax.h	Wed Jan 18 13:06:03 1995
***************
*** 0 ****
--- 1,49 ----
+ /* $XConsortium: lbxfax.h,v 1.2 94/11/22 22:26:19 mor Exp $ */
+ /*
+  * Copyright (c) 1988, 1989, 1990, 1991, 1992 Sam Leffler
+  * Copyright (c) 1991, 1992 Silicon Graphics, Inc.
+  *
+  * Permission to use, copy, modify, distribute, and sell this software and 
+  * its documentation for any purpose is hereby granted without fee, provided
+  * that (i) the above copyright notices and this permission notice appear in
+  * all copies of the software and related documentation, and (ii) the names of
+  * Sam Leffler and Silicon Graphics may not be used in any advertising or
+  * publicity relating to the software without the specific, prior written
+  * permission of Sam Leffler and Silicon Graphics.
+  * 
+  * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
+  * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
+  * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
+  * 
+  * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
+  * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
+  * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+  * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
+  * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
+  * OF THIS SOFTWARE.
+  */
+ 
+ /*
+  * This header file contains various constants and tables needed
+  * for FAX G42D compression.
+  */
+ 
+ typedef struct tableentry {
+     unsigned short length;	/* bit length of g3 code */
+     unsigned short code;	/* g3 code */
+     short	runlen;		/* run length in bits */
+ } tableentry;
+ 
+ #define	EOL	0x001	/* EOL code value - 0000 0000 0000 1 */
+ 
+ /* status values returned instead of a run length */
+ 
+ #define	G3CODE_INVALID	-1
+ #define	G3CODE_INCOMP	-2
+ #define	G3CODE_EOL	-3
+ #define	G3CODE_EOF	-4
+ 
+ #define ROUNDUP(x) (((x) > (int)(x)) ? ((int) (x) + 1) : ((int) (x)))
+ 
+ extern tableentry TIFFFaxWhiteCodes[];
+ extern tableentry TIFFFaxBlackCodes[];
*** /dev/null	Wed Jan 18 13:06:08 1995
--- xc/workInProgress/lbx/lib/lbxutil/image/mkg3states.c	Wed Jan 18 13:06:07 1995
***************
*** 0 ****
--- 1,764 ----
+ /* $XConsortium: mkg3states.c,v 1.2 95/01/17 20:29:41 mor Exp $ */
+ /*
+  * Copyright (c) 1991, 1992 Sam Leffler
+  * Copyright (c) 1991, 1992 Silicon Graphics, Inc.
+  *
+  * Permission to use, copy, modify, distribute, and sell this software and 
+  * its documentation for any purpose is hereby granted without fee, provided
+  * that (i) the above copyright notices and this permission notice appear in
+  * all copies of the software and related documentation, and (ii) the names of
+  * Sam Leffler and Silicon Graphics may not be used in any advertising or
+  * publicity relating to the software without the specific, prior written
+  * permission of Sam Leffler and Silicon Graphics.
+  * 
+  * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
+  * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
+  * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
+  * 
+  * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
+  * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
+  * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+  * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
+  * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
+  * OF THIS SOFTWARE.
+  */
+ 
+ /*
+  * Program to construct Group 3 & Group 4 decoding tables.
+  *
+  * This code is derived from code by Michael P. Marking.  In
+  * particular, the algorithms to generate the null_mode and
+  * horiz_mode state tables are his.  See the comments below
+  * for more information.
+  *
+  * BEGIN (from the original source)
+  LEGAL
+  *	Copyright 1989, 1990 Michael P. Marking, Post Office Box 8039,
+  *	Scottsdale, Arizona 85252-8039. All rights reserved.
+  *
+  *	License is granted by the copyright holder to distribute and use this
+  *	code without payment of royalties or the necessity of notification as
+  *	long as this notice (all the text under "LEGAL") is included.
+  *
+  *	This program is offered without any warranty of any kind. It includes
+  *	no warranty of merchantability or fitness for any purpose. Testing and
+  *	suitability for any use are the sole responsibility of the user.
+  *
+  INFORMATION
+  *	Although there is no support offered with this program, the author will
+  *	endeavor to correct errors. Updates will also be made available from
+  *	time to time.
+  *
+  *	Contact: Michael P. Marking, Post Office Box 8039, Scottsdale, Arizona
+  *	85252-8039 USA. Replies are not guaranteed to be swift. Beginning
+  *	July 1990, e-mail may be sent to uunet!ipel!marking.
+  *
+  *	Also beginning in July 1990, this code will be archived at the
+  *	ipel!phoenix BBS in file g3g4.zoo. The 24-hour telephone number
+  *	for 300/1200/2400 is (602)274-0462. When logging in, specify user
+  *	"public", system "bbs", and password "public".
+  *
+  *	This code is also available from the C Users Group in volume 317.
+  *
+  * END (from the original source)
+  */
+ #include <stdio.h>
+ 
+ #ifndef TRUE
+ #define	TRUE	1
+ #define	FALSE	0
+ #endif
+ 
+ #define WHITE	0
+ #define BLACK	1
+ 
+ /*
+  * G3 2D and G4 decoding modes.  Note that
+  * the vertical modes are ordered so that
+  * (mode - MODE_VERT_V0) gives the vertical
+  * adjustment for the b1 parameter.
+  */
+ #define MODE_NULL	0
+ #define MODE_PASS	1
+ #define MODE_HORIZ	2
+ #define MODE_VERT_VL3	3
+ #define MODE_VERT_VL2	4
+ #define MODE_VERT_VL1	5
+ #define MODE_VERT_V0	6
+ #define MODE_VERT_VR1	7
+ #define MODE_VERT_VR2	8
+ #define MODE_VERT_VR3	9
+ #define MODE_UNCOMP	10
+ #define MODE_ERROR	11
+ #define MODE_ERROR_1	12
+ 
+ unsigned long append_0 (prefix)
+ unsigned long prefix;
+ {
+     return (prefix + (1L<<16));
+ }
+ 
+ unsigned long append_1 (prefix)
+ unsigned long prefix;
+ {
+     static unsigned short prefix_bit[16] = {
+ 	0x8000, 0x4000, 0x2000, 0x1000,
+ 	0x0800, 0x0400, 0x0200, 0x0100,
+ 	0x0080, 0x0040, 0x0020, 0x0010,
+ 	0x0008, 0x0004, 0x0002, 0x0001
+     };
+     unsigned char len = (prefix >> 16) & 0xf;
+     return (append_0(prefix) + prefix_bit[len]);
+ }
+ 
+ #define	G3CODES
+ #include "lbxfax.h"
+ #include "lbxbwcodes.h"
+ 
+ short search_table (prefix, tab, n)
+ unsigned long prefix;
+ tableentry *tab;
+ int n;
+ {
+     unsigned short len = (prefix >> 16) & 0xf;
+     unsigned short code = (prefix & 0xffff) >> (16 - len);
+ 
+     while (n-- > 0) {
+ 	if (tab->length == len && tab->code == code)
+ 	    return ((short) tab->runlen);
+ 	tab++;
+     }
+     return (G3CODE_INCOMP);
+ }
+ 
+ #define	NCODES(a)	(sizeof (a) / sizeof (a[0]))
+ short white_run_length (prefix)
+ unsigned long prefix;
+ {
+     return (search_table(prefix, TIFFFaxWhiteCodes, NCODES(TIFFFaxWhiteCodes)));
+ }
+ 
+ short black_run_length (prefix)
+ unsigned long prefix;
+ {
+     return (search_table(prefix, TIFFFaxBlackCodes, NCODES(TIFFFaxBlackCodes)));
+ }
+ #undef NCODES
+ 
+ #define MAX_NULLPREFIX	200	/* max # of null-mode prefixes */
+ typedef	unsigned char NullModeTable[MAX_NULLPREFIX][256];
+ #define MAX_HORIZPREFIX	250	/* max # of incomplete 1-D prefixes */
+ typedef	unsigned char HorizModeTable[MAX_HORIZPREFIX][256];
+ 
+   /* the bit string corresponding to this row of the decoding table */
+ long	null_mode_prefix[MAX_NULLPREFIX];
+ NullModeTable null_mode;		/* MODE_*, indexed by bit and byte */
+ NullModeTable null_mode_next_state;	/* next row of decoding tables to use */
+   /* number of prefixes or rows in the G4 decoding tables */
+ short	null_mode_prefix_count = 0;
+ 
+ /*
+  * 2D uncompressed mode codes.  Note
+  * that two groups of codes are arranged
+  * so that the decoder can caluclate the
+  * length of the run by subtracting the
+  * code from a known base value.
+  */
+ #define	UNCOMP_INCOMP	0
+ /* runs of [0]*1 */
+ #define	UNCOMP_RUN0	1
+ #define	UNCOMP_RUN1	2
+ #define	UNCOMP_RUN2	3
+ #define	UNCOMP_RUN3	4
+ #define	UNCOMP_RUN4	5
+ #define	UNCOMP_RUN5	6
+ #define	UNCOMP_RUN6	7
+ /* runs of [0]* w/ terminating color */
+ #define	UNCOMP_TRUN0	8
+ #define	UNCOMP_TRUN1	9
+ #define	UNCOMP_TRUN2	10
+ #define	UNCOMP_TRUN3	11
+ #define	UNCOMP_TRUN4	12
+ /* special code for unexpected EOF */
+ #define	UNCOMP_EOF	13
+ /* invalid code encountered */
+ #define	UNCOMP_INVALID	14
+ 
+ long	uncomp_mode_prefix[MAX_NULLPREFIX];
+ NullModeTable uncomp_mode;
+ NullModeTable uncomp_mode_next_state;
+ short	uncomp_mode_prefix_count = 0;
+ 
+ /*
+  * Decoding action values for horiz_mode.
+  */
+ #define ACT_INCOMP	0		/* incompletely decoded code */
+ #define ACT_INVALID	1		/* invalide code */
+ #define	ACT_WRUNT	2		/* terminating white run code */
+ #define	ACT_WRUN	65		/* non-terminating white run code */
+ #define	ACT_BRUNT	106		/* terminating black run code */
+ #define	ACT_BRUN	169		/* non-terminating black run code */
+ #define ACT_EOL		210		/* end-of-line code */
+ HorizModeTable horiz_mode;
+ 
+ short horiz_mode_code_black (runlen)
+ short runlen;
+ {
+     return (runlen < 64 ? runlen + ACT_BRUNT : (runlen / 64) + ACT_BRUN);
+ }
+ 
+ short horiz_mode_code_white (runlen)
+ short runlen;
+ {
+     return (runlen < 64 ? runlen + ACT_WRUNT : (runlen / 64) + ACT_WRUN);
+ }
+ 
+ /*
+  * If the corresponding horiz_mode entry is ACT_INCOMP
+  * this entry is a row number for decoding the next byte;
+  * otherwise, it is the bit number with which to continue
+  * decoding the next codeword.
+  */
+ HorizModeTable horiz_mode_next_state;
+ 		/* prefixes corresponding to the rows of the decoding table */
+ long	horiz_mode_prefix[MAX_HORIZPREFIX];
+ 		/* color of next run, BLACK or WHITE */
+ char	horiz_mode_color[MAX_HORIZPREFIX];
+ short	horiz_mode_prefix_count = 0;
+ 
+ static	unsigned char bit_mask[8] =
+     { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };
+ 
+ void	build_null_mode_tables();
+ short	find_horiz_mode_prefix();
+ short	find_null_mode_prefix();
+ short	null_mode_type();
+ void	build_horiz_mode_tables();
+ short	horiz_mode_code_black();
+ short	horiz_mode_code_white();
+ void	build_uncomp_mode_tables();
+ void	write_tables();
+ 
+ int	verbose = FALSE;
+ char	*storage_class = "";
+ 
+ void main (argc, argv)
+ int argc;
+ char** argv;
+ {
+     while (argc > 1 && argv[1][0] == '-') {
+ 	if (strcmp(argv[1], "-v") == 0) {
+ 	    verbose = TRUE;
+ 	    argc--, argv++;
+ 	} else if (strcmp(argv[1], "-c") == 0) {
+ 	    storage_class = "const ";
+ 	    argc--, argv++;
+ 	}
+     }
+     build_null_mode_tables();		/* null mode decoding tables */
+     if (verbose) {
+ 	fprintf(stderr, "%d null mode prefixes defined\n",
+ 	    (int) null_mode_prefix_count);
+ 	fprintf(stderr, "building uncompressed mode scripts...\n");
+     }
+     build_uncomp_mode_tables();		/* uncompressed mode decoding tables */
+     if (verbose) {
+ 	fprintf(stderr, "%d uncompressed mode prefixes defined\n",
+ 	    (int) uncomp_mode_prefix_count);
+ 	fprintf(stderr, "building 1D scripts...\n");
+     }
+     build_horiz_mode_tables();		/* 1D decoding tables */
+     if (verbose)
+ 	fprintf(stderr, "%d incomplete prefixes defined\n",
+ 	    (int) horiz_mode_prefix_count);
+     write_tables(stdout);
+     exit(0);
+ }
+ 
+ void write_null_mode_table (fd, table, name)
+ FILE *fd;
+ NullModeTable table;
+ char *name;
+ {
+     int i, j;
+     char* outersep;
+     char* sep;
+ 
+     fprintf(fd, "%sunsigned char\t%s[%d][256] = {", storage_class,
+ 	name, (int) null_mode_prefix_count);
+     outersep = "";
+     for (i = 0; i < null_mode_prefix_count; i++) {
+ 	fprintf(fd, "%s\n/* prefix %d */ {\n", outersep, i);
+ 	sep = "    ";
+ 	for (j = 0; j < 256; j++) {
+ 	    fprintf(fd, "%s%2d", sep, (int) table[i][j]);
+ 	    if (((j+1) % 16) == 0) {
+ 		fprintf(fd, ", /* %3d-%3d */\n", j-15, j);
+ 		sep = "    ";
+ 	    } else
+ 		sep = ",";
+ 	}
+ 	fprintf(fd, "}");
+ 	outersep = ",";
+     }
+     fprintf(fd, "\n};\n");
+ }
+ 
+ void write_horiz_mode_table (fd, table, name)
+ FILE *fd;
+ HorizModeTable table;
+ char *name;
+ {
+     int i, j;
+     char* outersep;
+     char* sep;
+ 
+     fprintf(fd, "%s unsigned char\t%s[%d][256] = {", storage_class,
+ 	name, (int) horiz_mode_prefix_count);
+     outersep = "";
+     for (i = 0; i < horiz_mode_prefix_count; i++) {
+ 	fprintf(fd, "%s\n/* prefix %d */ {\n", outersep, i);
+ 	sep = "    ";
+ 	for (j = 0; j < 256; j++) {
+ 	    fprintf(fd, "%s%3d", sep, (int) table[i][j]);
+ 	    if (((j+1) % 14) == 0) {
+ 		fprintf(fd, ", /* %3d-%3d */\n", j-13, j);
+ 		sep = "    ";
+ 	    } else
+ 		sep = ",";
+ 	}
+ 	fprintf(fd, "\n}");
+ 	outersep = ",";
+     }
+     fprintf(fd, "\n};\n");
+ }
+ 
+ void
+ write_define(fd, name, value, comment)
+     FILE *fd;
+     char *name;
+     int value;
+     char *comment;
+ {
+     fprintf(fd, "#define\t%s\t%d", name, value);
+     if (comment)
+ 	fprintf(fd, "\t/* %s */", comment);
+     fprintf(fd, "\n");
+ }
+ 
+ void
+ write_preamble(fd)
+     FILE *fd;
+ {
+     fprintf(fd, "%s\n",
+ "/* DO NOT EDIT THIS FILE, IT WAS AUTOMATICALLY CREATED BY mkg3state */");
+     write_define(fd, "ACT_INCOMP", ACT_INCOMP, "incompletely decoded code");
+     write_define(fd, "ACT_INVALID", ACT_INVALID, "invalide code");
+     write_define(fd, "ACT_WRUNT", ACT_WRUNT, "terminating white run code");
+     write_define(fd, "ACT_WRUN", ACT_WRUN, "non-terminating white run code");
+     write_define(fd, "ACT_BRUNT", ACT_BRUNT, "terminating black run code");
+     write_define(fd, "ACT_BRUN", ACT_BRUN, "non-terminating black run code");
+     write_define(fd, "ACT_EOL", ACT_EOL, "end-of-line code");
+     fprintf(fd, "\n");
+     fprintf(fd, "/* modes that the decoder can be in */\n");
+     write_define(fd, "MODE_NULL", MODE_NULL, NULL);
+     write_define(fd, "MODE_PASS", MODE_PASS, NULL);
+     write_define(fd, "MODE_HORIZ", MODE_HORIZ, NULL);
+     write_define(fd, "MODE_VERT_V0", MODE_VERT_V0, NULL);
+     write_define(fd, "MODE_VERT_VR1", MODE_VERT_VR1, NULL);
+     write_define(fd, "MODE_VERT_VR2", MODE_VERT_VR2, NULL);
+     write_define(fd, "MODE_VERT_VR3", MODE_VERT_VR3, NULL);
+     write_define(fd, "MODE_VERT_VL1", MODE_VERT_VL1, NULL);
+     write_define(fd, "MODE_VERT_VL2", MODE_VERT_VL2, NULL);
+     write_define(fd, "MODE_VERT_VL3", MODE_VERT_VL3, NULL);
+     write_define(fd, "MODE_UNCOMP", MODE_UNCOMP, NULL);
+     write_define(fd, "MODE_ERROR", MODE_ERROR, NULL);
+     write_define(fd, "MODE_ERROR_1", MODE_ERROR_1, NULL);
+     fprintf(fd, "\n");
+     fprintf(fd, "#define\tRUNLENGTH(ix)	(TIFFFaxWhiteCodes[ix].runlen)\n");
+     fprintf(fd, "\n");
+     write_define(fd, "UNCOMP_INCOMP", UNCOMP_INCOMP, NULL);
+     fprintf(fd, "/* runs of [0]*1 */\n");
+     write_define(fd, "UNCOMP_RUN0", UNCOMP_RUN0, NULL);
+     write_define(fd, "UNCOMP_RUN1", UNCOMP_RUN1, NULL);
+     write_define(fd, "UNCOMP_RUN2", UNCOMP_RUN2, NULL);
+     write_define(fd, "UNCOMP_RUN3", UNCOMP_RUN3, NULL);
+     write_define(fd, "UNCOMP_RUN4", UNCOMP_RUN4, NULL);
+     write_define(fd, "UNCOMP_RUN5", UNCOMP_RUN5, NULL);
+     write_define(fd, "UNCOMP_RUN6", UNCOMP_RUN6, NULL);
+     fprintf(fd, "/* runs of [0]* w/ terminating color */\n");
+     write_define(fd, "UNCOMP_TRUN0", UNCOMP_TRUN0, NULL);
+     write_define(fd, "UNCOMP_TRUN1", UNCOMP_TRUN1, NULL);
+     write_define(fd, "UNCOMP_TRUN2", UNCOMP_TRUN2, NULL);
+     write_define(fd, "UNCOMP_TRUN3", UNCOMP_TRUN3, NULL);
+     write_define(fd, "UNCOMP_TRUN4", UNCOMP_TRUN4, NULL);
+     fprintf(fd, "/* special code for unexpected EOF */\n");
+     write_define(fd, "UNCOMP_EOF", UNCOMP_EOF, NULL);
+     fprintf(fd, "/* invalid code encountered */\n");
+     write_define(fd, "UNCOMP_INVALID", UNCOMP_INVALID, NULL);
+     fprintf(fd, "/* codes >= terminate uncompress mode */\n");
+     fprintf(fd, "#define\tUNCOMP_EXIT	UNCOMP_TRUN0\n");
+     fprintf(fd, "\n");
+ }
+ 
+ void
+ extern_table(fd, name)
+     FILE* fd;
+     char* name;
+ {
+     fprintf(fd, "extern\t%sunsigned char %s[][256];\n", storage_class, name);
+ }
+ 
+ void
+ write_tables(fd)
+     FILE* fd;
+ {
+     write_preamble(fd);
+     write_null_mode_table(fd, null_mode, "TIFFFax2DMode");
+     write_null_mode_table(fd, null_mode_next_state, "TIFFFax2DNextState");
+     write_null_mode_table(fd, uncomp_mode, "TIFFFaxUncompAction");
+     write_null_mode_table(fd, uncomp_mode_next_state, "TIFFFaxUncompNextState");
+     write_horiz_mode_table(fd, horiz_mode, "TIFFFax1DAction");
+     write_horiz_mode_table(fd, horiz_mode_next_state, "TIFFFax1DNextState");
+ }
+ 
+ short find_null_mode_prefix (prefix)
+ long prefix;
+ {
+     short j1;
+ 
+     if (prefix == 0L)
+ 	return (0);
+     for (j1 = 8; j1 < null_mode_prefix_count; j1++)
+ 	if (prefix == null_mode_prefix[j1])
+ 		return (j1);
+     if (null_mode_prefix_count == MAX_NULLPREFIX) {
+ 	fprintf(stderr, "ERROR: null mode prefix table overflow\n");
+ 	exit(1);
+     }
+     if (verbose)
+ 	fprintf(stderr, "adding null mode prefix[%d] 0x%lx\n",
+ 	    (int) null_mode_prefix_count, prefix);
+     null_mode_prefix[null_mode_prefix_count++] = prefix;
+     return (null_mode_prefix_count-1);
+ }
+ 
+ short find_horiz_mode_prefix (prefix, color)
+ long prefix;
+ char color;
+ {
+     short j1;
+ 
+     for (j1 = 0; j1 < horiz_mode_prefix_count; j1++)
+ 	if (prefix == horiz_mode_prefix[j1] && horiz_mode_color[j1] == color)
+ 	    return (j1);
+     /*
+      * It wasn't found, so add it to the tables, but first, is there room?
+      */
+     if (horiz_mode_prefix_count == MAX_HORIZPREFIX) {
+ 	fprintf(stderr, "ERROR: 1D prefix table overflow\n");
+ 	exit(1);
+     }
+     /* OK, there's room... */
+     if (verbose)
+ 	fprintf(stderr, "\nhoriz mode prefix %d, color %c = 0x%lx ",
+ 	    (int) horiz_mode_prefix_count, "WB"[color], prefix);
+     horiz_mode_prefix[horiz_mode_prefix_count] = prefix;
+     horiz_mode_color[horiz_mode_prefix_count] = color;
+     horiz_mode_prefix_count++;
+     return (horiz_mode_prefix_count - 1);
+ }
+ 
+ short find_uncomp_mode_prefix (prefix)
+ long prefix;
+ {
+     short j1;
+ 
+     if (prefix == 0L)
+ 	return (0);
+     for (j1 = 8; j1 < uncomp_mode_prefix_count; j1++)
+ 	if (prefix == uncomp_mode_prefix[j1])
+ 		return (j1);
+     if (uncomp_mode_prefix_count == MAX_NULLPREFIX) {
+ 	fprintf(stderr, "ERROR: uncomp mode prefix table overflow\n");
+ 	exit(1);
+     }
+     if (verbose)
+ 	fprintf(stderr, "adding uncomp mode prefix[%d] 0x%lx\n",
+ 	    (int) uncomp_mode_prefix_count, prefix);
+     uncomp_mode_prefix[uncomp_mode_prefix_count++] = prefix;
+     return (uncomp_mode_prefix_count-1);
+ }
+ 
+ short null_mode_type (prefix)
+ long prefix;
+ {
+     switch (prefix) {
+     case 0x18000L: return (MODE_VERT_V0);	/* 1 */
+     case 0x36000L: return (MODE_VERT_VR1);	/* 011 */
+     case 0x34000L: return (MODE_VERT_VL1);	/* 010 */
+     case 0x32000L: return (MODE_HORIZ);		/* 001 */
+     case 0x41000L: return (MODE_PASS);		/* 0001 */
+     case 0x60C00L: return (MODE_VERT_VR2);	/* 0000 11 */
+     case 0x60800L: return (MODE_VERT_VL2);	/* 0000 10 */
+     case 0x70600L: return (MODE_VERT_VR3);	/* 0000 011 */
+     case 0x70400L: return (MODE_VERT_VL3);	/* 0000 010 */
+     case 0x80200L: return (MODE_ERROR);		/* 0000 0010 */
+     case 0x90300L: return (MODE_ERROR);		/* 0000 0011 0 */
+     case 0xA0380L: return (MODE_ERROR);		/* 0000 0011 10 */
+     case 0xA03C0L: return (MODE_UNCOMP);	/* 0000 0011 11 */
+     /*
+      * Under the assumption that there are no
+      * errors in the file, then this bit string
+      * can only be the beginning of an EOL code.
+      */
+     case 0x70000L: return (MODE_ERROR_1);	/* 0000 000 */
+     }
+     return (-1);
+ }
+ 
+ short uncomp_mode_type (prefix)
+ long prefix;
+ {
+     short code;
+     short len;
+     switch (prefix) {
+     case 0x18000L: return (UNCOMP_RUN1);	/* 1 */
+     case 0x24000L: return (UNCOMP_RUN2);	/* 01 */
+     case 0x32000L: return (UNCOMP_RUN3);	/* 001 */
+     case 0x41000L: return (UNCOMP_RUN4);	/* 0001 */
+     case 0x50800L: return (UNCOMP_RUN5);	/* 0000 1 */
+     case 0x60400L: return (UNCOMP_RUN6);	/* 0000 01 */
+     case 0x70200L: return (UNCOMP_TRUN0);	/* 0000 001 */
+     case 0x80100L: return (UNCOMP_TRUN1);	/* 0000 0001 */
+     case 0x90080L: return (UNCOMP_TRUN2);	/* 0000 0000 1 */
+     case 0xA0040L: return (UNCOMP_TRUN3);	/* 0000 0000 01 */
+     case 0xB0020L: return (UNCOMP_TRUN4);	/* 0000 0000 001 */
+     }
+     code = prefix & 0xffffL;
+     len = (prefix >> 16) & 0xf;
+     return ((code || len > 10) ? UNCOMP_INVALID : -1);
+ }
+ 
+ #define	BASESTATE(b)	((unsigned char) ((b) & 0x7))
+ 
+ void
+ build_null_mode_tables()
+ {
+     short prefix;
+ 
+     /*
+      * Note: the first eight entries correspond to
+      * a null prefix and starting bit numbers 0-7.
+      */
+     null_mode_prefix_count = 8;
+     for (prefix = 0; prefix < null_mode_prefix_count; prefix++) {
+ 	short byte;
+ 	for (byte = 0; byte < 256; byte++) {
+ 	    short firstbit;
+ 	    short bit;
+ 	    long curprefix;
+ 	    char found_code = FALSE;
+ 
+ 	    if (prefix < 8) {
+ 		curprefix = 0L;
+ 		firstbit = prefix;
+ 	    } else {
+ 		curprefix = null_mode_prefix[prefix];
+ 		firstbit = 0;
+ 	    }
+ 	    for (bit = firstbit; bit < 8 && !found_code; bit++) {
+ 		short mode;
+ 
+ 		if (bit_mask[bit] & byte)
+ 		    curprefix = append_1(curprefix);
+ 		else
+ 		    curprefix = append_0(curprefix);
+ 		switch (mode = null_mode_type(curprefix)) {
+ 		case MODE_PASS:
+ 		case MODE_HORIZ:
+ 		case MODE_VERT_V0:
+ 		case MODE_VERT_VR1:
+ 		case MODE_VERT_VR2:
+ 		case MODE_VERT_VR3:
+ 		case MODE_VERT_VL1:
+ 		case MODE_VERT_VL2:
+ 		case MODE_VERT_VL3:
+ 		case MODE_UNCOMP:
+ 		case MODE_ERROR:
+ 		case MODE_ERROR_1:
+ 		    /*
+ 		     * NOTE: if the bit number is 8, then the table
+ 		     * entry will be zero, which indicates a new byte
+ 		     * is to be fetched during the decoding process
+ 		     */
+ 		    found_code = TRUE;
+ 		    null_mode[prefix][byte] = (unsigned char) mode;
+ 		    null_mode_next_state[prefix][byte] = BASESTATE(bit+1);
+ 		    break;
+ 		}
+ 	    }
+ 	    if (!found_code) {
+ 		null_mode_next_state[prefix][byte] = (unsigned char)
+ 		    find_null_mode_prefix(curprefix);
+ 		/*
+ 		 * This indicates to the decoder that
+ 		 * no valid code has yet been identified.
+ 		 */
+ 		null_mode[prefix][byte] = MODE_NULL;
+ 	    }
+ 	}
+     }
+ }
+ 
+ void
+ build_horiz_mode_tables()
+ {
+     unsigned short byte;
+     short prefix;
+ 
+     /*
+      * The first 8 are for white,
+      * the second 8 are for black,
+      * beginning with bits 0-7.
+      */
+     horiz_mode_prefix_count = 16;
+     for (prefix = 0; prefix < horiz_mode_prefix_count; prefix++)
+ 	for (byte = 0; byte < 256; byte++) {
+ 	    short bits_digested = 0;
+ 	    short bit;
+ 	    short firstbit;
+ 	    char color;
+ 	    unsigned long curprefix;
+ 
+ 	    if (prefix < 8) {
+ 		color = WHITE;
+ 		curprefix = 0L;
+ 		firstbit = prefix;
+ 	    } else if (prefix < 16) {
+ 		color = BLACK;
+ 		curprefix = 0L;
+ 		firstbit = prefix - 8;
+ 	    } else {
+ 		color = horiz_mode_color[prefix];
+ 		curprefix = horiz_mode_prefix[prefix];
+ 		firstbit = 0;
+ 	    }
+ 	    for (bit = firstbit; bit < 8 && !bits_digested; bit++) {
+ 		if (bit_mask[bit] & byte)
+ 		    curprefix = append_1(curprefix);
+ 		else
+ 		    curprefix = append_0(curprefix);
+ 		/*
+ 		 * The following conversion allows for arbitrary strings of
+ 		 * zeroes to precede the end-of-line code 0000 0000 0001.
+ 		 * It assumes no errors in the data, and is based on
+ 		 * the assumption that the code replaced (12 consecutive
+ 		 * zeroes) can only be "legally" encountered before the
+ 		 * end-of-line code.  This assumption is valid only for
+ 		 * a Group 3 image; the combination will never occur
+ 		 * in horizontal mode in a proper Group 4 image.
+ 		 */
+ 		if (curprefix == 0xC0000L)
+ 		    curprefix = 0xB0000L;
+ 		if (color == WHITE) {
+ 		    short runlength = white_run_length(curprefix);
+ 
+ 		    if (runlength == G3CODE_INVALID) {
+ 			horiz_mode[prefix][byte] = (unsigned char) ACT_INVALID;
+ 			horiz_mode_next_state[prefix][byte] = (unsigned char) bit;
+ 			bits_digested = bit + 1;
+ 		    } else if (runlength == G3CODE_EOL) { /* Group 3 only */
+ 			horiz_mode[prefix][byte] = (unsigned char) ACT_EOL;
+ 			horiz_mode_next_state[prefix][byte] = BASESTATE(bit+1);
+ 			bits_digested = bit + 1;
+ 		    } else if (runlength != G3CODE_INCOMP) {
+ 			horiz_mode[prefix][byte] = (unsigned char)
+ 			    horiz_mode_code_white(runlength);
+ 			horiz_mode_next_state[prefix][byte] = BASESTATE(bit+1);
+ 			bits_digested = bit + 1;
+ 		    }
+ 		} else {		/* color == BLACK */
+ 		    short runlength = black_run_length(curprefix);
+ 
+ 		    if (runlength == G3CODE_INVALID) {
+ 			horiz_mode[prefix][byte] = (unsigned char) ACT_INVALID;
+ 			horiz_mode_next_state[prefix][byte] = (unsigned char) (bit+8);
+ 			bits_digested = bit + 1;
+ 		    } else if (runlength == G3CODE_EOL) { /* Group 3 only */
+ 			horiz_mode[prefix][byte] = (unsigned char) ACT_EOL;
+ 			horiz_mode_next_state[prefix][byte] = BASESTATE(bit+1);
+ 			bits_digested = bit + 1;
+ 		    } else if (runlength != G3CODE_INCOMP) {
+ 			horiz_mode[prefix][byte] = (unsigned char)
+ 			    horiz_mode_code_black(runlength);
+ 			horiz_mode_next_state[prefix][byte] = BASESTATE(bit+1);
+ 			bits_digested = bit + 1;
+ 		    }
+ 		}
+ 	    }
+ 	    if (!bits_digested) {	/* no codewords after examining byte */
+ 		horiz_mode[prefix][byte] = (unsigned char) ACT_INCOMP;
+ 		horiz_mode_next_state[prefix][byte] = (unsigned char)
+ 		    find_horiz_mode_prefix(curprefix, color);
+ 	    }
+ 	}
+ }
+ 
+ void
+ build_uncomp_mode_tables()
+ {
+     short prefix;
+ 
+     /*
+      * Note: the first eight entries correspond to
+      * a null prefix and starting bit numbers 0-7.
+      */
+     uncomp_mode_prefix_count = 8;
+     for (prefix = 0; prefix < uncomp_mode_prefix_count; prefix++) {
+ 	short byte;
+ 	for (byte = 0; byte < 256; byte++) {
+ 	    short firstbit;
+ 	    short bit;
+ 	    long curprefix;
+ 	    char found_code = FALSE;
+ 
+ 	    if (prefix < 8) {
+ 		curprefix = 0L;
+ 		firstbit = prefix;
+ 	    } else {
+ 		curprefix = uncomp_mode_prefix[prefix];
+ 		firstbit = 0;
+ 	    }
+ 	    for (bit = firstbit; bit < 8 && !found_code; bit++) {
+ 		short mode;
+ 
+ 		if (bit_mask[bit] & byte)
+ 		    curprefix = append_1(curprefix);
+ 		else
+ 		    curprefix = append_0(curprefix);
+ 		mode = uncomp_mode_type(curprefix);
+ 		if (mode != -1) {
+ 		    /*
+ 		     * NOTE: if the bit number is 8, then the table
+ 		     * entry will be zero, which indicates a new byte
+ 		     * is to be fetched during the decoding process
+ 		     */
+ 		    found_code = TRUE;
+ 		    uncomp_mode[prefix][byte] = (unsigned char) mode;
+ 		    uncomp_mode_next_state[prefix][byte] = BASESTATE(bit+1);
+ 		    break;
+ 		}
+ 	    }
+ 	    if (!found_code) {
+ 		uncomp_mode_next_state[prefix][byte] = (unsigned char)
+ 		    find_uncomp_mode_prefix(curprefix);
+ 		/*
+ 		 * This indicates to the decoder that
+ 		 * no valid code has yet been identified.
+ 		 */
+ 		uncomp_mode[prefix][byte] = UNCOMP_INCOMP;
+ 	    }
+ 	}
+     }
+ }
*** /dev/null	Wed Jan 18 13:06:12 1995
--- xc/workInProgress/lbx/lib/lbxutil/image/lbxbwcodes.h	Wed Jan 18 13:06:10 1995
***************
*** 0 ****
--- 1,258 ----
+ /* $XConsortium: lbxbwcodes.h,v 1.1 95/01/17 18:17:40 mor Exp $ */
+ 
+ /*
+  * Copyright (c) 1988, 1989, 1990, 1991, 1992 Sam Leffler
+  * Copyright (c) 1991, 1992 Silicon Graphics, Inc.
+  *
+  * Permission to use, copy, modify, distribute, and sell this software and 
+  * its documentation for any purpose is hereby granted without fee, provided
+  * that (i) the above copyright notices and this permission notice appear in
+  * all copies of the software and related documentation, and (ii) the names of
+  * Sam Leffler and Silicon Graphics may not be used in any advertising or
+  * publicity relating to the software without the specific, prior written
+  * permission of Sam Leffler and Silicon Graphics.
+  * 
+  * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
+  * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
+  * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
+  * 
+  * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
+  * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
+  * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+  * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
+  * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
+  * OF THIS SOFTWARE.
+  */
+ 
+ /*
+  * Note that these tables are ordered such that the
+  * index into the table is known to be either the
+  * run length, or (run length / 64) + a fixed offset.
+  *
+  * NB: The G3CODE_INVALID entries are only used
+  *     during state generation (see mkg3states.c).
+  */
+ 
+ tableentry TIFFFaxWhiteCodes[] = {
+     { 8, 0x35, 0 },	/* 0011 0101 */
+     { 6, 0x7, 1 },	/* 0001 11 */
+     { 4, 0x7, 2 },	/* 0111 */
+     { 4, 0x8, 3 },	/* 1000 */
+     { 4, 0xB, 4 },	/* 1011 */
+     { 4, 0xC, 5 },	/* 1100 */
+     { 4, 0xE, 6 },	/* 1110 */
+     { 4, 0xF, 7 },	/* 1111 */
+     { 5, 0x13, 8 },	/* 1001 1 */
+     { 5, 0x14, 9 },	/* 1010 0 */
+     { 5, 0x7, 10 },	/* 0011 1 */
+     { 5, 0x8, 11 },	/* 0100 0 */
+     { 6, 0x8, 12 },	/* 0010 00 */
+     { 6, 0x3, 13 },	/* 0000 11 */
+     { 6, 0x34, 14 },	/* 1101 00 */
+     { 6, 0x35, 15 },	/* 1101 01 */
+     { 6, 0x2A, 16 },	/* 1010 10 */
+     { 6, 0x2B, 17 },	/* 1010 11 */
+     { 7, 0x27, 18 },	/* 0100 111 */
+     { 7, 0xC, 19 },	/* 0001 100 */
+     { 7, 0x8, 20 },	/* 0001 000 */
+     { 7, 0x17, 21 },	/* 0010 111 */
+     { 7, 0x3, 22 },	/* 0000 011 */
+     { 7, 0x4, 23 },	/* 0000 100 */
+     { 7, 0x28, 24 },	/* 0101 000 */
+     { 7, 0x2B, 25 },	/* 0101 011 */
+     { 7, 0x13, 26 },	/* 0010 011 */
+     { 7, 0x24, 27 },	/* 0100 100 */
+     { 7, 0x18, 28 },	/* 0011 000 */
+     { 8, 0x2, 29 },	/* 0000 0010 */
+     { 8, 0x3, 30 },	/* 0000 0011 */
+     { 8, 0x1A, 31 },	/* 0001 1010 */
+     { 8, 0x1B, 32 },	/* 0001 1011 */
+     { 8, 0x12, 33 },	/* 0001 0010 */
+     { 8, 0x13, 34 },	/* 0001 0011 */
+     { 8, 0x14, 35 },	/* 0001 0100 */
+     { 8, 0x15, 36 },	/* 0001 0101 */
+     { 8, 0x16, 37 },	/* 0001 0110 */
+     { 8, 0x17, 38 },	/* 0001 0111 */
+     { 8, 0x28, 39 },	/* 0010 1000 */
+     { 8, 0x29, 40 },	/* 0010 1001 */
+     { 8, 0x2A, 41 },	/* 0010 1010 */
+     { 8, 0x2B, 42 },	/* 0010 1011 */
+     { 8, 0x2C, 43 },	/* 0010 1100 */
+     { 8, 0x2D, 44 },	/* 0010 1101 */
+     { 8, 0x4, 45 },	/* 0000 0100 */
+     { 8, 0x5, 46 },	/* 0000 0101 */
+     { 8, 0xA, 47 },	/* 0000 1010 */
+     { 8, 0xB, 48 },	/* 0000 1011 */
+     { 8, 0x52, 49 },	/* 0101 0010 */
+     { 8, 0x53, 50 },	/* 0101 0011 */
+     { 8, 0x54, 51 },	/* 0101 0100 */
+     { 8, 0x55, 52 },	/* 0101 0101 */
+     { 8, 0x24, 53 },	/* 0010 0100 */
+     { 8, 0x25, 54 },	/* 0010 0101 */
+     { 8, 0x58, 55 },	/* 0101 1000 */
+     { 8, 0x59, 56 },	/* 0101 1001 */
+     { 8, 0x5A, 57 },	/* 0101 1010 */
+     { 8, 0x5B, 58 },	/* 0101 1011 */
+     { 8, 0x4A, 59 },	/* 0100 1010 */
+     { 8, 0x4B, 60 },	/* 0100 1011 */
+     { 8, 0x32, 61 },	/* 0011 0010 */
+     { 8, 0x33, 62 },	/* 0011 0011 */
+     { 8, 0x34, 63 },	/* 0011 0100 */
+     { 5, 0x1B, 64 },	/* 1101 1 */
+     { 5, 0x12, 128 },	/* 1001 0 */
+     { 6, 0x17, 192 },	/* 0101 11 */
+     { 7, 0x37, 256 },	/* 0110 111 */
+     { 8, 0x36, 320 },	/* 0011 0110 */
+     { 8, 0x37, 384 },	/* 0011 0111 */
+     { 8, 0x64, 448 },	/* 0110 0100 */
+     { 8, 0x65, 512 },	/* 0110 0101 */
+     { 8, 0x68, 576 },	/* 0110 1000 */
+     { 8, 0x67, 640 },	/* 0110 0111 */
+     { 9, 0xCC, 704 },	/* 0110 0110 0 */
+     { 9, 0xCD, 768 },	/* 0110 0110 1 */
+     { 9, 0xD2, 832 },	/* 0110 1001 0 */
+     { 9, 0xD3, 896 },	/* 0110 1001 1 */
+     { 9, 0xD4, 960 },	/* 0110 1010 0 */
+     { 9, 0xD5, 1024 },	/* 0110 1010 1 */
+     { 9, 0xD6, 1088 },	/* 0110 1011 0 */
+     { 9, 0xD7, 1152 },	/* 0110 1011 1 */
+     { 9, 0xD8, 1216 },	/* 0110 1100 0 */
+     { 9, 0xD9, 1280 },	/* 0110 1100 1 */
+     { 9, 0xDA, 1344 },	/* 0110 1101 0 */
+     { 9, 0xDB, 1408 },	/* 0110 1101 1 */
+     { 9, 0x98, 1472 },	/* 0100 1100 0 */
+     { 9, 0x99, 1536 },	/* 0100 1100 1 */
+     { 9, 0x9A, 1600 },	/* 0100 1101 0 */
+     { 6, 0x18, 1664 },	/* 0110 00 */
+     { 9, 0x9B, 1728 },	/* 0100 1101 1 */
+     { 11, 0x8, 1792 },	/* 0000 0001 000 */
+     { 11, 0xC, 1856 },	/* 0000 0001 100 */
+     { 11, 0xD, 1920 },	/* 0000 0001 101 */
+     { 12, 0x12, 1984 },	/* 0000 0001 0010 */
+     { 12, 0x13, 2048 },	/* 0000 0001 0011 */
+     { 12, 0x14, 2112 },	/* 0000 0001 0100 */
+     { 12, 0x15, 2176 },	/* 0000 0001 0101 */
+     { 12, 0x16, 2240 },	/* 0000 0001 0110 */
+     { 12, 0x17, 2304 },	/* 0000 0001 0111 */
+     { 12, 0x1C, 2368 },	/* 0000 0001 1100 */
+     { 12, 0x1D, 2432 },	/* 0000 0001 1101 */
+     { 12, 0x1E, 2496 },	/* 0000 0001 1110 */
+     { 12, 0x1F, 2560 },	/* 0000 0001 1111 */
+     { 12, 0x1, G3CODE_EOL },	/* 0000 0000 0001 */
+     { 9, 0x1, G3CODE_INVALID },	/* 0000 0000 1 */
+     { 10, 0x1, G3CODE_INVALID },	/* 0000 0000 01 */
+     { 11, 0x1, G3CODE_INVALID },	/* 0000 0000 001 */
+     { 12, 0x0, G3CODE_INVALID },	/* 0000 0000 0000 */
+ };
+ 
+ tableentry TIFFFaxBlackCodes[] = {
+     { 10, 0x37, 0 },	/* 0000 1101 11 */
+     { 3, 0x2, 1 },	/* 010 */
+     { 2, 0x3, 2 },	/* 11 */
+     { 2, 0x2, 3 },	/* 10 */
+     { 3, 0x3, 4 },	/* 011 */
+     { 4, 0x3, 5 },	/* 0011 */
+     { 4, 0x2, 6 },	/* 0010 */
+     { 5, 0x3, 7 },	/* 0001 1 */
+     { 6, 0x5, 8 },	/* 0001 01 */
+     { 6, 0x4, 9 },	/* 0001 00 */
+     { 7, 0x4, 10 },	/* 0000 100 */
+     { 7, 0x5, 11 },	/* 0000 101 */
+     { 7, 0x7, 12 },	/* 0000 111 */
+     { 8, 0x4, 13 },	/* 0000 0100 */
+     { 8, 0x7, 14 },	/* 0000 0111 */
+     { 9, 0x18, 15 },	/* 0000 1100 0 */
+     { 10, 0x17, 16 },	/* 0000 0101 11 */
+     { 10, 0x18, 17 },	/* 0000 0110 00 */
+     { 10, 0x8, 18 },	/* 0000 0010 00 */
+     { 11, 0x67, 19 },	/* 0000 1100 111 */
+     { 11, 0x68, 20 },	/* 0000 1101 000 */
+     { 11, 0x6C, 21 },	/* 0000 1101 100 */
+     { 11, 0x37, 22 },	/* 0000 0110 111 */
+     { 11, 0x28, 23 },	/* 0000 0101 000 */
+     { 11, 0x17, 24 },	/* 0000 0010 111 */
+     { 11, 0x18, 25 },	/* 0000 0011 000 */
+     { 12, 0xCA, 26 },	/* 0000 1100 1010 */
+     { 12, 0xCB, 27 },	/* 0000 1100 1011 */
+     { 12, 0xCC, 28 },	/* 0000 1100 1100 */
+     { 12, 0xCD, 29 },	/* 0000 1100 1101 */
+     { 12, 0x68, 30 },	/* 0000 0110 1000 */
+     { 12, 0x69, 31 },	/* 0000 0110 1001 */
+     { 12, 0x6A, 32 },	/* 0000 0110 1010 */
+     { 12, 0x6B, 33 },	/* 0000 0110 1011 */
+     { 12, 0xD2, 34 },	/* 0000 1101 0010 */
+     { 12, 0xD3, 35 },	/* 0000 1101 0011 */
+     { 12, 0xD4, 36 },	/* 0000 1101 0100 */
+     { 12, 0xD5, 37 },	/* 0000 1101 0101 */
+     { 12, 0xD6, 38 },	/* 0000 1101 0110 */
+     { 12, 0xD7, 39 },	/* 0000 1101 0111 */
+     { 12, 0x6C, 40 },	/* 0000 0110 1100 */
+     { 12, 0x6D, 41 },	/* 0000 0110 1101 */
+     { 12, 0xDA, 42 },	/* 0000 1101 1010 */
+     { 12, 0xDB, 43 },	/* 0000 1101 1011 */
+     { 12, 0x54, 44 },	/* 0000 0101 0100 */
+     { 12, 0x55, 45 },	/* 0000 0101 0101 */
+     { 12, 0x56, 46 },	/* 0000 0101 0110 */
+     { 12, 0x57, 47 },	/* 0000 0101 0111 */
+     { 12, 0x64, 48 },	/* 0000 0110 0100 */
+     { 12, 0x65, 49 },	/* 0000 0110 0101 */
+     { 12, 0x52, 50 },	/* 0000 0101 0010 */
+     { 12, 0x53, 51 },	/* 0000 0101 0011 */
+     { 12, 0x24, 52 },	/* 0000 0010 0100 */
+     { 12, 0x37, 53 },	/* 0000 0011 0111 */
+     { 12, 0x38, 54 },	/* 0000 0011 1000 */
+     { 12, 0x27, 55 },	/* 0000 0010 0111 */
+     { 12, 0x28, 56 },	/* 0000 0010 1000 */
+     { 12, 0x58, 57 },	/* 0000 0101 1000 */
+     { 12, 0x59, 58 },	/* 0000 0101 1001 */
+     { 12, 0x2B, 59 },	/* 0000 0010 1011 */
+     { 12, 0x2C, 60 },	/* 0000 0010 1100 */
+     { 12, 0x5A, 61 },	/* 0000 0101 1010 */
+     { 12, 0x66, 62 },	/* 0000 0110 0110 */
+     { 12, 0x67, 63 },	/* 0000 0110 0111 */
+     { 10, 0xF, 64 },	/* 0000 0011 11 */
+     { 12, 0xC8, 128 },	/* 0000 1100 1000 */
+     { 12, 0xC9, 192 },	/* 0000 1100 1001 */
+     { 12, 0x5B, 256 },	/* 0000 0101 1011 */
+     { 12, 0x33, 320 },	/* 0000 0011 0011 */
+     { 12, 0x34, 384 },	/* 0000 0011 0100 */
+     { 12, 0x35, 448 },	/* 0000 0011 0101 */
+     { 13, 0x6C, 512 },	/* 0000 0011 0110 0 */
+     { 13, 0x6D, 576 },	/* 0000 0011 0110 1 */
+     { 13, 0x4A, 640 },	/* 0000 0010 0101 0 */
+     { 13, 0x4B, 704 },	/* 0000 0010 0101 1 */
+     { 13, 0x4C, 768 },	/* 0000 0010 0110 0 */
+     { 13, 0x4D, 832 },	/* 0000 0010 0110 1 */
+     { 13, 0x72, 896 },	/* 0000 0011 1001 0 */
+     { 13, 0x73, 960 },	/* 0000 0011 1001 1 */
+     { 13, 0x74, 1024 },	/* 0000 0011 1010 0 */
+     { 13, 0x75, 1088 },	/* 0000 0011 1010 1 */
+     { 13, 0x76, 1152 },	/* 0000 0011 1011 0 */
+     { 13, 0x77, 1216 },	/* 0000 0011 1011 1 */
+     { 13, 0x52, 1280 },	/* 0000 0010 1001 0 */
+     { 13, 0x53, 1344 },	/* 0000 0010 1001 1 */
+     { 13, 0x54, 1408 },	/* 0000 0010 1010 0 */
+     { 13, 0x55, 1472 },	/* 0000 0010 1010 1 */
+     { 13, 0x5A, 1536 },	/* 0000 0010 1101 0 */
+     { 13, 0x5B, 1600 },	/* 0000 0010 1101 1 */
+     { 13, 0x64, 1664 },	/* 0000 0011 0010 0 */
+     { 13, 0x65, 1728 },	/* 0000 0011 0010 1 */
+     { 11, 0x8, 1792 },	/* 0000 0001 000 */
+     { 11, 0xC, 1856 },	/* 0000 0001 100 */
+     { 11, 0xD, 1920 },	/* 0000 0001 101 */
+     { 12, 0x12, 1984 },	/* 0000 0001 0010 */
+     { 12, 0x13, 2048 },	/* 0000 0001 0011 */
+     { 12, 0x14, 2112 },	/* 0000 0001 0100 */
+     { 12, 0x15, 2176 },	/* 0000 0001 0101 */
+     { 12, 0x16, 2240 },	/* 0000 0001 0110 */
+     { 12, 0x17, 2304 },	/* 0000 0001 0111 */
+     { 12, 0x1C, 2368 },	/* 0000 0001 1100 */
+     { 12, 0x1D, 2432 },	/* 0000 0001 1101 */
+     { 12, 0x1E, 2496 },	/* 0000 0001 1110 */
+     { 12, 0x1F, 2560 },	/* 0000 0001 1111 */
+     { 12, 0x1, G3CODE_EOL },	/* 0000 0000 0001 */
+     { 9, 0x1, G3CODE_INVALID },	/* 0000 0000 1 */
+     { 10, 0x1, G3CODE_INVALID },	/* 0000 0000 01 */
+     { 11, 0x1, G3CODE_INVALID },	/* 0000 0000 001 */
+     { 12, 0x0, G3CODE_INVALID },	/* 0000 0000 0000 */
+ };
*** -	Wed Jan 18 13:06:16 1995
--- xc/workInProgress/lbx/lib/lbxutil/lzw/compress_lzw.c	Wed Jan 18 13:06:16 1995
***************
*** 19,29 ****
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   * 
!  * $NCDId: @(#)compress_lzw.c,v 1.5 1994/03/24 17:55:03 lemke Exp $
   */
  /* Copyright 1988, 1989, 1990 Network Computing Devices, Inc.  All rights reserved. */
  
! /* $XConsortium: compress_lzw.c,v 1.6 94/03/27 11:54:09 dpw Exp $ */
  
  #include <X11/Xos.h>
  #include <X11/Xfuncs.h>
--- 19,29 ----
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   * 
!  * $NCDId: @(#)compress_lzw.c,v 1.6 1994/09/01 17:31:04 lemke Exp $
   */
  /* Copyright 1988, 1989, 1990 Network Computing Devices, Inc.  All rights reserved. */
  
! /* $XConsortium: compress_lzw.c,v 1.7 94/12/01 20:14:02 mor Exp $ */
  
  #include <X11/Xos.h>
  #include <X11/Xfuncs.h>
***************
*** 48,57 ****
  void LzwFree();
  
  #ifdef LBX_STATS
! extern int lzw_out_compressed;
! extern int lzw_out_plain;
! extern int lzw_in_compressed;
! extern int lzw_in_plain;
  #endif
  
  #define BYTESTREAM_DAEMON
--- 48,57 ----
  void LzwFree();
  
  #ifdef LBX_STATS
! int lzw_out_compressed;
! int lzw_out_plain;
! int lzw_in_compressed;
! int lzw_in_plain;
  #endif
  
  #define BYTESTREAM_DAEMON
*** -	Wed Jan 18 13:06:44 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/cache.c	Wed Jan 18 13:06:44 1995
***************
*** 1,4 ****
! /* $XConsortium: cache.c,v 1.6 94/04/17 21:17:16 dpw Exp $ */
  /*
  Copyright (c) 1994  X Consortium
  
--- 1,4 ----
! /* $XConsortium: cache.c,v 1.7 94/12/01 21:46:00 dpw Exp $ */
  /*
  Copyright (c) 1994  X Consortium
  
***************
*** 92,102 ****
  	return (Cache) 0;
      cache->entries = (CacheEntryPtr *)
  	xalloc(INITBUCKETS * sizeof(CacheEntryPtr));
-     bzero((char *) cache->entries, (INITBUCKETS * sizeof(CacheEntryPtr)));
      if (!cache->entries) {
  	xfree(cache);
  	return (Cache) 0;
      }
      caches[id] = cache;
      cache->elements = 0;
      cache->buckets = INITBUCKETS;
--- 92,102 ----
  	return (Cache) 0;
      cache->entries = (CacheEntryPtr *)
  	xalloc(INITBUCKETS * sizeof(CacheEntryPtr));
      if (!cache->entries) {
  	xfree(cache);
  	return (Cache) 0;
      }
+     bzero((char *) cache->entries, (INITBUCKETS * sizeof(CacheEntryPtr)));
      caches[id] = cache;
      cache->elements = 0;
      cache->buckets = INITBUCKETS;
***************
*** 228,233 ****
--- 228,246 ----
      }
      assert(cache->cursize == 0);
  }
+ 
+ void
+ CacheFreeAll()
+ {
+     int         i;
+ 
+     for (i = 1; i < num_caches; i++) {
+ 	if (caches[i])
+ 	    CacheFreeCache(caches[i]);
+     }
+     num_caches = 1;
+ }
+ 
  
  static void
  flush_cache(cache, needed)
*** -	Wed Jan 18 13:06:46 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/cache.h	Wed Jan 18 13:06:45 1995
***************
*** 1,4 ****
! /* $XConsortium: cache.h,v 1.4 94/04/12 22:01:23 dpw Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
--- 1,4 ----
! /* $XConsortium: cache.h,v 1.5 94/12/01 20:52:35 mor Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
***************
*** 24,30 ****
   * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
!  * $NCDId: @(#)cache.h,v 1.3 1994/03/04 00:06:34 lemke Exp $
   *
   */
  
--- 24,30 ----
   * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
!  * $NCDId: @(#)cache.h,v 1.4 1994/11/16 02:27:57 lemke Exp $
   *
   */
  
***************
*** 47,52 ****
--- 47,53 ----
  extern void CacheSimpleFree();
  extern Cache CacheInit();
  extern void CacheReset();
+ extern void CacheFreeAll();
  extern void CacheResize();
  extern void CacheFreeCache();
  extern pointer CacheFetchMemory();
*** -	Wed Jan 18 13:06:49 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/colormap.c	Wed Jan 18 13:06:49 1995
***************
*** 1,4 ****
! /* $XConsortium: colormap.c,v 1.6 94/03/27 13:35:25 dpw Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
--- 1,4 ----
! /* $XConsortium: colormap.c,v 1.7 94/12/01 20:40:50 mor Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
***************
*** 20,26 ****
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
!  * $NCDId: @(#)colormap.c,v 1.10 1994/03/24 17:54:51 lemke Exp $
   */
  /*
   * XXX
--- 20,26 ----
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
!  * $NCDId: @(#)colormap.c,v 1.11 1994/09/07 01:50:28 lemke Exp $
   */
  /*
   * XXX
***************
*** 45,50 ****
--- 45,51 ----
  
  #include	<stdio.h>
  #include	<X11/X.h>	/* for KeymapNotify */
+ #define	NEED_REPLIES
  #include	<X11/Xproto.h>
  #include	"lbxdata.h"
  #include	"assert.h"
*** -	Wed Jan 18 13:06:51 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/dispatch.c	Wed Jan 18 13:06:51 1995
***************
*** 1,7 ****
! /* $XConsortium: dispatch.c,v 1.6 94/03/27 13:37:34 dpw Exp $ */
  /*
   * $NCDOr: dispatch.c,v 1.2 1993/11/19 21:28:48 keithp Exp keithp $
!  * $NCDId: @(#)dispatch.c,v 1.21 1994/03/24 17:54:33 lemke Exp $
   *
   * Copyright 1992 Network Computing Devices
   *
--- 1,7 ----
! /* $XConsortium: dispatch.c,v 1.7 94/12/01 20:47:30 mor Exp $ */
  /*
   * $NCDOr: dispatch.c,v 1.2 1993/11/19 21:28:48 keithp Exp keithp $
!  * $NCDId: @(#)dispatch.c,v 1.27 1994/11/18 20:35:09 lemke Exp $
   *
   * Copyright 1992 Network Computing Devices
   *
***************
*** 40,51 ****
  #define _XLBX_SERVER_
  #include "lbxstr.h"
  #include "swap.h"
  
  extern int (* InitialVector[3]) ();
  extern int (* ProcVector[256]) ();
- extern int (* SwappedProcVector[256]) ();
- extern void (* EventSwapVector[128]) ();
- extern void (* ReplySwapVector[256]) ();
  extern void WriteSConnSetupPrefix();
  extern char *ClientAuthorized();
  extern Bool InsertFakeRequest();
--- 40,49 ----
  #define _XLBX_SERVER_
  #include "lbxstr.h"
  #include "swap.h"
+ #include "lbxext.h"
  
  extern int (* InitialVector[3]) ();
  extern int (* ProcVector[256]) ();
  extern void WriteSConnSetupPrefix();
  extern char *ClientAuthorized();
  extern Bool InsertFakeRequest();
***************
*** 61,66 ****
--- 59,67 ----
  char dispatchException = 0;
  char isItTimeToYield;
  Bool lbxUseLbx = TRUE;
+ Bool lbxCompressImages = TRUE;
+ Bool lbxDoShortCircuiting = TRUE;
+ Bool lbxDoLbxGfx = TRUE;
  
  #define MAJOROP ((xReq *)client->requestBuffer)->reqType
  
***************
*** 221,226 ****
--- 222,229 ----
      client->osPrivate = ospriv;
      client->server = servers[0];    /* XXX want to use multiple servers */
      client->swapped = FALSE;
+     LBXCacheSafe(client) = FALSE;
+     LBXCanDelayReply(client) = FALSE;
      if (!InitClientResources(client))
      {
  	xfree(client);
***************
*** 320,328 ****
  #endif
  
      nClients++;
- /*
-     client->requestVector = client->swapped ? SwappedProcVector : ProcVector;
- */
      client->requestVector = ProcVector;
      client->sequence = 0;
      LBXSequenceNumber(client) = 0;
--- 323,328 ----
***************
*** 412,417 ****
--- 412,418 ----
  	    nextFreeClientID = client->index;
  	clients[client->index] = NullClient;
  	FreeLBXStuff(client);
+ 	DeleteClientExtensions(client);
          xfree(client);
  	if (nClients == 0)
  	{
***************
*** 479,483 ****
--- 480,521 ----
      if (!lbxUseTags) {
  	ProcVector[X_GetModifierMapping] = ProcStandardRequest;
  	ProcVector[X_GetKeyboardMapping] = ProcStandardRequest;
+ 	ProcVector[X_QueryFont] = ProcStandardRequest;
+ 	ProcVector[X_ChangeProperty] = ProcStandardRequest;
+ 	ProcVector[X_GetProperty] = ProcStandardRequest;
+     }
+ 
+     if (!lbxCompressImages) {
+ 	ProcVector[X_PutImage] = ProcStandardRequest;
+ 	ProcVector[X_GetImage] = ProcStandardRequest;
+     }
+ 
+     if (!lbxDoShortCircuiting) {
+ 	ProcVector[X_InternAtom] = ProcStandardRequest;
+ 	ProcVector[X_GetAtomName] = ProcStandardRequest;
+ 	ProcVector[X_CreateColormap] = ProcStandardRequest;
+ 	ProcVector[X_FreeColormap] = ProcStandardRequest;
+ 	ProcVector[X_CopyColormapAndFree] = ProcStandardRequest;
+ 	ProcVector[X_AllocColor] = ProcStandardRequest;
+ 	ProcVector[X_AllocNamedColor] = ProcStandardRequest;
+ 	ProcVector[X_FreeColors] = ProcStandardRequest;
+ 	ProcVector[X_LookupColor] = ProcStandardRequest;
+     }
+ 
+     if (!lbxDoLbxGfx) {
+ 	ProcVector[X_CopyArea] = ProcStandardRequest;
+ 	ProcVector[X_CopyPlane] = ProcStandardRequest;
+ 	ProcVector[X_PolyPoint] = ProcStandardRequest;
+ 	ProcVector[X_PolyLine] = ProcStandardRequest;
+ 	ProcVector[X_PolySegment] = ProcStandardRequest;
+ 	ProcVector[X_PolyRectangle] = ProcStandardRequest;
+ 	ProcVector[X_PolyArc] = ProcStandardRequest;
+ 	ProcVector[X_FillPoly] = ProcStandardRequest;
+ 	ProcVector[X_PolyFillRectangle] = ProcStandardRequest;
+ 	ProcVector[X_PolyFillArc] = ProcStandardRequest;
+ 	ProcVector[X_PolyText8] = ProcStandardRequest;
+ 	ProcVector[X_PolyText16] = ProcStandardRequest;
+ 	ProcVector[X_ImageText8] = ProcStandardRequest;
+ 	ProcVector[X_ImageText16] = ProcStandardRequest;
      }
  }
*** -	Wed Jan 18 13:06:56 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/lbxdata.h	Wed Jan 18 13:06:56 1995
***************
*** 1,4 ****
! /* $XConsortium: lbxdata.h,v 1.5 94/03/27 13:40:46 dpw Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
--- 1,4 ----
! /* $XConsortium: lbxdata.h,v 1.9 94/12/01 20:49:17 mor Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
***************
*** 20,41 ****
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
!  * $NCDId: @(#)lbxdata.h,v 1.15 1994/03/24 17:55:08 lemke Exp $
   */
  
  #ifndef	_LBXDATA_H_
  #define	_LBXDATA_H_
  
  #include	<X11/X.h>	/* for X typedefs */
  #include 	"os.h"
  #include	"atomcache.h"
  
  /* cache stuff */
  #define MAX_ATOM_LENGTH 256	/* screw any large ones */
  #define MAX_COLORNAME_LENGTH    256	/* screw any large ones */
  
  /*
!  * notes on request short-circuiting
   *
   * X guarentees that any replies, events or errors generated by a
   * previous request will be sent before those of a later request.
--- 20,47 ----
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
!  * $NCDId: @(#)lbxdata.h,v 1.23 1994/11/29 22:14:02 lemke Exp $
!  *
!  * Author: Dave Lemke, Network Computing Devices
   */
  
  #ifndef	_LBXDATA_H_
  #define	_LBXDATA_H_
  
  #include	<X11/X.h>	/* for X typedefs */
+ #define	NEED_REPLIES
+ #include	<X11/Xproto.h>	/* for X typedefs */
  #include 	"os.h"
  #include	"atomcache.h"
+ #define _XLBX_SERVER_
+ #include	"lbxstr.h"
  
  /* cache stuff */
  #define MAX_ATOM_LENGTH 256	/* screw any large ones */
  #define MAX_COLORNAME_LENGTH    256	/* screw any large ones */
  
  /*
!  * Notes on request short-circuiting
   *
   * X guarentees that any replies, events or errors generated by a
   * previous request will be sent before those of a later request.
***************
*** 82,87 ****
--- 88,123 ----
   *
   * this means we can't assume a single pending reply, but many.
   * currently these get tacked onto a list.
+  *
+  *
+  * Notes on how the proxy attempts to solve all of this:
+  *
+  * There are 4 request that it will attempt to short-circuit:
+  * InternAtom, GetAtomName, LookupColor, AllocColor, and AllocNamedColor.
+  * All the code to do this is in lbxfuncs.c, and all of it works in
+  * essentially the same way -- whenever possible, it will try to respond 
+  * to the client without sending the request all the way to the X server.
+  * The goal is to remove a roudn-trip entirely -- even though not a lot of data
+  * is involved, remving the roundtrip can make this useful.
+ 
+  * Unfortunately, figuring out *when* its safe is very nasty.  First
+  * there are all the possibile stages outlined above.  If the proxy
+  * isn't waiting, thinking there might be pending data, it can always
+  * short-circuit the request.  However, this is the rare case.  When
+  * the proxy can't immediately respond, it attempts to short-circuit anyways,
+  * delaying the reply until whatever it was waiting on arrives.  Often
+  * it can't -- if the most paranoid type of checking is turned on, it'll
+  * never work.  The complex part occurs with loose checking.  If it knows
+  * a reply is coming back, it can delay the short-circuit until it gets
+  * the reply.  This works fine for the core protocol, but breaks down 
+  * again for extensions -- to be safe, any unknown extensions are assumed
+  * to have replies -- but since they may never arrive, the delayed
+  * short-circuit can never be flushed.  To avoid this, whether a reply
+  * has been guessed at is tracked, and this info is used to decide
+  * whether a short-circuit can be delayed -- if not, it always needs
+  * to do the full round-trip.
+  *
+  * The complexity really makes me wonder if this stuff is worth the effort...
   */
  
  
***************
*** 163,172 ****
  	    PropertyTagDataRec ptd;
  	}           getprop;
  	struct _setup {
! 	    int		majorVersion;
! 	    int		minorVersion;
! 	    pointer	changes;
! 	}	    setup;
      }           typedata;
  }           QueryTagRec, *QueryTagPtr;
  
--- 199,208 ----
  	    PropertyTagDataRec ptd;
  	}           getprop;
  	struct _setup {
! 	    int         majorVersion;
! 	    int         minorVersion;
! 	    pointer     changes;
! 	}           setup;
      }           typedata;
  }           QueryTagRec, *QueryTagPtr;
  
***************
*** 175,180 ****
--- 211,217 ----
      int         request;	/* request code */
      int         extension;	/* extension opcode */
      Bool        lbx_req;	/* is this an LBX request? */
+     Bool        guessed;	/* did we have to guess? */
      union {			/* reply data */
  	struct atom_data {
  	    Atom        atom;
***************
*** 211,222 ****
--- 248,281 ----
  	struct changeprop {
  	    PropertyTagDataRec ptd;
  	}           lbxchangeprop;
+ 	struct queryextension {
+ 	    char       *name;
+ 	}           lbxqueryextension;
+ 	struct getimage {
+ #ifdef LBX_STATS
+ 	    Drawable	drawable;
+ 	    INT16	x;
+ 	    INT16	y;
+ #endif
+ 	    CARD16      width;
+ 	    CARD16      height;
+ 	}           lbxgetimage;
+ 	pointer     lbxextensiondata;
      }           request_info;
      struct _replystuff *next;
  }           ReplyStuffRec, *ReplyStuffPtr;
  
+ typedef struct _replydata {
+     int         dlen;
+     xReply      reply;
+     pointer     data;
+     int         delay_seq_no;	/* what seq i'm waiting for */
+     struct _replydata *next;
+ }           ReplyDataRec, *ReplyDataPtr;
+ 
  typedef struct _lbxdata {
      Bool        cache_safe;	/* safe to short circuit request? */
+     Bool        can_delay_reply;/* safe to delay short-circuit request? */
  
      int         sequenceNumber;	/* what we've seen */
      int         sequence_lost;	/* requests short-circuited */
***************
*** 226,232 ****
--- 285,300 ----
  
      KeyCode     minKeyCode,
                  maxKeyCode;
+ 
+     CARD8          imageByteOrder;        /* LSBFirst, MSBFirst */
+     CARD8          bitmapBitOrder;        /* LeastSignificant, MostSign...*/
+     CARD8          bitmapScanlineUnit,     /* 8, 16, 32 */
+                    bitmapScanlinePad;     /* 8, 16, 32 */
+ 
      ReplyStuffPtr replylist;	/* list of pending replies */
+     ReplyDataPtr replydata;	/* list of delayed short-circuited replies */
+     Drawable	drawableCache[GFX_CACHE_SIZE];
+     GContext	gcontextCache[GFX_CACHE_SIZE];
  }           LBXDataRec;
  
  typedef struct _lbxdata *LBXDataPtr;
***************
*** 237,243 ****
--- 305,316 ----
  
  extern ReplyStuffPtr NewReply();
  extern ReplyStuffPtr GetReply();
+ extern ReplyStuffPtr GetMatchingReply();
+ 
+ extern Bool FlushDelayedReply();
+ extern Bool SaveDelayedReply();
  extern int  NumReplies();
+ extern int  NumGuessedReplies();
  extern void RemoveReply();
  extern void BumpSequence();
  extern int  QueryTag();
***************
*** 257,264 ****
  extern void LbxFreeTag();
  extern void LbxSendTagData();
  
- #define	LBX_STATS
- 
  #ifdef LBX_STATS
  extern int  intern_good,
              intern_miss;
--- 330,335 ----
***************
*** 294,303 ****
--- 365,382 ----
  
  #define	LBXSequenceNumber(client)	(((LBXDataPtr)((client)->screenPrivate[0]))->sequenceNumber)
  #define	LBXCacheSafe(client)	(((LBXDataPtr)((client)->screenPrivate[0]))->cache_safe)
+ #define	LBXCanDelayReply(client) (((LBXDataPtr)((client)->screenPrivate[0]))->can_delay_reply)
  #define	LBXSequenceLost(client)	(((LBXDataPtr)((client)->screenPrivate[0]))->sequence_lost)
  #define	LBXYanked(client)	(((LBXDataPtr)((client)->screenPrivate[0]))->yanked)
  #define	LBXLastReply(client)	(((LBXDataPtr)((client)->screenPrivate[0]))->lastReply)
  #define	LBXReplyList(client)	(((LBXDataPtr)((client)->screenPrivate[0]))->replylist)
+ #define	LBXReplyData(client)	(((LBXDataPtr)((client)->screenPrivate[0]))->replydata)
  #define	LBXMinKeyCode(client)	(((LBXDataPtr)((client)->screenPrivate[0]))->minKeyCode)
  #define	LBXMaxKeyCode(client)	(((LBXDataPtr)((client)->screenPrivate[0]))->maxKeyCode)
+ #define	LBXImageByteOrder(client) (((LBXDataPtr)((client)->screenPrivate[0]))->imageByteOrder)
+ #define	LBXBitmapBitOrder(client) (((LBXDataPtr)((client)->screenPrivate[0]))->bitmapBitOrder)
+ #define	LBXBitmapScanlineUnit(client) (((LBXDataPtr)((client)->screenPrivate[0]))->bitmapScanlineUnit)
+ #define	LBXBitmapScanlinePad(client) (((LBXDataPtr)((client)->screenPrivate[0]))->bitmapScanlinePad)
+ #define	LBXDrawableCache(client)(((LBXDataPtr)((client)->screenPrivate[0]))->drawableCache)
+ #define	LBXGContextCache(client)(((LBXDataPtr)((client)->screenPrivate[0]))->gcontextCache)
  #endif				/* _LBXDATA_H_ */
*** -	Wed Jan 18 13:06:58 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/lbxfuncs.c	Wed Jan 18 13:06:58 1995
***************
*** 18,28 ****
   * OR PROFITS, EVEN IF ADVISED OF THE POSSIBILITY THEREOF, AND REGARDLESS OF
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
!  * 
!  * $NCDId: @(#)lbxfuncs.c,v 1.31 1994/03/24 17:54:54 lemke Exp $
   */
  
! /* $XConsortium: lbxfuncs.c,v 1.5 94/03/27 13:42:04 dpw Exp $ */
  
  /*
   * top level LBX request & reply handling
--- 18,28 ----
   * OR PROFITS, EVEN IF ADVISED OF THE POSSIBILITY THEREOF, AND REGARDLESS OF
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
!  *
!  * $NCDId: @(#)lbxfuncs.c,v 1.40 1994/11/18 20:39:18 lemke Exp $
   */
  
! /* $XConsortium: lbxfuncs.c,v 1.7 94/12/01 20:50:00 mor Exp $ */
  
  /*
   * top level LBX request & reply handling
***************
*** 60,67 ****
  #include	"resource.h"
  #include	"wire.h"
  #include	"swap.h"
  #define _XLBX_SERVER_
! #include	"lbxstr.h"	/* gets dixstruct.h */
  
  #define reply_length(cp,rep) ((rep)->type==X_Reply ? \
          32 + (HostUnswapLong((cp),(rep)->length) << 2) \
--- 60,69 ----
  #include	"resource.h"
  #include	"wire.h"
  #include	"swap.h"
+ #include	"reqtype.h"
  #define _XLBX_SERVER_
! #include	"lbxstr.h"
! #include	"lbxext.h"
  
  #define reply_length(cp,rep) ((rep)->type==X_Reply ? \
          32 + (HostUnswapLong((cp),(rep)->length) << 2) \
***************
*** 193,199 ****
      xInternAtomReq *req;
      char       *s;
      Atom        atom,
!                 a;
      xInternAtomReply reply;
      ReplyStuffPtr nr;
      char        n;
--- 195,201 ----
      xInternAtomReq *req;
      char       *s;
      Atom        atom,
!                 a = None;
      xInternAtomReply reply;
      ReplyStuffPtr nr;
      char        n;
***************
*** 211,238 ****
      s = data + sizeof(xInternAtomReq);
  
      atom = LbxMakeAtom(s, nbytes, a, FALSE);
!     if (atom != None) {
! 	/* found preset atom */
! 	if (LBXCacheSafe(client)) {
! 	    reply.type = X_Reply;
! 	    reply.length = 0;
! 	    reply.sequenceNumber = LBXSequenceNumber(client);
! 	    reply.atom = atom;
! 	    if (client->swapped) {
! 		SwapInternAtomReply(&reply);
! 	    }
  	    WriteToClient(client, sizeof(xInternAtomReply), &reply);
  
  #ifdef LBX_STATS
! 	    intern_good++;
  #endif
  
! 	    return REQ_YANK;
! 	}
      } else if (nbytes < MAX_ATOM_LENGTH) {
  	nr = NewReply(client);
  	if (nr) {
  	    strncpy(nr->request_info.lbxatom.str, s, nbytes);
  	    nr->request_info.lbxatom.len = nbytes;
  	    nr->sequenceNumber = LBXSequenceNumber(client);
  	    nr->request = X_InternAtom;
--- 213,241 ----
      s = data + sizeof(xInternAtomReq);
  
      atom = LbxMakeAtom(s, nbytes, a, FALSE);
!     if (atom != None && LBXCanDelayReply(client)) {
! 	reply.type = X_Reply;
! 	reply.length = 0;
! 	reply.sequenceNumber = LBXSequenceNumber(client);
! 	reply.atom = atom;
! 	if (client->swapped) {
! 	    SwapInternAtomReply(&reply);
! 	}
! 	if (LBXCacheSafe(client))
  	    WriteToClient(client, sizeof(xInternAtomReply), &reply);
+ 	else			/* store for later */
+ 	    SaveReplyData(client, (xReply *) & reply, 0, NULL);
  
  #ifdef LBX_STATS
! 	intern_good++;
  #endif
  
! 	return REQ_YANK;
      } else if (nbytes < MAX_ATOM_LENGTH) {
  	nr = NewReply(client);
  	if (nr) {
  	    strncpy(nr->request_info.lbxatom.str, s, nbytes);
+ 	    nr->request_info.lbxatom.str[nbytes] = '\0';
  	    nr->request_info.lbxatom.len = nbytes;
  	    nr->sequenceNumber = LBXSequenceNumber(client);
  	    nr->request = X_InternAtom;
***************
*** 260,266 ****
  
      reply = (xInternAtomReply *) data;
  
!     nr = GetReply(client);
      assert(nr);
      str = nr->request_info.lbxatom.str;
      len = nr->request_info.lbxatom.len;
--- 263,269 ----
  
      reply = (xInternAtomReply *) data;
  
!     nr = GetMatchingReply(client, reply->sequenceNumber);
      assert(nr);
      str = nr->request_info.lbxatom.str;
      len = nr->request_info.lbxatom.len;
***************
*** 297,323 ****
      }
      str = NameForAtom(id);
  
!     if (str) {
! 	/* found the value */
  	if (LBXCacheSafe(client)) {
- 
- 	    len = strlen(str);
- 	    reply.type = X_Reply;
- 	    reply.length = (len + 3) >> 2;
- 	    reply.sequenceNumber = LBXSequenceNumber(client);
- 	    reply.nameLength = len;
- 	    if (client->swapped) {
- 		SwapGetAtomNameReply(&reply);
- 	    }
  	    WriteToClient(client, sizeof(xGetAtomNameReply), &reply);
  	    WriteToClientPad(client, len, str);
  
  #ifdef LBX_STATS
! 	    getatom_good++;
  #endif
  
! 	    return REQ_YANK;
! 	}
      } else {
  	nr = NewReply(client);
  	if (nr) {
--- 300,326 ----
      }
      str = NameForAtom(id);
  
!     if (str && LBXCanDelayReply(client)) {	/* found the value */
! 	len = strlen(str);
! 	reply.type = X_Reply;
! 	reply.length = (len + 3) >> 2;
! 	reply.sequenceNumber = LBXSequenceNumber(client);
! 	reply.nameLength = len;
! 	if (client->swapped) {
! 	    SwapGetAtomNameReply(&reply);
! 	}
  	if (LBXCacheSafe(client)) {
  	    WriteToClient(client, sizeof(xGetAtomNameReply), &reply);
  	    WriteToClientPad(client, len, str);
+ 	} else {
+ 	    SaveReplyData(client, (xReply *) & reply, len, str);
+ 	}
  
  #ifdef LBX_STATS
! 	getatom_good++;
  #endif
  
! 	return REQ_YANK;
      } else {
  	nr = NewReply(client);
  	if (nr) {
***************
*** 355,361 ****
      s = data + sizeof(xGetAtomNameReply);
  
      len -= sizeof(xGetAtomNameReply);
!     nr = GetReply(client);
      assert(nr);
      atom = nr->request_info.lbxatom.atom;
  
--- 358,364 ----
      s = data + sizeof(xGetAtomNameReply);
  
      len -= sizeof(xGetAtomNameReply);
!     nr = GetMatchingReply(client, reply->sequenceNumber);
      assert(nr);
      atom = nr->request_info.lbxatom.atom;
  
***************
*** 394,425 ****
  
      rgbe = FindColorName((char *) &req[1], len, cmap);
  
!     if (rgbe) {
! 	/* found the value */
! 	if (LBXCacheSafe(client)) {
! 	    reply.type = X_Reply;
! 	    reply.length = 0;
! 	    reply.sequenceNumber = LBXSequenceNumber(client);
! 
! 	    reply.exactRed = rgbe->xred;
! 	    reply.exactBlue = rgbe->xblue;
! 	    reply.exactGreen = rgbe->xgreen;
! 
! 	    reply.screenRed = rgbe->vred;
! 	    reply.screenBlue = rgbe->vblue;
! 	    reply.screenGreen = rgbe->vgreen;
  
! 	    if (client->swapped) {
! 		SwapLookupColorReply(&reply);
! 	    }
  	    WriteToClient(client, sizeof(xLookupColorReply), &reply);
  
  #ifdef LBX_STATS
! 	    luc_good++;
  #endif
  
! 	    return REQ_YANK;
! 	}
      } else {
  	nr = NewReply(client);
  	if (nr) {
--- 397,428 ----
  
      rgbe = FindColorName((char *) &req[1], len, cmap);
  
!     if (rgbe && LBXCanDelayReply(client)) {	/* found the value */
! 	reply.type = X_Reply;
! 	reply.length = 0;
! 	reply.sequenceNumber = LBXSequenceNumber(client);
! 
! 	reply.exactRed = rgbe->xred;
! 	reply.exactBlue = rgbe->xblue;
! 	reply.exactGreen = rgbe->xgreen;
! 
! 	reply.screenRed = rgbe->vred;
! 	reply.screenBlue = rgbe->vblue;
! 	reply.screenGreen = rgbe->vgreen;
  
! 	if (client->swapped) {
! 	    SwapLookupColorReply(&reply);
! 	}
! 	if (LBXCacheSafe(client))
  	    WriteToClient(client, sizeof(xLookupColorReply), &reply);
+ 	else
+ 	    SaveReplyData(client, (xReply *) & reply, 0, NULL);
  
  #ifdef LBX_STATS
! 	luc_good++;
  #endif
  
! 	return REQ_YANK;
      } else {
  	nr = NewReply(client);
  	if (nr) {
***************
*** 451,457 ****
  
      reply = (xLookupColorReply *) data;
  
!     nr = GetReply(client);
      assert(nr);
  
      rgbe.xred = reply->exactRed;
--- 454,460 ----
  
      reply = (xLookupColorReply *) data;
  
!     nr = GetMatchingReply(client, reply->sequenceNumber);
      assert(nr);
  
      rgbe.xred = reply->exactRed;
***************
*** 506,541 ****
      }
      FindPixel(client, cmap, (int) red, (int) green,
  	      (int) blue, &pent);
!     if (pent) {
  	/* always inc the pixel, so our refcounts match the server's */
  	IncrementPixel(client, cmap, pent);
  
! 	/* found the value */
! 	if (LBXCacheSafe(client)) {
! 
! 	    /* must tell server to bump refcnt */
! 	    SendIncrementPixel(client, req->cmap, pent->pixel);
  
! 	    reply.type = X_Reply;
! 	    reply.length = 0;
! 	    reply.sequenceNumber = LBXSequenceNumber(client);
! 
! 	    reply.red = pent->rep_red;
! 	    reply.green = pent->rep_green;
! 	    reply.blue = pent->rep_blue;
! 	    reply.pixel = pent->pixel;
  
! 	    if (client->swapped) {
! 		SwapAllocColorReply(&reply);
! 	    }
  	    WriteToClient(client, sizeof(xAllocColorReply), &reply);
  
  #ifdef LBX_STATS
! 	    ac_good++;
  #endif
  
! 	    return REQ_REPLACE;	/* packet sent anyways */
! 	}
      } else {
  	nr = NewReply(client);
  	if (nr) {
--- 509,543 ----
      }
      FindPixel(client, cmap, (int) red, (int) green,
  	      (int) blue, &pent);
!     if (pent && LBXCanDelayReply(client)) {	/* found the value */
  	/* always inc the pixel, so our refcounts match the server's */
  	IncrementPixel(client, cmap, pent);
  
! 	/* must tell server to bump refcnt */
! 	SendIncrementPixel(client, req->cmap, pent->pixel);
  
! 	reply.type = X_Reply;
! 	reply.length = 0;
! 	reply.sequenceNumber = LBXSequenceNumber(client);
! 
! 	reply.red = pent->rep_red;
! 	reply.green = pent->rep_green;
! 	reply.blue = pent->rep_blue;
! 	reply.pixel = pent->pixel;
  
! 	if (client->swapped) {
! 	    SwapAllocColorReply(&reply);
! 	}
! 	if (LBXCacheSafe(client))
  	    WriteToClient(client, sizeof(xAllocColorReply), &reply);
+ 	else
+ 	    SaveReplyData(client, (xReply *) & reply, 0, NULL);
  
  #ifdef LBX_STATS
! 	ac_good++;
  #endif
  
! 	return REQ_REPLACE;	/* packet sent anyways */
      } else {
  	nr = NewReply(client);
  	if (nr) {
***************
*** 570,576 ****
  
      reply = (xAllocColorReply *) data;
  
!     nr = GetReply(client);
      assert(nr);
  
      pixel = reply->pixel;
--- 572,578 ----
  
      reply = (xAllocColorReply *) data;
  
!     nr = GetMatchingReply(client, reply->sequenceNumber);
      assert(nr);
  
      pixel = reply->pixel;
***************
*** 625,663 ****
      rgbe = FindColorName((char *) &req[1], nbytes, cmap);
  
      /* better get both if we got one... */
!     if (pent && rgbe) {
  	/* always inc the pixel, so our refcounts match the server's */
  	IncrementPixel(client, cmap, pent);
! 	/* found the value */
! 	if (LBXCacheSafe(client)) {
  
! 	    /* must tell server to bump refcnt */
! 	    SendIncrementPixel(client, cmap, pent->pixel);
  
! 	    reply.type = X_Reply;
! 	    reply.length = 0;
! 	    reply.sequenceNumber = LBXSequenceNumber(client);
! 
! 	    reply.screenRed = pent->rep_red;
! 	    reply.screenGreen = pent->rep_green;
! 	    reply.screenBlue = pent->rep_blue;
! 	    reply.exactRed = rgbe->xred;
! 	    reply.exactGreen = rgbe->xgreen;
! 	    reply.exactBlue = rgbe->xblue;
! 
! 	    reply.pixel = pent->pixel;
! 
!             if (client->swapped) {
! 		SwapAllocNamedColorReply(&reply);
!             }
  	    WriteToClient(client, sizeof(xAllocNamedColorReply), &reply);
  
  #ifdef LBX_STATS
! 	    anc_good++;
  #endif
  
! 	    return REQ_REPLACE;	/* packet sent anyways */
! 	}
      } else {
  	nr = NewReply(client);
  	if (nr) {
--- 627,665 ----
      rgbe = FindColorName((char *) &req[1], nbytes, cmap);
  
      /* better get both if we got one... */
!     if (pent && rgbe && LBXCanDelayReply(client)) {	/* found the value */
! 
  	/* always inc the pixel, so our refcounts match the server's */
  	IncrementPixel(client, cmap, pent);
! 	/* must tell server to bump refcnt */
! 	SendIncrementPixel(client, cmap, pent->pixel);
! 
! 	reply.type = X_Reply;
! 	reply.length = 0;
! 	reply.sequenceNumber = LBXSequenceNumber(client);
! 
! 	reply.screenRed = pent->rep_red;
! 	reply.screenGreen = pent->rep_green;
! 	reply.screenBlue = pent->rep_blue;
! 	reply.exactRed = rgbe->xred;
! 	reply.exactGreen = rgbe->xgreen;
! 	reply.exactBlue = rgbe->xblue;
  
! 	reply.pixel = pent->pixel;
  
! 	if (client->swapped) {
! 	    SwapAllocNamedColorReply(&reply);
! 	}
! 	if (LBXCacheSafe(client))
  	    WriteToClient(client, sizeof(xAllocNamedColorReply), &reply);
+ 	else			/* store for later */
+ 	    SaveReplyData(client, (xReply *) & reply, 0, NULL);
  
  #ifdef LBX_STATS
! 	anc_good++;
  #endif
  
! 	return REQ_REPLACE;	/* packet sent anyways */
      } else {
  	nr = NewReply(client);
  	if (nr) {
***************
*** 696,702 ****
  
      reply = (xAllocNamedColorReply *) data;
  
!     nr = GetReply(client);
      assert(nr);
  
      xred = reply->exactRed;
--- 698,704 ----
  
      reply = (xAllocNamedColorReply *) data;
  
!     nr = GetMatchingReply(client, reply->sequenceNumber);
      assert(nr);
  
      xred = reply->exactRed;
***************
*** 901,907 ****
  
      rep = (xLbxGetModifierMappingReply *) data;
  
!     nr = GetReply(client);
      assert(nr);
  
      tag = rep->tag;
--- 903,909 ----
  
      rep = (xLbxGetModifierMappingReply *) data;
  
!     nr = GetMatchingReply(client, rep->sequenceNumber);
      assert(nr);
  
      tag = rep->tag;
***************
*** 1001,1008 ****
  {
      xGetKeyboardMappingReply reply;
      int         len = (kpk * count) << 2;
!     char	*sdata;
!     Bool	freedata = FALSE;
  
      reply.type = X_Reply;
      reply.keySymsPerKeyCode = kpk;
--- 1003,1010 ----
  {
      xGetKeyboardMappingReply reply;
      int         len = (kpk * count) << 2;
!     char       *sdata;
!     Bool        freedata = FALSE;
  
      reply.type = X_Reply;
      reply.keySymsPerKeyCode = kpk;
***************
*** 1013,1019 ****
      if (client->swapped) {
  	SwapKeymapReply(&reply);
  	/* have to copy data because we could be handed the tag storage */
! 	sdata = (char *)ALLOCATE_LOCAL(len);
  	if (sdata) {
  	    bcopy(data, sdata, len);
  	    SwapLongs((CARD32 *) sdata, len / 4);
--- 1015,1021 ----
      if (client->swapped) {
  	SwapKeymapReply(&reply);
  	/* have to copy data because we could be handed the tag storage */
! 	sdata = (char *) ALLOCATE_LOCAL(len);
  	if (sdata) {
  	    bcopy(data, sdata, len);
  	    SwapLongs((CARD32 *) sdata, len / 4);
***************
*** 1044,1050 ****
  
      rep = (xLbxGetKeyboardMappingReply *) data;
  
!     nr = GetReply(client);
      assert(nr);
      tag = rep->tag;
      if (client->swapped) {
--- 1046,1052 ----
  
      rep = (xLbxGetKeyboardMappingReply *) data;
  
!     nr = GetMatchingReply(client, rep->sequenceNumber);
      assert(nr);
      tag = rep->tag;
      if (client->swapped) {
***************
*** 1193,1199 ****
  
      rep = (xLbxQueryFontReply *) data;
  
!     nr = GetReply(client);
      assert(nr);
  
      tag = rep->tag;
--- 1195,1201 ----
  
      rep = (xLbxQueryFontReply *) data;
  
!     nr = GetMatchingReply(client, rep->sequenceNumber);
      assert(nr);
  
      tag = rep->tag;
***************
*** 1381,1396 ****
      ClientPtr   client;
  {
      ReplyStuffPtr nr;
  
      REQUEST(xReq);
  
      /* create the reply struct for requests we don't do anything with */
!     if (generates_replies(stuff->reqType)) {
  	nr = NewReply(client);
  	if (nr) {
  	    nr->sequenceNumber = LBXSequenceNumber(client);
  	    nr->request = stuff->reqType;
! 	    nr->extension = (stuff->reqType > X_NoOperation) ? stuff->reqType : 0;
  	}
      }
      return FinishLBXRequest(client, REQ_PASSTHROUGH);
--- 1383,1401 ----
      ClientPtr   client;
  {
      ReplyStuffPtr nr;
+     int	gen;
  
      REQUEST(xReq);
  
      /* create the reply struct for requests we don't do anything with */
!     if (gen = GeneratesReplies(stuff)) {
  	nr = NewReply(client);
  	if (nr) {
  	    nr->sequenceNumber = LBXSequenceNumber(client);
  	    nr->request = stuff->reqType;
! 	    nr->extension = (stuff->reqType > X_NoOperation) ? stuff->data : 0;
! 	    if (gen == REQ_TYPE_MAYBE)
! 	    	nr->guessed = TRUE;
  	}
      }
      return FinishLBXRequest(client, REQ_PASSTHROUGH);
***************
*** 1411,1419 ****
  #endif
  
  #ifdef PROTOCOL_FULL
!     if (!yankable(yank) && (generates_events(stuff->reqType) ||
! 			    generates_replies(stuff->reqType)
! 			    || generates_errors(stuff->reqType)))
  	LBXCacheSafe(client) = FALSE;
      else
  	LBXCacheSafe(client) = TRUE;
--- 1416,1424 ----
  #endif
  
  #ifdef PROTOCOL_FULL
!     if (!yankable(yank) && (GeneratesEvents(stuff) ||
! 			    GeneratesReplies(stuff)
! 			    || GeneratesErrors(stuff)))
  	LBXCacheSafe(client) = FALSE;
      else
  	LBXCacheSafe(client) = TRUE;
***************
*** 1421,1427 ****
  
  #ifdef PROTOCOL_MOST
      if (!yankable(yank)
!      (generates_events(stuff->reqType) || generates_replies(stuff->reqType)))
  	LBXCacheSafe(client) = FALSE;
      else
  	LBXCacheSafe(client) = TRUE;
--- 1426,1432 ----
  
  #ifdef PROTOCOL_MOST
      if (!yankable(yank)
! 	    (GeneratesEvents(stuff) || GeneratesReplies(stuff)))
  	LBXCacheSafe(client) = FALSE;
      else
  	LBXCacheSafe(client) = TRUE;
***************
*** 1431,1436 ****
--- 1436,1462 ----
      LBXCacheSafe(client) = TRUE;
  #endif
  
+     /* never safe to short-circuit if requests are outstanding */
+     if (NumReplies(client) > 0)
+ 	LBXCacheSafe(client) = FALSE;
+ 
+ /* XXX is this correct for anything but PROTOCOL_POOR ??? */
+     /*
+      * if we can't write it instantly, and there *may* be a reply pending,
+      * (unknown, because its an unrecognized extension request) we can't even
+      * delay a short-circuit, cause we'll never know when its safe to send the
+      * delayed reply
+      */
+     if (!LBXCacheSafe(client))	{
+     	if (NumReplies(client) && NumGuessedReplies(client) == 0)
+ 	    LBXCanDelayReply(client) = TRUE;
+ 	else
+ 	    LBXCanDelayReply(client) = FALSE;
+     } else {	/* always true if cacheable, so we get a chance to write */
+ 	LBXCanDelayReply(client) = TRUE;
+     }
+     	
+ 
      if (yank == REQ_YANK) {
  	LBXSequenceLost(client)++;
  	LBXYanked(client)++;
***************
*** 1465,1471 ****
      ReplyStuffPtr nr;
  {
      QueryTagPtr qtp;
!     int         retval = 0;
      CARD16      minor_code;
      char        n;
  
--- 1491,1497 ----
      ReplyStuffPtr nr;
  {
      QueryTagPtr qtp;
!     int         retval = 1;
      CARD16      minor_code;
      char        n;
  
***************
*** 1513,1519 ****
  	}
  	break;
      default:
! 	assert(0);
  	break;
      }
      if (client->swapped) {
--- 1539,1546 ----
  	}
  	break;
      default:
! 	retval = 0;		/* error caused by some LBX req that shouldn't
! 				 * have an error, so eat it */
  	break;
      }
      if (client->swapped) {
***************
*** 1584,1590 ****
  		if (client->swapped) {
  		    SwapConnectionInfo((xConnSetup *) & prefix[1]);
  		}
! 		GetConnectionInfo(client, (xConnSetup *) &prefix[1], NULL);
  	    }
  	}
  	return TRUE;
--- 1611,1617 ----
  		if (client->swapped) {
  		    SwapConnectionInfo((xConnSetup *) & prefix[1]);
  		}
! 		GetConnectionInfo(client, (xConnSetup *) & prefix[1], NULL);
  	    }
  	}
  	return TRUE;
***************
*** 1608,1628 ****
  		(reply->type & 0x7f), reply->sequenceNumber, client->XRemId);
  #endif
  
- 	if ((reply->type & 0x7f) >= LASTEvent)
- 	    fprintf(stderr, "Extension event or BOGUS REPLY TYPE\n");
- 
  	/* clear out pending replies that resulted in errors */
  	if (reply->type == X_Error) {
  	    err = (xError *) reply;
! 	    nr = GetReply(client);
  	    if (error_matches(client, nr, err)) {
  		if (err->majorCode == client->server->lbxReq) {
! 		    if (patchup_error(client, err, nr) < 0) {
  			CloseDownClient(client);
  			return FALSE;
  		    }
  		}
! 		RemoveReply(client);
  	    }
  	}
  	/* KeymapNotify has no sequence # */
--- 1635,1659 ----
  		(reply->type & 0x7f), reply->sequenceNumber, client->XRemId);
  #endif
  
  	/* clear out pending replies that resulted in errors */
  	if (reply->type == X_Error) {
  	    err = (xError *) reply;
! 	    nr = GetMatchingReply(client, reply->sequenceNumber);
  	    if (error_matches(client, nr, err)) {
  		if (err->majorCode == client->server->lbxReq) {
! 		    int         eret;
! 
! 		    if ((eret = patchup_error(client, err, nr)) < 0) {
  			CloseDownClient(client);
  			return FALSE;
+ 		    } else if (eret == 0) {
+ 			/* error for proxy -- eat it */
+ 			ret = FALSE;
  		    }
  		}
! 		/* handle extension error */
! 		HandleExtensionError(client, err);
! 		RemoveReply(client, nr);
  	    }
  	}
  	/* KeymapNotify has no sequence # */
***************
*** 1645,1657 ****
  	if (reply->type == MotionNotify) {
  	    AllowMotion(client, 1);
  	}
  	if (client->swapped) {	/* put seq & length back */
  	    swaps(&reply->sequenceNumber, n);
  	    swapl(&reply->length, n);
  	}
! 	return TRUE;
      }
!     nr = GetReply(client);
  
      if (!nr)			/* what is this???? */
  	return TRUE;
--- 1676,1689 ----
  	if (reply->type == MotionNotify) {
  	    AllowMotion(client, 1);
  	}
+ 	HandleExtensionEvent(client, reply);
  	if (client->swapped) {	/* put seq & length back */
  	    swaps(&reply->sequenceNumber, n);
  	    swapl(&reply->length, n);
  	}
! 	return ret;
      }
!     nr = GetMatchingReply(client, reply->sequenceNumber);
  
      if (!nr)			/* what is this???? */
  	return TRUE;
***************
*** 1663,1675 ****
       * either a safe reply struct, or an extension struct that has a matching
       * sequence number.
       */
      while (!nr->lbx_req && nr->extension && NumReplies(client) > 1) {
  	if ((nr->sequenceNumber & 0xffff) == reply->sequenceNumber)
  	    break;
! 	RemoveReply(client);
  	nr = GetReply(client);
  	assert(nr);
      }
  
  
  #ifdef TRACE
--- 1695,1710 ----
       * either a safe reply struct, or an extension struct that has a matching
       * sequence number.
       */
+ 
+ #ifdef old
      while (!nr->lbx_req && nr->extension && NumReplies(client) > 1) {
  	if ((nr->sequenceNumber & 0xffff) == reply->sequenceNumber)
  	    break;
! 	RemoveReply(client, nr);
  	nr = GetReply(client);
  	assert(nr);
      }
+ #endif
  
  
  #ifdef TRACE
***************
*** 1734,1747 ****
  	    remove_it = GetQueryTagReply(client, (char *) reply);
  	    ret = FALSE;
  	    break;
  	default:
  	    break;
  	}
      } else {
  	/* XXX handle any other extensions we may know about */
      }
      if (remove_it)
! 	RemoveReply(client);
      if (client->swapped) {	/* put seq & length back */
  	swaps(&reply->sequenceNumber, n);
  	swapl(&reply->length, n);
--- 1769,1791 ----
  	    remove_it = GetQueryTagReply(client, (char *) reply);
  	    ret = FALSE;
  	    break;
+ 	case X_LbxGetImage:
+ 	    remove_it = GetLbxImageReply(client, (char *) reply);
+ 	    ret = FALSE;
+ 	    break;
+ 	case X_LbxQueryExtension:
+ 	    remove_it = HandleLbxQueryExtensionReply(client, (char *) reply);
+ 	    ret = FALSE;
+ 	    break;
  	default:
  	    break;
  	}
      } else {
  	/* XXX handle any other extensions we may know about */
+ 	remove_it = HandleExtensionReply(client, reply, nr);
      }
      if (remove_it)
! 	RemoveReply(client, nr);
      if (client->swapped) {	/* put seq & length back */
  	swaps(&reply->sequenceNumber, n);
  	swapl(&reply->length, n);
*** -	Wed Jan 18 13:07:00 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/main.c	Wed Jan 18 13:07:00 1995
***************
*** 1,7 ****
! /* $XConsortium: main.c,v 1.6 94/03/27 13:44:50 dpw Exp $ */
  /*
   * $NCDOr$
!  * $NCDId: @(#)main.c,v 1.15 1994/03/24 17:54:31 lemke Exp $
   *
   * Copyright 1992 Network Computing Devices
   *
--- 1,7 ----
! /* $XConsortium: main.c,v 1.7 94/12/01 20:43:25 mor Exp $ */
  /*
   * $NCDOr$
!  * $NCDId: @(#)main.c,v 1.17 1994/11/16 02:27:55 lemke Exp $
   *
   * Copyright 1992 Network Computing Devices
   *
***************
*** 39,44 ****
--- 39,45 ----
  #include "atomcache.h"
  #include "colormap.h"
  #include "tags.h"
+ #include "lbxext.h"
  
  char	*display = "10";
  
***************
*** 64,69 ****
--- 65,71 ----
  	if (serverGeneration == 1)
  	{
  	    CreateWellKnownSockets ();
+ 	    RegisterAllExtensions();
  	    clients = (ClientPtr *)xalloc(MAXCLIENTS * sizeof(ClientPtr));
  	    if (!clients)
  		FatalError("couldn't create client array");
***************
*** 87,101 ****
--- 89,106 ----
          if (!InitClientResources(serverClient))
              FatalError("couldn't init server resources");
          InitDeleteFuncs();
+ 	InitExtensions();
          clients[0] = serverClient;
          currentMaxClients = 1;
  
  	if (Dispatch () != 0)
  	    break;
+ 	ShutdownExtensions();
          FreeAllResources();
          FreeAtoms();
          FreeColors();
          FreeTags();
+ 	CacheFreeAll();
      }
      exit (0);
  }
*** -	Wed Jan 18 13:07:01 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/reqtype.c	Wed Jan 18 13:07:01 1995
***************
*** 1,4 ****
! /* $XConsortium: reqtype.c,v 1.4 94/03/27 13:50:59 dpw Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
--- 1,4 ----
! /* $XConsortium: reqtype.c,v 1.5 94/12/01 20:48:07 mor Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
***************
*** 7,15 ****
   * that the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
   * documentation, and that the name Network Computing Devices, Inc. not be
!  * used in advertising or publicity pertaining to distribution of this 
   * software without specific, written prior permission.
!  * 
   * THIS SOFTWARE IS PROVIDED `AS-IS'.  NETWORK COMPUTING DEVICES, INC.,
   * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT
   * LIMITATION ALL IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
--- 7,15 ----
   * that the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
   * documentation, and that the name Network Computing Devices, Inc. not be
!  * used in advertising or publicity pertaining to distribution of this
   * software without specific, written prior permission.
!  *
   * THIS SOFTWARE IS PROVIDED `AS-IS'.  NETWORK COMPUTING DEVICES, INC.,
   * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT
   * LIMITATION ALL IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
***************
*** 19,32 ****
   * OR PROFITS, EVEN IF ADVISED OF THE POSSIBILITY THEREOF, AND REGARDLESS OF
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
!  * 
!  * $NCDId: @(#)reqtype.c,v 1.4 1994/03/24 17:54:59 lemke Exp $
   */
  
  /* decides what tupe of request it is */
  #include	<X11/Xproto.h>
! #include        "os.h"          /* in server/include */
  #include	"reqtype.h"
  
  static Bool cause_replies[] = {
      FALSE,			/* BadRequest */
--- 19,33 ----
   * OR PROFITS, EVEN IF ADVISED OF THE POSSIBILITY THEREOF, AND REGARDLESS OF
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
!  *
!  * $NCDId: @(#)reqtype.c,v 1.7 1994/09/24 01:07:43 lemke Exp $
   */
  
  /* decides what tupe of request it is */
  #include	<X11/Xproto.h>
! #include        "os.h"		/* in server/include */
  #include	"reqtype.h"
+ #include	"lbxext.h"
  
  static Bool cause_replies[] = {
      FALSE,			/* BadRequest */
***************
*** 279,306 ****
  
  /* ARGSUSED */
  Bool
! generates_errors(req)
!     int         req;
  {
!     return TRUE;		/* eveyrthing causes an error */
  }
  
  Bool
! generates_events(req)
!     int         req;
  {
      /* don't grok extensions */
!     if (req > X_NoOperation)
! 	return TRUE;
!     return cause_events[req];
  }
  
! Bool
! generates_replies(req)
!     int         req;
  {
      /* don't grok extensions */
!     if (req > X_NoOperation)
! 	return TRUE;
!     return cause_replies[req];
  }
--- 280,307 ----
  
  /* ARGSUSED */
  Bool
! GeneratesErrors(req)
!     xReq       *req;
  {
!     return TRUE;		/* everything can  a least BadAlloc */
  }
  
  Bool
! GeneratesEvents(req)
!     xReq       *req;
  {
      /* don't grok extensions */
!     if (req->reqType > X_NoOperation)
! 	return CheckExtensionForEvents(req);
!     return cause_events[req->reqType];
  }
  
! int
! GeneratesReplies(req)
!     xReq       *req;
  {
      /* don't grok extensions */
!     if (req->reqType > X_NoOperation)
! 	return CheckExtensionForReplies(req);
!     return (int) cause_replies[req->reqType];
  }
*** -	Wed Jan 18 13:07:03 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/reqtype.h	Wed Jan 18 13:07:02 1995
***************
*** 1,4 ****
! /* $XConsortium: reqtype.h,v 1.3 94/02/20 11:14:14 dpw Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
--- 1,4 ----
! /* $XConsortium: reqtype.h,v 1.4 94/12/01 20:48:07 mor Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
***************
*** 7,15 ****
   * that the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
   * documentation, and that the name Network Computing Devices, Inc. not be
!  * used in advertising or publicity pertaining to distribution of this 
   * software without specific, written prior permission.
!  * 
   * THIS SOFTWARE IS PROVIDED `AS-IS'.  NETWORK COMPUTING DEVICES, INC.,
   * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT
   * LIMITATION ALL IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
--- 7,15 ----
   * that the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
   * documentation, and that the name Network Computing Devices, Inc. not be
!  * used in advertising or publicity pertaining to distribution of this
   * software without specific, written prior permission.
!  *
   * THIS SOFTWARE IS PROVIDED `AS-IS'.  NETWORK COMPUTING DEVICES, INC.,
   * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT
   * LIMITATION ALL IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
***************
*** 19,32 ****
   * OR PROFITS, EVEN IF ADVISED OF THE POSSIBILITY THEREOF, AND REGARDLESS OF
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
!  * 
!  * $NCDId: @(#)reqtype.h,v 1.2 1994/02/09 19:25:26 lemke Exp $
   */
  #ifndef	_REQTYPE_H_
  #define	_REQTYPE_H_
  
! extern Bool generates_events();
! extern Bool generates_errors();
! extern Bool generates_replies();
  
  #endif				/* _REQTYPE_H_ */
--- 19,38 ----
   * OR PROFITS, EVEN IF ADVISED OF THE POSSIBILITY THEREOF, AND REGARDLESS OF
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
!  *
!  * $NCDId: @(#)reqtype.h,v 1.5 1994/09/24 01:07:45 lemke Exp $
   */
+ 
  #ifndef	_REQTYPE_H_
  #define	_REQTYPE_H_
  
! extern Bool GeneratesErrors();
! extern Bool GeneratesEvents();
! extern int  GeneratesReplies();
! 
! #define	REQ_TYPE_NO	0
! #define	REQ_TYPE_YES	1
! #define	REQ_TYPE_MAYBE	2
! 
  
  #endif				/* _REQTYPE_H_ */
*** -	Wed Jan 18 13:07:04 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/resource.c	Wed Jan 18 13:07:03 1995
***************
*** 1,6 ****
  /* Copyright 1988, 1989 Network Computing Devices, Inc.  All rights reserved. */
  
! /* $NCDId: @(#)resource.c,v 1.5 1994/03/24 17:54:47 lemke Exp $ */
  
  /************************************************************
  
--- 1,6 ----
  /* Copyright 1988, 1989 Network Computing Devices, Inc.  All rights reserved. */
  
! /* $NCDId: @(#)resource.c,v 1.6 1994/09/07 01:50:30 lemke Exp $ */
  
  /************************************************************
  
***************
*** 50,56 ****
  
  ********************************************************/
  
! /* $XConsortium: resource.c,v 1.5 94/04/17 21:17:19 dpw Exp $ */
  
  /*	Routines to manage various kinds of resources:
   *
--- 50,56 ----
  
  ********************************************************/
  
! /* $XConsortium: resource.c,v 1.6 94/12/01 20:42:14 mor Exp $ */
  
  /*	Routines to manage various kinds of resources:
   *
***************
*** 76,81 ****
--- 76,82 ----
   */
  
  #include <X11/X.h>
+ #define	NEED_REPLIES
  #include <X11/Xproto.h>
  #include "misc.h"
  #include "os.h"
*** -	Wed Jan 18 13:07:05 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/stubs.c	Wed Jan 18 13:07:05 1995
***************
*** 1,7 ****
! /* $XConsortium: stubs.c,v 1.5 94/03/27 13:53:51 dpw Exp $ */
  /*
   * $NCDOr: stubs.c,v 1.1 1993/11/16 17:58:49 keithp Exp keithp $
!  * $NCDId: @(#)stubs.c,v 1.11 1994/03/24 17:54:41 lemke Exp $
   *
   * Copyright 1992 Network Computing Devices
   *
--- 1,7 ----
! /* $XConsortium: stubs.c,v 1.6 94/12/01 20:45:10 mor Exp $ */
  /*
   * $NCDOr: stubs.c,v 1.1 1993/11/16 17:58:49 keithp Exp keithp $
!  * $NCDId: @(#)stubs.c,v 1.16 1994/11/18 20:35:22 lemke Exp $
   *
   * Copyright 1992 Network Computing Devices
   *
***************
*** 42,52 ****
  }
  
  extern int  lbxDebug;
- extern int  lbxLZW;
- extern int  lbxDeltaN;
  extern int  lbxTagCacheSize;
  extern Bool lbxUseTags;
  extern Bool lbxUseLbx;
  
  ddxProcessArgument (argc, argv, i)
      char    **argv;
--- 42,54 ----
  }
  
  extern int  lbxDebug;
  extern int  lbxTagCacheSize;
  extern Bool lbxUseTags;
  extern Bool lbxUseLbx;
+ extern Bool lbxDoSquishing;
+ extern Bool lbxCompressImages;
+ extern Bool lbxDoShortCircuiting;
+ extern Bool lbxDoLbxGfx;
  
  ddxProcessArgument (argc, argv, i)
      char    **argv;
***************
*** 59,72 ****
  	    UseMsg ();
  	return 2;
      }
      if (strcmp (argv[i], "-nolzw") == 0)
      {
! 	lbxLZW = 0;
  	return 1;
      }
      if (strcmp (argv[i], "-nodelta") == 0)
      {
! 	lbxDeltaN = 0;
  	return 1;
      }
      if (strcmp (argv[i], "-notags") == 0)
--- 61,89 ----
  	    UseMsg ();
  	return 2;
      }
+     if (strcmp (argv[i], "-nogfx") == 0)
+     {
+ 	lbxDoLbxGfx = 0;
+ 	return 1;
+     }
+     if (strcmp (argv[i], "-nosc") == 0)
+     {
+ 	lbxDoShortCircuiting = 0;
+ 	return 1;
+     }
      if (strcmp (argv[i], "-nolzw") == 0)
      {
! 	LbxNoComp();
! 	return 1;
!     }
!     if (strcmp (argv[i], "-nocomp") == 0)
!     {
! 	LbxNoComp();
  	return 1;
      }
      if (strcmp (argv[i], "-nodelta") == 0)
      {
! 	LbxNoDelta();
  	return 1;
      }
      if (strcmp (argv[i], "-notags") == 0)
***************
*** 77,82 ****
--- 94,109 ----
      if (strcmp (argv[i], "-nolbx") == 0)
      {
  	lbxUseLbx = 0;
+ 	return 1;
+     }
+     if (strcmp (argv[i], "-noimage") == 0)
+     {
+ 	lbxCompressImages = 0;
+ 	return 1;
+     }
+     if (strcmp (argv[i], "-nosquish") == 0)
+     {
+ 	LbxNoSquish();
  	return 1;
      }
      if (strcmp (argv[i], "-tagcachesize") == 0)
*** -	Wed Jan 18 13:07:06 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/tables.c	Wed Jan 18 13:07:06 1995
***************
*** 1,7 ****
! /* $XConsortium: tables.c,v 1.5 94/03/27 13:56:27 dpw Exp $ */
  /*
   * $NCDOr$
!  * $NCDId: @(#)tables.c,v 1.13 1994/03/21 21:08:30 lemke Exp $
   *
   * Copyright 1992 Network Computing Devices
   *
--- 1,7 ----
! /* $XConsortium: tables.c,v 1.8 94/12/01 20:47:07 mor Exp $ */
  /*
   * $NCDOr$
!  * $NCDId: @(#)tables.c,v 1.18 1994/11/18 20:38:46 lemke Exp $
   *
   * Copyright 1992 Network Computing Devices
   *
***************
*** 19,202 ****
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL NCD.
   * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
!  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
   * Author:  Keith Packard, Network Computing Devices
   */
  
! extern int    ProcInitialConnection(), ProcEstablishConnection();
  
! extern int    ProcStandardRequest ();
  
! extern int	ProcLBXInternAtom(),
! 		ProcLBXGetAtomName(),
!                 ProcLBXCreateColormap(),
!                 ProcLBXFreeColormap(),
!                 ProcLBXCopyColormapAndFree(),
!                 ProcLBXFreeColors(),
!                 ProcLBXLookupColor(),
!                 ProcLBXAllocColor(),
!                 ProcLBXAllocNamedColor(),
!                 ProcLBXGetModifierMapping(),
!                 ProcLBXGetKeyboardMapping(),
!                 ProcLBXQueryFont(),
!                 ProcLBXChangeProperty(),
!                 ProcLBXGetProperty(),
! 		ProcLBXPolyPoint(),
! 		ProcLBXPolyLine(),
! 		ProcLBXPolySegment(),
! 		ProcLBXPolyRectangle(),
! 		ProcLBXPolyArc(),
! 		ProcLBXFillPoly(),
! 		ProcLBXPolyFillRectangle(),
! 		ProcLBXPolyFillArc()
!                 ;
  
! extern int    ProcBadRequest(), ProcCreateWindow(),
!     ProcChangeWindowAttributes(), ProcGetWindowAttributes(),
!     ProcDestroyWindow(), ProcDestroySubwindows(), ProcChangeSaveSet(),
!     ProcReparentWindow(), ProcMapWindow(), ProcMapSubwindows(),
!     ProcUnmapWindow(), ProcUnmapSubwindows(), ProcConfigureWindow(),
!     ProcCirculateWindow(), ProcGetGeometry(), ProcQueryTree(),
!     ProcInternAtom(), ProcGetAtomName(), ProcChangeProperty(),
!     ProcDeleteProperty(), ProcGetProperty(), ProcListProperties(),
!     ProcSetSelectionOwner(), ProcGetSelectionOwner(), ProcConvertSelection(),
!     ProcSendEvent(), ProcGrabPointer(), ProcUngrabPointer(),
!     ProcGrabButton(), ProcUngrabButton(), ProcChangeActivePointerGrab(),
!     ProcGrabKeyboard(), ProcUngrabKeyboard(), ProcGrabKey(),
!     ProcUngrabKey(), ProcAllowEvents(), ProcGrabServer(),
!     ProcUngrabServer(), ProcQueryPointer(), ProcGetMotionEvents(),
!     ProcTranslateCoords(), ProcWarpPointer(), ProcSetInputFocus(),
!     ProcGetInputFocus(), ProcQueryKeymap(), ProcOpenFont(),
!     ProcCloseFont(), ProcQueryFont(), ProcQueryTextExtents(),
!     ProcListFonts(), ProcListFontsWithInfo(), ProcSetFontPath(),
!     ProcGetFontPath(), ProcCreatePixmap(), ProcFreePixmap(),
!     ProcCreateGC(), ProcChangeGC(), ProcCopyGC(),
!     ProcSetDashes(), ProcSetClipRectangles(), ProcFreeGC(),
!     ProcClearToBackground(), ProcCopyArea(), ProcCopyPlane(),
!     ProcPolyPoint(), ProcPolyLine(), ProcPolySegment(),
!     ProcPolyRectangle(), ProcPolyArc(), ProcFillPoly(),
!     ProcPolyFillRectangle(), ProcPolyFillArc(), ProcPutImage(),
!     ProcGetImage(), ProcPolyText(),
!     ProcImageText8(), ProcImageText16(), ProcCreateColormap(),
!     ProcFreeColormap(), ProcCopyColormapAndFree(), ProcInstallColormap(),
!     ProcUninstallColormap(), ProcListInstalledColormaps(), ProcAllocColor(),
!     ProcAllocNamedColor(), ProcAllocColorCells(), ProcAllocColorPlanes(),
!     ProcFreeColors(), ProcStoreColors(), ProcStoreNamedColor(),
!     ProcQueryColors(), ProcLookupColor(), ProcCreateCursor(),
!     ProcCreateGlyphCursor(), ProcFreeCursor(), ProcRecolorCursor(),
!     ProcQueryBestSize(), ProcQueryExtension(), ProcListExtensions(),
!     ProcChangeKeyboardMapping(), ProcSetPointerMapping(),
!     ProcGetKeyboardMapping(), ProcGetPointerMapping(),
!     ProcChangeKeyboardControl(),
!     ProcGetKeyboardControl(), ProcBell(), ProcChangePointerControl(),
!     ProcGetPointerControl(), ProcSetScreenSaver(), ProcGetScreenSaver(),
!     ProcChangeHosts(), ProcListHosts(), ProcChangeAccessControl(),
!     ProcChangeCloseDownMode(), ProcKillClient(),
!     ProcRotateProperties(), ProcForceScreenSaver(),
!     ProcSetModifierMapping(), ProcGetModifierMapping(),
!     ProcNoOperation();
  
! extern int    SProcSProcBadRequest(), SProcCreateWindow(),
!     SProcChangeWindowAttributes(), 
!     SProcReparentWindow(), SProcConfigureWindow(),
!     SProcInternAtom(), SProcChangeProperty(),
!     SProcDeleteProperty(), SProcGetProperty(),
!     SProcSetSelectionOwner(),
!     SProcConvertSelection(),
!     SProcSendEvent(), SProcGrabPointer(),
!     SProcGrabButton(), SProcUngrabButton(), SProcChangeActivePointerGrab(),
!     SProcGrabKeyboard(), SProcGrabKey(),
!     SProcUngrabKey(), SProcGetMotionEvents(),
!     SProcTranslateCoords(), SProcWarpPointer(), SProcSetInputFocus(),
!     SProcOpenFont(),
!     SProcListFonts(), SProcListFontsWithInfo(), SProcSetFontPath(),
!     SProcCreatePixmap(),
!     SProcCreateGC(), SProcChangeGC(), SProcCopyGC(),
!     SProcSetDashes(), SProcSetClipRectangles(),
!     SProcClearToBackground(), SProcCopyArea(), SProcCopyPlane(),
!     SProcPoly(), SProcFillPoly(), SProcPutImage(),
!     SProcGetImage(), SProcPolyText(), 
!     SProcImageText(), SProcCreateColormap(),
!     SProcCopyColormapAndFree(), SProcAllocColor(),
!     SProcAllocNamedColor(), SProcAllocColorCells(), SProcAllocColorPlanes(),
!     SProcFreeColors(), SProcStoreColors(), SProcStoreNamedColor(),
!     SProcQueryColors(), SProcLookupColor(), SProcCreateCursor(),
!     SProcCreateGlyphCursor(), SProcRecolorCursor(),
!     SProcQueryBestSize(), SProcQueryExtension(),
!     SProcChangeKeyboardMapping(), SProcChangeKeyboardControl(),
!     SProcChangePointerControl(),
!     SProcSetScreenSaver(),
!     SProcChangeHosts(),
!     SProcRotateProperties(), 
!     SProcNoOperation(), SProcResourceReq(), SProcSimpleReq();
! 
! extern void 
!     SErrorEvent(), NotImplemented(), SKeyButtonPtrEvent(), SKeyButtonPtrEvent(),
!     SKeyButtonPtrEvent(), SKeyButtonPtrEvent(), SKeyButtonPtrEvent(),
!     SEnterLeaveEvent(), SEnterLeaveEvent(), SFocusEvent(),
!     SFocusEvent(), SKeymapNotifyEvent(), SExposeEvent(),
!     SGraphicsExposureEvent(), SNoExposureEvent(), SVisibilityEvent(),
!     SCreateNotifyEvent(), SDestroyNotifyEvent(), SUnmapNotifyEvent(),
!     SMapNotifyEvent(), SMapRequestEvent(), SReparentEvent(),
!     SConfigureNotifyEvent(), SConfigureRequestEvent(), SGravityEvent(),
!     SResizeRequestEvent(), SCirculateEvent(), SCirculateEvent(),
!     SPropertyEvent(), SSelectionClearEvent(), SSelectionRequestEvent(),
!     SSelectionNotifyEvent(), SColormapEvent(), SClientMessageEvent(), SMappingEvent();
! 
! extern void
!     SGetWindowAttributesReply(), SGetGeometryReply(), SQueryTreeReply(),
!     SInternAtomReply(), SGetAtomNameReply(), SGetPropertyReply(),
!     SListPropertiesReply(), 
!     SGetSelectionOwnerReply(),
!     SQueryPointerReply(), SGetMotionEventsReply(), STranslateCoordsReply(),
!     SGetInputFocusReply(), SQueryKeymapReply(), SQueryFontReply(),
!     SQueryTextExtentsReply(), SListFontsReply(), SListFontsWithInfoReply(),
!     SGetFontPathReply(), SGetImageReply(), SListInstalledColormapsReply(),
!     SAllocColorReply(), SAllocNamedColorReply(), SAllocColorCellsReply(),
!     SAllocColorPlanesReply(), SQueryColorsReply(), SLookupColorReply(),
!     SQueryBestSizeReply(), SListExtensionsReply(),
!     SGetKeyboardMappingReply(), SGetKeyboardControlReply(), 
!     SGetPointerControlReply(), SGetScreenSaverReply(), 
!     SListHostsReply(), SGetPointerMappingReply(),
!     SGetModifierMappingReply(), SGenericReply();
! 
! int (* InitialVector[3]) () =
  {
      0,
      ProcInitialConnection,
      ProcEstablishConnection
  };
  
! int (* ProcVector[256]) () =
  {
      ProcBadRequest,
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
!     ProcStandardRequest,		/* 5 */
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
!     ProcStandardRequest,			/* 10 */
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
!     ProcStandardRequest,			/* 15 */
      ProcLBXInternAtom,
      ProcLBXGetAtomName,
      ProcLBXChangeProperty,
      ProcStandardRequest,
!     ProcLBXGetProperty,			/* 20 */
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
!     ProcStandardRequest,			/* 25 */
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
--- 19,101 ----
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL NCD.
   * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
!  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
   * Author:  Keith Packard, Network Computing Devices
   */
  
! extern int  ProcInitialConnection(), ProcEstablishConnection();
  
! extern int  ProcStandardRequest();
  
! extern int  ProcLBXInternAtom(),
!             ProcLBXGetAtomName(),
!             ProcLBXCreateColormap(),
!             ProcLBXFreeColormap(),
!             ProcLBXCopyColormapAndFree(),
!             ProcLBXFreeColors(),
!             ProcLBXLookupColor(),
!             ProcLBXAllocColor(),
!             ProcLBXAllocNamedColor(),
!             ProcLBXGetModifierMapping(),
!             ProcLBXGetKeyboardMapping(),
!             ProcLBXQueryFont(),
!             ProcLBXChangeProperty(),
!             ProcLBXGetProperty(),
! 	    ProcLBXCopyArea(),
! 	    ProcLBXCopyPlane(),
!             ProcLBXPolyPoint(),
!             ProcLBXPolyLine(),
!             ProcLBXPolySegment(),
!             ProcLBXPolyRectangle(),
!             ProcLBXPolyArc(),
!             ProcLBXFillPoly(),
!             ProcLBXPolyFillRectangle(),
!             ProcLBXPolyFillArc(),
! 	    ProcLBXPolyText(),
! 	    ProcLBXImageText(),
!             ProcLBXQueryExtension(),
! 	    ProcLBXGetImage(),
! 	    ProcLBXPutImage();
  
! extern int  ProcBadRequest();
  
! int         (*InitialVector[3]) () =
  {
      0,
      ProcInitialConnection,
      ProcEstablishConnection
  };
  
! int         (*ProcVector[256]) () =
  {
      ProcBadRequest,
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
!     ProcStandardRequest,	/* 5 */
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
!     ProcStandardRequest,	/* 10 */
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
!     ProcStandardRequest,	/* 15 */
      ProcLBXInternAtom,
      ProcLBXGetAtomName,
      ProcLBXChangeProperty,
      ProcStandardRequest,
!     ProcLBXGetProperty,		/* 20 */
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
!     ProcStandardRequest,	/* 25 */
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
***************
*** 206,302 ****
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
!     ProcStandardRequest,			/* 35 */
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
!     ProcStandardRequest,		/* 40 */
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
!     ProcStandardRequest,			/* 45 */
      ProcStandardRequest,
      ProcLBXQueryFont,
      ProcStandardRequest,
      ProcStandardRequest,
!     ProcStandardRequest,		/* 50 */
!     ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
-     ProcStandardRequest,			/* 55 */
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
-     ProcStandardRequest,			/* 60 */
-     ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
      ProcLBXPolyPoint,
!     ProcLBXPolyLine,				/* 65 */
      ProcLBXPolySegment,
      ProcLBXPolyRectangle,
      ProcLBXPolyArc,
      ProcLBXFillPoly,
!     ProcLBXPolyFillRectangle,			/* 70 */
      ProcLBXPolyFillArc,
!     ProcStandardRequest,
!     ProcStandardRequest,
!     ProcStandardRequest,
!     ProcStandardRequest,			/* 75 */
!     ProcStandardRequest,
!     ProcStandardRequest,
      ProcLBXCreateColormap,
      ProcLBXFreeColormap,
!     ProcLBXCopyColormapAndFree,		/* 80 */
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
      ProcLBXAllocColor,
!     ProcLBXAllocNamedColor,		/* 85 */
      ProcStandardRequest,
      ProcStandardRequest,
      ProcLBXFreeColors,
      ProcStandardRequest,
!     ProcStandardRequest,		/* 90 */
      ProcStandardRequest,
      ProcLBXLookupColor,
      ProcStandardRequest,
      ProcStandardRequest,
!     ProcStandardRequest,			/* 95 */
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
!     ProcStandardRequest,
!     ProcStandardRequest,		/* 100 */
      ProcLBXGetKeyboardMapping,
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
!     ProcStandardRequest,		/* 105 */
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
!     ProcStandardRequest,			/* 110 */
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
!     ProcStandardRequest,		/* 115 */
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
      ProcLBXGetModifierMapping,
!     0,					/* 120 */
      0,
      0,
      0,
      0,
!     0,					/* 125 */
      0,
      ProcStandardRequest,
      ProcStandardRequest,
--- 105,201 ----
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
!     ProcStandardRequest,	/* 35 */
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
!     ProcStandardRequest,	/* 40 */
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
!     ProcStandardRequest,	/* 45 */
      ProcStandardRequest,
      ProcLBXQueryFont,
      ProcStandardRequest,
      ProcStandardRequest,
!     ProcStandardRequest,	/* 50 */
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
+     ProcStandardRequest,	/* 55 */
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
+     ProcStandardRequest,	/* 60 */
      ProcStandardRequest,
+     ProcLBXCopyArea,
+     ProcLBXCopyPlane,
      ProcLBXPolyPoint,
!     ProcLBXPolyLine,		/* 65 */
      ProcLBXPolySegment,
      ProcLBXPolyRectangle,
      ProcLBXPolyArc,
      ProcLBXFillPoly,
!     ProcLBXPolyFillRectangle,	/* 70 */
      ProcLBXPolyFillArc,
!     ProcLBXPutImage,
!     ProcLBXGetImage,
!     ProcLBXPolyText,
!     ProcLBXPolyText,		/* 75 */
!     ProcLBXImageText,
!     ProcLBXImageText,
      ProcLBXCreateColormap,
      ProcLBXFreeColormap,
!     ProcLBXCopyColormapAndFree,	/* 80 */
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
      ProcLBXAllocColor,
!     ProcLBXAllocNamedColor,	/* 85 */
      ProcStandardRequest,
      ProcStandardRequest,
      ProcLBXFreeColors,
      ProcStandardRequest,
!     ProcStandardRequest,	/* 90 */
      ProcStandardRequest,
      ProcLBXLookupColor,
      ProcStandardRequest,
      ProcStandardRequest,
!     ProcStandardRequest,	/* 95 */
      ProcStandardRequest,
      ProcStandardRequest,
+     ProcLBXQueryExtension,
      ProcStandardRequest,
!     ProcStandardRequest,	/* 100 */
      ProcLBXGetKeyboardMapping,
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
!     ProcStandardRequest,	/* 105 */
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
!     ProcStandardRequest,	/* 110 */
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
!     ProcStandardRequest,	/* 115 */
      ProcStandardRequest,
      ProcStandardRequest,
      ProcStandardRequest,
      ProcLBXGetModifierMapping,
!     0,				/* 120 */
      0,
      0,
      0,
      0,
!     0,				/* 125 */
      0,
      ProcStandardRequest,
      ProcStandardRequest,
***************
*** 429,746 ****
      ProcStandardRequest,
  };
  
- int (* SwappedProcVector[256]) () =
- {
-     ProcStandardRequest,
-     SProcCreateWindow,
-     SProcChangeWindowAttributes,
-     SProcResourceReq,			/* GetWindowAttributes */
-     SProcResourceReq,			/* DestroyWindow */
-     SProcResourceReq,			/* 5 DestroySubwindows */
-     SProcResourceReq,			/* SProcChangeSaveSet, */
-     SProcReparentWindow,
-     SProcResourceReq,			/* MapWindow */
-     SProcResourceReq,			/* MapSubwindows */
-     SProcResourceReq,			/* 10 UnmapWindow */
-     SProcResourceReq,			/* UnmapSubwindows */
-     SProcConfigureWindow,
-     SProcResourceReq,			/* SProcCirculateWindow, */
-     SProcResourceReq,			/* GetGeometry */
-     SProcResourceReq,			/* 15 QueryTree */
-     SProcInternAtom,
-     SProcResourceReq,			/* SProcGetAtomName, */
-     SProcChangeProperty,
-     SProcDeleteProperty,
-     SProcGetProperty,			/* 20 */
-     SProcResourceReq,			/* SProcListProperties, */
-     SProcSetSelectionOwner,
-     SProcResourceReq, 			/* SProcGetSelectionOwner, */
-     SProcConvertSelection,
-     SProcSendEvent,			/* 25 */
-     SProcGrabPointer,
-     SProcResourceReq, 			/* SProcUngrabPointer, */
-     SProcGrabButton,
-     SProcUngrabButton,
-     SProcChangeActivePointerGrab,	/* 30 */
-     SProcGrabKeyboard,
-     SProcResourceReq,			/* SProcUngrabKeyboard, */
-     SProcGrabKey,
-     SProcUngrabKey,
-     SProcResourceReq,			/* 35 SProcAllowEvents, */
-     SProcSimpleReq,			/* SProcGrabServer, */
-     SProcSimpleReq,			/* SProcUngrabServer, */
-     SProcResourceReq,			/* SProcQueryPointer, */
-     SProcGetMotionEvents,
-     SProcTranslateCoords,		/*40 */
-     SProcWarpPointer,
-     SProcSetInputFocus,
-     SProcSimpleReq,			/* SProcGetInputFocus, */
-     SProcSimpleReq,			/* QueryKeymap, */
-     SProcOpenFont,			/* 45 */
-     SProcResourceReq,			/* SProcCloseFont, */
-     SProcResourceReq, 			/* SProcQueryFont, */
-     SProcResourceReq,			/* SProcQueryTextExtents,  */
-     SProcListFonts,
-     SProcListFontsWithInfo,		/* 50 */
-     SProcSetFontPath,
-     SProcSimpleReq,			/* GetFontPath, */
-     SProcCreatePixmap,
-     SProcResourceReq,			/* SProcFreePixmap, */
-     SProcCreateGC,			/* 55 */
-     SProcChangeGC,
-     SProcCopyGC,
-     SProcSetDashes,
-     SProcSetClipRectangles,
-     SProcResourceReq,			/* 60 SProcFreeGC, */
-     SProcClearToBackground,
-     SProcCopyArea,
-     SProcCopyPlane,
-     SProcPoly,				/* PolyPoint, */
-     SProcPoly,				/* 65 PolyLine */
-     SProcPoly,				/* PolySegment, */
-     SProcPoly,				/* PolyRectangle, */
-     SProcPoly,				/* PolyArc, */
-     SProcFillPoly,
-     SProcPoly,				/* 70 PolyFillRectangle */
-     SProcPoly,				/* PolyFillArc, */
-     SProcPutImage,
-     SProcGetImage,
-     SProcPolyText,
-     SProcPolyText,			/* 75 */
-     SProcImageText,
-     SProcImageText,
-     SProcCreateColormap,
-     SProcResourceReq,			/* SProcFreeColormap, */
-     SProcCopyColormapAndFree,		/* 80 */
-     SProcResourceReq,			/* SProcInstallColormap, */
-     SProcResourceReq,			/* SProcUninstallColormap, */
-     SProcResourceReq, 			/* SProcListInstalledColormaps, */
-     SProcAllocColor,
-     SProcAllocNamedColor,		/* 85 */
-     SProcAllocColorCells,
-     SProcAllocColorPlanes,
-     SProcFreeColors,
-     SProcStoreColors,
-     SProcStoreNamedColor,		/* 90 */
-     SProcQueryColors,
-     SProcLookupColor,
-     SProcCreateCursor,
-     SProcCreateGlyphCursor,
-     SProcResourceReq,			/* 95 SProcFreeCursor, */
-     SProcRecolorCursor,
-     SProcQueryBestSize,
-     SProcQueryExtension,
-     SProcSimpleReq,			/* ListExtensions, */
-     SProcChangeKeyboardMapping,		/* 100 */
-     SProcSimpleReq,			/* GetKeyboardMapping, */
-     SProcChangeKeyboardControl,
-     SProcSimpleReq,			/* GetKeyboardControl, */
-     SProcSimpleReq,			/* Bell, */
-     SProcChangePointerControl,		/* 105 */
-     SProcSimpleReq,			/* GetPointerControl, */
-     SProcSetScreenSaver,
-     SProcSimpleReq,			/* GetScreenSaver, */
-     SProcChangeHosts,
-     SProcSimpleReq,			/* 110 ListHosts, */
-     SProcSimpleReq,			/* SProcChangeAccessControl, */
-     SProcSimpleReq,			/* SProcChangeCloseDownMode, */
-     SProcResourceReq,			/* SProcKillClient, */
-     SProcRotateProperties,
-     SProcSimpleReq,			/* 115 ForceScreenSaver */
-     SProcSimpleReq,			/* SetPointerMapping, */
-     SProcSimpleReq,			/* GetPointerMapping, */
-     SProcSimpleReq,			/* SetModifierMapping, */
-     SProcSimpleReq,			/* GetModifierMapping, */
-     0,					/* 120 */
-     0,
-     0,
-     0,
-     0,
-     0,					/* 125 */
-     0,
-     SProcNoOperation
- };
- 
- #ifdef notyet
- void (* EventSwapVector[128]) () =
- {
-     SErrorEvent,
-     NotImplemented,
-     SKeyButtonPtrEvent,
-     SKeyButtonPtrEvent,
-     SKeyButtonPtrEvent,
-     SKeyButtonPtrEvent,			/* 5 */
-     SKeyButtonPtrEvent,
-     SEnterLeaveEvent,
-     SEnterLeaveEvent,
-     SFocusEvent,
-     SFocusEvent,			/* 10 */
-     SKeymapNotifyEvent,
-     SExposeEvent,
-     SGraphicsExposureEvent,
-     SNoExposureEvent,
-     SVisibilityEvent,			/* 15 */
-     SCreateNotifyEvent,
-     SDestroyNotifyEvent,
-     SUnmapNotifyEvent,
-     SMapNotifyEvent,
-     SMapRequestEvent,			/* 20 */
-     SReparentEvent,
-     SConfigureNotifyEvent,
-     SConfigureRequestEvent,
-     SGravityEvent,
-     SResizeRequestEvent,		/* 25 */
-     SCirculateEvent,
-     SCirculateEvent,
-     SPropertyEvent,
-     SSelectionClearEvent,
-     SSelectionRequestEvent,		/* 30 */
-     SSelectionNotifyEvent,
-     SColormapEvent,
-     SClientMessageEvent,
-     SMappingEvent,
- };
- 
- void (* ReplySwapVector[256]) () =
- {
-     NotImplemented,
-     NotImplemented,
-     NotImplemented,
-     SGetWindowAttributesReply,
-     NotImplemented,
-     NotImplemented,			/* 5 */
-     NotImplemented,
-     NotImplemented,
-     NotImplemented,
-     NotImplemented,
-     NotImplemented,			/* 10 */
-     NotImplemented,
-     NotImplemented,
-     NotImplemented,
-     SGetGeometryReply,
-     SQueryTreeReply,			/* 15 */
-     SInternAtomReply,
-     SGetAtomNameReply,
-     NotImplemented,
-     NotImplemented,
-     SGetPropertyReply,			/* 20 */
-     SListPropertiesReply,
-     NotImplemented,
-     SGetSelectionOwnerReply,
-     NotImplemented,
-     NotImplemented,			/* 25 */
-     SGenericReply,			/* SGrabPointerReply, */
-     NotImplemented,
-     NotImplemented,
-     NotImplemented,
-     NotImplemented,			/* 30 */
-     SGenericReply,			/* SGrabKeyboardReply, */
-     NotImplemented,
-     NotImplemented,
-     NotImplemented,
-     NotImplemented,			/* 35 */
-     NotImplemented,
-     NotImplemented,
-     SQueryPointerReply,
-     SGetMotionEventsReply,
-     STranslateCoordsReply,		/* 40 */
-     NotImplemented,
-     NotImplemented,
-     SGetInputFocusReply,
-     SQueryKeymapReply,
-     NotImplemented,			/* 45 */
-     NotImplemented,
-     SQueryFontReply,
-     SQueryTextExtentsReply,
-     SListFontsReply,
-     SListFontsWithInfoReply,		/* 50 */
-     NotImplemented,
-     SGetFontPathReply,
-     NotImplemented,
-     NotImplemented,
-     NotImplemented,			/* 55 */
-     NotImplemented,
-     NotImplemented,
-     NotImplemented,
-     NotImplemented,
-     NotImplemented,			/* 60 */
-     NotImplemented,
-     NotImplemented,
-     NotImplemented,
-     NotImplemented,
-     NotImplemented,			/* 65 */
-     NotImplemented,
-     NotImplemented,
-     NotImplemented,
-     NotImplemented,
-     NotImplemented,			/* 70 */
-     NotImplemented,
-     NotImplemented,
-     SGetImageReply,
-     NotImplemented,
-     NotImplemented,			/* 75 */
-     NotImplemented,
-     NotImplemented,
-     NotImplemented,
-     NotImplemented,
-     NotImplemented,			/* 80 */
-     NotImplemented,
-     NotImplemented,
-     SListInstalledColormapsReply,
-     SAllocColorReply,
-     SAllocNamedColorReply,		/* 85 */
-     SAllocColorCellsReply,
-     SAllocColorPlanesReply,
-     NotImplemented,
-     NotImplemented,
-     NotImplemented,			/* 90 */
-     SQueryColorsReply,
-     SLookupColorReply,
-     NotImplemented,
-     NotImplemented,
-     NotImplemented,			/* 95 */
-     NotImplemented,
-     SQueryBestSizeReply,
-     SGenericReply,			/* SQueryExtensionReply, */
-     SListExtensionsReply,
-     NotImplemented,			/* 100 */
-     SGetKeyboardMappingReply,
-     NotImplemented,
-     SGetKeyboardControlReply,
-     NotImplemented,
-     NotImplemented,			/* 105 */
-     SGetPointerControlReply,
-     NotImplemented,
-     SGetScreenSaverReply,
-     NotImplemented,
-     SListHostsReply,			/* 110 */
-     NotImplemented,
-     NotImplemented,
-     NotImplemented,
-     NotImplemented,
-     NotImplemented,			/* 115 */
-     SGenericReply,			/* SetPointerMapping */
-     SGetPointerMappingReply,
-     SGenericReply,			/* SetModifierMapping */
-     SGetModifierMappingReply,		/* 119 */
-     NotImplemented,			/* 120 */
-     NotImplemented,			/* 121 */
-     NotImplemented,			/* 122 */
-     NotImplemented,			/* 123 */
-     NotImplemented,			/* 124 */
-     NotImplemented,			/* 125 */
-     NotImplemented,			/* 126 */
-     NotImplemented,			/* NoOperation */
-     NotImplemented
- };
- 
- #endif
  
  
! extern int  ServerProcError (), ServerProcReply (),
! 	    ServerProcStandardEvent ();
! 	    
! int (*ServerVector[256])() = {
      ServerProcStandardEvent,
      ServerProcStandardEvent,
      ServerProcStandardEvent,
--- 328,338 ----
      ProcStandardRequest,
  };
  
  
+ extern int  ServerProcError(), ServerProcReply(),
+             ServerProcStandardEvent();
  
! int         (*ServerVector[256]) () = {
      ServerProcStandardEvent,
      ServerProcStandardEvent,
      ServerProcStandardEvent,
*** -	Wed Jan 18 13:07:12 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/utils.c	Wed Jan 18 13:07:12 1995
***************
*** 45,52 ****
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: utils.c,v 1.8 94/04/17 21:17:22 gildea Exp $ */
! /* $NCDId: @(#)utils.c,v 1.7 1994/03/11 20:02:07 lemke Exp $ */
  
  #include "Xos.h"
  #include <stdio.h>
--- 45,52 ----
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: utils.c,v 1.9 94/12/01 20:42:36 mor Exp $ */
! /* $NCDId: @(#)utils.c,v 1.8 1994/11/16 02:27:25 lemke Exp $ */
  
  #include "Xos.h"
  #include <stdio.h>
***************
*** 214,225 ****
  void UseMsg()
  {
  #if !defined(AIXrt) && !defined(AIX386)
!     ErrorF("use: X [:<display>] [option]\n");
      ErrorF("-ac                    disable access control restrictions\n");
  #ifdef MEMBUG
      ErrorF("-alloc int             chance alloc should fail\n");
  #endif
      ErrorF("-auth string           select authorization file\n");	
      ErrorF("-help                  prints message with these options\n");
      ErrorF("-I                     ignore all remaining arguments\n");
      ErrorF("-to #                  connection time out\n");
--- 214,227 ----
  void UseMsg()
  {
  #if !defined(AIXrt) && !defined(AIX386)
!     ErrorF("use: lbxproxy [:<display>] [option]\n");
      ErrorF("-ac                    disable access control restrictions\n");
  #ifdef MEMBUG
      ErrorF("-alloc int             chance alloc should fail\n");
  #endif
+ /*
      ErrorF("-auth string           select authorization file\n");	
+ */
      ErrorF("-help                  prints message with these options\n");
      ErrorF("-I                     ignore all remaining arguments\n");
      ErrorF("-to #                  connection time out\n");
***************
*** 500,506 ****
  #if NeedVarargsPrototypes
      va_list args;
  #endif
!     ErrorF("\nFatal server error:\n");
  #if NeedVarargsPrototypes
      va_start(args, f);
      VErrorF(f, args);
--- 502,508 ----
  #if NeedVarargsPrototypes
      va_list args;
  #endif
!     ErrorF("\nFatal proxy error:\n");
  #if NeedVarargsPrototypes
      va_start(args, f);
      VErrorF(f, args);
*** -	Wed Jan 18 13:07:15 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/wire.c	Wed Jan 18 13:07:14 1995
***************
*** 1,7 ****
! /* $XConsortium: wire.c,v 1.7 94/03/27 14:01:53 dpw Exp $ */
  /*
!  * $NCDOr: wire.c,v 1.2 1993/11/19 21:29:10 keithp Exp keithp $
!  * $NCDId: @(#)wire.c,v 1.36 1994/03/24 17:54:36 lemke Exp $
   *
   * Copyright 1992 Network Computing Devices
   *
--- 1,7 ----
! /* $XConsortium: wire.c,v 1.9 94/12/01 20:51:38 mor Exp $ */
  /*
!  * $NCDOr: wire.c,v 1.1 1994/10/18 17:43:32 keithp Exp keithp $
!  * $NCDId: @(#)wire.c,v 1.44 1994/11/18 20:39:50 lemke Exp $
   *
   * Copyright 1992 Network Computing Devices
   *
***************
*** 37,43 ****
--- 37,45 ----
  #define _XLBX_SERVER_
  #include "lbxstr.h"
  #include "lbxdata.h"
+ #include "proxyopts.h"
  #include "swap.h"
+ #include "assert.h"
  
  extern int  NewOutputPending;
  
***************
*** 48,53 ****
--- 50,56 ----
  extern int  delta_in_total;
  extern int  delta_in_attempts;
  extern int  delta_in_hits;
+ 
  #endif
  
  #ifndef NDEBUG
***************
*** 55,64 ****
  
  #endif
  
- int         lbxDeltaN = 16;
- int         lbxDeltaMaxLen = 64;
- int         lbxLZW = 14;
- 
  #define MAXBYTESDIFF		8
  
  static unsigned char tempdeltabuf[256];
--- 58,63 ----
***************
*** 81,96 ****
--- 80,100 ----
  #ifdef LBX_STATS
      delta_out_total++;
  #endif
+ 
      if (DELTA_CACHEABLE(&server->outdeltas, len)) {
+ 
  #ifdef LBX_STATS
  	delta_out_attempts++;
  #endif
+ 
  	if ((diffs = LBXDeltaMinDiffs(&server->outdeltas, buf, len,
  			     min(MAXBYTESDIFF, (len - sz_xLbxDeltaReq) >> 1),
  				      &cindex)) >= 0) {
+ 
  #ifdef LBX_STATS
  	    delta_out_hits++;
  #endif
+ 
  	    LBXEncodeDelta(&server->outdeltas, buf, diffs, cindex,
  			   &tempdeltabuf[sz_xLbxDeltaReq]);
  	    p->reqType = server->lbxReq;
***************
*** 98,104 ****
  	    p->diffs = diffs;
  	    p->cindex = cindex;
  	    newlen = sz_xLbxDeltaReq + sz_xLbxDiffItem * diffs;
! 	    p->length = (newlen + 3) >> 2;	/* BYTESWAP!! */
  	    WriteToServer(client, newlen, (char *) p);
  	    written = TRUE;
  	}
--- 102,109 ----
  	    p->diffs = diffs;
  	    p->cindex = cindex;
  	    newlen = sz_xLbxDeltaReq + sz_xLbxDiffItem * diffs;
! 	    p->length = (newlen + 3) >> 2;
! 	    /* Don't byte swap -- lengths are always in proxy order */
  	    WriteToServer(client, newlen, (char *) p);
  	    written = TRUE;
  	}
***************
*** 108,115 ****
  	WriteToServer(client, len, buf);
  }
  
! WriteToServer(client, len, buf)
      ClientPtr   client;
      int         len;
      char       *buf;
  {
--- 113,121 ----
  	WriteToServer(client, len, buf);
  }
  
! _write_to_server(client, compressed, len, buf)
      ClientPtr   client;
+     Bool        compressed;
      int         len;
      char       *buf;
  {
***************
*** 129,135 ****
  	server->send = client;
      }
      DBG(DBG_IO, (stderr, "downstream %d len %d\n", client->index, len));
!     WriteToClient(server->serverClient, len, buf);
  }
  
  /* all these requests may need to be swapped back to the order of
--- 135,160 ----
  	server->send = client;
      }
      DBG(DBG_IO, (stderr, "downstream %d len %d\n", client->index, len));
!     if (compressed)
! 	WriteToClient(server->serverClient, len, buf);
!     else
! 	UncompressWriteToClient(server->serverClient, len, buf);
! }
! 
! WriteToServer(client, len, buf)
!     ClientPtr   client;
!     int         len;
!     char       *buf;
! {
!     _write_to_server(client, TRUE, len, buf);
! }
! 
! WriteToServerUncompressed(client, len, buf)
!     ClientPtr   client;
!     int         len;
!     char       *buf;
! {
!     _write_to_server(client, FALSE, len, buf);
  }
  
  /* all these requests may need to be swapped back to the order of
***************
*** 149,155 ****
      n.length = 2 + (setuplen >> 2);
      n.client = client->index;
      if (clients[0]->swapped) {
!     	SwapNewClient(&n);
      }
      WriteToServer(clients[0], sizeof(n), (char *) &n);
      ++server->serverClient->sequence;
--- 174,180 ----
      n.length = 2 + (setuplen >> 2);
      n.client = client->index;
      if (clients[0]->swapped) {
! 	SwapNewClient(&n);
      }
      WriteToServer(clients[0], sizeof(n), (char *) &n);
      ++server->serverClient->sequence;
***************
*** 177,183 ****
  	if (client->swapped) {
  	    SwapCloseClient(&n);
  	}
! 	WriteToServer(client, sizeof(n), (char *) &n);
      }
  }
  
--- 202,208 ----
  	if (client->swapped) {
  	    SwapCloseClient(&n);
  	}
! 	WriteReqToServer(client, sizeof(n), (char *) &n);
      }
  }
  
***************
*** 195,203 ****
      req.length = 2;
      req.adjust = num;
      if (client->swapped) {
!     	SwapModifySequence(&req);
      }
!     WriteToServer(client, sizeof(req), (char *) &req);
  }
  
  AllowMotion(client, num)
--- 220,228 ----
      req.length = 2;
      req.adjust = num;
      if (client->swapped) {
! 	SwapModifySequence(&req);
      }
!     WriteReqToServer(client, sizeof(req), (char *) &req);
  }
  
  AllowMotion(client, num)
***************
*** 224,232 ****
      req.pixel = pixel;
      req.amount = 1;
      if (client->swapped) {
!     	SwapIncrementPixel(&req);
      }
!     WriteToServer(client, sizeof(req), (char *) &req);
  }
  
  SendGetModifierMapping(client)
--- 249,257 ----
      req.pixel = pixel;
      req.amount = 1;
      if (client->swapped) {
! 	SwapIncrementPixel(&req);
      }
!     WriteReqToServer(client, sizeof(req), (char *) &req);
  }
  
  SendGetModifierMapping(client)
***************
*** 242,250 ****
      req.lbxReqType = X_LbxGetModifierMapping;
      req.length = 1;
      if (client->swapped) {
!     	SwapGetModifierMapping(&req);
      }
!     WriteToServer(client, sizeof(req), (char *) &req);
  }
  
  SendGetKeyboardMapping(client)
--- 267,275 ----
      req.lbxReqType = X_LbxGetModifierMapping;
      req.length = 1;
      if (client->swapped) {
! 	SwapGetModifierMapping(&req);
      }
!     WriteReqToServer(client, sizeof(req), (char *) &req);
  }
  
  SendGetKeyboardMapping(client)
***************
*** 266,274 ****
      req.firstKeyCode = LBXMinKeyCode(client);
      req.count = LBXMaxKeyCode(client) - LBXMinKeyCode(client) + 1;
      if (client->swapped) {
!     	SwapGetKeyboardMapping(&req);
      }
!     WriteToServer(client, sizeof(req), (char *) &req);
  }
  
  SendQueryFont(client, fid)
--- 291,299 ----
      req.firstKeyCode = LBXMinKeyCode(client);
      req.count = LBXMaxKeyCode(client) - LBXMinKeyCode(client) + 1;
      if (client->swapped) {
! 	SwapGetKeyboardMapping(&req);
      }
!     WriteReqToServer(client, sizeof(req), (char *) &req);
  }
  
  SendQueryFont(client, fid)
***************
*** 286,294 ****
      req.length = 2;
      req.fid = fid;
      if (client->swapped) {
!     	SwapQueryFont(&req);
      }
!     WriteToServer(client, sizeof(req), (char *) &req);
  }
  
  SendChangeProperty(client, win, prop, type, format, mode, num)
--- 311,319 ----
      req.length = 2;
      req.fid = fid;
      if (client->swapped) {
! 	SwapQueryFont(&req);
      }
!     WriteReqToServer(client, sizeof(req), (char *) &req);
  }
  
  SendChangeProperty(client, win, prop, type, format, mode, num)
***************
*** 316,325 ****
      req.mode = mode;
      req.nUnits = num;
      if (client->swapped) {
!     	SwapChangeProperty(&req);
      }
! 
!     WriteToServer(client, sizeof(req), (char *) &req);
  }
  
  SendGetProperty(client, win, prop, type, delete, off, len)
--- 341,349 ----
      req.mode = mode;
      req.nUnits = num;
      if (client->swapped) {
! 	SwapChangeProperty(&req);
      }
!     WriteReqToServer(client, sizeof(req), (char *) &req);
  }
  
  SendGetProperty(client, win, prop, type, delete, off, len)
***************
*** 347,356 ****
      req.longOffset = off;
      req.longLength = len;
      if (client->swapped) {
!     	SwapGetProperty(&req);
      }
! 
!     WriteToServer(client, sizeof(req), (char *) &req);
  }
  
  SendQueryTag(client, tag)
--- 371,379 ----
      req.longOffset = off;
      req.longLength = len;
      if (client->swapped) {
! 	SwapGetProperty(&req);
      }
!     WriteReqToServer(client, sizeof(req), (char *) &req);
  }
  
  SendQueryTag(client, tag)
***************
*** 365,373 ****
      req.length = 2;
      req.tag = tag;
      if (client->swapped) {
!         SwapQueryTag(&req);
      }
!     WriteToServer(client, sizeof(req), (char *) &req);
  }
  
  SendInvalidateTag(client, tag)
--- 388,396 ----
      req.length = 2;
      req.tag = tag;
      if (client->swapped) {
! 	SwapQueryTag(&req);
      }
!     WriteReqToServer(client, sizeof(req), (char *) &req);
  }
  
  SendInvalidateTag(client, tag)
***************
*** 380,386 ****
      if (!servers[0])		/* proxy resetting */
  	return;
      if (!client)
! 	client = clients[0];		/* XXX watch multi-proxy */
      server = client->server;
  
      req.reqType = server->lbxReq;
--- 403,409 ----
      if (!servers[0])		/* proxy resetting */
  	return;
      if (!client)
! 	client = clients[0];	/* XXX watch multi-proxy */
      server = client->server;
  
      req.reqType = server->lbxReq;
***************
*** 389,397 ****
      req.tag = tag;
      /* need tag type ? */
      if (client->swapped) {
!         SwapInvalidateTag(&req);
      }
!     WriteToServer(client, sizeof(req), (char *) &req);
  }
  
  SendTagData(client, tag, len, data)
--- 412,420 ----
      req.tag = tag;
      /* need tag type ? */
      if (client->swapped) {
! 	SwapInvalidateTag(&req);
      }
!     WriteReqToServer(client, sizeof(req), (char *) &req);
  }
  
  SendTagData(client, tag, len, data)
***************
*** 400,425 ****
      unsigned long len;
      pointer     data;
  {
!     xLbxTagDataReq req;
      XServerPtr  server;
  
!     client = clients[0];	    /* XXX watch multi proxy */
      server = client->server;
  
!     req.reqType = server->lbxReq;
!     req.lbxReqType = X_LbxTagData;
!     req.length = 3 + ((len + 3) >> 2);
!     req.real_length = len;
!     req.tag = tag;
      /* need tag type ? */
      if (client->swapped) {
!     	SwapTagData(&req);
      }
      WriteToServer(client, sizeof(req), (char *) &req);
-     if (len)
- 	WriteToServer(client, len, (char *) data);
  }
  
  static unsigned long pendingServerReplySequence;
  static void (*serverReplyFunc) ();
  
--- 423,497 ----
      unsigned long len;
      pointer     data;
  {
!     xLbxTagDataReq req,
!                *reqp;
!     int         req_len;
      XServerPtr  server;
  
!     client = clients[0];	/* XXX watch multi proxy */
      server = client->server;
  
!     req_len = 3 + ((len + 3) >> 2);
!     if (DELTA_CACHEABLE(&server->outdeltas, req_len << 2)) {
! 	reqp = (xLbxTagDataReq *) xalloc(req_len << 2);
! 	bcopy(data, (pointer) (reqp + 1), len);
!     } else {
! 	reqp = &req;
!     }
!     reqp->reqType = server->lbxReq;
!     reqp->lbxReqType = X_LbxTagData;
!     reqp->length = req_len;
!     reqp->real_length = len;
!     reqp->tag = tag;
      /* need tag type ? */
      if (client->swapped) {
! 	SwapTagData(reqp);
!     }
!     if (reqp == &req) {
! 	WriteToServer(client, sizeof(req), (char *) &req);
! 	if (len)
! 	    WriteToServer(client, len, (char *) data);
!     } else {
! 	WriteReqToServer(client, req_len << 2, (char *) reqp);
! 	xfree(reqp);
!     }
! }
! 
! 
! SendGetImage(client, drawable, x, y, width, height, planeMask, format)
!     ClientPtr   client;
!     Drawable    drawable;
!     int         x;
!     int         y;
!     unsigned int width;
!     unsigned int height;
!     unsigned long planeMask;
!     int         format;
! {
!     xLbxGetImageReq req;
!     XServerPtr  server = client->server;
! 
!     if (client->server->serverClient == client)
! 	return;
! 
!     req.reqType = server->lbxReq;
!     req.lbxReqType = X_LbxGetImage;
!     req.length = 6;
!     req.drawable = drawable;
!     req.x = x;
!     req.y = y;
!     req.width = width;
!     req.height = height;
!     req.planeMask = planeMask;
!     req.format = format;
! 
!     if (client->swapped) {
! 	SwapGetImage(&req);
      }
      WriteToServer(client, sizeof(req), (char *) &req);
  }
  
+ 
  static unsigned long pendingServerReplySequence;
  static void (*serverReplyFunc) ();
  
***************
*** 482,489 ****
      }
      *partp = FALSE;
      rep = (xReply *) req;
!     if (rep->generic.type != X_Reply)
! 	return 32;
      return (8 + rep->generic.length) << 2;
  }
  
--- 554,562 ----
      }
      *partp = FALSE;
      rep = (xReply *) req;
!     if (rep->generic.type != X_Reply) {
! 	return EventLength(rep);
!     }
      return (8 + rep->generic.length) << 2;
  }
  
***************
*** 510,515 ****
--- 583,589 ----
  #ifdef LBX_STATS
      delta_in_total++;
  #endif
+ 
      if (rep->generic.type == server->lbxEvent &&
  	    rep->generic.data1 == LbxDeltaEvent) {
  	xLbxDeltaReq *delta = (xLbxDeltaReq *) rep;
***************
*** 518,523 ****
--- 592,598 ----
  	delta_in_attempts++;
  	delta_in_hits++;
  #endif
+ 
  	/* Note that LBXDecodeDelta decodes and adds current msg to the cache */
  	len = LBXDecodeDelta(&server->indeltas, ((char *) rep) + sz_xLbxDeltaReq,
  			     delta->diffs, delta->cindex, &rep);
***************
*** 531,545 ****
  	       rep->generic.data1 == LbxSwitchEvent) {
  	cacheable = FALSE;
      }
- 
      /* stick in delta buffer before LBX code modified things */
      if (cacheable && DELTA_CACHEABLE(&server->indeltas, len)) {
  #ifdef LBX_STATS
  	delta_in_attempts++;
  #endif
  	LBXAddDeltaIn(&server->indeltas, (char *) rep, len);
      }
- 
      if (rep->generic.type != server->lbxEvent) {
  	if (!client->awaitingSetup && rep->generic.type == X_Reply) {
  	    /*
--- 606,620 ----
  	       rep->generic.data1 == LbxSwitchEvent) {
  	cacheable = FALSE;
      }
      /* stick in delta buffer before LBX code modified things */
      if (cacheable && DELTA_CACHEABLE(&server->indeltas, len)) {
+ 
  #ifdef LBX_STATS
  	delta_in_attempts++;
  #endif
+ 
  	LBXAddDeltaIn(&server->indeltas, (char *) rep, len);
      }
      if (rep->generic.type != server->lbxEvent) {
  	if (!client->awaitingSetup && rep->generic.type == X_Reply) {
  	    /*
***************
*** 559,566 ****
  	    ServerReply(server, rep);
  	} else {
  	    if (!client->clientGone) {
! 		if (DoLBXReply(client, (char *) rep, len))
! 		    WriteToClient(client, len, rep);
  	    }
  	    client->awaitingSetup = FALSE;
  	}
--- 634,652 ----
  	    ServerReply(server, rep);
  	} else {
  	    if (!client->clientGone) {
! 		xEvent      ev;
! 		char       *rp;
! 
! 		if (!client->awaitingSetup &&
! 			UnsquishEvent(rep, &ev, &len)) {
! 		    rp = (char *) &ev;
! 		} else {
! 		    rp = (char *) rep;
! 		}
! 		if (DoLBXReply(client, (char *) rp, len))
! 		    WriteToClient(client, len, rp);
! 		/* flush out any delayed replies that follow this one */
! 		FlushDelayedReply(client, rep->generic.sequenceNumber + 1);
  	    }
  	    client->awaitingSetup = FALSE;
  	}
***************
*** 606,614 ****
      return Success;
  }
  
! extern int GrabInProgress;
! static int lbxIgnoringAll;
! static int lbxGrabInProgress;
  
  int
  LbxIgnoreAllClients(server)
--- 692,700 ----
      return Success;
  }
  
! extern int  GrabInProgress;
! static int  lbxIgnoringAll;
! static int  lbxGrabInProgress;
  
  int
  LbxIgnoreAllClients(server)
***************
*** 648,654 ****
      else {
  	if (GrabInProgress)
  	    ListenToAllClients();
! 	OnlyListenToOneClient (client);
      }
  }
  
--- 734,740 ----
      else {
  	if (GrabInProgress)
  	    ListenToAllClients();
! 	OnlyListenToOneClient(client);
      }
  }
  
***************
*** 689,695 ****
      if (NewOutputPending)
  	FlushAllOutput();
  
!     if (server->lzwHandle) {
  	if (LzwInputAvail(server->fd))
  	    AvailableClientInput(server->serverClient);
  	if (LzwFlush(server->fd) != 0)
--- 775,781 ----
      if (NewOutputPending)
  	FlushAllOutput();
  
!     if (server->compHandle) {
  	if (LzwInputAvail(server->fd))
  	    AvailableClientInput(server->serverClient);
  	if (LzwFlush(server->fd) != 0)
***************
*** 718,725 ****
      servers[server->index] = 0;
      LBXFreeDeltaCache(&server->indeltas);
      LBXFreeDeltaCache(&server->outdeltas);
!     if (server->lzwHandle) {
! 	LzwFree(server->lzwHandle);
      }
      /* remove all back pointers */
      for (i = 1; i < MAXCLIENTS; i++) {
--- 804,811 ----
      servers[server->index] = 0;
      LBXFreeDeltaCache(&server->indeltas);
      LBXFreeDeltaCache(&server->outdeltas);
!     if (server->compHandle) {
! 	LzwFree(server->compHandle);
      }
      /* remove all back pointers */
      for (i = 1; i < MAXCLIENTS; i++) {
***************
*** 742,757 ****
      XServerPtr  server;
      xLbxStartReply *rep;
  {
!     LBXInitDeltaCache(&server->indeltas, rep->deltaN, rep->deltaMaxLen);
!     LBXInitDeltaCache(&server->outdeltas, rep->deltaN, rep->deltaMaxLen);
      QueueWorkProc(ProxyWorkProc, NULL, (pointer) server->index);
!     if (rep->comptype == LbxCompressLZW) {
  	char       *extra = (char *) rep;
- 	int         maxbits = *(CARD32 *) (extra + sizeof(xReply));
  	int         len = sizeof(xReply) + (rep->length << 2);
  	int         left = BytesInClientBuffer(server->serverClient);
  
! 	server->lzwHandle = (void *) LzwInit(server->fd, maxbits);
  	SwitchConnectionFuncs(server->serverClient,
  			      LzwRead, LzwWriteV, CloseServer);
  	extra += len;
--- 828,877 ----
      XServerPtr  server;
      xLbxStartReply *rep;
  {
!     int         replylen;
!     int         nopts = rep->nOpts;
! 
!     replylen = (rep->length << 2) + sz_xLbxStartReply - sz_xLbxStartReplyHdr;
!     if (rep->nOpts == 0xff) {
! 	fprintf(stderr, "WARNING: option negotiation failed - using defaults\n");
! 	LbxOptInit();
!     } else if (LbxOptParseReply(rep->nOpts, &rep->optDataStart, replylen) < 0) {
! 	FatalError("Bad options from server");
!     }
! 
! #ifdef OPTDEBUG
!     fprintf(stderr, "server: N = %d, maxlen = %d, proxy: N = %d, maxlen = %d\n",
! 	    lbxNegOpt.serverDeltaN, lbxNegOpt.serverDeltaMaxLen,
! 	    lbxNegOpt.proxyDeltaN, lbxNegOpt.proxyDeltaMaxLen);
! #endif
! 
!     LBXInitDeltaCache(&server->indeltas, lbxNegOpt.serverDeltaN,
! 		      lbxNegOpt.serverDeltaMaxLen);
!     LBXInitDeltaCache(&server->outdeltas, lbxNegOpt.proxyDeltaN,
! 		      lbxNegOpt.proxyDeltaMaxLen);
      QueueWorkProc(ProxyWorkProc, NULL, (pointer) server->index);
! 
! #ifdef OPTDEBUG
!     fprintf(stderr, "squishing = %d\n", lbxNegOpt.squish);
! #endif
! 
!     /*
!      * TBD - this needs to be cleaned up so that we don't reference LZW
!      * functions directly since we want to be capable of using any stream
!      * compressor.
!      */
!     if (lbxNegOpt.streamCompInit) {
  	char       *extra = (char *) rep;
  	int         len = sizeof(xReply) + (rep->length << 2);
  	int         left = BytesInClientBuffer(server->serverClient);
  
! #ifdef OPTDEBUG
! 	fprintf(stderr, "Starting up LZW: codesize = %d\n",
! 		(int) lbxNegOpt.streamCompArg);
! #endif
! 
! 	server->compHandle =
! 	    (*lbxNegOpt.streamCompInit) (server->fd, lbxNegOpt.streamCompArg);
  	SwitchConnectionFuncs(server->serverClient,
  			      LzwRead, LzwWriteV, CloseServer);
  	extra += len;
***************
*** 761,788 ****
  			       LzwCompressOn, LzwCompressOff);
      }
      server->initialized = TRUE;
!     MakeClientGrabImpervious (server->serverClient);
  }
  
  StartProxy(server)
      XServerPtr  server;
  {
!     char        buf[sz_xLbxStartProxyReq + 4];
      xLbxStartProxyReq *n = (xLbxStartProxyReq *) buf;
      extern Bool NewOutputPending;
  
      n->reqType = server->lbxReq;
      n->lbxReqType = X_LbxStartProxy;
!     n->deltaN = lbxDeltaN;
!     n->deltaMaxLen = lbxDeltaMaxLen;
!     if (lbxLZW) {
! 	n->comptype = LbxCompressLZW;
! 	*(CARD32 *) (n + 1) = lbxLZW;
! 	n->length = (sz_xLbxStartProxyReq + 4) >> 2;
!     } else {
! 	n->comptype = LbxCompressNone;
! 	n->length = sz_xLbxStartProxyReq >> 2;
!     }
      WriteToServer(clients[0], n->length << 2, (char *) n);
      server->serverClient->sequence++;
      ExpectServerReply(server, StartProxyReply);
--- 881,903 ----
  			       LzwCompressOn, LzwCompressOff);
      }
      server->initialized = TRUE;
!     MakeClientGrabImpervious(server->serverClient);
  }
  
  StartProxy(server)
      XServerPtr  server;
  {
!     char        buf[1024];
!     int         reqlen;
      xLbxStartProxyReq *n = (xLbxStartProxyReq *) buf;
      extern Bool NewOutputPending;
  
+     LbxOptInit();
      n->reqType = server->lbxReq;
      n->lbxReqType = X_LbxStartProxy;
!     reqlen = LbxOptBuildReq(buf + sz_xLbxStartProxyReq);
!     assert(reqlen > 0 && reqlen + sz_xLbxStartProxyReq <= 1024);
!     n->length = (reqlen + sz_xLbxStartProxyReq + 3) >> 2;
      WriteToServer(clients[0], n->length << 2, (char *) n);
      server->serverClient->sequence++;
      ExpectServerReply(server, StartProxyReply);
***************
*** 824,830 ****
      server->lbxReq = request;
      server->lbxEvent = event;
      server->lbxError = error;
!     server->lzwHandle = NULL;
      server->initialized = FALSE;
      server->send = clients[0];
      server->recv = clients[0];
--- 939,945 ----
      server->lbxReq = request;
      server->lbxEvent = event;
      server->lbxError = error;
!     server->compHandle = NULL;
      server->initialized = FALSE;
      server->send = clients[0];
      server->recv = clients[0];
*** -	Wed Jan 18 13:07:17 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/wire.h	Wed Jan 18 13:07:17 1995
***************
*** 1,7 ****
! /* $XConsortium: wire.h,v 1.3 94/02/20 11:14:33 dpw Exp $ */
  /*
   * $NCDOr: wire.h,v 1.1 1993/11/16 17:58:49 keithp Exp keithp $
!  * $NCDId: @(#)wire.h,v 1.5 1994/01/18 19:27:47 dct Exp $
   *
   * Copyright 1992 Network Computing Devices
   *
--- 1,7 ----
! /* $XConsortium: wire.h,v 1.4 94/12/01 20:43:38 mor Exp $ */
  /*
   * $NCDOr: wire.h,v 1.1 1993/11/16 17:58:49 keithp Exp keithp $
!  * $NCDId: @(#)wire.h,v 1.7 1994/09/15 22:43:04 dct Exp $
   *
   * Copyright 1992 Network Computing Devices
   *
***************
*** 39,45 ****
      ClientPtr		serverClient;
      int			recv_expect;
      int			motion_allowed;
!     void		*lzwHandle;
      LBXDeltasRec	indeltas;
      LBXDeltasRec	outdeltas;
  } XServerRec;
--- 39,45 ----
      ClientPtr		serverClient;
      int			recv_expect;
      int			motion_allowed;
!     pointer		compHandle;
      LBXDeltasRec	indeltas;
      LBXDeltasRec	outdeltas;
  } XServerRec;
*** -	Wed Jan 18 13:07:18 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/Imakefile	Wed Jan 18 13:07:18 1995
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile,v 1.4 94/04/13 18:08:49 rws Exp $
  
  #include <Server.tmpl>
  
--- 1,4 ----
! XCOMM $XConsortium: Imakefile,v 1.7 94/12/01 20:42:00 mor Exp $
  
  #include <Server.tmpl>
  
***************
*** 9,20 ****
  		utils.c stubs.c tables.c init.c \
  		cache.c colormap.c lbxfuncs.c reqtype.c \
                  resource.c tags.c atomcache.c gfx.c lbxutil.c \
!                 props.c swapreq.c swaprep.c
      OBJS = main.o dispatch.o wire.o globals.o \
  		utils.o stubs.o tables.o init.o \
  		cache.o colormap.o lbxfuncs.o reqtype.o \
                  resource.o tags.o atomcache.o gfx.o lbxutil.o \
!                 props.o swapreq.o swaprep.o
  
      EXTRA_DEFINES = AllocateLocalDefines
  	
--- 9,22 ----
  		utils.c stubs.c tables.c init.c \
  		cache.c colormap.c lbxfuncs.c reqtype.c \
                  resource.c tags.c atomcache.c gfx.c lbxutil.c \
!                 props.c swapreq.c swaprep.c unsquish.c extensions.c \
! 		options.c
      OBJS = main.o dispatch.o wire.o globals.o \
  		utils.o stubs.o tables.o init.o \
  		cache.o colormap.o lbxfuncs.o reqtype.o \
                  resource.o tags.o atomcache.o gfx.o lbxutil.o \
!                 props.o swapreq.o swaprep.o unsquish.o extensions.o \
! 		options.o
  
      EXTRA_DEFINES = AllocateLocalDefines
  	
*** -	Wed Jan 18 13:07:20 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/props.c	Wed Jan 18 13:07:20 1995
***************
*** 1,4 ****
! /* $XConsortium: props.c,v 1.5 94/03/27 14:05:19 dpw Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
--- 1,4 ----
! /* $XConsortium: props.c,v 1.6 94/12/01 20:42:57 mor Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
***************
*** 19,26 ****
   * OR PROFITS, EVEN IF ADVISED OF THE POSSIBILITY THEREOF, AND REGARDLESS OF
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
!  * 
!  * $NCDId: @(#)props.c,v 1.12 1994/03/24 17:54:57 lemke Exp $
   */
  /*
   * property handling
--- 19,26 ----
   * OR PROFITS, EVEN IF ADVISED OF THE POSSIBILITY THEREOF, AND REGARDLESS OF
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
!  *
!  * $NCDId: @(#)props.c,v 1.13 1994/09/07 00:43:39 lemke Exp $
   */
  /*
   * property handling
***************
*** 229,235 ****
      	swapl(&rep->tag, n);
      }
  
!     nr = GetReply(client);
      assert(nr);
      ptdp = &nr->request_info.lbxchangeprop.ptd;
      if (rep->tag) {
--- 229,235 ----
      	swapl(&rep->tag, n);
      }
  
!     nr = GetMatchingReply(client, rep->sequenceNumber);
      assert(nr);
      ptdp = &nr->request_info.lbxchangeprop.ptd;
      if (rep->tag) {
***************
*** 310,316 ****
      if (!pdata)
  	pdata = ptdp->data;
  
!     pdata = (pointer) ((char *)pdata + (4 * offset));
  
      reply.type = X_Reply;
      reply.sequenceNumber = seqnum;
--- 310,316 ----
      if (!pdata)
  	pdata = ptdp->data;
  
!     pdata = (pointer) ((char *) pdata + (4 * offset));
  
      reply.type = X_Reply;
      reply.sequenceNumber = seqnum;
***************
*** 359,365 ****
  
      rep = (xLbxGetPropertyReply *) data;
  
!     nr = GetReply(client);
      assert(nr);
  
      ptd.type = rep->propertyType;
--- 359,365 ----
  
      rep = (xLbxGetPropertyReply *) data;
  
!     nr = GetMatchingReply(client, rep->sequenceNumber);
      assert(nr);
  
      ptd.type = rep->propertyType;
*** -	Wed Jan 18 13:07:21 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/gfx.c	Wed Jan 18 13:07:21 1995
***************
*** 1,4 ****
! /* $XConsortium: gfx.c,v 1.3 94/03/27 14:06:51 dpw Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
--- 1,4 ----
! /* $XConsortium: gfx.c,v 1.13 94/12/01 20:55:35 mor Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
***************
*** 7,15 ****
   * that the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
   * documentation, and that the name Network Computing Devices, Inc. not be
!  * used in advertising or publicity pertaining to distribution of this 
   * software without specific, written prior permission.
!  * 
   * THIS SOFTWARE IS PROVIDED `AS-IS'.  NETWORK COMPUTING DEVICES, INC.,
   * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT
   * LIMITATION ALL IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
--- 7,15 ----
   * that the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
   * documentation, and that the name Network Computing Devices, Inc. not be
!  * used in advertising or publicity pertaining to distribution of this
   * software without specific, written prior permission.
!  *
   * THIS SOFTWARE IS PROVIDED `AS-IS'.  NETWORK COMPUTING DEVICES, INC.,
   * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT
   * LIMITATION ALL IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
***************
*** 19,26 ****
   * OR PROFITS, EVEN IF ADVISED OF THE POSSIBILITY THEREOF, AND REGARDLESS OF
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
!  * 
!  * $NCDId: @(#)gfx.c,v 1.3 1994/03/24 17:54:44 lemke Exp $
   */
  /*
   * graphics acceleration
--- 19,26 ----
   * OR PROFITS, EVEN IF ADVISED OF THE POSSIBILITY THEREOF, AND REGARDLESS OF
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
!  *
!  * $NCDId: @(#)gfx.c,v 1.9 1994/11/29 19:56:39 lemke Exp $
   */
  /*
   * graphics acceleration
***************
*** 32,37 ****
--- 32,38 ----
  #include	<X11/X.h>	/* for KeymapNotify */
  #include	<X11/Xproto.h>
  #include	"assert.h"
+ #include	"misc.h"
  #include	"lbxdata.h"
  #include	"util.h"
  #include	"lbx.h"		/* gets dixstruct.h */
***************
*** 39,44 ****
--- 40,46 ----
  #include	"wire.h"
  #define _XLBX_SERVER_
  #include	"lbxstr.h"	/* gets dixstruct.h */
+ #include        "lbximage.h"
  
  static int  pad[4] = {0, 3, 2, 1};
  
***************
*** 73,78 ****
--- 75,260 ----
  	    *(out)++ = 0x80 | ((angle / 45) + 4); \
      }
  
+ #define COPY_AND_SWAPS(oval, ival) \
+     { \
+ 	register int n; \
+ 	(oval) = (ival); \
+ 	if (client->swapped) \
+ 	    swaps(&(oval), n); \
+     }
+ 
+ #define SWAP_REENCODE_SHORT(ival, out) { \
+     register int    _n; \
+     short	    _val; \
+     _val = (ival); \
+     if (client->swapped) swaps (&_val, _n); \
+     REENCODE_SHORT(_val, out); \
+ }
+ 
+ #define SWAP_REENCODE_USHORT(ival, out) { \
+     register int    _n; \
+     unsigned short  _val; \
+     _val = (ival); \
+     if (client->swapped) swaps (&_val, _n); \
+     REENCODE_USHORT(_val, out); \
+ }
+ 
+ int         gfx_gc_hit;
+ int         gfx_gc_miss;
+ int         gfx_draw_hit;
+ int         gfx_draw_miss;
+ int         gfx_total;
+ int         gfx_bail;
+ 
+ static void
+ push(cache, xid)
+     XID         cache[GFX_CACHE_SIZE];
+     XID         xid;
+ {
+     bcopy(cache, cache + 1, (GFX_CACHE_SIZE - 1) * sizeof(cache[0]));
+     cache[0] = xid;
+ }
+ 
+ static void
+ use(cache, i)
+     XID         cache[GFX_CACHE_SIZE];
+     int         i;
+ {
+     XID         tmp;
+ 
+     if (i == 0)
+ 	return;
+     tmp = cache[i];
+     bcopy(cache, cache + 1, i * sizeof(cache[0]));
+     cache[0] = tmp;
+ }
+ 
+ static int
+ match(cache, xid)
+     XID         cache[GFX_CACHE_SIZE];
+     XID         xid;
+ {
+     int         j;
+ 
+     for (j = 0; j < GFX_CACHE_SIZE; j++)
+ 	if (cache[j] == xid)
+ 	    return j;
+     return GFXCacheNone;
+ }
+ 
+ #define GFX_REQ_PAD	8
+ 
+ #define GFX_SRC_DST_REQ_PAD	12
+ 
+ #define GFX_CACHE_DECLARE   int		_dcache, _gcache; \
+ 			    Drawable	_drawable; \
+ 			    GContext	_gcontext; \
+ 
+ #define GFX_SRC_DST_CACHE_DECLARE	int _srcDcache, _dstDcache, _gcache; \
+ 					Drawable _srcDrawable, _dstDrawable; \
+ 					GContext _gcontext;
+ 
+ #define GFX_SETUP_DRAWABLE_AND_GC(after) {\
+     _drawable = stuff->drawable; \
+     _gcontext = stuff->gc; \
+     if (client->swapped) { \
+ 	register int _n; \
+ 	swapl(&_drawable, _n); \
+ 	swapl(&_gcontext, _n); \
+     } \
+     _dcache = match (LBXDrawableCache(client), _drawable); \
+     if (_dcache == GFXCacheNone) \
+     { \
+ 	bcopy (&stuff->drawable, after, 4); \
+ 	after += 4; \
+     } \
+     _gcache = match (LBXGContextCache(client), _gcontext); \
+     if (_gcache == GFXCacheNone) \
+     { \
+ 	bcopy (&stuff->gc, after, 4); \
+ 	after += 4; \
+     } \
+ }
+ 
+ #define GFX_SETUP_SRC_DST_DRAWABLE_AND_GC(after) {\
+     Drawable	tmpDrawableCache[GFX_CACHE_SIZE]; \
+     bcopy (LBXDrawableCache(client), tmpDrawableCache, sizeof (LBXDrawableCache(client))); \
+     _srcDrawable = stuff->srcDrawable; \
+     _dstDrawable = stuff->dstDrawable; \
+     _gcontext = stuff->gc; \
+     if (client->swapped) { \
+ 	register int _n; \
+ 	swapl (&_srcDrawable, _n); \
+ 	swapl (&_dstDrawable, _n); \
+ 	swapl (&_gcontext, _n); \
+     } \
+     _srcDcache = match (LBXDrawableCache(client), _srcDrawable); \
+     if (_srcDcache == GFXCacheNone) \
+     { \
+ 	bcopy (&stuff->srcDrawable, after, 4); \
+ 	after += 4; \
+ 	push (tmpDrawableCache, _srcDrawable); \
+     } else \
+ 	use (tmpDrawableCache, _srcDcache); \
+     _dstDcache = match (tmpDrawableCache, _dstDrawable); \
+     if (_dstDcache == GFXCacheNone) \
+     { \
+ 	bcopy (&stuff->dstDrawable, after, 4); \
+ 	after += 4; \
+     } \
+     _gcache = match (LBXGContextCache(client), _gcontext); \
+     if (_gcache == GFXCacheNone) \
+     { \
+ 	bcopy (&stuff->gc, after, 4); \
+ 	after += 4; \
+     } \
+ }
+ 
+ #define GFX_SET_DRAWABLE_AND_GC {\
+     if (_dcache == GFXCacheNone) { \
+ 	gfx_draw_miss++; \
+ 	push (LBXDrawableCache(client), _drawable); \
+     } else { \
+ 	gfx_draw_hit++; \
+ 	use (LBXDrawableCache(client), _dcache); \
+     } \
+     if (_gcache == GFXCacheNone) { \
+ 	gfx_gc_miss++; \
+ 	push (LBXGContextCache(client), _gcontext);\
+     } else { \
+ 	gfx_gc_hit++; \
+ 	use (LBXGContextCache(client), _gcache); \
+     } \
+     newreq->cacheEnts = GFXCacheEnts (_dcache, _gcache); \
+     gfx_total++; \
+ }
+ #define GFX_SET_SRC_DST_DRAWABLE_AND_GC {\
+     if (_srcDcache == GFXCacheNone) { \
+ 	gfx_draw_miss++; \
+ 	push (LBXDrawableCache(client), _srcDrawable); \
+     } else { \
+ 	gfx_draw_hit++; \
+ 	use (LBXDrawableCache(client), _srcDcache); \
+     } \
+     newreq->srcCache = GFXCacheEnts (_srcDcache, 0); \
+     if (_dstDcache == GFXCacheNone) { \
+ 	gfx_draw_miss++; \
+ 	push (LBXDrawableCache(client), _dstDrawable); \
+     } else { \
+ 	gfx_draw_hit++; \
+ 	use (LBXDrawableCache(client), _dstDcache); \
+     } \
+     if (_gcache == GFXCacheNone) { \
+ 	gfx_gc_miss++; \
+ 	push (LBXGContextCache(client), _gcontext);\
+     } else { \
+ 	gfx_gc_hit++; \
+ 	use (LBXGContextCache(client), _gcache); \
+     } \
+     newreq->cacheEnts = GFXCacheEnts (_dstDcache, _gcache); \
+     gfx_total++; \
+ }
+ 
  static int
  reencode_poly(client, lbxreq, reencode_rtn)
      ClientPtr   client;
***************
*** 81,115 ****
  {
      REQUEST(xPolyPointReq);
      XServerPtr  server = client->server;
!     int         len = stuff->length << 2;
      xLbxPolyPointReq *newreq = NULL;
      int         bytes;
  
!     /* If it's delta compressible, don't try to reencode */
!     if (DELTA_CACHEABLE(&server->outdeltas, len) ||
! 	    (newreq = (xLbxPolyPointReq *) xalloc(len)) == NULL ||
! 	    (bytes = (*reencode_rtn) (client, (short *) &stuff[1],
! 				      (char *) newreq + sz_xLbxPolyPointReq,
! 				      (len - sz_xPolyPointReq) >> 2)) == 0) {
! 	if (newreq)
! 	    xfree(newreq);
! 	return ProcStandardRequest(client);
!     }
!     FinishLBXRequest(client, REQ_PASSTHROUGH);
  
      newreq->reqType = server->lbxReq;
      newreq->lbxReqType = lbxreq;
!     newreq->drawable = stuff->drawable;
!     newreq->gc = stuff->gc;
!     len = sz_xLbxPolyPointReq + bytes;
      newreq->padBytes = pad[len % 4];
      len += newreq->padBytes;
      newreq->length = len >> 2;
!     WriteToServer(client, len, (char *) newreq);
      xfree(newreq);
      return Success;
  }
  
  /* ARGSUSED */
  static int
  reencode_points_origin(client, in, out, count)
--- 263,307 ----
  {
      REQUEST(xPolyPointReq);
      XServerPtr  server = client->server;
!     int         len = client->req_len << 2;
!     int         space;
      xLbxPolyPointReq *newreq = NULL;
+     char       *after;
      int         bytes;
  
!     GFX_CACHE_DECLARE
  
+ 	space = len - sz_xPolyPointReq + sz_xLbxPolyPointReq + GFX_REQ_PAD + 3;
+     newreq = (xLbxPolyPointReq *) xalloc(space);
+     if (newreq == NULL)
+ 	goto bail;
+     after = ((char *) newreq) + sz_xLbxPolyPointReq;
+     GFX_SETUP_DRAWABLE_AND_GC(after);
+     bytes = (*reencode_rtn) (client, (short *) &stuff[1],
+ 			     (char *) after,
+ 			     (len - sz_xPolyPointReq) >> 2);
+     if (bytes == 0)
+ 	goto bail;
+     FinishLBXRequest(client, REQ_PASSTHROUGH);
      newreq->reqType = server->lbxReq;
      newreq->lbxReqType = lbxreq;
!     GFX_SET_DRAWABLE_AND_GC;
!     len = after - ((char *) newreq) + bytes;
      newreq->padBytes = pad[len % 4];
+     bzero(((char *) newreq) + len, newreq->padBytes);
      len += newreq->padBytes;
      newreq->length = len >> 2;
!     WriteReqToServer(client, len, (char *) newreq);
      xfree(newreq);
      return Success;
+ bail:
+     if (newreq)
+ 	xfree(newreq);
+     return ProcStandardRequest(client);
+ 
  }
  
+ 
  /* ARGSUSED */
  static int
  reencode_points_origin(client, in, out, count)
***************
*** 120,135 ****
  {
      register short diff;
      int         i;
      short       last_x = 0;
      short       last_y = 0;
      char       *start_out = out;
  
      for (i = 0; i < count; i++, in += 2) {
! 	diff = in[0] - last_x;
! 	last_x = in[0];
  	REENCODE_SHORT(diff, out);
! 	diff = in[1] - last_y;
! 	last_y = in[1];
  	REENCODE_SHORT(diff, out);
      }
      return out - start_out;
--- 312,330 ----
  {
      register short diff;
      int         i;
+     short       inval;
      short       last_x = 0;
      short       last_y = 0;
      char       *start_out = out;
  
      for (i = 0; i < count; i++, in += 2) {
! 	COPY_AND_SWAPS(inval, in[0]);
! 	diff = inval - last_x;
! 	last_x = inval;
  	REENCODE_SHORT(diff, out);
! 	COPY_AND_SWAPS(inval, in[1]);
! 	diff = inval - last_y;
! 	last_y = inval;
  	REENCODE_SHORT(diff, out);
      }
      return out - start_out;
***************
*** 144,154 ****
      int         count;
  {
      int         i;
      char       *start_out = out;
  
      for (i = 0; i < count; i++, in += 2) {
! 	REENCODE_SHORT(in[0], out);
! 	REENCODE_SHORT(in[1], out);
      }
      return out - start_out;
  }
--- 339,352 ----
      int         count;
  {
      int         i;
+     short       inval;
      char       *start_out = out;
  
      for (i = 0; i < count; i++, in += 2) {
! 	COPY_AND_SWAPS(inval, in[0]);
! 	REENCODE_SHORT(inval, out);
! 	COPY_AND_SWAPS(inval, in[1]);
! 	REENCODE_SHORT(inval, out);
      }
      return out - start_out;
  }
***************
*** 163,168 ****
--- 361,367 ----
  {
      register short diff;
      int         i;
+     short       inval;
      short       last_x = 0;
      short       last_y = 0;
      char       *start_out = out;
***************
*** 170,186 ****
      count >>= 1;
      for (i = 0; i < count; i++, in += 4) {
  	/* reencode (x1, y1) */
! 	diff = in[0] - last_x;
! 	last_x = in[0];
  	REENCODE_SHORT(diff, out);
! 	diff = in[1] - last_y;
! 	last_y = in[1];
  	REENCODE_SHORT(diff, out);
  
  	/* reencode (x2, y2) */
! 	diff = in[2] - last_x;
  	REENCODE_SHORT(diff, out);
! 	diff = in[3] - last_y;
  	REENCODE_SHORT(diff, out);
      }
      return out - start_out;
--- 369,389 ----
      count >>= 1;
      for (i = 0; i < count; i++, in += 4) {
  	/* reencode (x1, y1) */
! 	COPY_AND_SWAPS(inval, in[0]);
! 	diff = inval - last_x;
! 	last_x = inval;
  	REENCODE_SHORT(diff, out);
! 	COPY_AND_SWAPS(inval, in[1]);
! 	diff = inval - last_y;
! 	last_y = inval;
  	REENCODE_SHORT(diff, out);
  
  	/* reencode (x2, y2) */
! 	COPY_AND_SWAPS(inval, in[2]);
! 	diff = inval - last_x;
  	REENCODE_SHORT(diff, out);
! 	COPY_AND_SWAPS(inval, in[3]);
! 	diff = inval - last_y;
  	REENCODE_SHORT(diff, out);
      }
      return out - start_out;
***************
*** 196,201 ****
--- 399,405 ----
  {
      register short diff;
      int         i;
+     short       inval;
      short       last_x = 0;
      short       last_y = 0;
      char       *start_out = out;
***************
*** 203,218 ****
      count >>= 1;
      for (i = 0; i < count; i++, in += 4) {
  	/* reencode (x, y) origin */
! 	diff = in[0] - last_x;
! 	last_x = in[0];
  	REENCODE_SHORT(diff, out);
! 	diff = in[1] - last_y;
! 	last_y = in[1];
  	REENCODE_SHORT(diff, out);
  
  	/* reencode (width, height) */
! 	REENCODE_USHORT(in[2], out);
! 	REENCODE_USHORT(in[3], out);
      }
      return out - start_out;
  }
--- 407,426 ----
      count >>= 1;
      for (i = 0; i < count; i++, in += 4) {
  	/* reencode (x, y) origin */
! 	COPY_AND_SWAPS(inval, in[0]);
! 	diff = inval - last_x;
! 	last_x = inval;
  	REENCODE_SHORT(diff, out);
! 	COPY_AND_SWAPS(inval, in[1]);
! 	diff = inval - last_y;
! 	last_y = inval;
  	REENCODE_SHORT(diff, out);
  
  	/* reencode (width, height) */
! 	COPY_AND_SWAPS(inval, in[2]);
! 	REENCODE_USHORT(inval, out);
! 	COPY_AND_SWAPS(inval, in[3]);
! 	REENCODE_USHORT(inval, out);
      }
      return out - start_out;
  }
***************
*** 227,232 ****
--- 435,441 ----
  {
      register short diff;
      int         i;
+     short       inval;
      short       last_x = 0;
      short       last_y = 0;
      char       *start_out = out;
***************
*** 234,253 ****
      count = count / 3;
      for (i = 0; i < count; i++, in += 6) {
  	/* reencode (x, y) origin */
! 	diff = in[0] - last_x;
! 	last_x = in[0];
  	REENCODE_SHORT(diff, out);
! 	diff = in[1] - last_y;
! 	last_y = in[1];
  	REENCODE_SHORT(diff, out);
  
  	/* reencode (width, height) */
! 	REENCODE_USHORT(in[2], out);
! 	REENCODE_USHORT(in[3], out);
  
  	/* reencode (angle1, angle2) */
! 	REENCODE_ANGLE(in[4], out);
! 	REENCODE_ANGLE(in[5], out);
      }
      return out - start_out;
  }
--- 443,468 ----
      count = count / 3;
      for (i = 0; i < count; i++, in += 6) {
  	/* reencode (x, y) origin */
! 	COPY_AND_SWAPS(inval, in[0]);
! 	diff = inval - last_x;
! 	last_x = inval;
  	REENCODE_SHORT(diff, out);
! 	COPY_AND_SWAPS(inval, in[1]);
! 	diff = inval - last_y;
! 	last_y = inval;
  	REENCODE_SHORT(diff, out);
  
  	/* reencode (width, height) */
! 	COPY_AND_SWAPS(inval, in[2]);
! 	REENCODE_USHORT(inval, out);
! 	COPY_AND_SWAPS(inval, in[3]);
! 	REENCODE_USHORT(inval, out);
  
  	/* reencode (angle1, angle2) */
! 	COPY_AND_SWAPS(inval, in[4]);
! 	REENCODE_ANGLE(inval, out);
! 	COPY_AND_SWAPS(inval, in[5]);
! 	REENCODE_ANGLE(inval, out);
      }
      return out - start_out;
  }
***************
*** 303,340 ****
  {
      REQUEST(xFillPolyReq);
      XServerPtr  server = client->server;
!     int         len = stuff->length << 2;
      xLbxFillPolyReq *newreq = NULL;
      int         bytes;
      int         (*reencode_rtn) ();
  
      reencode_rtn = (stuff->coordMode) ? reencode_points_previous :
  	reencode_points_origin;
  
!     /* If it's delta compressible, don't try to reencode */
!     if (DELTA_CACHEABLE(&server->outdeltas, len) ||
! 	    (newreq = (xLbxFillPolyReq *) xalloc(len)) == NULL ||
! 	    (bytes = (*reencode_rtn) (client, (short *) &stuff[1],
! 				      (char *) newreq + sz_xLbxFillPolyReq,
! 				      (len - sz_xFillPolyReq) >> 2)) == 0) {
! 	if (newreq)
! 	    xfree(newreq);
! 	return ProcStandardRequest(client);
!     }
!     FinishLBXRequest(client, REQ_PASSTHROUGH);
  
      newreq->reqType = server->lbxReq;
      newreq->lbxReqType = X_LbxFillPoly;
-     newreq->drawable = stuff->drawable;
-     newreq->gc = stuff->gc;
      newreq->shape = stuff->shape;
!     len = sz_xLbxPolyPointReq + bytes;
      newreq->padBytes = pad[len % 4];
      len += newreq->padBytes;
      newreq->length = len >> 2;
!     WriteToServer(client, len, (char *) newreq);
      xfree(newreq);
      return Success;
  }
  
  int
--- 518,563 ----
  {
      REQUEST(xFillPolyReq);
      XServerPtr  server = client->server;
!     int         len = client->req_len << 2;
      xLbxFillPolyReq *newreq = NULL;
+     char       *after;
      int         bytes;
+     int         space;
      int         (*reencode_rtn) ();
  
+     GFX_CACHE_DECLARE;
+ 
      reencode_rtn = (stuff->coordMode) ? reencode_points_previous :
  	reencode_points_origin;
  
!     space = len - sz_xFillPolyReq + sz_xLbxPolyPointReq + GFX_REQ_PAD + 3;
!     newreq = (xLbxFillPolyReq *) xalloc(space);
!     if (newreq == NULL)
! 	goto bail;
!     after = ((char *) newreq) + sz_xLbxFillPolyReq;
!     GFX_SETUP_DRAWABLE_AND_GC(after);
!     bytes = (*reencode_rtn) (client, (short *) &stuff[1], after,
! 			     (len - sz_xFillPolyReq) >> 2);
!     if (bytes == 0)
! 	goto bail;
  
+     FinishLBXRequest(client, REQ_PASSTHROUGH);
      newreq->reqType = server->lbxReq;
      newreq->lbxReqType = X_LbxFillPoly;
      newreq->shape = stuff->shape;
!     GFX_SET_DRAWABLE_AND_GC;
!     len = after - ((char *) newreq) + bytes;
      newreq->padBytes = pad[len % 4];
+     bzero(((char *) newreq) + len, newreq->padBytes);
      len += newreq->padBytes;
      newreq->length = len >> 2;
!     WriteReqToServer(client, len, (char *) newreq);
      xfree(newreq);
      return Success;
+ bail:
+     if (newreq)
+ 	xfree(newreq);
+     return ProcStandardRequest(client);
  }
  
  int
***************
*** 349,352 ****
--- 572,1050 ----
      ClientPtr   client;
  {
      return reencode_poly(client, X_LbxPolyFillArc, reencode_arc);
+ }
+ 
+ static int
+ reencode_copy(client, in, out)
+     ClientPtr   client;
+     register xCopyAreaReq *in;
+     register char *out;
+ {
+     char       *start_out = out;
+ 
+     SWAP_REENCODE_SHORT(in->srcX, out);
+     SWAP_REENCODE_SHORT(in->srcY, out);
+     SWAP_REENCODE_SHORT(in->dstX, out);
+     SWAP_REENCODE_SHORT(in->dstY, out);
+     SWAP_REENCODE_USHORT(in->width, out);
+     SWAP_REENCODE_USHORT(in->height, out);
+     return out - start_out;
+ }
+ 
+ int
+ ProcLBXCopyArea(client)
+     ClientPtr   client;
+ {
+     REQUEST(xCopyAreaReq);
+     XServerPtr  server = client->server;
+     int         len;
+     xLbxCopyAreaReq *newreq = NULL;
+     unsigned long space[(SIZEOF(xLbxCopyAreaReq) + GFX_SRC_DST_REQ_PAD + 7 * sizeof(unsigned long) - 1) / sizeof(unsigned long)];
+     char       *after;
+     int         extra;
+     int         bytes;
+ 
+     GFX_SRC_DST_CACHE_DECLARE;
+ 
+     newreq = (xLbxCopyAreaReq *) space;
+     after = ((char *) newreq) + sz_xLbxCopyAreaReq;
+     GFX_SETUP_SRC_DST_DRAWABLE_AND_GC(after);
+     bytes = reencode_copy(client, stuff, after);
+     if (bytes == 0)
+ 	goto bail;
+     FinishLBXRequest(client, REQ_PASSTHROUGH);
+     newreq->reqType = server->lbxReq;
+     newreq->lbxReqType = X_LbxCopyArea;
+     GFX_SET_SRC_DST_DRAWABLE_AND_GC;
+     len = ((after + bytes) - ((char *) newreq));
+     extra = pad[len & 3];
+     bzero(((char *) newreq) + len, extra);
+     len += extra;
+     newreq->length = len >> 2;
+     WriteReqToServer(client, len, (char *) newreq);
+     return Success;
+ bail:
+     return ProcStandardRequest(client);
+ }
+ 
+ int
+ ProcLBXCopyPlane(client)
+     ClientPtr   client;
+ {
+     REQUEST(xCopyPlaneReq);
+     XServerPtr  server = client->server;
+     int         len;
+     xLbxCopyPlaneReq *newreq = NULL;
+     unsigned long space[(SIZEOF(xLbxCopyPlaneReq) + GFX_SRC_DST_REQ_PAD + 7 * sizeof(unsigned long) - 1) / sizeof(unsigned long)];
+     char       *after;
+     int         bytes;
+     int         extra;
+ 
+     GFX_SRC_DST_CACHE_DECLARE;
+ 
+     newreq = (xLbxCopyPlaneReq *) space;
+     after = ((char *) newreq) + sz_xLbxCopyPlaneReq;
+     GFX_SETUP_SRC_DST_DRAWABLE_AND_GC(after);
+     bytes = reencode_copy(client, stuff, after);
+     if (bytes == 0)
+ 	goto bail;
+     FinishLBXRequest(client, REQ_PASSTHROUGH);
+     newreq->reqType = server->lbxReq;
+     newreq->bitPlane = stuff->bitPlane;
+     newreq->lbxReqType = X_LbxCopyPlane;
+     GFX_SET_SRC_DST_DRAWABLE_AND_GC;
+     len = ((after + bytes) - ((char *) newreq));
+     extra = pad[len & 3];
+     bzero(((char *) newreq) + len, extra);
+     len += extra;
+     newreq->length = len >> 2;
+     WriteReqToServer(client, len, (char *) newreq);
+     return Success;
+ bail:
+     return ProcStandardRequest(client);
+ }
+ 
+ reencode_text_pos(client, in, out)
+     ClientPtr   client;
+     xPolyTextReq *in;
+     char       *out;
+ {
+     char       *start_out;
+ 
+     start_out = out;
+     SWAP_REENCODE_SHORT(in->x, out);
+     SWAP_REENCODE_SHORT(in->y, out);
+     return out - start_out;
+ }
+ 
+ int
+ ProcLBXPolyText(client)
+     ClientPtr   client;
+ {
+     REQUEST(xPolyTextReq);
+     XServerPtr  server = client->server;
+     int         len = client->req_len << 2;
+     xLbxPolyTextReq *newreq = NULL;
+     int         space;
+     char       *after;
+     int         bytes;
+     int         extra;
+ 
+     GFX_CACHE_DECLARE;
+ 
+     space = len - sz_xPolyTextReq + sz_xLbxPolyTextReq + GFX_REQ_PAD + 4 + 3;
+     newreq = (xLbxPolyTextReq *) xalloc(space);
+     if (newreq == NULL)
+ 	goto bail;
+     after = ((char *) newreq) + sz_xLbxPolyTextReq;
+     GFX_SETUP_DRAWABLE_AND_GC(after);
+     /* Reencode the text position */
+     bytes = reencode_text_pos(client, stuff, after);
+     if (bytes == 0)
+ 	goto bail;
+     /* copy the text elements */
+     bcopy((char *) &stuff[1], after + bytes, len - sz_xPolyTextReq);
+     bytes += len - sz_xPolyTextReq;
+     FinishLBXRequest(client, REQ_PASSTHROUGH);
+     newreq->reqType = server->lbxReq;
+     newreq->lbxReqType = stuff->reqType == X_PolyText8 ? X_LbxPolyText8 : X_LbxPolyText16;
+     GFX_SET_DRAWABLE_AND_GC;
+     len = ((after + bytes) - ((char *) newreq));
+     extra = pad[len & 3];
+     bzero(((char *) newreq) + len, extra);
+     len += extra;
+     newreq->length = len >> 2;
+     WriteReqToServer(client, len, (char *) newreq);
+     xfree(newreq);
+     return Success;
+ bail:
+     if (newreq)
+ 	xfree(newreq);
+     return ProcStandardRequest(client);
+ }
+ 
+ int
+ ProcLBXImageText(client)
+     ClientPtr   client;
+ {
+     REQUEST(xImageTextReq);
+     XServerPtr  server = client->server;
+     int         len = client->req_len << 2;
+     xLbxImageTextReq *newreq = NULL;
+     int         space;
+     char       *after;
+     int         bytes;
+     int         extra;
+ 
+     GFX_CACHE_DECLARE;
+ 
+     space = len - sz_xImageTextReq + sz_xLbxImageTextReq + GFX_REQ_PAD + 4 + 3;
+     newreq = (xLbxImageTextReq *) xalloc(space);
+     if (newreq == NULL)
+ 	goto bail;
+     after = ((char *) newreq) + sz_xLbxImageTextReq;
+     GFX_SETUP_DRAWABLE_AND_GC(after);
+     /* Reencode the text position */
+     bytes = reencode_text_pos(client, (xPolyTextReq *) stuff, after);
+     if (bytes == 0)
+ 	goto bail;
+     /* copy the text elements */
+     bcopy((char *) &stuff[1], after + bytes, stuff->nChars);
+     FinishLBXRequest(client, REQ_PASSTHROUGH);
+     newreq->reqType = server->lbxReq;
+     newreq->lbxReqType = stuff->reqType == X_ImageText8 ? X_LbxImageText8 : X_LbxImageText16;
+     newreq->nChars = stuff->nChars;
+     GFX_SET_DRAWABLE_AND_GC;
+     len = ((after + bytes + stuff->nChars) - ((char *) newreq));
+     extra = pad[len & 3];
+     bzero(((char *) newreq) + len, extra);
+     len += extra;
+     newreq->length = len >> 2;
+     WriteReqToServer(client, len, (char *) newreq);
+     xfree(newreq);
+     return Success;
+ bail:
+     if (newreq)
+ 	xfree(newreq);
+     return ProcStandardRequest(client);
+ }
+ 
+ static void
+ SwapXPutImage(req)
+     xPutImageReq *req;
+ {
+     char        n;
+ 
+     swaps(&req->length, n);
+     swapl(&req->drawable, n);
+     swapl(&req->gc, n);
+     swaps(&req->width, n);
+     swaps(&req->height, n);
+     swaps(&req->dstX, n);
+     swaps(&req->dstY, n);
+ }
+ 
+ 
+ int
+ ProcLBXPutImage(client)
+     ClientPtr   client;
+ {
+     REQUEST(xPutImageReq);
+     XServerPtr  server = client->server;
+     xLbxPutImageReq *newreq = NULL;
+     int         len,
+                 method,
+                 compBytes,
+                 status;
+     float       percentCompression;
+ 
+     if (client->swapped)
+ 	SwapXPutImage(stuff);
+ 
+     len = stuff->length << 2;
+ 
+     if (!((stuff->format == ZPixmap && stuff->depth == 8) ||
+ 	  stuff->depth == 1)) {
+ 	status = LBX_IMAGE_COMPRESS_UNSUPPORTED_FORMAT;
+     } else if ((newreq = (xLbxPutImageReq *) xalloc(len)) == NULL) {
+ 	status = LBX_IMAGE_COMPRESS_BAD_MALLOC;
+     } else {
+ 	if (stuff->depth == 1) {
+ 	    status = LbxImageEncodeFaxG42D((unsigned char *) &stuff[1],
+ 			       (unsigned char *) newreq + sz_xLbxPutImageReq,
+ 					   len - sz_xLbxPutImageReq,
+ 					   len - sz_xPutImageReq,
+ 					   (int) stuff->width,
+ 					   LBXBitmapBitOrder(client) == LSBFirst,
+ 					   &compBytes);
+ 
+ 	    method = LbxImageCompressFaxG42D;
+ 	} else {		/* depth 8 and ZPixmap format */
+ 	    status = LbxImageEncodePackBits((char *) &stuff[1],
+ 					(char *) newreq + sz_xLbxPutImageReq,
+ 					    len - sz_xLbxPutImageReq,
+ 			(int) stuff->height, (int) stuff->width, &compBytes);
+ 
+ 	    method = LbxImageCompressPackBits;
+ 	}
+     }
+ 
+ #ifdef LBX_STATS
+     fprintf(stderr, "PutImage (xid=%x, w=%d, h=%d, x=%d, y=%d): ",
+ 	    stuff->drawable, stuff->width, stuff->height,
+ 	    stuff->dstX, stuff->dstY);
+ #endif
+ 
+     if (status != LBX_IMAGE_COMPRESS_SUCCESS) {
+ 
+ #ifdef LBX_STATS
+ 	fprintf(stderr, "image not compressed - ");
+ 
+ 	if (status == LBX_IMAGE_COMPRESS_UNSUPPORTED_FORMAT)
+ 	    fprintf(stderr, "unsupported format\n");
+ 	else if (status == LBX_IMAGE_COMPRESS_NOT_WORTH_IT)
+ 	    fprintf(stderr, "not worth it\n");
+ 	else if (status == LBX_IMAGE_COMPRESS_BAD_MALLOC)
+ 	    fprintf(stderr, "bad malloc\n");
+ #endif
+ 
+ 	if (newreq)
+ 	    xfree(newreq);
+ 
+ 	if (client->swapped)	/* Swap it back */
+ 	    SwapXPutImage(stuff);
+ 
+ 	return ProcStandardRequest(client);
+     }
+     if (client->swapped) {
+ 	/*
+ 	 * Swap the length back because FinishLBXRequest will swap it.
+ 	 */
+ 
+ 	char        n;
+ 
+ 	swaps(&stuff->length, n);
+     }
+     FinishLBXRequest(client, REQ_PASSTHROUGH);
+ 
+     newreq->reqType = server->lbxReq;
+     newreq->lbxReqType = X_LbxPutImage;
+     newreq->compressionMethod = method;
+     newreq->drawable = stuff->drawable;
+     newreq->gc = stuff->gc;
+     newreq->width = stuff->width;
+     newreq->height = stuff->height;
+     newreq->dstX = stuff->dstX;
+     newreq->dstY = stuff->dstY;
+     newreq->format = stuff->format;
+     newreq->leftPad = stuff->leftPad;
+     newreq->depth = stuff->depth;
+ 
+     len = sz_xLbxPutImageReq + compBytes;
+     newreq->padBytes = pad[len % 4];
+     len += newreq->padBytes;
+     newreq->lbxLength = len >> 2;
+     newreq->xLength = stuff->length;
+ 
+ #ifdef LBX_STATS
+     percentCompression = 100.0 * (1.0 -
+ 				  ((float) (compBytes + pad[compBytes % 4]) /
+ 			  (float) ((stuff->length << 2) - sz_xPutImageReq)));
+ 
+     fprintf(stderr, "%f percent compression ", percentCompression);
+     if (method == LbxImageCompressFaxG42D)
+ 	fprintf(stderr, "(FAX G42D)\n");
+     else if (method == LbxImageCompressPackBits)
+ 	fprintf(stderr, "(PackBits)\n");
+ #endif
+ 
+     if (client->swapped)
+ 	SwapPutImage(newreq);
+ 
+     WriteToServerUncompressed(client, len, (char *) newreq);
+ 
+     xfree(newreq);
+     return Success;
+ }
+ 
+ 
+ static int
+ get_image_req(client, data)
+     ClientPtr   client;
+     char       *data;
+ {
+     ReplyStuffPtr nr;
+     xGetImageReq *req;
+ 
+     req = (xGetImageReq *) data;
+     nr = NewReply(client);
+ 
+     if (nr) {
+ 	if (client->swapped) {
+ 	    char        n;
+ 
+ 	    swapl(&req->drawable, n);
+ 	    swaps(&req->x, n);
+ 	    swaps(&req->y, n);
+ 	    swaps(&req->width, n);
+ 	    swaps(&req->height, n);
+ 	    swapl(&req->planeMask, n);
+ 	}
+ 	nr->sequenceNumber = LBXSequenceNumber(client);
+ 	nr->request = X_LbxGetImage;
+ 	nr->lbx_req = TRUE;
+ 	nr->extension = client->server->lbxReq;
+ 	nr->request_info.lbxgetimage.width = req->width;
+ 	nr->request_info.lbxgetimage.height = req->height;
+ 
+ #ifdef LBX_STATS
+ 	nr->request_info.lbxgetimage.drawable = req->drawable;
+ 	nr->request_info.lbxgetimage.x = req->x;
+ 	nr->request_info.lbxgetimage.y = req->y;
+ #endif
+ 
+ 	/*
+ 	 * this expects a reply.  since we write the data here, we have to be
+ 	 * sure the seq number is in sync first
+ 	 */
+ 
+ 	ForceSequenceUpdate(client);
+ 
+ 	SendGetImage(client, req->drawable, req->x, req->y,
+ 		     req->width, req->height, req->planeMask, req->format);
+ 
+ 	return REQ_REPLACE;
+     } else
+ 	return REQ_NOCHANGE;
+ }
+ 
+ int
+ ProcLBXGetImage(client)
+     ClientPtr   client;
+ {
+     int         yank;
+ 
+     yank = get_image_req(client, client->requestBuffer);
+     return FinishLBXRequest(client, yank);
+ }
+ 
+ 
+ Bool
+ GetLbxImageReply(client, data)
+     ClientPtr   client;
+     char       *data;
+ {
+     xLbxGetImageReply *rep;
+     xGetImageReply reply;
+     int         len;
+     pointer     imageData;
+     ReplyStuffPtr nr;
+     int         freeIt = 1;
+ 
+     rep = (xLbxGetImageReply *) data;
+ 
+     nr = GetReply(client);
+     assert(nr);
+ 
+     if (client->swapped) {
+ 	char        n;
+ 
+ 	swapl(&rep->xLength, n);
+ 	swapl(&rep->visual, n);
+     }
+     if ((imageData = (pointer) xalloc(rep->xLength << 2)) == NULL)
+ 	return FALSE;
+ 
+     if (rep->compressionMethod == LbxImageCompressFaxG42D) {
+ 	LbxImageDecodeFaxG42D(
+ 		      (unsigned char *) &rep[1], (unsigned char *) imageData,
+ 			      (int) ((rep->xLength << 2) - sz_xPutImageReq),
+ 			      (int) nr->request_info.lbxgetimage.width,
+ 			      LBXBitmapBitOrder(client) == LSBFirst);
+     } else if (rep->compressionMethod == LbxImageCompressPackBits) {
+ 	LbxImageDecodePackBits((char *) &rep[1], (char *) imageData,
+ 			       (int) nr->request_info.lbxgetimage.height,
+ 			       (int) nr->request_info.lbxgetimage.width);
+     } else if (rep->compressionMethod == LbxImageCompressNone) {
+ 	xfree((char *) imageData);
+ 	imageData = (pointer) &rep[1];
+ 	freeIt = 0;
+     }
+     reply.type = X_Reply;
+     reply.depth = rep->depth;
+     reply.sequenceNumber = rep->sequenceNumber;
+     reply.length = rep->xLength;
+     reply.visual = rep->visual;
+ 
+     if (client->swapped)
+ 	SwapGetImageReply(&reply);
+ 
+ #ifdef LBX_STATS
+     fprintf (stderr, "GetImage (xid=%x, w=%d, h=%d, x=%d, y=%d): ",
+ 			nr->request_info.lbxgetimage.drawable,
+ 			nr->request_info.lbxgetimage.width,
+ 			nr->request_info.lbxgetimage.height,
+ 			nr->request_info.lbxgetimage.x,
+ 			nr->request_info.lbxgetimage.y);
+     if (rep->compressionMethod == LbxImageCompressNone) {
+ 	fprintf(stderr, "image not compressed\n");
+     } else {
+ 	float       percentCompression = 100.0 * (1.0 -
+ 			    ((float) rep->lbxLength / (float) rep->xLength));
+ 
+ 	fprintf(stderr, "%f percent compression ", percentCompression);
+ 	if (rep->compressionMethod == LbxImageCompressFaxG42D)
+ 	    fprintf(stderr, "(FAX G42D)\n");
+ 	else if (rep->compressionMethod == LbxImageCompressPackBits)
+ 	    fprintf(stderr, "(PackBits)\n");
+     }
+ #endif
+ 
+     WriteToClient(client, sizeof(xGetImageReply), &reply);
+     WriteToClientPad(client, rep->xLength << 2, imageData);
+ 
+     if (freeIt)
+ 	xfree((char *) imageData);
+ 
+     return TRUE;
  }
*** -	Wed Jan 18 13:07:23 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/lbxutil.c	Wed Jan 18 13:07:23 1995
***************
*** 1,4 ****
! /* $XConsortium: lbxutil.c,v 1.4 94/03/27 14:08:16 dpw Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
--- 1,4 ----
! /* $XConsortium: lbxutil.c,v 1.6 94/12/01 20:52:12 mor Exp $ */
  /*
   * Copyright 1994 Network Computing Devices, Inc.
   *
***************
*** 20,26 ****
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
!  * $NCDId: @(#)lbxutil.c,v 1.14 1994/03/24 17:55:07 lemke Exp $
   */
  /*
   * utility routines for LBX requests
--- 20,26 ----
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
!  * $NCDId: @(#)lbxutil.c,v 1.20 1994/11/29 19:57:19 lemke Exp $
   */
  /*
   * utility routines for LBX requests
***************
*** 50,55 ****
--- 50,59 ----
   * if preformance becomes an issue, the reply stuff can be reworked
   * to use a quicker allocation strategy.  we're at least guarenteed
   * that they'll come back in the order requested.
+  *
+  * this has some safety features in case replies come back out of
+  * order -- this is probably completly useless, but it makes it easier
+  * to debug strange sequence bugs...
   */
  ReplyStuffPtr
  NewReply(client)
***************
*** 79,93 ****
  }
  
  void
! RemoveReply(client)
      ClientPtr   client;
  {
!     ReplyStuffPtr old;
  
!     old = LBXReplyList(client);
!     assert(old);
!     LBXReplyList(client) = old->next;
!     xfree(old);
  }
  
  ReplyStuffPtr
--- 83,109 ----
  }
  
  void
! RemoveReply(client, rp)
      ClientPtr   client;
+     ReplyStuffPtr rp;
  {
!     ReplyStuffPtr cur,
!                 prev = NULL;
! 
!     cur = LBXReplyList(client);
!     assert(cur);
  
!     while (cur != rp) {
! 	prev = cur;
! 	cur = cur->next;
!     }
!     assert(cur);
!     if (prev)
! 	prev->next = cur->next;
!     else
! 	LBXReplyList(client) = cur->next;
! 
!     xfree(cur);
  }
  
  ReplyStuffPtr
***************
*** 97,102 ****
--- 113,133 ----
      return LBXReplyList(client);
  }
  
+ ReplyStuffPtr
+ GetMatchingReply(client, seqno)
+     ClientPtr   client;
+     int         seqno;
+ {
+     ReplyStuffPtr t;
+ 
+     t = LBXReplyList(client);
+     while (t && (t->sequenceNumber & 0xffff) != seqno) {
+ 	t = t->next;
+     }
+     assert(t);
+     return t;
+ }
+ 
  int
  NumReplies(client)
      ClientPtr   client;
***************
*** 113,118 ****
--- 144,261 ----
      return num;
  }
  
+ int
+ NumGuessedReplies(client)
+     ClientPtr	client;
+ {
+     int         num = 0;
+     ReplyStuffPtr t;
+ 
+     assert(LBXReplyList(client));
+     t = LBXReplyList(client);
+     while (t) {
+ 	if (t->guessed)
+ 	    num++;
+ 	t = t->next;
+     }
+     return num;
+ }
+ 
+ int
+ LargestReplySeqNo(client)
+     ClientPtr	client;
+ {
+     int         seqno = 0;
+     ReplyStuffPtr t;
+ 
+     assert(LBXReplyList(client));
+     t = LBXReplyList(client);
+     while (t) {
+ 	if (t->sequenceNumber > seqno)
+ 	    seqno = t->sequenceNumber;
+ 	t = t->next;
+     }
+     return seqno;
+ }
+ 
+ /*
+  * this is used for stashing short-circuited replies for later.
+  * it currently assumes that all of them will be 32 bytes for the reply
+  * plus some amount of extra data
+  */
+ 
+ Bool
+ SaveReplyData(client, rep, len, data)
+     ClientPtr   client;
+     xReply     *rep;
+     pointer     data;
+ {
+     ReplyDataPtr new,
+                 list;
+ 
+     new = (ReplyDataPtr) xalloc(sizeof(ReplyDataRec));
+     if (!new)
+ 	return FALSE;
+     bzero((char *) new, sizeof(ReplyDataRec));
+     if (len) {
+ 	new->data = (pointer) xalloc(len);
+ 	if (!new->data) {
+ 	    xfree(new);
+ 	    return FALSE;
+ 	} else {
+ 	    bcopy((char *) data, (char *) new->data, len);
+ 	}
+     }
+     new->reply = *rep;
+     new->dlen = len;
+     new->delay_seq_no = LargestReplySeqNo(client);
+ 
+     list = LBXReplyData(client);
+     if (!list) {
+ 	LBXReplyData(client) = new;
+     } else {
+ 	while (list) {
+ 	    if (!list->next) {
+ 		list->next = new;
+ 		break;
+ 	    }
+ 	    list = list->next;
+ 	}
+     }
+     return TRUE;
+ }
+ 
+ static void
+ send_delayed_reply(client, rd)
+     ClientPtr   client;
+     ReplyDataPtr rd;
+ {
+     WriteToClient(client, sizeof(xReply), (char *) &rd->reply);
+     if (rd->dlen)
+ 	WriteToClient(client, rd->dlen, (char *) rd->data);
+ }
+ 
+  
+ Bool
+ FlushDelayedReply(client, seqno)
+     ClientPtr   client;
+     int         seqno;
+ {
+     ReplyDataPtr list,
+                 next;
+ 
+     list = LBXReplyData(client);
+     while (list) {
+ 	next = list->next;
+ 	if (list->delay_seq_no <= seqno) {
+ 	    send_delayed_reply(client, list);
+ 	    LBXReplyData(client) = next;
+ 	    xfree(list);
+ 	}
+ 	list = next;
+     }
+ }
+ 
  void
  BumpSequence(client)
      ClientPtr   client;
***************
*** 222,228 ****
  	    assert(0);
  	}
      }
- 
      if (TagStoreData(global_cache, qtp->tag, len, qtp->tagtype, tdata)) {
  	/* lost tag again... */
  	SendInvalidateTag(client, qtp->tag);
--- 365,370 ----
***************
*** 372,381 ****
  int         delta_in_attempts;
  int         delta_in_hits;
  
! int         lzw_out_compressed;
! int         lzw_out_plain;
! int         lzw_in_compressed;
! int         lzw_in_plain;
  
  void
  DumpStats()
--- 514,530 ----
  int         delta_in_attempts;
  int         delta_in_hits;
  
! extern int  lzw_out_compressed;
! extern int  lzw_out_plain;
! extern int  lzw_in_compressed;
! extern int  lzw_in_plain;
! 
! extern int	    gfx_gc_hit;
! extern int	    gfx_gc_miss;
! extern int	    gfx_draw_hit;
! extern int	    gfx_draw_miss;
! extern int	    gfx_total;
! extern int	    gfx_bail;
  
  void
  DumpStats()
***************
*** 408,413 ****
--- 557,575 ----
  	    lzw_out_compressed, lzw_out_plain);
      fprintf(stderr, "Received: compressed bytes = %d (plain text = %d)\n",
  	    lzw_in_compressed, lzw_in_plain);
+     fprintf(stderr, "GFX Cache stats\n");
+     fprintf(stderr, "Bailed = %d reencoded = %d\n", gfx_bail, gfx_total);
+ #define percent(s,t)	((t) ? ((s) * 100) / (t) : 0)
+     
+ #define ratios(h,m)	(h), percent (h, (h)+(m)), (m), percent (m, (h) + (m))
+     fprintf(stderr, "Draw hit = %d (%d%%) miss = %d (%d%%) GC hit = %d (%d%%) miss = %d (%d%%)\n",
+ 	    ratios (gfx_draw_hit, gfx_draw_miss), 
+ 	    ratios (gfx_gc_hit, gfx_gc_miss));
+ #define savings(h,m)	(((h) + (m)) * 4) - ((h) + (m) * 5)
+     fprintf(stderr, "Total bytes saved = %d Draw = %d GC = %d\n",
+ 	    savings (gfx_gc_hit + gfx_draw_hit, gfx_gc_miss + gfx_draw_miss),
+ 	    savings (gfx_draw_hit, gfx_draw_miss),
+ 	    savings (gfx_gc_hit, gfx_gc_miss));
  }
  
  void
***************
*** 434,439 ****
--- 596,608 ----
      delta_in_total = delta_in_attempts = delta_in_hits = 0;
  
      lzw_out_compressed = lzw_out_plain = lzw_in_compressed = lzw_in_plain = 0;
+ 
+     gfx_gc_hit = 0;
+     gfx_gc_miss = 0;
+     gfx_draw_hit = 0;
+     gfx_draw_miss = 0;
+     gfx_total = 0;
+     gfx_bail = 0;
  }
  
  #endif
***************
*** 471,476 ****
--- 640,649 ----
      /* get more as needed */
      LBXMinKeyCode(client) = cs->minKeyCode;
      LBXMaxKeyCode(client) = cs->maxKeyCode;
+     LBXImageByteOrder(client) = cs->imageByteOrder;
+     LBXBitmapBitOrder(client) = cs->bitmapBitOrder;
+     LBXBitmapScanlineUnit(client) = cs->bitmapScanlineUnit;
+     LBXBitmapScanlinePad(client) = cs->bitmapScanlinePad;
  
      if (have_client_setup_info && !changes)
  	return;
*** -	Wed Jan 18 13:07:26 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/swap.h	Wed Jan 18 13:07:25 1995
***************
*** 1,4 ****
--- 1,6 ----
  /*
+  * $XConsortium: swap.h,v 1.3 94/12/01 20:41:41 mor Exp $
+  *
   * Copyright 1994 Network Computing Devices, Inc.
   *
   * Permission to use, copy, modify, distribute, and sell this software and
***************
*** 19,26 ****
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
!  * $NCDId: @(#)swap.h,v 1.1 1994/03/24 17:55:15 lemke Exp $
!  * $XConsortium: swap.h,v 1.1 94/03/27 14:27:25 dpw Exp $
   */
  
  #ifndef _SWAP_H_
--- 21,27 ----
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
!  * $NCDId: @(#)swap.h,v 1.3 1994/11/18 20:36:17 lemke Exp $
   */
  
  #ifndef _SWAP_H_
***************
*** 38,47 ****
--- 39,51 ----
  extern void SwapGetProperty();
  extern void SwapInvalidateTag();
  extern void SwapQueryTag();
+ extern void SwapQueryExtension();
  extern void SwapTagData();
  extern void SwapLbxConnSetupPrefix();
  extern void SwapConnSetupPrefix();
  extern void SwapConnectionInfo();
+ extern void SwapPutImage();
+ extern void SwapGetImage();
  
  extern void SwapGetPropertyReply();
  extern void SwapInternAtomReply();
***************
*** 52,57 ****
--- 56,62 ----
  extern void SwapModmapReply();
  extern void SwapKeymapReply();
  extern void SwapFont();
+ extern void SwapGetImageReply();
  
  extern void WriteSConnectionInfo();
  
*** -	Wed Jan 18 13:07:27 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/swaprep.c	Wed Jan 18 13:07:26 1995
***************
*** 1,4 ****
--- 1,6 ----
  /*
+  * $XConsortium: swaprep.c,v 1.3 94/12/01 20:53:19 mor Exp $
+  *
   * Copyright 1994 Network Computing Devices, Inc.
   *
   * Permission to use, copy, modify, distribute, and sell this software and
***************
*** 19,26 ****
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
!  * $NCDId: @(#)swaprep.c,v 1.3 1994/03/24 17:55:13 lemke Exp $
!  * $XConsortium: swaprep.c,v 1.1 94/03/27 14:27:43 dpw Exp $
   */
  
  #include	<stdio.h>
--- 21,27 ----
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
!  * $NCDId: @(#)swaprep.c,v 1.5 1994/11/18 20:36:00 lemke Exp $
   */
  
  #include	<stdio.h>
***************
*** 37,45 ****
  
  extern int  (*InitialVector[3]) ();
  extern int  (*ProcVector[256]) ();
- extern int  (*SwappedProcVector[256]) ();
- extern void (*EventSwapVector[128]) ();
- extern void (*ReplySwapVector[256]) ();
  
  void
  SwapConnSetup(pConnSetup, pConnSetupT)
--- 38,43 ----
***************
*** 314,319 ****
--- 312,328 ----
  
      swaps(&rep->sequenceNumber, n);
      swapl(&rep->length, n);
+ }
+ 
+ void
+ SwapGetImageReply (rep)
+     xGetImageReply *rep;
+ {
+     char n;
+ 
+     swaps (&rep->sequenceNumber, n);
+     swapl (&rep->length, n);
+     swapl (&rep->visual, n);
  }
  
  static void
*** -	Wed Jan 18 13:07:28 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/swapreq.c	Wed Jan 18 13:07:28 1995
***************
*** 1,4 ****
--- 1,6 ----
  /*
+  * $XConsortium: swapreq.c,v 1.3 94/12/01 20:54:00 mor Exp $
+  *
   * Copyright 1994 Network Computing Devices, Inc.
   *
   * Permission to use, copy, modify, distribute, and sell this software and
***************
*** 19,26 ****
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
!  * $NCDId: @(#)swapreq.c,v 1.2 1994/03/24 17:55:10 lemke Exp $
!  * $XConsortium: swapreq.c,v 1.1 94/03/27 14:27:44 dpw Exp $
   */
  
  #include	<stdio.h>
--- 21,27 ----
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
!  * $NCDId: @(#)swapreq.c,v 1.5 1994/11/18 20:35:58 lemke Exp $
   */
  
  #include	<stdio.h>
***************
*** 36,49 ****
  
  extern int  (*InitialVector[3]) ();
  extern int  (*ProcVector[256]) ();
- extern int  (*SwappedProcVector[256]) ();
- extern void (*EventSwapVector[128]) ();
- extern void (*ReplySwapVector[256]) ();
- 
- /* Thanks to Jack Palevich for testing and subsequently rewriting all this */
  
  /* Byte swap a list of longs */
- 
  void
  SwapLongs(list, count)
      register CARD32 *list;
--- 37,44 ----
***************
*** 72,78 ****
  }
  
  /* Byte swap a list of shorts */
- 
  void
  SwapShorts(list, count)
      register short *list;
--- 67,72 ----
***************
*** 108,1211 ****
      }
  }
  
- /* The following is used for all requests that have
-    no fields to be swapped (except "length") */
- int
- SProcSimpleReq(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xReq);
-     swaps(&stuff->length, n);
-     return (*ProcVector[stuff->reqType]) (client);
- }
- 
- /* The following is used for all requests that have
-    only a single 32-bit field to be swapped, coming
-    right after the "length" field */
- int
- SProcResourceReq(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xResourceReq);
-     swaps(&stuff->length, n);
-     REQUEST_AT_LEAST_SIZE(xResourceReq);	/* not EXACT */
-     swapl(&stuff->id, n);
-     return (*ProcVector[stuff->reqType]) (client);
- }
- 
- int
- SProcCreateWindow(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xCreateWindowReq);
-     swaps(&stuff->length, n);
-     REQUEST_AT_LEAST_SIZE(xCreateWindowReq);
-     swapl(&stuff->wid, n);
-     swapl(&stuff->parent, n);
-     swaps(&stuff->x, n);
-     swaps(&stuff->y, n);
-     swaps(&stuff->width, n);
-     swaps(&stuff->height, n);
-     swaps(&stuff->borderWidth, n);
-     swaps(&stuff->class, n);
-     swapl(&stuff->visual, n);
-     swapl(&stuff->mask, n);
-     SwapRestL(stuff);
-     return ((*ProcVector[X_CreateWindow]) (client));
- }
- 
- int
- SProcChangeWindowAttributes(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xChangeWindowAttributesReq);
-     swaps(&stuff->length, n);
-     REQUEST_AT_LEAST_SIZE(xChangeWindowAttributesReq);
-     swapl(&stuff->window, n);
-     swapl(&stuff->valueMask, n);
-     SwapRestL(stuff);
-     return ((*ProcVector[X_ChangeWindowAttributes]) (client));
- }
- 
- int
- SProcReparentWindow(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xReparentWindowReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xReparentWindowReq);
-     swapl(&stuff->window, n);
-     swapl(&stuff->parent, n);
-     swaps(&stuff->x, n);
-     swaps(&stuff->y, n);
-     return ((*ProcVector[X_ReparentWindow]) (client));
- }
- 
- int
- SProcConfigureWindow(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xConfigureWindowReq);
-     swaps(&stuff->length, n);
-     REQUEST_AT_LEAST_SIZE(xConfigureWindowReq);
-     swapl(&stuff->window, n);
-     swaps(&stuff->mask, n);
-     SwapRestL(stuff);
-     return ((*ProcVector[X_ConfigureWindow]) (client));
- 
- }
- 
- 
- int
- SProcInternAtom(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xInternAtomReq);
-     swaps(&stuff->length, n);
-     REQUEST_AT_LEAST_SIZE(xInternAtomReq);
-     swaps(&stuff->nbytes, n);
-     return ((*ProcVector[X_InternAtom]) (client));
- }
- 
- int
- SProcChangeProperty(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xChangePropertyReq);
-     swaps(&stuff->length, n);
-     REQUEST_AT_LEAST_SIZE(xChangePropertyReq);
-     swapl(&stuff->window, n);
-     swapl(&stuff->property, n);
-     swapl(&stuff->type, n);
-     swapl(&stuff->nUnits, n);
-     switch (stuff->format) {
-     case 8:
- 	break;
-     case 16:
- 	SwapRestS(stuff);
- 	break;
-     case 32:
- 	SwapRestL(stuff);
- 	break;
-     }
-     return ((*ProcVector[X_ChangeProperty]) (client));
- }
- 
- int
- SProcDeleteProperty(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xDeletePropertyReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xDeletePropertyReq);
-     swapl(&stuff->window, n);
-     swapl(&stuff->property, n);
-     return ((*ProcVector[X_DeleteProperty]) (client));
- 
- }
- 
- int
- SProcGetProperty(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xGetPropertyReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xGetPropertyReq);
-     swapl(&stuff->window, n);
-     swapl(&stuff->property, n);
-     swapl(&stuff->type, n);
-     swapl(&stuff->longOffset, n);
-     swapl(&stuff->longLength, n);
-     return ((*ProcVector[X_GetProperty]) (client));
- }
- 
- int
- SProcSetSelectionOwner(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xSetSelectionOwnerReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xSetSelectionOwnerReq);
-     swapl(&stuff->window, n);
-     swapl(&stuff->selection, n);
-     swapl(&stuff->time, n);
-     return ((*ProcVector[X_SetSelectionOwner]) (client));
- }
- 
- int
- SProcConvertSelection(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xConvertSelectionReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xConvertSelectionReq);
-     swapl(&stuff->requestor, n);
-     swapl(&stuff->selection, n);
-     swapl(&stuff->target, n);
-     swapl(&stuff->property, n);
-     swapl(&stuff->time, n);
-     return ((*ProcVector[X_ConvertSelection]) (client));
- }
- 
- int
- SProcSendEvent(client)
-     register ClientPtr client;
- {
- 
- #ifdef notyet
-     register char n;
-     xEvent      eventT;
-     void        (*proc) (),
-                 NotImplemented();
- 
-     REQUEST(xSendEventReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xSendEventReq);
-     swapl(&stuff->destination, n);
-     swapl(&stuff->eventMask, n);
- 
-     /* Swap event */
-     proc = EventSwapVector[stuff->event.u.u.type & 0177];
-     if (!proc || (int (*) ()) proc == (int (*) ()) NotImplemented)	/* no swapping proc;
- 									 * invalid event type? */
- 	return (BadValue);
-     (*proc) (&stuff->event, &eventT);
-     stuff->event = eventT;
- 
-     return ((*ProcVector[X_SendEvent]) (client));
- #endif
- }
- 
- int
- SProcGrabPointer(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xGrabPointerReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xGrabPointerReq);
-     swapl(&stuff->grabWindow, n);
-     swaps(&stuff->eventMask, n);
-     swapl(&stuff->confineTo, n);
-     swapl(&stuff->cursor, n);
-     swapl(&stuff->time, n);
-     return ((*ProcVector[X_GrabPointer]) (client));
- }
- 
- int
- SProcGrabButton(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xGrabButtonReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xGrabButtonReq);
-     swapl(&stuff->grabWindow, n);
-     swaps(&stuff->eventMask, n);
-     swapl(&stuff->confineTo, n);
-     swapl(&stuff->cursor, n);
-     swaps(&stuff->modifiers, n);
-     return ((*ProcVector[X_GrabButton]) (client));
- }
- 
- int
- SProcUngrabButton(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xUngrabButtonReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xUngrabButtonReq);
-     swapl(&stuff->grabWindow, n);
-     swaps(&stuff->modifiers, n);
-     return ((*ProcVector[X_UngrabButton]) (client));
- }
- 
- int
- SProcChangeActivePointerGrab(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xChangeActivePointerGrabReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xChangeActivePointerGrabReq);
-     swapl(&stuff->cursor, n);
-     swapl(&stuff->time, n);
-     swaps(&stuff->eventMask, n);
-     return ((*ProcVector[X_ChangeActivePointerGrab]) (client));
- }
- 
- int
- SProcGrabKeyboard(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xGrabKeyboardReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xGrabKeyboardReq);
-     swapl(&stuff->grabWindow, n);
-     swapl(&stuff->time, n);
-     return ((*ProcVector[X_GrabKeyboard]) (client));
- }
- 
- int
- SProcGrabKey(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xGrabKeyReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xGrabKeyReq);
-     swapl(&stuff->grabWindow, n);
-     swaps(&stuff->modifiers, n);
-     return ((*ProcVector[X_GrabKey]) (client));
- }
- 
- int
- SProcUngrabKey(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xUngrabKeyReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xUngrabKeyReq);
-     swapl(&stuff->grabWindow, n);
-     swaps(&stuff->modifiers, n);
-     return ((*ProcVector[X_UngrabKey]) (client));
- }
- 
- int
- SProcGetMotionEvents(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xGetMotionEventsReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xGetMotionEventsReq);
-     swapl(&stuff->window, n);
-     swapl(&stuff->start, n);
-     swapl(&stuff->stop, n);
-     return ((*ProcVector[X_GetMotionEvents]) (client));
- }
- 
- int
- SProcTranslateCoords(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xTranslateCoordsReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xTranslateCoordsReq);
-     swapl(&stuff->srcWid, n);
-     swapl(&stuff->dstWid, n);
-     swaps(&stuff->srcX, n);
-     swaps(&stuff->srcY, n);
-     return ((*ProcVector[X_TranslateCoords]) (client));
- }
- 
- int
- SProcWarpPointer(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xWarpPointerReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xWarpPointerReq);
-     swapl(&stuff->srcWid, n);
-     swapl(&stuff->dstWid, n);
-     swaps(&stuff->srcX, n);
-     swaps(&stuff->srcY, n);
-     swaps(&stuff->srcWidth, n);
-     swaps(&stuff->srcHeight, n);
-     swaps(&stuff->dstX, n);
-     swaps(&stuff->dstY, n);
-     return ((*ProcVector[X_WarpPointer]) (client));
- }
- 
- int
- SProcSetInputFocus(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xSetInputFocusReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xSetInputFocusReq);
-     swapl(&stuff->focus, n);
-     swapl(&stuff->time, n);
-     return ((*ProcVector[X_SetInputFocus]) (client));
- }
- 
- int
- SProcOpenFont(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xOpenFontReq);
-     swaps(&stuff->length, n);
-     REQUEST_AT_LEAST_SIZE(xOpenFontReq);
-     swapl(&stuff->fid, n);
-     swaps(&stuff->nbytes, n);
-     return ((*ProcVector[X_OpenFont]) (client));
- }
- 
- int
- SProcListFonts(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xListFontsReq);
-     swaps(&stuff->length, n);
-     REQUEST_AT_LEAST_SIZE(xListFontsReq);
-     swaps(&stuff->maxNames, n);
-     swaps(&stuff->nbytes, n);
-     return ((*ProcVector[X_ListFonts]) (client));
- }
- 
- int
- SProcListFontsWithInfo(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xListFontsWithInfoReq);
-     swaps(&stuff->length, n);
-     REQUEST_AT_LEAST_SIZE(xListFontsWithInfoReq);
-     swaps(&stuff->maxNames, n);
-     swaps(&stuff->nbytes, n);
-     return ((*ProcVector[X_ListFontsWithInfo]) (client));
- }
- 
- int
- SProcSetFontPath(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xSetFontPathReq);
-     swaps(&stuff->length, n);
-     REQUEST_AT_LEAST_SIZE(xSetFontPathReq);
-     swaps(&stuff->nFonts, n);
-     return ((*ProcVector[X_SetFontPath]) (client));
- }
- 
- int
- SProcCreatePixmap(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xCreatePixmapReq);
- 
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xCreatePixmapReq);
-     swapl(&stuff->pid, n);
-     swapl(&stuff->drawable, n);
-     swaps(&stuff->width, n);
-     swaps(&stuff->height, n);
-     return ((*ProcVector[X_CreatePixmap]) (client));
- }
- 
- int
- SProcCreateGC(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xCreateGCReq);
-     swaps(&stuff->length, n);
-     REQUEST_AT_LEAST_SIZE(xCreateGCReq);
-     swapl(&stuff->gc, n);
-     swapl(&stuff->drawable, n);
-     swapl(&stuff->mask, n);
-     SwapRestL(stuff);
-     return ((*ProcVector[X_CreateGC]) (client));
- }
- 
- int
- SProcChangeGC(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xChangeGCReq);
-     swaps(&stuff->length, n);
-     REQUEST_AT_LEAST_SIZE(xChangeGCReq);
-     swapl(&stuff->gc, n);
-     swapl(&stuff->mask, n);
-     SwapRestL(stuff);
-     return ((*ProcVector[X_ChangeGC]) (client));
- }
- 
- int
- SProcCopyGC(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xCopyGCReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xCopyGCReq);
-     swapl(&stuff->srcGC, n);
-     swapl(&stuff->dstGC, n);
-     swapl(&stuff->mask, n);
-     return ((*ProcVector[X_CopyGC]) (client));
- }
- 
- int
- SProcSetDashes(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xSetDashesReq);
-     swaps(&stuff->length, n);
-     REQUEST_AT_LEAST_SIZE(xSetDashesReq);
-     swapl(&stuff->gc, n);
-     swaps(&stuff->dashOffset, n);
-     swaps(&stuff->nDashes, n);
-     return ((*ProcVector[X_SetDashes]) (client));
- 
- }
- 
- int
- SProcSetClipRectangles(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xSetClipRectanglesReq);
-     swaps(&stuff->length, n);
-     REQUEST_AT_LEAST_SIZE(xSetClipRectanglesReq);
-     swapl(&stuff->gc, n);
-     swaps(&stuff->xOrigin, n);
-     swaps(&stuff->yOrigin, n);
-     SwapRestS(stuff);
-     return ((*ProcVector[X_SetClipRectangles]) (client));
- }
- 
- int
- SProcClearToBackground(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xClearAreaReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xClearAreaReq);
-     swapl(&stuff->window, n);
-     swaps(&stuff->x, n);
-     swaps(&stuff->y, n);
-     swaps(&stuff->width, n);
-     swaps(&stuff->height, n);
-     return ((*ProcVector[X_ClearArea]) (client));
- }
- 
- int
- SProcCopyArea(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xCopyAreaReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xCopyAreaReq);
-     swapl(&stuff->srcDrawable, n);
-     swapl(&stuff->dstDrawable, n);
-     swapl(&stuff->gc, n);
-     swaps(&stuff->srcX, n);
-     swaps(&stuff->srcY, n);
-     swaps(&stuff->dstX, n);
-     swaps(&stuff->dstY, n);
-     swaps(&stuff->width, n);
-     swaps(&stuff->height, n);
-     return ((*ProcVector[X_CopyArea]) (client));
- }
- 
- int
- SProcCopyPlane(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xCopyPlaneReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xCopyPlaneReq);
-     swapl(&stuff->srcDrawable, n);
-     swapl(&stuff->dstDrawable, n);
-     swapl(&stuff->gc, n);
-     swaps(&stuff->srcX, n);
-     swaps(&stuff->srcY, n);
-     swaps(&stuff->dstX, n);
-     swaps(&stuff->dstY, n);
-     swaps(&stuff->width, n);
-     swaps(&stuff->height, n);
-     swapl(&stuff->bitPlane, n);
-     return ((*ProcVector[X_CopyPlane]) (client));
- }
- 
- /* The following routine is used for all Poly drawing requests
-    (except FillPoly, which uses a different request format) */
- int
- SProcPoly(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xPolyPointReq);
-     swaps(&stuff->length, n);
-     REQUEST_AT_LEAST_SIZE(xPolyPointReq);
-     swapl(&stuff->drawable, n);
-     swapl(&stuff->gc, n);
-     SwapRestS(stuff);
-     return ((*ProcVector[stuff->reqType]) (client));
- }
- 
- /* cannot use SProcPoly for this one, because xFillPolyReq
-    is longer than xPolyPointReq, and we don't want to swap
-    the difference as shorts! */
- int
- SProcFillPoly(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xFillPolyReq);
-     swaps(&stuff->length, n);
-     REQUEST_AT_LEAST_SIZE(xFillPolyReq);
-     swapl(&stuff->drawable, n);
-     swapl(&stuff->gc, n);
-     SwapRestS(stuff);
-     return ((*ProcVector[X_FillPoly]) (client));
- }
- 
- int
- SProcPutImage(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xPutImageReq);
-     swaps(&stuff->length, n);
-     REQUEST_AT_LEAST_SIZE(xPutImageReq);
-     swapl(&stuff->drawable, n);
-     swapl(&stuff->gc, n);
-     swaps(&stuff->width, n);
-     swaps(&stuff->height, n);
-     swaps(&stuff->dstX, n);
-     swaps(&stuff->dstY, n);
-     /* Image should already be swapped */
-     return ((*ProcVector[X_PutImage]) (client));
- 
- }
- 
- int
- SProcGetImage(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xGetImageReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xGetImageReq);
-     swapl(&stuff->drawable, n);
-     swaps(&stuff->x, n);
-     swaps(&stuff->y, n);
-     swaps(&stuff->width, n);
-     swaps(&stuff->height, n);
-     swapl(&stuff->planeMask, n);
-     return ((*ProcVector[X_GetImage]) (client));
- }
- 
- /* ProcPolyText used for both PolyText8 and PolyText16 */
- 
- int
- SProcPolyText(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xPolyTextReq);
-     swaps(&stuff->length, n);
-     REQUEST_AT_LEAST_SIZE(xPolyTextReq);
-     swapl(&stuff->drawable, n);
-     swapl(&stuff->gc, n);
-     swaps(&stuff->x, n);
-     swaps(&stuff->y, n);
-     return ((*ProcVector[stuff->reqType]) (client));
- }
- 
- /* ProcImageText used for both ImageText8 and ImageText16 */
- 
- int
- SProcImageText(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xImageTextReq);
-     swaps(&stuff->length, n);
-     REQUEST_AT_LEAST_SIZE(xImageTextReq);
-     swapl(&stuff->drawable, n);
-     swapl(&stuff->gc, n);
-     swaps(&stuff->x, n);
-     swaps(&stuff->y, n);
-     return ((*ProcVector[stuff->reqType]) (client));
- }
- 
- int
- SProcCreateColormap(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xCreateColormapReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xCreateColormapReq);
-     swapl(&stuff->mid, n);
-     swapl(&stuff->window, n);
-     swapl(&stuff->visual, n);
-     return ((*ProcVector[X_CreateColormap]) (client));
- }
- 
- 
- int
- SProcCopyColormapAndFree(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xCopyColormapAndFreeReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xCopyColormapAndFreeReq);
-     swapl(&stuff->mid, n);
-     swapl(&stuff->srcCmap, n);
-     return ((*ProcVector[X_CopyColormapAndFree]) (client));
- 
- }
- 
- int
- SProcAllocColor(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xAllocColorReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xAllocColorReq);
-     swapl(&stuff->cmap, n);
-     swaps(&stuff->red, n);
-     swaps(&stuff->green, n);
-     swaps(&stuff->blue, n);
-     return ((*ProcVector[X_AllocColor]) (client));
- }
- 
- int
- SProcAllocNamedColor(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xAllocNamedColorReq);
-     swaps(&stuff->length, n);
-     REQUEST_AT_LEAST_SIZE(xAllocNamedColorReq);
-     swapl(&stuff->cmap, n);
-     swaps(&stuff->nbytes, n);
-     return ((*ProcVector[X_AllocNamedColor]) (client));
- }
- 
- int
- SProcAllocColorCells(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xAllocColorCellsReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xAllocColorCellsReq);
-     swapl(&stuff->cmap, n);
-     swaps(&stuff->colors, n);
-     swaps(&stuff->planes, n);
-     return ((*ProcVector[X_AllocColorCells]) (client));
- }
- 
- int
- SProcAllocColorPlanes(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xAllocColorPlanesReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xAllocColorPlanesReq);
-     swapl(&stuff->cmap, n);
-     swaps(&stuff->colors, n);
-     swaps(&stuff->red, n);
-     swaps(&stuff->green, n);
-     swaps(&stuff->blue, n);
-     return ((*ProcVector[X_AllocColorPlanes]) (client));
- }
- 
- int
- SProcFreeColors(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xFreeColorsReq);
-     swaps(&stuff->length, n);
-     REQUEST_AT_LEAST_SIZE(xFreeColorsReq);
-     swapl(&stuff->cmap, n);
-     swapl(&stuff->planeMask, n);
-     SwapRestL(stuff);
-     return ((*ProcVector[X_FreeColors]) (client));
- 
- }
- 
- void
- SwapColorItem(pItem)
-     xColorItem *pItem;
- {
-     register char n;
- 
-     swapl(&pItem->pixel, n);
-     swaps(&pItem->red, n);
-     swaps(&pItem->green, n);
-     swaps(&pItem->blue, n);
- }
- 
- int
- SProcStoreColors(client)
-     register ClientPtr client;
- {
-     register char n;
-     long        count;
-     xColorItem *pItem;
- 
-     REQUEST(xStoreColorsReq);
-     swaps(&stuff->length, n);
-     REQUEST_AT_LEAST_SIZE(xStoreColorsReq);
-     swapl(&stuff->cmap, n);
-     pItem = (xColorItem *) & stuff[1];
-     for (count = LengthRestB(stuff) / sizeof(xColorItem); --count >= 0;)
- 	SwapColorItem(pItem++);
-     return ((*ProcVector[X_StoreColors]) (client));
- }
- 
- int
- SProcStoreNamedColor(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xStoreNamedColorReq);
-     swaps(&stuff->length, n);
-     REQUEST_AT_LEAST_SIZE(xStoreNamedColorReq);
-     swapl(&stuff->cmap, n);
-     swapl(&stuff->pixel, n);
-     swaps(&stuff->nbytes, n);
-     return ((*ProcVector[X_StoreNamedColor]) (client));
- }
- 
- int
- SProcQueryColors(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xQueryColorsReq);
-     swaps(&stuff->length, n);
-     REQUEST_AT_LEAST_SIZE(xQueryColorsReq);
-     swapl(&stuff->cmap, n);
-     SwapRestL(stuff);
-     return ((*ProcVector[X_QueryColors]) (client));
- }
- 
- int
- SProcLookupColor(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xLookupColorReq);
-     swaps(&stuff->length, n);
-     REQUEST_AT_LEAST_SIZE(xLookupColorReq);
-     swapl(&stuff->cmap, n);
-     swaps(&stuff->nbytes, n);
-     return ((*ProcVector[X_LookupColor]) (client));
- }
- 
- int
- SProcCreateCursor(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xCreateCursorReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xCreateCursorReq);
-     swapl(&stuff->cid, n);
-     swapl(&stuff->source, n);
-     swapl(&stuff->mask, n);
-     swaps(&stuff->foreRed, n);
-     swaps(&stuff->foreGreen, n);
-     swaps(&stuff->foreBlue, n);
-     swaps(&stuff->backRed, n);
-     swaps(&stuff->backGreen, n);
-     swaps(&stuff->backBlue, n);
-     swaps(&stuff->x, n);
-     swaps(&stuff->y, n);
-     return ((*ProcVector[X_CreateCursor]) (client));
- }
- 
- int
- SProcCreateGlyphCursor(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xCreateGlyphCursorReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xCreateGlyphCursorReq);
-     swapl(&stuff->cid, n);
-     swapl(&stuff->source, n);
-     swapl(&stuff->mask, n);
-     swaps(&stuff->sourceChar, n);
-     swaps(&stuff->maskChar, n);
-     swaps(&stuff->foreRed, n);
-     swaps(&stuff->foreGreen, n);
-     swaps(&stuff->foreBlue, n);
-     swaps(&stuff->backRed, n);
-     swaps(&stuff->backGreen, n);
-     swaps(&stuff->backBlue, n);
-     return ((*ProcVector[X_CreateGlyphCursor]) (client));
- }
- 
- 
- int
- SProcRecolorCursor(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xRecolorCursorReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xRecolorCursorReq);
-     swapl(&stuff->cursor, n);
-     swaps(&stuff->foreRed, n);
-     swaps(&stuff->foreGreen, n);
-     swaps(&stuff->foreBlue, n);
-     swaps(&stuff->backRed, n);
-     swaps(&stuff->backGreen, n);
-     swaps(&stuff->backBlue, n);
-     return ((*ProcVector[X_RecolorCursor]) (client));
- }
- 
- int
- SProcQueryBestSize(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xQueryBestSizeReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xQueryBestSizeReq);
-     swapl(&stuff->drawable, n);
-     swaps(&stuff->width, n);
-     swaps(&stuff->height, n);
-     return ((*ProcVector[X_QueryBestSize]) (client));
- 
- }
- 
- int
- SProcQueryExtension(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xQueryExtensionReq);
-     swaps(&stuff->length, n);
-     REQUEST_AT_LEAST_SIZE(xQueryExtensionReq);
-     swaps(&stuff->nbytes, n);
-     return ((*ProcVector[X_QueryExtension]) (client));
- }
- 
- int
- SProcChangeKeyboardMapping(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xChangeKeyboardMappingReq);
-     swaps(&stuff->length, n);
-     REQUEST_AT_LEAST_SIZE(xChangeKeyboardMappingReq);
-     SwapRestL(stuff);
-     return ((*ProcVector[X_ChangeKeyboardMapping]) (client));
- }
- 
- 
- int
- SProcChangeKeyboardControl(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xChangeKeyboardControlReq);
-     swaps(&stuff->length, n);
-     REQUEST_AT_LEAST_SIZE(xChangeKeyboardControlReq);
-     swapl(&stuff->mask, n);
-     SwapRestL(stuff);
-     return ((*ProcVector[X_ChangeKeyboardControl]) (client));
- }
- 
- int
- SProcChangePointerControl(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xChangePointerControlReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xChangePointerControlReq);
-     swaps(&stuff->accelNum, n);
-     swaps(&stuff->accelDenum, n);
-     swaps(&stuff->threshold, n);
-     return ((*ProcVector[X_ChangePointerControl]) (client));
- }
- 
- 
- int
- SProcSetScreenSaver(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xSetScreenSaverReq);
-     swaps(&stuff->length, n);
-     REQUEST_SIZE_MATCH(xSetScreenSaverReq);
-     swaps(&stuff->timeout, n);
-     swaps(&stuff->interval, n);
-     return ((*ProcVector[X_SetScreenSaver]) (client));
- }
- 
- int
- SProcChangeHosts(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xChangeHostsReq);
-     swaps(&stuff->length, n);
-     REQUEST_AT_LEAST_SIZE(xChangeHostsReq);
-     swaps(&stuff->hostLength, n);
-     return ((*ProcVector[X_ChangeHosts]) (client));
- 
- }
- 
- int
- SProcRotateProperties(client)
-     register ClientPtr client;
- {
-     register char n;
- 
-     REQUEST(xRotatePropertiesReq);
-     swaps(&stuff->length, n);
-     REQUEST_AT_LEAST_SIZE(xRotatePropertiesReq);
-     swapl(&stuff->window, n);
-     swaps(&stuff->nAtoms, n);
-     swaps(&stuff->nPositions, n);
-     SwapRestL(stuff);
-     return ((*ProcVector[X_RotateProperties]) (client));
- }
- 
- /*ARGSUSED*/
- int
- SProcNoOperation(client)
-     ClientPtr   client;
- {
-     register char n;
- 
-     REQUEST(xReq);
-     swaps(&stuff->length, n);
-     return ((*ProcVector[X_NoOperation]) (client));
- }
- 
  void
  SwapConnClientPrefix(pCCP)
      xConnClientPrefix *pCCP;
--- 102,107 ----
***************
*** 1218,1225 ****
      swaps(&pCCP->nbytesAuthString, n);
  }
  
- 
- 
  void
  SwapNewClient(r)
      xLbxNewClientReq *r;
--- 114,119 ----
***************
*** 1307,1312 ****
--- 201,235 ----
  }
  
  void
+ SwapPutImage (r)
+     xLbxPutImageReq *r;
+ {
+     char        n;
+ 
+     swaps(&r->xLength, n);
+     swapl(&r->drawable, n);
+     swapl(&r->gc, n);
+     swaps(&r->width, n);
+     swaps(&r->height, n);
+     swaps(&r->dstX, n);
+     swaps(&r->dstY, n);
+ }
+ 
+ void
+ SwapGetImage (r)
+     xLbxGetImageReq *r;
+ {
+     char        n;
+ 
+     swapl(&r->drawable, n);
+     swaps(&r->x, n);
+     swaps(&r->y, n);
+     swaps(&r->width, n);
+     swaps(&r->height, n);
+     swapl(&r->planeMask, n);
+ }
+ 
+ void
  SwapQueryTag(r)
      xLbxQueryTagReq *r;
  {
***************
*** 1332,1337 ****
--- 255,269 ----
  
      swapl(&r->real_length, n);
      swapl(&r->tag, n);
+ }
+ 
+ void
+ SwapQueryExtension(r)
+     xLbxQueryExtensionReq *r;
+ {
+     char        n;
+ 
+     swapl(&r->nbytes, n);
  }
  
  void
*** /dev/null	Wed Jan 18 13:07:30 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/extensions.c	Wed Jan 18 13:07:30 1995
***************
*** 0 ****
--- 1,477 ----
+ /* $XConsortium: extensions.c,v 1.1 94/12/01 20:39:01 mor Exp $ */
+ /*
+  * Copyright 1994 Network Computing Devices, Inc.
+  *
+  * Permission to use, copy, modify, distribute, and sell this software and
+  * its documentation for any purpose is hereby granted without fee, provided
+  * that the above copyright notice appear in all copies and that both that
+  * copyright notice and this permission notice appear in supporting
+  * documentation, and that the name Network Computing Devices, Inc. not be
+  * used in advertising or publicity pertaining to distribution of this
+  * software without specific, written prior permission.
+  *
+  * THIS SOFTWARE IS PROVIDED `AS-IS'.  NETWORK COMPUTING DEVICES, INC.,
+  * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT
+  * LIMITATION ALL IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
+  * PARTICULAR PURPOSE, OR NONINFRINGEMENT.  IN NO EVENT SHALL NETWORK
+  * COMPUTING DEVICES, INC., BE LIABLE FOR ANY DAMAGES WHATSOEVER, INCLUDING
+  * SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES, INCLUDING LOSS OF USE, DATA,
+  * OR PROFITS, EVEN IF ADVISED OF THE POSSIBILITY THEREOF, AND REGARDLESS OF
+  * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
+  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  *
+  * $NCDId: @(#)extensions.c,v 1.6 1994/09/24 01:07:42 lemke Exp $
+  */
+ 
+ /* tracks server extensions, and provides hooks for supporting them */
+ 
+ #include	"X.h"
+ #define NEED_REPLIES
+ #define NEED_EVENTS
+ #include	"Xproto.h"
+ #include	"assert.h"
+ #include	"wire.h"
+ #include	"lbxdata.h"
+ #include	"lbxext.h"
+ #include	"lbx.h"
+ #include	"reqtype.h"
+ #define _XLBX_SERVER_
+ #include	"lbxstr.h"
+ 
+ /* XXX does this handle extension aliases properly? */
+ typedef struct _extinfo {
+     char       *name;
+     int         idx;
+     int         opcode;
+     int         event;
+     int         error;
+     int         num_users;
+     CARD8      *rep_mask,
+                *ev_mask;
+     int         num_reqs;
+     ClientPtr  *users;
+     struct _extinfo *next;
+ }           ExtensionInfoRec, *ExtensionInfoPtr;
+ 
+ static ExtensionInfoPtr extension_list = NULL;
+ 
+ static ExtensionVectors supported_extensions[MAX_SUPPORTED_EXTENSIONS];
+ static int  num_supported_extensions;
+ 
+ void
+ RegisterExtension(new)
+     ExtensionVectors *new;
+ {
+     if (num_supported_extensions >= MAX_SUPPORTED_EXTENSIONS)
+ 	FatalError("Too may supported extensions");
+     supported_extensions[num_supported_extensions++] = *new;
+ }
+ 
+ static void
+ add_vectors(eip)
+     ExtensionInfoPtr eip;
+ {
+     int         i;
+ 
+     for (i = 0; i < num_supported_extensions; i++) {
+ 	if (strcmp(eip->name, supported_extensions[i].name) == 0) {
+ 	    eip->idx = i;
+ 	    ProcVector[eip->opcode] = supported_extensions[i].req_vector;
+ 	    return;
+ 	}
+     }
+ }
+ 
+ static void
+ remove_vectors(eip)
+     ExtensionInfoPtr eip;
+ {
+     extern int  ProcStandardRequest();
+ 
+     ProcVector[eip->opcode] = ProcStandardRequest;
+ }
+ 
+ Bool
+ AddExtension(client, name, reply, rep_mask, ev_mask)
+     ClientPtr   client;
+     char       *name;
+     xLbxQueryExtensionReply *reply;
+     CARD8      *rep_mask,
+                *ev_mask;
+ {
+     int         i;
+     ExtensionInfoPtr eip = NULL;
+     ClientPtr  *newclients;
+     int         req_mask_len;
+ 
+     eip = extension_list;
+     while (eip) {
+ 	if (strcmp(eip->name, name) == 0) {
+ 	    break;
+ 	}
+ 	eip = eip->next;
+     }
+     if (eip) {			/* another use */
+ 	/* be sure its not already here */
+ 	for (i = 0; i < eip->num_users; i++) {
+ 	    if (eip->users[i] == client) {
+ 		return TRUE;
+ 	    }
+ 	}
+ 	newclients = (ClientPtr *) xrealloc(eip->users,
+ 				   (eip->num_users + 1) * sizeof(ClientPtr));
+ 	if (newclients) {
+ 	    eip->users = newclients;
+ 	    eip->users[eip->num_users++] = client;
+ 	    return TRUE;
+ 	} else {
+ 	    return FALSE;
+ 	}
+     } else {			/* new one */
+ 	eip = (ExtensionInfoPtr) xalloc(sizeof(ExtensionInfoRec));
+ 	if (!eip)
+ 	    return FALSE;
+ 	eip->users = (ClientPtr *) xalloc(sizeof(ClientPtr));
+ 	if (!eip->users) {
+ 	    xfree(eip);
+ 	    return FALSE;
+ 	}
+ 	eip->name = (char *) xalloc(strlen(name) + 1);
+ 	if (!eip->name) {
+ 	    xfree(eip->users);
+ 	    xfree(eip);
+ 	    return FALSE;
+ 	}
+ 	req_mask_len = (reply->numReqs / (8 * sizeof(CARD8))) + 1;
+ 	eip->rep_mask = (CARD8 *) xalloc(sizeof(CARD8) * req_mask_len);
+ 	eip->ev_mask = (CARD8 *) xalloc(sizeof(CARD8) * req_mask_len);
+ 	if (!eip->rep_mask || !eip->ev_mask) {
+ 	    xfree(eip->rep_mask);
+ 	    xfree(eip->ev_mask);
+ 	    xfree(eip->name);
+ 	    xfree(eip->users);
+ 	    xfree(eip);
+ 	    return FALSE;
+ 	}
+ 	strcpy(eip->name, name);
+ 
+ 	if (reply->numReqs) {
+ 	    bcopy((char *) rep_mask, (char *) eip->rep_mask, req_mask_len);
+ 	    bcopy((char *) ev_mask, (char *) eip->ev_mask, req_mask_len);
+ 	}
+ 	eip->num_reqs = reply->numReqs;
+ 
+ 	eip->opcode = reply->major_opcode;
+ 	eip->event = reply->first_event;
+ 	eip->error = reply->first_error;
+ 	eip->users[0] = client;
+ 	eip->num_users = 1;
+ 	eip->next = extension_list;
+ 	extension_list = eip;
+ 	add_vectors(eip);
+ 	return TRUE;
+     }
+ }
+ 
+ static Bool
+ known_extension(name)
+     char       *name;
+ {
+     ExtensionInfoPtr eip;
+ 
+     eip = extension_list;
+     while (eip) {
+ 	if (strcmp(eip->name, name) == 0)
+ 	    return TRUE;
+ 	eip = eip->next;
+     }
+     return FALSE;
+ }
+ 
+ static Bool
+ has_extension(eip, client)
+     ExtensionInfoPtr eip;
+     ClientPtr   client;
+ {
+     int         i;
+ 
+     for (i = 0; i < eip->num_users; i++) {
+ 	if (eip->users[i] == client)
+ 	    return TRUE;
+     }
+     return FALSE;
+ }
+ 
+ static void
+ remove_user(eip, client)
+     ExtensionInfoPtr eip;
+     ClientPtr   client;
+ {
+     int         i;
+ 
+     if (eip->num_users == 1) {
+ 	xfree(eip->users);
+ 	eip->users = NULL;
+ 	eip->num_users = 0;
+ 	return;
+     } else {
+ 	for (i = 0; i < eip->num_users; i++) {
+ 	    if (eip->users[i] == client) {
+ 		eip->num_users--;
+ 		if ((eip->num_users - i) > 0) {
+ 		    /* collapse list if not at end */
+ 		    bcopy((char *) eip->users[i + 1], (char *) eip->users[i],
+ 			  sizeof(ClientPtr) * (eip->num_users - i));
+ 		}
+ 		/* shrink it */
+ 		eip->users = (ClientPtr *) xrealloc(eip->users,
+ 					 sizeof(ClientPtr) * eip->num_users);
+ 		return;
+ 	    }
+ 	}
+     }
+ }
+ 
+ void
+ DeleteClientExtensions(client)
+     ClientPtr   client;
+ {
+     ExtensionInfoPtr eip,
+                 top = NULL,
+                 next;
+ 
+     eip = extension_list;
+     while (eip) {
+ 	next = eip->next;
+ 	if (has_extension(eip, client)) {
+ 	    remove_user(eip, client);
+ 	}
+ 	eip = next;
+     }
+     eip = extension_list;
+     while (eip) {
+ 	next = eip->next;
+ 	if (eip->num_users == 0) {
+ 	    remove_vectors(eip);
+ 	    xfree(eip->name);
+ 	    xfree(eip->users);
+ 	    xfree(eip->rep_mask);
+ 	    xfree(eip->ev_mask);
+ 	    xfree(eip);
+ 	    if (!top || top == eip)
+ 		top = next;
+ 	}
+ 	eip = next;
+     }
+     extension_list = top;
+ }
+ 
+ void
+ RegisterAllExtensions()
+ {
+ }
+ 
+ void
+ InitExtensions()
+ {
+     extension_list = NULL;
+ }
+ 
+ void
+ ShutdownExtensions()
+ {
+     ExtensionInfoPtr eip,
+                 next;
+ 
+     eip = extension_list;
+     while (eip) {
+ 	next = eip->next;
+ 	xfree(eip->users);
+ 	xfree(eip->name);
+ 	xfree(eip->rep_mask);
+ 	xfree(eip->ev_mask);
+ 	xfree(eip);
+ 	eip = next;
+     }
+ }
+ 
+ void
+ HandleExtensionError(client, err)
+     ClientPtr   client;
+     xError     *err;
+ {
+     if (err->errorCode < FirstExtensionError)
+ 	return;
+ }
+ 
+ void
+ HandleExtensionEvent(client, ev)
+     ClientPtr   client;
+     xEvent     *ev;
+ {
+     if ((ev->u.u.type & 0x7f) < LASTEvent)
+ 	return;
+ }
+ 
+ Bool
+ HandleExtensionReply(client, reply, nr)
+     ClientPtr   client;
+     xReply     *reply;
+     ReplyStuffPtr nr;
+ {
+     return TRUE;
+ }
+ 
+ static Bool
+ check_mask(mask, minor)
+     CARD8      *mask;
+     int         minor;
+ {
+     int         mword;
+ 
+     mword = minor / (8 * sizeof(CARD8));
+     if (mask[mword] & (1 << (minor % (8 * sizeof(CARD8)))))
+ 	return REQ_TYPE_YES;
+     else
+ 	REQ_TYPE_NO;
+ }
+ 
+ Bool
+ CheckExtensionForEvents(req)
+     xReq       *req;
+ {
+     int         opcode = req->reqType;
+     int         minor = req->data;
+     int         mword;
+     ExtensionInfoPtr eip;
+ 
+     eip = extension_list;
+     while (eip) {
+ 	if (eip->opcode == opcode) {
+ 	    if (!eip->ev_mask || eip->num_reqs == 0)
+ 		return TRUE;	/* assume worst */
+ 	    return check_mask(eip->ev_mask, minor);
+ 	}
+ 	eip = eip->next;
+     }
+     /* assume the worst */
+     return TRUE;
+ }
+ 
+ Bool
+ CheckExtensionForReplies(req)
+     xReq       *req;
+ {
+     int         opcode = req->reqType;
+     int         minor = req->data;
+     int         mword;
+     ExtensionInfoPtr eip;
+ 
+     eip = extension_list;
+     while (eip) {
+ 	if (eip->opcode == opcode) {
+ 	    if (!eip->rep_mask || eip->num_reqs == 0)
+ 		return REQ_TYPE_MAYBE;	/* assume worst */
+ 	    return check_mask(eip->rep_mask, minor);
+ 	}
+ 	eip = eip->next;
+     }
+     /* assume the worst */
+     return REQ_TYPE_MAYBE;
+ }
+ 
+ Bool
+ HandleLbxQueryExtensionReply(client, data)
+     ClientPtr   client;
+     char       *data;
+ {
+     xLbxQueryExtensionReply *reply;
+     xQueryExtensionReply crep;
+     ReplyStuffPtr nr;
+     char       *ename;
+     int         req_mask_len;
+     char       *rep_mask = NULL,
+                *ev_mask = NULL;
+ 
+     reply = (xLbxQueryExtensionReply *) data;
+ 
+     nr = GetMatchingReply(client, reply->sequenceNumber);
+     assert(nr);
+ 
+     ename = nr->request_info.lbxqueryextension.name;
+ 
+     if (reply->length) {
+ 	rep_mask = (char *) &reply[1];
+ 	req_mask_len = (reply->numReqs / (8 * sizeof(CARD8))) + 1;
+ 	/* round to word size */
+ 	req_mask_len = (((req_mask_len + 3) >> 2) << 2);
+ 	ev_mask = rep_mask + req_mask_len;
+     }
+     if (reply->present)
+ 	AddExtension(client, ename, reply, rep_mask, ev_mask);
+     xfree(ename);
+ 
+     /* and finally tell client about it */
+     crep.type = X_Reply;
+     crep.length = 0;
+     crep.sequenceNumber = reply->sequenceNumber;
+     crep.present = reply->present;
+     crep.major_opcode = reply->major_opcode;
+     crep.first_event = reply->first_event;
+     crep.first_error = reply->first_error;
+     WriteToClient(client, sizeof(xQueryExtensionReply), (char *) &crep);
+ 
+     return TRUE;
+ }
+ 
+ static int
+ query_extension_req(client, data)
+     ClientPtr   client;
+     char       *data;
+ {
+     xQueryExtensionReq *xreq;
+     char        n;
+     char       *ename;
+     xLbxQueryExtensionReq req;
+     XServerPtr  server;
+     CARD16      nlen;
+     ReplyStuffPtr nr;
+ 
+     /* just want to see this one so we can precede it with our own query */
+     xreq = (xQueryExtensionReq *) data;
+     nlen = xreq->nbytes;
+     if (client->swapped) {
+ 	swaps(&nlen, n);
+     }
+     ename = (char *) xalloc(nlen + 1);
+     if (!ename)
+ 	return BadAlloc;
+     bcopy((char *) &xreq[1], ename, nlen);
+     ename[nlen] = '\0';
+ 
+     req.reqType = client->server->lbxReq;
+     req.lbxReqType = X_LbxQueryExtension;
+     req.length = 2 + ((nlen + 3) >> 2);
+     req.nbytes = nlen;
+     if (client->swapped) {
+ 	SwapQueryExtension(&req);
+     }
+     nr = NewReply(client);
+     nr->request_info.lbxqueryextension.name = ename;
+     nr->sequenceNumber = LBXSequenceNumber(client);
+     nr->request = X_LbxQueryExtension;
+     nr->extension = client->server->lbxReq;
+     nr->lbx_req = TRUE;
+     WriteToServer(client, sizeof(req), (char *) &req);
+     WriteToServer(client, nlen, ename);
+ 
+     return Success;
+ }
+ 
+ int
+ ProcLBXQueryExtension(client)
+     ClientPtr   client;
+ {
+     /* replacing this with outr own version that also returns the masks */
+     return query_extension_req(client, client->requestBuffer);
+ }
*** /dev/null	Wed Jan 18 13:07:32 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/lbxext.h	Wed Jan 18 13:07:32 1995
***************
*** 0 ****
--- 1,71 ----
+ /* $XConsortium: lbxext.h,v 1.1 94/12/01 20:39:01 mor Exp $ */
+ /*
+  * Copyright 1994 Network Computing Devices, Inc.
+  *
+  * Permission to use, copy, modify, distribute, and sell this software and
+  * its documentation for any purpose is hereby granted without fee, provided
+  * that the above copyright notice appear in all copies and that both that
+  * copyright notice and this permission notice appear in supporting
+  * documentation, and that the name Network Computing Devices, Inc. not be
+  * used in advertising or publicity pertaining to distribution of this
+  * software without specific, written prior permission.
+  *
+  * THIS SOFTWARE IS PROVIDED `AS-IS'.  NETWORK COMPUTING DEVICES, INC.,
+  * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT
+  * LIMITATION ALL IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
+  * PARTICULAR PURPOSE, OR NONINFRINGEMENT.  IN NO EVENT SHALL NETWORK
+  * COMPUTING DEVICES, INC., BE LIABLE FOR ANY DAMAGES WHATSOEVER, INCLUDING
+  * SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES, INCLUDING LOSS OF USE, DATA,
+  * OR PROFITS, EVEN IF ADVISED OF THE POSSIBILITY THEREOF, AND REGARDLESS OF
+  * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
+  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  *
+  * $NCDId: @(#)lbxext.h,v 1.3 1994/09/14 21:57:05 lemke Exp $
+  */
+ 
+ #ifndef _LBXEXT_H_
+ #define _LBXEXT_H_
+ 
+ /* number of extensions the proxy understands */
+ #define	MAX_SUPPORTED_EXTENSIONS	10
+ 
+ typedef int (*ExtensionRequests) ();
+ typedef int (*ExtensionReplies) ();
+ typedef int (*ExtensionEvents) ();
+ typedef int (*ExtensionErrors) ();
+ typedef int (*SExtensionRequests) ();
+ typedef int (*SExtensionReplies) ();
+ typedef int (*SExtensionEvents) ();
+ typedef int (*SExtensionErrors) ();
+ 
+ typedef struct _vectors {
+     char       *name;
+     ExtensionRequests req_vector;
+     ExtensionReplies rep_vector;
+     ExtensionEvents ev_vector;
+     ExtensionErrors err_vector;
+     SExtensionRequests sreq_vector;
+ }           ExtensionVectors;
+ 
+ extern int  (*ProcVector[256]) ();
+ extern int  (*SwappedProcVector[256]) ();
+ 
+ extern Bool AddExtension();
+ extern void DeleteClientExtensions();
+ extern void ShutdownExtensions();
+ extern void InitExtensions();
+ 
+ extern void RegisterExtension();
+ 
+ extern void RegisterAllExtensions();
+ 
+ extern void HandleExtensionError();
+ extern void HandleExtensionEvent();
+ extern Bool HandleExtensionReply();
+ 
+ extern Bool CheckExtensionForEvents();
+ extern Bool CheckExtensionForReplies();
+ 
+ extern Bool HandleQueryExtensionReply();
+ 
+ #endif				/* _LBXEXT_H_ */
*** /dev/null	Wed Jan 18 13:07:33 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/options.c	Wed Jan 18 13:07:33 1995
***************
*** 0 ****
--- 1,365 ----
+ /* $XConsortium: options.c,v 1.1 94/12/01 20:39:01 mor Exp $ */
+ /*
+  * Copyright 1994 Network Computing Devices, Inc.
+  *
+  * Permission to use, copy, modify, distribute, and sell this software and
+  * its documentation for any purpose is hereby granted without fee, provided
+  * that the above copyright notice appear in all copies and that both that
+  * copyright notice and this permission notice appear in supporting
+  * documentation, and that the name Network Computing Devices, Inc. not be
+  * used in advertising or publicity pertaining to distribution of this
+  * software without specific, written prior permission.
+  *
+  * THIS SOFTWARE IS PROVIDED `AS-IS'.  NETWORK COMPUTING DEVICES, INC.,
+  * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT
+  * LIMITATION ALL IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
+  * PARTICULAR PURPOSE, OR NONINFRINGEMENT.  IN NO EVENT SHALL NETWORK
+  * COMPUTING DEVICES, INC., BE LIABLE FOR ANY DAMAGES WHATSOEVER, INCLUDING
+  * SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES, INCLUDING LOSS OF USE, DATA,
+  * OR PROFITS, EVEN IF ADVISED OF THE POSSIBILITY THEREOF, AND REGARDLESS OF
+  * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
+  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  *
+  * $NCDId: @(#)options.c,v 1.2 1994/09/23 18:23:50 dct Exp $
+  */
+ 
+ #include <stdio.h>
+ #include "X.h"
+ #include "misc.h"
+ #include "lbxopts.h"
+ #include "proxyopts.h"
+ #ifndef NO_LZW
+ #include "lbxlzw.h"
+ #endif /* NO_LZW */
+ 
+ static int LbxDeltaReply();
+ static int LbxProxyDeltaReq();
+ static int LbxServerDeltaReq();
+ static int LbxStreamCompReq();
+ #ifdef notyet
+ static int LbxBitmapCompReq();
+ static int LbxPixmapCompReq();
+ #endif
+ static int LbxSquishReq();
+ 
+ static int LbxProxyDeltaReply();
+ static int LbxServerDeltaReply();
+ static int LbxStreamCompReply();
+ #ifdef notyet
+ static int LbxBitmapCompReply();
+ static int LbxPixmapCompReply();
+ #endif
+ static int LbxSquishReply();
+ 
+ #define OPT_INDEX_STREAM_COMP		2
+ 
+ /*
+  * List of LBX options we recognize and may negotiate
+  */
+ static struct _LbxOption {
+     CARD8	optcode;
+     Bool	negotiate;
+     int		(*req)();
+     int		(*reply)();
+ } LbxOptions[] = {
+     { LBX_OPT_DELTA_PROXY,  TRUE,  LbxProxyDeltaReq,	LbxProxyDeltaReply },
+     { LBX_OPT_DELTA_SERVER, TRUE,  LbxServerDeltaReq,	LbxServerDeltaReply },
+     { LBX_OPT_STREAM_COMP,  TRUE,  LbxStreamCompReq,	LbxStreamCompReply },
+ #ifdef notyet
+     { LBX_OPT_BITMAP_COMP,  TRUE,  LbxBitmapCompReq,	LbxBitmapCompReply },
+     { LBX_OPT_PIXMAP_COMP,  TRUE,  LbxPixmapCompReq,	LbxPixmapCompReply },
+ #endif
+     { LBX_OPT_MSG_COMP,     TRUE,  LbxSquishReq,	LbxSquishReply },
+ };
+ 
+ #define LBX_N_OPTS	(sizeof(LbxOptions) / sizeof(struct _LbxOption))
+ 
+ static int optcount;
+ static int optlist[LBX_N_OPTS];
+ 
+ LbxNegOptsRec lbxNegOpt;
+ 
+ void
+ LbxOptInit()
+ {
+     bzero((char *)&lbxNegOpt, sizeof(LbxNegOptsRec));
+     lbxNegOpt.proxyDeltaN = LBX_OPT_DELTA_NCACHE_DFLT;
+     lbxNegOpt.proxyDeltaMaxLen = LBX_OPT_DELTA_MSGLEN_DFLT;
+     lbxNegOpt.serverDeltaN = LBX_OPT_DELTA_NCACHE_DFLT;
+     lbxNegOpt.serverDeltaMaxLen = LBX_OPT_DELTA_MSGLEN_DFLT;
+     lbxNegOpt.squish = TRUE;
+ }
+ 
+ int
+ LbxOptBuildReq(buf)
+     register unsigned char *buf;
+ {
+     int		  i;
+     unsigned char *bufstart = buf;
+     unsigned char *pnopts = buf++;
+ 
+     optcount = 0;
+ 
+     for (i = 0; i < LBX_N_OPTS; i++) {
+ 	int reqlen;
+ 
+ 	if (LbxOptions[i].negotiate) {
+ 	    reqlen = (*LbxOptions[i].req)(buf + LBX_OPT_SMALLHDR_LEN);
+ 	    *buf++ = LbxOptions[i].optcode;
+ 	    *buf++ = LBX_OPT_SMALLHDR_LEN + reqlen;
+ 	    buf += reqlen;
+ 	    optlist[optcount++] = i;
+ 	}
+     }
+ 
+     *pnopts = optcount;
+     return (buf - bufstart);
+ }
+ 
+ int
+ LbxOptParseReply(nopts, preply, replylen)
+     int		  nopts;
+     unsigned char *preply;
+     int		  replylen;
+ {
+     int		  i;
+ 
+     for (i = 0; i < nopts; i++) {
+ 	int j;
+ 	int len;
+ 	int hdrlen;
+ 	int result;
+ 	int optindex = *preply;
+ 
+ 	if (optindex >= optcount)
+ 	    return -1;
+ 	LBX_OPT_DECODE_LEN(preply + 1, len, hdrlen);
+ 	if (len < ++hdrlen || len > replylen) {
+ #ifdef OPTDEBUG
+ 	    fprintf(stderr, "bad length, len = %d, hdrlen = %d, optlen = %d\n",
+ 			    len, hdrlen, replylen);
+ #endif
+ 	    return -1;
+ 	}
+ 
+ 	result = (*LbxOptions[optlist[optindex]].reply)(preply + hdrlen,
+ 							len - hdrlen);
+ 	if (result < 0)
+ 	    return -1;
+ 
+ 	preply += len;
+ 	replylen -= len;
+     }
+ }
+ 
+ struct deltaOpt {
+     CARD8	minN;			/* min cache size */
+     CARD8	maxN;			/* max cache size */
+     CARD8	prefN;			/* preferred cache size */
+     CARD8	minMaxMsgLen;		/* min max-message-len / 4 */
+     CARD8	maxMaxMsgLen;		/* max max-message-len / 4 */
+     CARD8	prefMaxMsgLen;		/* preferred max-message-len / 4 */
+ };
+ 
+ static struct deltaOpt proxyDeltaOpt = {
+     0,
+     0xff,
+     LBX_OPT_DELTA_NCACHE_DFLT,
+     LBX_OPT_DELTA_MSGLEN_MIN >> 2,
+     0xff,
+     LBX_OPT_DELTA_MSGLEN_DFLT >> 2
+ };
+ 
+ static struct deltaOpt serverDeltaOpt = {
+     0,
+     0xff,
+     LBX_OPT_DELTA_NCACHE_DFLT,
+     LBX_OPT_DELTA_MSGLEN_MIN >> 2,
+     0xff,
+     LBX_OPT_DELTA_MSGLEN_DFLT >> 2
+ };
+ 
+ void
+ LbxNoDelta()
+ {
+     proxyDeltaOpt.prefN = 0;
+     serverDeltaOpt.prefN = 0;
+ }
+ 
+ static int
+ LbxProxyDeltaReq(buf)
+     unsigned char *buf;
+ {
+     bcopy((char *)&proxyDeltaOpt, buf, sizeof(struct deltaOpt));
+     return LBX_OPT_DELTA_REQLEN;
+ }
+ 
+ static int
+ LbxServerDeltaReq(buf)
+     unsigned char *buf;
+ {
+     bcopy((char *)&serverDeltaOpt, buf, sizeof(struct deltaOpt));
+     return LBX_OPT_DELTA_REQLEN;
+ }
+ 
+ static int
+ LbxProxyDeltaReply(preply, replylen)
+     unsigned char *preply;
+     int		  replylen;
+ {
+     return LbxDeltaReply(preply, 
+ 			 replylen,
+ 			 &lbxNegOpt.proxyDeltaN,
+ 			 &lbxNegOpt.proxyDeltaMaxLen);
+ }
+ 
+ static int
+ LbxServerDeltaReply(preply, replylen)
+     unsigned char *preply;
+     int		  replylen;
+ {
+     return LbxDeltaReply(preply, 
+ 			 replylen,
+ 			 &lbxNegOpt.serverDeltaN,
+ 			 &lbxNegOpt.serverDeltaMaxLen);
+ }
+ 
+ static int
+ LbxDeltaReply(preply, replylen, pn, pmaxlen)
+     unsigned char *preply;
+     int		  replylen;
+     short	  *pn;
+     short	  *pmaxlen;
+ {
+     if (replylen < 2)
+ 	return -1;
+     *pn = *preply++;
+     *pmaxlen = *preply;
+     if ((*pmaxlen <<= 2) == 0)
+ 	*pn = 0;
+     else if (*pmaxlen < 32) {
+ #ifdef DEBUG
+ 	printf("bad delta max msg length %d\n", *pmaxlen);
+ #endif
+ 	return -1;
+      }
+     return 0;
+ }
+ 
+ static int OptLzwReq();
+ static int OptLzwReply();
+ 
+ static struct _LbxStreamComp {
+     int		typelen;
+     char	*type;
+     int		(*req)();
+     int		(*reply)();
+ } LbxStreamComp[] = {
+ #ifndef NO_LZW
+     { LZW_STRCOMP_OPT_LEN,  LZW_STRCOMP_OPT,  OptLzwReq,  OptLzwReply }
+ #endif /* NO_LZW */
+ };
+ 
+ #define LBX_N_STRCOMP	\
+     (sizeof(LbxStreamComp) / sizeof(struct _LbxStreamComp))
+ 
+ void
+ LbxNoComp()
+ {
+     LbxOptions[OPT_INDEX_STREAM_COMP].negotiate = FALSE;
+ }
+ 
+ static int
+ LbxStreamCompReq(buf)
+     unsigned char *buf;
+ {
+     int		  i;
+     int		  reqlen;
+ 
+     *buf++ = LBX_N_STRCOMP;
+     reqlen = 1;
+ 
+     for (i = 0; i < LBX_N_STRCOMP; i++) {
+ 	int optdatalen;
+ 	int typelen = LbxStreamComp[i].typelen;
+ 
+ 	*buf++ = typelen;
+ 	bcopy(LbxStreamComp[i].type, buf, typelen);
+ 	buf += typelen;
+ 	reqlen += 1 + typelen;
+ 
+ 	optdatalen = (*LbxStreamComp[i].req)(buf + 1);
+ 	*buf = optdatalen + 1;
+ 	buf += optdatalen + 1;
+ 	reqlen += optdatalen + 1;
+     }
+ 
+     return reqlen;
+ }
+ 
+ static int
+ LbxStreamCompReply(preply, replylen)
+     unsigned char *preply;
+     int		  replylen;
+ {
+     int		  optindex;
+ 
+     if (replylen < 1 || (optindex = *preply) >= LBX_N_STRCOMP)
+ 	return -1;
+     return (*LbxStreamComp[optindex].reply)(preply + 1, replylen - 1);
+ 	
+ }
+ 
+ /* LZW code sizes in order of preference */
+ static CARD8 lzwCodeSizes[] = { 14, 12 };
+ 
+ static int
+ OptLzwReq(buf)
+     unsigned char *buf;
+ {
+     *buf++ = sizeof(lzwCodeSizes);
+     bcopy(lzwCodeSizes, buf, sizeof(lzwCodeSizes));
+     return (1 + sizeof(lzwCodeSizes));
+ }
+ 
+ static int
+ OptLzwReply(preply, replylen)
+     unsigned char *preply;
+     int		  replylen;
+ {
+     int		   index;
+     extern pointer LzwInit();
+ 
+     if (replylen < 1 || (index = *preply) >= sizeof(lzwCodeSizes))
+ 	return -1;
+     lbxNegOpt.streamCompInit = LzwInit;
+     lbxNegOpt.streamCompArg = (pointer)lzwCodeSizes[index];
+     return 0;
+ }
+ 
+ static Bool lbxDoSquishing = TRUE;
+ 
+ void
+ LbxNoSquish()
+ {
+     lbxDoSquishing = FALSE;
+ }
+ 
+ static int
+ LbxSquishReq(buf)
+     unsigned char *buf;
+ {
+     *buf = lbxDoSquishing;
+     return 1;
+ }
+ 
+ static int
+ LbxSquishReply(preply, replylen)
+     unsigned char *preply;
+     int		  replylen;
+ {
+     if (replylen < 1)
+ 	return -1;
+     lbxNegOpt.squish = *preply;
+     return 0;
+ }
*** /dev/null	Wed Jan 18 13:07:34 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/proxyopts.h	Wed Jan 18 13:07:34 1995
***************
*** 0 ****
--- 1,49 ----
+ /* $XConsortium: proxyopts.h,v 1.1 94/12/01 20:39:01 mor Exp $ */
+ /*
+  * Copyright 1994 Network Computing Devices, Inc.
+  *
+  * Permission to use, copy, modify, distribute, and sell this software and
+  * its documentation for any purpose is hereby granted without fee, provided
+  * that the above copyright notice appear in all copies and that both that
+  * copyright notice and this permission notice appear in supporting
+  * documentation, and that the name Network Computing Devices, Inc. not be
+  * used in advertising or publicity pertaining to distribution of this
+  * software without specific, written prior permission.
+  *
+  * THIS SOFTWARE IS PROVIDED `AS-IS'.  NETWORK COMPUTING DEVICES, INC.,
+  * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT
+  * LIMITATION ALL IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
+  * PARTICULAR PURPOSE, OR NONINFRINGEMENT.  IN NO EVENT SHALL NETWORK
+  * COMPUTING DEVICES, INC., BE LIABLE FOR ANY DAMAGES WHATSOEVER, INCLUDING
+  * SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES, INCLUDING LOSS OF USE, DATA,
+  * OR PROFITS, EVEN IF ADVISED OF THE POSSIBILITY THEREOF, AND REGARDLESS OF
+  * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
+  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  *
+  * $NCDId: @(#)proxyopts.h,v 1.1 1994/09/15 22:42:59 dct Exp $
+  */
+ 
+ #ifndef _LBX_PROXYOPTS_H_
+ #define _LBX_PROXYOPTS_H_
+ 
+ typedef struct _LbxNegOpts {
+     short	proxyDeltaN;
+     short	proxyDeltaMaxLen;
+     short	serverDeltaN;
+     short	serverDeltaMaxLen;
+     pointer	(*streamCompInit)();
+     pointer	streamCompArg;
+ #ifdef notyet
+     pointer	(*bitmapCompInit)();
+     pointer	bitmapCompArg;
+     pointer	(*pixmapCompInit)();
+     pointer	pixmapCompArg;
+ #endif
+     Bool	squish;
+ } LbxNegOptsRec;
+ 
+ typedef LbxNegOptsRec *LbxNegOptsPtr;
+ 
+ extern LbxNegOptsRec lbxNegOpt;
+ 
+ #endif /* _LBX_PROXYOPTS_H_ */
*** /dev/null	Wed Jan 18 13:07:35 1995
--- xc/workInProgress/lbx/programs/lbxproxy/di/unsquish.c	Wed Jan 18 13:07:35 1995
***************
*** 0 ****
--- 1,249 ----
+ /* $XConsortium: unsquish.c,v 1.1 94/12/01 20:39:01 mor Exp $ */
+ /*
+  * Copyright 1994 Network Computing Devices, Inc.
+  *
+  * Permission to use, copy, modify, distribute, and sell this software and
+  * its documentation for any purpose is hereby granted without fee, provided
+  * that the above copyright notice appear in all copies and that both that
+  * copyright notice and this permission notice appear in supporting
+  * documentation, and that the name Network Computing Devices, Inc. not be
+  * used in advertising or publicity pertaining to distribution of this
+  * software without specific, written prior permission.
+  *
+  * THIS SOFTWARE IS PROVIDED `AS-IS'.  NETWORK COMPUTING DEVICES, INC.,
+  * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT
+  * LIMITATION ALL IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
+  * PARTICULAR PURPOSE, OR NONINFRINGEMENT.  IN NO EVENT SHALL NETWORK
+  * COMPUTING DEVICES, INC., BE LIABLE FOR ANY DAMAGES WHATSOEVER, INCLUDING
+  * SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES, INCLUDING LOSS OF USE, DATA,
+  * OR PROFITS, EVEN IF ADVISED OF THE POSSIBILITY THEREOF, AND REGARDLESS OF
+  * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
+  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  *
+  * $NCDId: @(#)unsquish.c,v 1.3 1994/09/15 22:43:05 dct Exp $
+  */
+ 
+ /* handles unsquishing replies, events & errors */
+ 
+ /* XXX should probably try to combine server & proxy side of this */
+ 
+ /*
+  * Notes on squishing:
+  *
+  * there are a number of places that need to know about squishing:
+  *
+  * any event changes should be set in lbxstr.h
+  *
+  * in the proxy:
+  *	unsquish.c
+  *
+  * in the server
+  *	LbxComputeReplyLen()
+  */
+ 
+ #include "X.h"
+ #define NEED_REPLIES
+ #define NEED_EVENTS
+ #include "Xproto.h"
+ #include "misc.h"
+ #define	_XLBX_SERVER_
+ #include "lbxstr.h"
+ #include "proxyopts.h"
+ 
+ #include	<stdio.h>
+ 
+ int
+ EventLength(ev)
+     xEvent     *ev;
+ {
+     int	evtype = ev->u.u.type;
+ 
+     if (!lbxNegOpt.squish || evtype == X_Error || evtype == X_Reply)
+ 	return 32;
+ 
+     switch (evtype) {
+     case KeyPress:
+     case KeyRelease:
+     case ButtonPress:
+     case ButtonRelease:
+     case MotionNotify:
+ 	return lbxsz_KeyButtonEvent;
+     case EnterNotify:
+     case LeaveNotify:
+ 	return lbxsz_EnterLeaveEvent;
+     case FocusIn:
+     case FocusOut:
+ 	return lbxsz_FocusEvent;
+     case KeymapNotify:
+ 	return lbxsz_KeymapEvent;
+     case Expose:
+ 	return lbxsz_ExposeEvent;
+     case GraphicsExpose:
+ 	return lbxsz_GfxExposeEvent;
+     case NoExpose:
+ 	return lbxsz_NoExposeEvent;
+     case VisibilityNotify:
+ 	return lbxsz_VisibilityEvent;
+     case CreateNotify:
+ 	return lbxsz_CreateNotifyEvent;
+     case DestroyNotify:
+ 	return lbxsz_DestroyNotifyEvent;
+     case UnmapNotify:
+ 	return lbxsz_UnmapNotifyEvent;
+     case MapNotify:
+ 	return lbxsz_MapNotifyEvent;
+     case MapRequest:
+ 	return lbxsz_MapRequestEvent;
+     case ReparentNotify:
+ 	return lbxsz_ReparentEvent;
+ 
+     case ConfigureNotify:
+ 	return lbxsz_ConfigureNotifyEvent;
+     case ConfigureRequest:
+ 	return lbxsz_ConfigureRequestEvent;
+     case GravityNotify:
+ 	return lbxsz_GravityEvent;
+     case ResizeRequest:
+ 	return lbxsz_ResizeRequestEvent;
+     case CirculateNotify:
+     case CirculateRequest:
+ 	return lbxsz_CirculateEvent;
+     case PropertyNotify:
+ 	return lbxsz_PropertyEvent;
+     case SelectionClear:
+ 	return lbxsz_SelectionClearEvent;
+     case SelectionRequest:
+ 	return lbxsz_SelectionRequestEvent;
+     case SelectionNotify:
+ 	return lbxsz_SelectionNotifyEvent;
+     case ColormapNotify:
+ 	return lbxsz_ColormapEvent;
+     case ClientMessage:
+ 	return lbxsz_ClientMessageEvent;
+     default:
+ 	return lbxsz_UnknownEvent;
+     }
+ }
+ 
+ static void
+ unpack_event(src, dst)
+     xEvent     *src,
+                *dst;
+ {
+     int	evtype = src->u.u.type;
+ 
+     switch (evtype) {
+     case KeyPress:
+     case KeyRelease:
+     case ButtonPress:
+     case ButtonRelease:
+     case MotionNotify:
+ 	memmove(dst, src, lbxsz_KeyButtonEvent);
+ 	break;
+     case EnterNotify:
+     case LeaveNotify:
+ 	memmove(dst, src, lbxsz_EnterLeaveEvent);
+ 	break;
+     case FocusIn:
+     case FocusOut:
+ 	memmove(dst, src, lbxsz_FocusEvent);
+ 	break;
+     case KeymapNotify:
+ 	memmove(dst, src, lbxsz_KeymapEvent);
+ 	break;
+     case Expose:
+ 	memmove(dst, src, lbxsz_ExposeEvent);
+ 	break;
+     case GraphicsExpose:
+ 	memmove(dst, src, lbxsz_GfxExposeEvent);
+ 	break;
+     case NoExpose:
+ 	memmove(dst, src, lbxsz_NoExposeEvent);
+ 	break;
+     case VisibilityNotify:
+ 	memmove(dst, src, lbxsz_VisibilityEvent);
+ 	break;
+     case CreateNotify:
+ 	memmove(dst, src, lbxsz_CreateNotifyEvent);
+ 	break;
+     case DestroyNotify:
+ 	memmove(dst, src, lbxsz_DestroyNotifyEvent);
+ 	break;
+     case UnmapNotify:
+ 	memmove(dst, src, lbxsz_UnmapNotifyEvent);
+ 	break;
+     case MapNotify:
+ 	memmove(dst, src, lbxsz_MapNotifyEvent);
+ 	break;
+     case MapRequest:
+ 	memmove(dst, src, lbxsz_MapRequestEvent);
+ 	break;
+     case ReparentNotify:
+ 	memmove(dst, src, lbxsz_ReparentEvent);
+ 	break;
+     case ConfigureNotify:
+ 	memmove(dst, src, lbxsz_ConfigureNotifyEvent);
+ 	break;
+     case ConfigureRequest:
+ 	memmove(dst, src, lbxsz_ConfigureRequestEvent);
+ 	break;
+     case GravityNotify:
+ 	memmove(dst, src, lbxsz_GravityEvent);
+ 	break;
+     case ResizeRequest:
+ 	memmove(dst, src, lbxsz_ResizeRequestEvent);
+ 	break;
+     case CirculateNotify:
+     case CirculateRequest:
+ 	memmove(dst, src, lbxsz_CirculateEvent);
+ 	break;
+     case PropertyNotify:
+ 	memmove(dst, src, lbxsz_PropertyEvent);
+ 	break;
+     case SelectionClear:
+ 	memmove(dst, src, lbxsz_SelectionClearEvent);
+ 	break;
+     case SelectionRequest:
+ 	memmove(dst, src, lbxsz_SelectionRequestEvent);
+ 	break;
+     case SelectionNotify:
+ 	memmove(dst, src, lbxsz_SelectionNotifyEvent);
+ 	break;
+     case ColormapNotify:
+ 	memmove(dst, src, lbxsz_ColormapEvent);
+ 	break;
+     case MappingNotify:
+ 	memmove(dst, src, lbxsz_MappingNotifyEvent);
+ 	break;
+     case ClientMessage:
+ 	memmove(dst, src, lbxsz_ClientMessageEvent);
+ 	break;
+     default:
+ 	*dst = *src;
+ 	break;
+     }
+ }
+ 
+ Bool
+ UnsquishEvent(rep, ev, lenp)
+     xReply     *rep;
+     xEvent     *ev;
+     int        *lenp;
+ {
+     int         rtype = rep->generic.type;
+     int         nlen;
+ 
+     switch (rtype) {
+     case X_Reply:
+ 	return FALSE;
+     case X_Error:
+ 	return FALSE;
+     default:			/* events */
+ 	*lenp = sizeof(xEvent);	/* unpacked size */
+ 	nlen = EventLength((xEvent *) rep);
+ 	if (nlen == sizeof(xEvent))
+ 	    return FALSE;
+ 	unpack_event((xEvent *) rep, ev);
+ 	return TRUE;
+     }
+ }
*** -	Wed Jan 18 13:07:42 1995
--- xc/workInProgress/lbx/programs/Xserver/lbx/Imakefile	Wed Jan 18 13:07:42 1995
***************
*** 1,6 ****
! /* $XConsortium: Imakefile,v 1.5 94/03/17 19:43:43 dpw Exp $ */
  /*
!  * $NCDId: @(#)Imakefile,v 1.11 1994/03/14 23:32:34 lemke Exp $
   *
   * Copyright 1992 Network Computing Devices
   *
--- 1,6 ----
! /* $XConsortium: Imakefile,v 1.8 94/12/01 20:28:16 mor Exp $ */
  /*
!  * $NCDId: @(#)Imakefile,v 1.16 1994/11/18 20:32:34 lemke Exp $
   *
   * Copyright 1992 Network Computing Devices
   *
***************
*** 28,51 ****
  
  #ifdef NCD
  INCLUDES = \
- 	-I$(EXTENSIONSRC)/include \
  	-I$(EXTENSIONSRC)/include/lbx \
  	-I$(EXTENSIONSRC)/lbxcommon/delta \
  	-I$(INCLUDESRC) \
  	-I$(FONTSRC)/include \
  	-I$(SERVERSRC)/include
  #else
! INCLUDES =  -I$(TOP)/include -I$(TOP)/include/fonts -I$(SERVERSRC)/include  -I$(EXTINCSRC)
  #endif
  
  SRCS =	\
  	lbxmain.c lbxdix.c lbxtags.c lbxprop.c lbxgfx.c lbxtables.c \
!         lbxswap.c
  
  
  OBJS =	\
  	lbxmain.o lbxdix.o lbxtags.o lbxprop.o lbxgfx.o lbxtables.o \
!         lbxswap.o
  
  NormalLibraryObjectRule()
  NormalLibraryTarget(lbx,$(OBJS))
--- 28,51 ----
  
  #ifdef NCD
  INCLUDES = \
  	-I$(EXTENSIONSRC)/include/lbx \
+ 	-I$(EXTENSIONSRC)/include \
  	-I$(EXTENSIONSRC)/lbxcommon/delta \
  	-I$(INCLUDESRC) \
  	-I$(FONTSRC)/include \
  	-I$(SERVERSRC)/include
  #else
! INCLUDES =  -I$(TOP)/include -I$(TOP)/include/fonts -I$(SERVERSRC)/include  -I$(EXTINCSRC) -I../../../include/extensions
  #endif
  
  SRCS =	\
  	lbxmain.c lbxdix.c lbxtags.c lbxprop.c lbxgfx.c lbxtables.c \
!         lbxswap.c lbxsquish.c lbxexts.c lbxopts.c
  
  
  OBJS =	\
  	lbxmain.o lbxdix.o lbxtags.o lbxprop.o lbxgfx.o lbxtables.o \
!         lbxswap.o lbxsquish.o lbxexts.o lbxopts.o
  
  NormalLibraryObjectRule()
  NormalLibraryTarget(lbx,$(OBJS))
*** -	Wed Jan 18 13:07:43 1995
--- xc/workInProgress/lbx/programs/Xserver/lbx/lbxmain.c	Wed Jan 18 13:07:43 1995
***************
*** 1,6 ****
! /* $XConsortium: lbxmain.c,v 1.11 94/03/27 13:09:25 dpw Exp $ */
  /*
!  * $NCDId: @(#)lbxmain.c,v 1.45 1994/03/24 17:54:24 lemke Exp $
   * $NCDOr: lbxmain.c,v 1.4 1993/12/06 18:47:18 keithp Exp keithp $
   *
   * Copyright 1992 Network Computing Devices
--- 1,6 ----
! /* $XConsortium: lbxmain.c,v 1.14 94/12/01 20:30:50 mor Exp $ */
  /*
!  * $NCDId: @(#)lbxmain.c,v 1.61 1994/11/18 20:32:36 lemke Exp $
   * $NCDOr: lbxmain.c,v 1.4 1993/12/06 18:47:18 keithp Exp keithp $
   *
   * Copyright 1992 Network Computing Devices
***************
*** 45,50 ****
--- 45,51 ----
  #define _XLBX_SERVER_
  #include "lbxstr.h"
  #include "lbxserve.h"
+ #include "lbxsrvopts.h"
  #include "Xfuncproto.h"
  #include <errno.h>
  #ifdef X_NOT_STDC_ENV
***************
*** 84,89 ****
--- 85,91 ----
  
  int	LbxWritev ();
  int	LbxWriteToClient ();
+ int	LbxUncompressedWriteToClient ();
  
  LbxProxyPtr proxyList;
  static unsigned char LbxReqCode;
***************
*** 189,194 ****
--- 191,198 ----
      LbxClientPtr    lbxClient;
      char	*buf;
  {
+     LbxProxyPtr	    proxy = lbxClient->proxy;
+ 
      if (lbxClient->awaiting_setup)
      {
  	xConnSetupPrefix	*csp = (xConnSetupPrefix *) buf;
***************
*** 196,202 ****
  	int			n;
  	if (lbxClient->client->swapped) {
  	    swaps(&len, n);
! 	}
  	lbxClient->reply_remaining = 8 + (len << 2);
  	DBG(DBG_LEN, (stderr, "%d setup bytes remaining\n", lbxClient->reply_remaining));
      }
--- 200,206 ----
  	int			n;
  	if (lbxClient->client->swapped) {
  	    swaps(&len, n);
!         }
  	lbxClient->reply_remaining = 8 + (len << 2);
  	DBG(DBG_LEN, (stderr, "%d setup bytes remaining\n", lbxClient->reply_remaining));
      }
***************
*** 204,216 ****
      {
  	xReply    *reply = (xReply *) buf;
  
! 	lbxClient->reply_remaining = 32;
  	if (reply->generic.type == X_Reply) {
  	    int   len = reply->generic.length;
  	    int	  n;
  	    if (lbxClient->client->swapped) {
  		swapl(&len, n);
! 	    }
  	    lbxClient->reply_remaining += len << 2;
  	}
  	DBG (DBG_LEN, (stderr, "%d reply bytes remaining\n", lbxClient->reply_remaining));
--- 208,220 ----
      {
  	xReply    *reply = (xReply *) buf;
  
! 	lbxClient->reply_remaining = LbxEventLength(proxy, (xEvent *) buf);
  	if (reply->generic.type == X_Reply) {
  	    int   len = reply->generic.length;
  	    int	  n;
  	    if (lbxClient->client->swapped) {
  		swapl(&len, n);
!             }
  	    lbxClient->reply_remaining += len << 2;
  	}
  	DBG (DBG_LEN, (stderr, "%d reply bytes remaining\n", lbxClient->reply_remaining));
***************
*** 547,553 ****
      LbxProxyPtr	    proxy;
  
      for (proxy = proxyList; proxy; proxy = proxy->next) {
! 	if (proxy->lzwHandle) {
  	    if (LzwFlush (proxy->fd) != 0) {
  		/* Assume we're write blocked.  What if it's a real error -
  		   leave it for the OS layer to figure out? */
--- 551,557 ----
      LbxProxyPtr	    proxy;
  
      for (proxy = proxyList; proxy; proxy = proxy->next) {
! 	if (proxy->compHandle) {
  	    if (LzwFlush (proxy->fd) != 0) {
  		/* Assume we're write blocked.  What if it's a real error -
  		   leave it for the OS layer to figure out? */
***************
*** 574,580 ****
  	return TRUE;
  
      for (proxy = proxyList; proxy; proxy = proxy->next) {
! 	if (proxy->lzwHandle) {
  	    if (LzwInputAvail (proxy->fd))
  		AvailableClientInput (proxy->lbxClients[0]->client);
  	}
--- 578,584 ----
  	return TRUE;
  
      for (proxy = proxyList; proxy; proxy = proxy->next) {
! 	if (proxy->compHandle) {
  	    if (LzwInputAvail (proxy->fd))
  		AvailableClientInput (proxy->lbxClients[0]->client);
  	}
***************
*** 592,598 ****
  void
  LbxBlockHandler (data, timeout, readmask)
      pointer data;
!     OSTimePtr timeout;
      pointer readmask;
  {
      if (lbxAnyOutputPending)
--- 596,602 ----
  void
  LbxBlockHandler (data, timeout, readmask)
      pointer data;
!     OSTimePtr	 timeout;
      pointer readmask;
  {
      if (lbxAnyOutputPending)
***************
*** 614,619 ****
--- 618,625 ----
      LbxProxyPtr		proxy = LbxProxy(client);
      LbxClientPtr	lbxClient = LbxClient(client);
      
+     if (lbxClient->ignored)
+     	return TRUE;
      if (GrabInProgress && client->index != GrabInProgress &&
          lbxClient != proxy->lbxClients[0])
  	return TRUE;
***************
*** 621,626 ****
--- 627,656 ----
  }
  
  void
+ LbxIgnoreClient(client)
+     ClientPtr	client;
+ {
+     LbxClientPtr lbxClient = LbxClient(client);
+ 
+     if (lbxClient)
+ 	lbxClient->ignored = TRUE;
+     else
+ 	IgnoreClient(client);
+ }
+ 
+ void
+ LbxAttendClient(client)
+     ClientPtr	client;
+ {
+     LbxClientPtr lbxClient = LbxClient(client);
+ 
+     if (lbxClient)
+ 	lbxClient->ignored = FALSE;
+     else
+ 	AttendClient(client);
+ }
+ 
+ void
  LbxSwitchRecv (proxy, lbxClient)
      LbxProxyPtr		proxy;
      LbxClientPtr	lbxClient;
***************
*** 743,748 ****
--- 773,818 ----
  #define MAJOROP(client) ((xReq *)client->requestBuffer)->reqType
  #define MINOROP(client) ((xReq *)client->requestBuffer)->data
  
+ static Bool lbxCacheable[] = {
+ 	FALSE,	/* LbxQueryVersion	  0 */
+ 	FALSE,	/* LbxStartProxy	  1 */
+ 	TRUE,	/* LbxStopProxy		  2 */
+ 	FALSE,	/* LbxSwitch		  3 */
+ 	FALSE,	/* LbxNewClient		  4 */
+ 	TRUE,	/* LbxCloseClient	  5 */
+ 	TRUE,	/* LbxModifySequence	  6 */
+ 	FALSE,	/* LbxAllowMotion	  7 */
+ 	TRUE,	/* LbxIncrementPixel	  8 */
+ 	FALSE,	/* LbxDelta		  9 */
+ 	TRUE,	/* LbxGetModifierMapping 10 */
+ 	TRUE,	/* LbxQueryTag		 11 */
+ 	TRUE,	/* LbxInvalidateTag	 12 */
+ 	TRUE,	/* LbxPolyPoint		 13 */
+ 	TRUE,	/* LbxPolyLine		 14 */
+ 	TRUE,	/* LbxPolySegment	 15 */
+ 	TRUE,	/* LbxPolyRectangle	 16 */
+ 	TRUE,	/* LbxPolyArc		 17 */
+ 	TRUE,	/* LbxFillPoly		 18 */
+ 	TRUE,	/* LbxPolyFillRectangle	 19 */
+ 	TRUE,	/* LbxPolyFillArc	 20 */
+ 	TRUE,	/* LbxGetKeyboardMapping 21 */
+ 	TRUE,	/* LbxQueryFont		 22 */
+ 	TRUE,	/* LbxChangeProperty	 23 */
+ 	TRUE,	/* LbxGetProperty	 24 */
+ 	TRUE,	/* LbxTagData		 25 */
+ 	TRUE,	/* LbxCopyArea		 26 */
+ 	TRUE,	/* LbxCopyPlane		 27 */
+ 	TRUE,	/* LbxPolyText8		 28 */
+ 	TRUE,	/* LbxPolyText16	 29 */
+ 	TRUE,	/* LbxImageText8	 30 */
+ 	TRUE,	/* LbxImageText16	 31 */
+ 	FALSE,	/* LbxQueryExtension	 32 */
+ 	FALSE,	/* LbxPutImage		 33 */
+ 	FALSE,	/* LbxGetImage		 34 */
+ };
+ 
+ #define NUM(a)	(sizeof (a) / sizeof (a[0]))
+ 
  int
  LbxReadRequestFromClient (client)
      ClientPtr	client;
***************
*** 766,772 ****
  	    return 0;
  	}
  	else {
! 	    ret = (*lbxClient->readRequest) (client);
  	    if (ret <= 0) {
  		lbxClient->reading_pending = FALSE;
  	        DBG (DBG_BLOCK, (stderr, "ending reading_pending for client %d\n", lbxClient->index));
--- 836,842 ----
  	    return 0;
  	}
  	else {
! 	    ret = LBXReadRequestFromClient (client);
  	    if (ret <= 0) {
  		lbxClient->reading_pending = FALSE;
  	        DBG (DBG_BLOCK, (stderr, "ending reading_pending for client %d\n", lbxClient->index));
***************
*** 782,788 ****
      {
  	Bool		cacheable;
  
! 	ret = (*lbxClient->readRequest) (masterClient);
  	DBG (DBG_READ_REQ, (stderr, "Real readRequest returns %d\n", ret));
  	if (ret <= 0)
  	    return ret;
--- 852,858 ----
      {
  	Bool		cacheable;
  
! 	ret = LBXReadRequestFromClient (masterClient);
  	DBG (DBG_READ_REQ, (stderr, "Real readRequest returns %d\n", ret));
  	if (ret <= 0)
  	    return ret;
***************
*** 792,797 ****
--- 862,870 ----
  
  	cacheable = TRUE;
  	if (MAJOROP(client) == LbxReqCode) {
+ 	    /* Check to see if this request is delta cached */
+ 	    if (MINOROP(client) < NUM(lbxCacheable))
+ 		cacheable = lbxCacheable[MINOROP(client)];
  	    if (MINOROP(client) == X_LbxSwitch)
  	    {
  		/* Switch is sent by proxy */
***************
*** 807,813 ****
  		DBG(DBG_DELTA, (stderr, "delta decompressed msg %d, len = %d\n",
  		    (unsigned) ((unsigned char *)client->requestBuffer)[0], ret));
  	    }
- 	    cacheable = FALSE; /* not caching any LBX requests for now */
  	}
  
  	if (cacheable && DELTA_CACHEABLE(&proxy->indeltas, ret)) {
--- 880,885 ----
***************
*** 848,859 ****
--- 920,1059 ----
      }
  }
  
+ /*
+  * have to copy data off into pending buffer 
+  */
+ void
+ LbxResetCurrentRequest(client)
+     ClientPtr	client;
+ {
+     LbxClientPtr lbxClient = LbxClient(client);
+     LbxProxyPtr proxy;
+     xReq       *req = (xReq *) client->requestBuffer;
+ 
+     if (lbxClient) {
+ 	proxy = lbxClient->proxy;
+ 	AppendFakeRequest(client, client->requestBuffer, req->length * 4);
+ 
+ 	++proxy->curRecv->reqs_pending;
+ 	if (!proxy->curRecv->input_blocked) {
+ 	    proxy->curRecv->input_blocked = TRUE;
+ 	    QueueWorkProc(LbxWaitForUnblocked, proxy->curRecv->client, NULL);
+ 	}
+     } else {
+ 	ResetCurrentRequest(client);
+     }
+ }
+ 
+ /* ARGSUSED */
+ static int
+ LbxWriteEventToClient(client, ev)
+     ClientPtr	client;
+     xEvent	*ev;
+ {
+     LbxClientPtr lbxClient = LbxClient(client);
+     LbxProxyPtr proxy = lbxClient->proxy;
+     int         len = sizeof(xEvent);
+     char        evbuf[32];
+     char       *bp = (char *) ev;
+ 
+     /* see if this is extraneous motion */
+     if (LbxThrottleMotionEvents(client, ev)) {
+ 	lbxClient->bytes_in_reply -= sizeof(xEvent);
+ 	return Success;
+     }
+     if (proxy->dosquishing) {
+ 	len = LbxSquishEvent(proxy, ev, evbuf);
+ 	bp = evbuf;
+     }
+     lbxClient->bytes_in_reply -= sizeof(xEvent);
+     lbxAnyOutputPending = TRUE;
+     return (*lbxClient->writeToClient) (client, len, bp);
+ }
+ 
+ /* determine how much data is being sent by server */
+ /* these are real lengths, not LBX lengths */
+ static int
+ reply_length(lbxClient, buf, len)
+     LbxClientPtr	lbxClient;
+     char	*buf;
+ {
+     xReply     *rep = (xReply *) buf;
+     char        n;
+ 
+     if (rep->generic.type != X_Reply) {
+ 	return len;		/* catch the multiple-event case */
+     }
+     if (lbxClient->awaiting_setup) {
+ 	CARD16      slen = ((xConnSetupPrefix *) buf)->length;
+ 
+ 	if (lbxClient->client->swapped) {
+ 	    swaps(&slen, n)
+ 	}
+ 	return (2 + slen) << 2;
+     } else {
+ 	CARD32      slen = rep->generic.length;
+ 
+ 	if (lbxClient->client->swapped) {
+ 	    swapl(&slen, n)
+ 	}
+ 	return (8 + slen) << 2;
+     }
+ }
+ 
+ /*
+  * assumes that only events & errors might be grouped.  if anything
+  * is somehow sending multiple replies in one WriteToClient() (which
+  * shouldn't be legal) this will break
+  */
  int
  LbxWriteToClient (client, len, buf)
      ClientPtr	client;
      int		len;
      char	*buf;
  {
+     LbxClientPtr lbxClient = LbxClient(client);
+     xReply     *rep = (xReply *) buf;
+     int         rlen = len,
+                 i,
+                 num;
+     if (!len)
+ 	return Success;
+ 
+     /*
+      * make sure we look at the start of a reply/event before trying to play
+      * with it
+      */
+     if (lbxClient->bytes_in_reply == 0) {
+ 	lbxClient->bytes_in_reply = reply_length(lbxClient, buf, len);
+ 
+ 	/* catch any events (or errors) that can be tossed or squished */
+ 	/* may be a whole mess of them, so break them up */
+ 	if (rep->generic.type != X_Reply) {
+ 	    num = len / 32;
+ 	    for (i = 0; i < num; i++, buf += 32) {
+ 		(void) LbxWriteEventToClient(client, (xEvent *) buf);
+ 	    }
+ 	    return Success;
+ 	}
+     } else {
+ 	/*
+ 	 * round length, since that's what reply len did, and extra reply is
+ 	 * often not a word-multiple
+ 	 */
+ 	rlen = ((len + 3) >> 2) << 2;
+     }
+     lbxClient->bytes_in_reply -= rlen;
+     lbxAnyOutputPending = TRUE;
+     return (*lbxClient->writeToClient) (client, len, buf);
+ }
+ 
+ int
+ LbxUncompressedWriteToClient (client, len, buf)
+     ClientPtr	client;
+     int		len;
+     char	*buf;
+ {
      LbxClientPtr    lbxClient = LbxClient(client);
  
      /* see if this is extraneous motion */
***************
*** 864,870 ****
  	    return Success;
      }
      lbxAnyOutputPending = TRUE;
!     return (*lbxClient->writeToClient) (client, len, buf);
  }
  
  Bool
--- 1064,1070 ----
  	    return Success;
      }
      lbxAnyOutputPending = TRUE;
!     return (*lbxClient->uncompressedWriteToClient) (client, len, buf);
  }
  
  Bool
***************
*** 887,899 ****
--- 1087,1105 ----
      lbxClient->input_blocked = FALSE;
      lbxClient->reading_pending = FALSE;
      lbxClient->reqs_pending = 0;
+     lbxClient->bytes_in_reply = 0;
+     lbxClient->ignored = FALSE;
      lbxClient->writeToClient = client->public.writeToClient;
+     lbxClient->uncompressedWriteToClient = client->public.uncompressedWriteToClient;
      lbxClient->readRequest = client->public.readRequest;
+     bzero (lbxClient->drawableCache, sizeof (lbxClient->drawableCache));
+     bzero (lbxClient->gcontextCache, sizeof (lbxClient->gcontextCache));
      lbxClients[client->index] = lbxClient;
      proxy->lbxClients[index] = lbxClient;
      proxy->numClients++;
      client->public.writeToClient = LbxWriteToClient;
      client->public.readRequest = LbxReadRequestFromClient;
+     client->public.uncompressedWriteToClient = LbxUncompressedWriteToClient;
  #ifdef notused
      client->public.requestLength = LbxRequestLength;
  #endif
***************
*** 941,948 ****
  	xfree(proxy->tempDeltaBuf);
      if (proxy->tempEventBuf)
  	xfree(proxy->tempEventBuf);
!     if (proxy->lzwHandle)
! 	LzwFree(proxy->lzwHandle);
      for (p = &proxyList; *p; p = &(*p)->next) {
  	if (*p == proxy) {
  	    *p = proxy->next;
--- 1147,1154 ----
  	xfree(proxy->tempDeltaBuf);
      if (proxy->tempEventBuf)
  	xfree(proxy->tempEventBuf);
!     if (proxy->compHandle)
! 	LzwFree(proxy->compHandle);
      for (p = &proxyList; *p; p = &(*p)->next) {
  	if (*p == proxy) {
  	    *p = proxy->next;
***************
*** 969,975 ****
  	}
      }
      LbxFlushTags(proxy);
!     if (proxy->lzwHandle)
  	--lbxCompressWorkProcCount;
      LbxFreeProxy(proxy);
      if (!--lbxBlockHandlerCount)
--- 1175,1181 ----
  	}
      }
      LbxFlushTags(proxy);
!     if (proxy->compHandle)
  	--lbxCompressWorkProcCount;
      LbxFreeProxy(proxy);
      if (!--lbxBlockHandlerCount)
***************
*** 1043,1051 ****
  }
  
  int Writev(fd, iov, iovcnt)
! int fd;
! struct iovec *iov;
! int iovcnt;
  {
      return writev(fd, iov, iovcnt);
  }
--- 1249,1257 ----
  }
  
  int Writev(fd, iov, iovcnt)
!     int	fd;
!     struct iovec *iov;
!     int iovcnt;
  {
      return writev(fd, iov, iovcnt);
  }
***************
*** 1057,1067 ****
      REQUEST(xLbxStartProxyReq);
      LbxProxyPtr	    proxy;
      LbxClientPtr    lbxClient;
!     short	    deltaN;
!     short	    deltaMaxLen;
!     int		    comptype;
!     int		    maxbits;
!     xLbxStartReply  rep;
      register int    n;
  
      REQUEST_AT_LEAST_SIZE(xLbxStartProxyReq);
--- 1263,1272 ----
      REQUEST(xLbxStartProxyReq);
      LbxProxyPtr	    proxy;
      LbxClientPtr    lbxClient;
!     int		    reqlen;
!     int		    replylen;
!     xLbxStartReply  *replybuf;
!     LbxNegOptsRec   negopt;
      register int    n;
  
      REQUEST_AT_LEAST_SIZE(xLbxStartProxyReq);
***************
*** 1076,1096 ****
      				 * MAX_NUM_PROXIES */
      proxyList = proxy;
  
!     deltaN = stuff->deltaN;
!     deltaMaxLen = stuff->deltaMaxLen;
!     comptype = stuff->comptype;
!     if (LBXInitDeltaCache(&proxy->indeltas, deltaN, deltaMaxLen) < 0 ||
! 	LBXInitDeltaCache(&proxy->outdeltas, deltaN, deltaMaxLen) < 0) {
  	LbxFreeProxy(proxy);
  	return BadAlloc;
      }
!     if (deltaN && deltaMaxLen) {
! 	if ((proxy->tempDeltaBuf = (unsigned char *)xalloc (deltaMaxLen))
! 		== NULL) {
  	    LbxFreeProxy(proxy);
  	    return BadAlloc;
  	}
      }
  #ifndef NCD
      MakeClientGrabImpervious(client);	/* proxy needs to be grab-proof */
  #else
--- 1281,1338 ----
      				 * MAX_NUM_PROXIES */
      proxyList = proxy;
  
!     /*
!      * Don't know exactly how big the reply will be, but it won't be
!      * bigger than the request
!      */
!     reqlen = stuff->length << 2;
!     replybuf = (xLbxStartReply *) xalloc(max(reqlen, sz_xLbxStartReply));
!     if (!replybuf) {
! 	LbxFreeProxy(proxy);
! 	return BadAlloc;
!     }
! 
!     LbxOptionInit(&negopt);
! 
!     replylen = LbxOptionParse(&negopt,
! 			      &stuff[1],
! 			      reqlen - sz_xLbxStartProxyReq,
! 			      &replybuf->optDataStart);
!     if (replylen < 0) {
! 	/*
! 	 * Didn't understand option format, so we'll just end up
! 	 * using the defaults.  Set nopts so that the proxy will
! 	 * be informed that we rejected the options because of
! 	 * decoding problems.
! 	 */
! 	LbxOptionInit(&negopt);
! 	negopt.nopts = 0xff;
! 	replylen = 0;
!     }
! 
!     if (LBXInitDeltaCache(&proxy->indeltas, negopt.proxyDeltaN,
! 			  negopt.proxyDeltaMaxLen) < 0
! 			||
! 	LBXInitDeltaCache(&proxy->outdeltas, negopt.serverDeltaN,
! 			  negopt.serverDeltaMaxLen) < 0) {
  	LbxFreeProxy(proxy);
+ 	xfree(replybuf);
  	return BadAlloc;
      }
! 
!     n = 0;
!     if (negopt.proxyDeltaN)
! 	n = negopt.proxyDeltaMaxLen;
!     if (negopt.serverDeltaN && negopt.serverDeltaMaxLen > n)
! 	n = negopt.serverDeltaMaxLen;
!     if (n) {
! 	if ((proxy->tempDeltaBuf = (unsigned char *)xalloc (n)) == NULL) {
  	    LbxFreeProxy(proxy);
+ 	    xfree(replybuf);
  	    return BadAlloc;
  	}
      }
+ 
  #ifndef NCD
      MakeClientGrabImpervious(client);	/* proxy needs to be grab-proof */
  #else
***************
*** 1099,1147 ****
      if ((proxy->tempEventBuf = (unsigned char *)
  		xalloc (max(MAXDELTASIZE, sizeof (xLbxEvent)))) == NULL) {
  	LbxFreeProxy(proxy);
  	return BadAlloc;
      }
      proxy->fd = ClientConnectionNumber(client);
!     if (comptype == LbxCompressLZW) {
! 	maxbits = *(CARD32 *)(stuff + 1);
! 	if (client->swapped) {
! 	    swapl(&maxbits, n);
! 	}
! 	if ((proxy->lzwHandle = (void *)LzwInit(proxy->fd, maxbits)) == NULL) {
  	    LbxFreeProxy(proxy);
  	    return BadAlloc;
  	}
      }
      if (!LbxInitClient (proxy, client, 0))
      {
  	LbxFreeProxy(proxy);
  	return BadAlloc;
      }
  
      /* send reply */
!     rep.type = X_Reply;
!     rep.sequenceNumber = client->sequence;
!     rep.length = 0;
!     rep.deltaN = stuff->deltaN;
!     rep.deltaMaxLen = stuff->deltaMaxLen;
!     rep.comptype = stuff->comptype;
!     if (proxy->lzwHandle)
! 	rep.length += 1;
      if (client->swapped) {
! 	swaps(&rep.sequenceNumber, n);
! 	swapl(&rep.length, n);
! 	swaps(&rep.deltaN, n);
! 	swaps(&rep.deltaMaxLen, n);
! 	swapl(&rep.comptype, n);
      }
      lbxClient = LbxClient(client);
!     (*lbxClient->writeToClient) (client, sizeof (xLbxStartReply), (char *)&rep);
!     if (proxy->lzwHandle)
! 	(*lbxClient->writeToClient) 
! 	    (client, sizeof (CARD32), (char *)(stuff + 1));
      FlushAllOutput();	/* what if entire reply doesn't get out here????? */
  
!     if (proxy->lzwHandle) {
  	int  len = client->req_len << 2;
  	int  left = BytesInClientBuffer (client);
  	char *extra = ((char *) stuff) + len;
--- 1341,1388 ----
      if ((proxy->tempEventBuf = (unsigned char *)
  		xalloc (max(MAXDELTASIZE, sizeof (xLbxEvent)))) == NULL) {
  	LbxFreeProxy(proxy);
+ 	xfree(replybuf);
  	return BadAlloc;
      }
      proxy->fd = ClientConnectionNumber(client);
!     if (negopt.streamCompInit) {
! 	proxy->compHandle =
! 	    (*negopt.streamCompInit)(proxy->fd, negopt.streamCompArg);
! 	if (proxy->compHandle == NULL) {
  	    LbxFreeProxy(proxy);
+ 	    xfree(replybuf);
  	    return BadAlloc;
  	}
      }
      if (!LbxInitClient (proxy, client, 0))
      {
  	LbxFreeProxy(proxy);
+ 	xfree(replybuf);
  	return BadAlloc;
      }
+     proxy->dosquishing = negopt.squish;
  
      /* send reply */
!     replybuf->type = X_Reply;
!     replybuf->nOpts = negopt.nopts;
!     replybuf->sequenceNumber = client->sequence;
!     replylen += sz_xLbxStartReplyHdr;
!     if (replylen < sz_xLbxStartReply)
! 	replylen = sz_xLbxStartReply;
!     replybuf->length = (replylen - sz_xLbxStartReply + 3) >> 2;
      if (client->swapped) {
! 	swaps(&replybuf->sequenceNumber, n);
! 	swapl(&replybuf->length, n);
      }
      lbxClient = LbxClient(client);
!     (*lbxClient->writeToClient) (client, replylen, (char *)replybuf);
      FlushAllOutput();	/* what if entire reply doesn't get out here????? */
+ #ifndef NDEBUG
+     if (PendingClientOutput(client))
+ 	fprintf(stderr, "Warning! StartProxy reply not transmitted\n");
+ #endif
  
!     if (proxy->compHandle) {
  	int  len = client->req_len << 2;
  	int  left = BytesInClientBuffer (client);
  	char *extra = ((char *) stuff) + len;
***************
*** 1164,1174 ****
      lbxClient->awaiting_setup = FALSE;
      if (!lbxBlockHandlerCount++)
  	RegisterBlockAndWakeupHandlers(LbxBlockHandler, LbxWakeupHandler, NULL);
!     if (proxy->lzwHandle) {
  	if (!lbxCompressWorkProcCount++)
  	    QueueWorkProc (LbxCheckCompressInput, NULL, NULL);
      }
  
      return Success;
  }
  
--- 1405,1416 ----
      lbxClient->awaiting_setup = FALSE;
      if (!lbxBlockHandlerCount++)
  	RegisterBlockAndWakeupHandlers(LbxBlockHandler, LbxWakeupHandler, NULL);
!     if (proxy->compHandle) {
  	if (!lbxCompressWorkProcCount++)
  	    QueueWorkProc (LbxCheckCompressInput, NULL, NULL);
      }
  
+     xfree(replybuf);
      return Success;
  }
  
***************
*** 1221,1227 ****
      int		    c;
      int		    len;
      char	    *setupbuf;
!   
      if (stuff->client >= MAX_LBX_CLIENTS || 
  	!proxy || proxy->lbxClients[stuff->client])
  	return BadLbxClientCode;
--- 1463,1469 ----
      int		    c;
      int		    len;
      char	    *setupbuf;
! 
      if (stuff->client >= MAX_LBX_CLIENTS || 
  	!proxy || proxy->lbxClients[stuff->client])
  	return BadLbxClientCode;
***************
*** 1231,1247 ****
      len = (stuff->length << 2) - sizeof(xLbxNewClientReq);
      setupbuf = (char *)xalloc (len);
      if (!setupbuf)
!       return BadAlloc;
      bcopy ((char *)&stuff[1], setupbuf, len);
  
!     newClient = AllocNewConnection (ClientTransportObject(client),
  				    ClientConnectionNumber (client), 
  				    LbxRead, LbxWritev, LbxCloseClient);
      if (!newClient)
  	return BadAlloc;
      if (((xLbxConnClientPrefix *)setupbuf)->useTag)
  	newClient->requestVector = LbxInitialVector;
!     if (proxy->lzwHandle)
  	StartOutputCompression (newClient, LbxCompressOn, LbxCompressOff);
      if (!LbxInitClient (proxy, newClient, c))
      {
--- 1473,1492 ----
      len = (stuff->length << 2) - sizeof(xLbxNewClientReq);
      setupbuf = (char *)xalloc (len);
      if (!setupbuf)
! 	return BadAlloc;
      bcopy ((char *)&stuff[1], setupbuf, len);
  
!     newClient = AllocNewConnection (
! #ifndef NCD	/* R6-ism */
!     ClientTransportObject(client),
! #endif
  				    ClientConnectionNumber (client), 
  				    LbxRead, LbxWritev, LbxCloseClient);
      if (!newClient)
  	return BadAlloc;
      if (((xLbxConnClientPrefix *)setupbuf)->useTag)
  	newClient->requestVector = LbxInitialVector;
!     if (proxy->compHandle)
  	StartOutputCompression (newClient, LbxCompressOn, LbxCompressOff);
      if (!LbxInitClient (proxy, newClient, c))
      {
***************
*** 1494,1499 ****
--- 1739,1798 ----
  }
  
  int
+ ProcLbxCopyArea (client)
+     register ClientPtr	client;
+ {
+     return LbxDecodeCopyArea(client);
+ }
+ 
+ int
+ ProcLbxCopyPlane (client)
+     register ClientPtr	client;
+ {
+     return LbxDecodeCopyPlane(client);
+ }
+ 
+ 
+ int
+ ProcLbxPolyText (client)
+     register ClientPtr	client;
+ {
+     return LbxDecodePolyText(client);
+ }
+ 
+ int
+ ProcLbxImageText (client)
+     register ClientPtr	client;
+ {
+     return LbxDecodeImageText(client);
+ }
+ 
+ int
+ ProcLbxQueryExtension(client)
+     ClientPtr	client;
+ {
+     REQUEST(xLbxQueryExtensionReq);
+     char	*ename;
+ 
+     ename = (char *) &stuff[1];
+     return LbxQueryExtension(client, ename, stuff->nbytes);
+ }
+ 
+ int
+ ProcLbxPutImage(client)
+     register ClientPtr	client;
+ {
+     return LbxDecodePutImage(client);
+ }
+ 
+ int
+ ProcLbxGetImage(client)
+     register ClientPtr	client;
+ {
+     return LbxDecodeGetImage(client);
+ }
+ 
+ int
  ProcLbxDispatch (client)
      register ClientPtr	client;
  {
***************
*** 1552,1557 ****
--- 1851,1872 ----
  	return ProcLbxGetProperty (client);
      case X_LbxTagData:
  	return ProcLbxTagData (client);
+     case X_LbxCopyArea:
+ 	return ProcLbxCopyArea (client);
+     case X_LbxCopyPlane:
+ 	return ProcLbxCopyPlane (client);
+     case X_LbxPolyText8:
+     case X_LbxPolyText16:
+ 	return ProcLbxPolyText (client);
+     case X_LbxImageText8:
+     case X_LbxImageText16:
+ 	return ProcLbxImageText (client);
+     case X_LbxQueryExtension:
+ 	return ProcLbxQueryExtension (client);
+     case X_LbxPutImage:
+ 	return ProcLbxPutImage (client);
+     case X_LbxGetImage:
+ 	return ProcLbxGetImage (client);
      default:
  	return BadRequest;
      }
*** -	Wed Jan 18 13:07:46 1995
--- xc/workInProgress/lbx/programs/Xserver/lbx/lbxdix.c	Wed Jan 18 13:07:46 1995
***************
*** 1,4 ****
! /* $XConsortium: lbxdix.c,v 1.6 94/03/27 13:10:46 dpw Exp $ */
  /*
   * Copyright 1993 Network Computing Devices, Inc.
   *
--- 1,4 ----
! /* $XConsortium: lbxdix.c,v 1.7 94/12/01 20:29:36 mor Exp $ */
  /*
   * Copyright 1993 Network Computing Devices, Inc.
   *
***************
*** 20,26 ****
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
!  * $NCDId: @(#)lbxdix.c,v 1.23 1994/03/24 17:54:27 lemke Exp $
   *
   * Author:  Dave Lemke, Network Computing Devices
   */
--- 20,26 ----
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
!  * $NCDId: @(#)lbxdix.c,v 1.24 1994/09/23 20:51:28 lemke Exp $
   *
   * Author:  Dave Lemke, Network Computing Devices
   */
***************
*** 902,908 ****
  	    /* don't do others yet (ever?) */
  	    break;
  	}
! 	AttendClient(client);
  	return;
      }
      /* save the info and the client being stalled */
--- 902,908 ----
  	    /* don't do others yet (ever?) */
  	    break;
  	}
! 	LbxAttendClient(client);
  	return;
      }
      /* save the info and the client being stalled */
***************
*** 964,970 ****
  	/* wake up stalled clients */
  	cp = *stqp->stalled_clients;
  	while (stqp->num_stalled--) {
! 	    AttendClient(cp);
  	    cp++;
  	}
  	LbxRemoveQTag(tag);
--- 964,970 ----
  	/* wake up stalled clients */
  	cp = *stqp->stalled_clients;
  	while (stqp->num_stalled--) {
! 	    LbxAttendClient(cp);
  	    cp++;
  	}
  	LbxRemoveQTag(tag);
*** -	Wed Jan 18 13:07:49 1995
--- xc/workInProgress/lbx/programs/Xserver/lbx/lbxserve.h	Wed Jan 18 13:07:49 1995
***************
*** 1,6 ****
! /* $XConsortium: lbxserve.h,v 1.3 94/03/27 13:12:41 dpw Exp $ */
  /*
!  * $NCDId: @(#)lbxserve.h,v 1.11 1994/03/24 01:30:14 dct Exp $
   * $NCDOr: lbxserve.h,v 1.1 1993/12/06 18:47:18 keithp Exp $
   *
   * Copyright 1992 Network Computing Devices
--- 1,6 ----
! /* $XConsortium: lbxserve.h,v 1.5 94/12/01 20:28:45 mor Exp $ */
  /*
!  * $NCDId: @(#)lbxserve.h,v 1.17 1994/11/18 20:32:38 lemke Exp $
   * $NCDOr: lbxserve.h,v 1.1 1993/12/06 18:47:18 keithp Exp $
   *
   * Copyright 1992 Network Computing Devices
***************
*** 27,32 ****
--- 27,34 ----
  
  /* XXX only handles one LBX connection right now */
  #include "lbxdeltastr.h"
+ #define _XLBX_SERVER_
+ #include "lbxstr.h"
  
  #define MAX_LBX_CLIENTS	MAXCLIENTS
  
***************
*** 43,50 ****
--- 45,57 ----
      Bool        input_blocked;
      Bool        reading_pending;
      int         reqs_pending;
+     int		bytes_in_reply;
+     Bool	ignored;
      int         (*readRequest) ();
      int         (*writeToClient) ();
+     int         (*uncompressedWriteToClient) ();
+     Drawable	drawableCache[GFX_CACHE_SIZE];
+     GContext	gcontextCache[GFX_CACHE_SIZE];
  }           LbxClientRec;
  
  typedef struct _LbxProxy {
***************
*** 63,70 ****
      int		grabClient;
      int         (*read) ();
      int         (*writev) ();
!     void       *lzwHandle;
      Bool        nocompression;
      LBXDeltasRec indeltas;
      LBXDeltasRec outdeltas;
      unsigned char *tempDeltaBuf;
--- 70,78 ----
      int		grabClient;
      int         (*read) ();
      int         (*writev) ();
!     pointer	compHandle;
      Bool        nocompression;
+     Bool        dosquishing;
      LBXDeltasRec indeltas;
      LBXDeltasRec outdeltas;
      unsigned char *tempDeltaBuf;
*** -	Wed Jan 18 13:07:52 1995
--- xc/workInProgress/lbx/programs/Xserver/lbx/lbxgfx.c	Wed Jan 18 13:07:52 1995
***************
*** 1,4 ****
! /* $XConsortium: lbxgfx.c,v 1.3 94/03/27 13:15:58 dpw Exp $ */
  /*
   * Copyright 1993 Network Computing Devices, Inc.
   *
--- 1,4 ----
! /* $XConsortium: lbxgfx.c,v 1.13 94/12/01 20:32:26 mor Exp $ */
  /*
   * Copyright 1993 Network Computing Devices, Inc.
   *
***************
*** 20,26 ****
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
!  * $NCDId: @(#)lbxgfx.c,v 1.4 1994/03/24 17:54:34 lemke Exp $
   *
   * Author:  Dave Lemke, Network Computing Devices
   */
--- 20,26 ----
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
!  * $NCDId: @(#)lbxgfx.c,v 1.8 1994/11/29 19:58:32 lemke Exp $
   *
   * Author:  Dave Lemke, Network Computing Devices
   */
***************
*** 38,51 ****
--- 38,209 ----
  #include "dixstruct.h"
  #include "resource.h"
  #include "servermd.h"
+ #include "windowstr.h"
+ #include "scrnintstr.h"
  #define _XLBX_SERVER_
  #include "lbxstr.h"
  #include "lbxserve.h"
  #include "lbxtags.h"
  #include "Xfuncproto.h"
+ #include "lbximage.h"
+ 
+ #define DrawableCache(client)	(LbxClient(client)->drawableCache)
+ #define GContextCache(client)	(LbxClient(client)->gcontextCache)
  
  extern int (*ProcVector[256])();
  
+ static void
+ push (cache, xid)
+     XID	    cache[GFX_CACHE_SIZE];
+     XID	    xid;
+ {
+     bcopy (cache, cache+1, (GFX_CACHE_SIZE - 1) * sizeof (cache[0]));
+     cache[0] = xid;
+ }
+ 
+ static XID
+ use (cache, i)
+     XID	    cache[GFX_CACHE_SIZE];
+     int	    i;
+ {
+     XID	tmp;
+ 
+     tmp = cache[i];
+     if (i != 0)
+     {
+ 	bcopy (cache, cache + 1, i * sizeof (cache[0]));
+ 	cache[0] = tmp;
+     }
+     return tmp;
+ }
+ 
+ extern char *ConnectionInfo;
+ 
+ int
+ LbxDecodeGFXCache(client, cacheEnts, after, drawp, gcp)
+     ClientPtr		client;
+     CARD8		cacheEnts;
+     char		*after;
+     Drawable		*drawp;
+     GContext		*gcp;
+ {
+     int	skip;
+     int	dcache, gcache;
+     
+     dcache = GFXdCacheEnt (cacheEnts);
+     gcache = GFXgCacheEnt (cacheEnts);
+     skip = 0;
+     if (dcache == GFXCacheNone)
+     {
+ 	bcopy (after, drawp, sizeof (Drawable));
+ 	push (DrawableCache(client), *drawp);
+ 	after += sizeof (Drawable);
+ 	skip += sizeof (Drawable);
+     }
+     else
+ 	*drawp = use (DrawableCache(client), dcache);
+     if (gcache == GFXCacheNone)
+     {
+ 	bcopy (after, gcp, sizeof (GContext));
+ 	push (GContextCache(client), *gcp);
+ 	skip += sizeof (GContext);
+     }
+     else
+ 	*gcp = use (GContextCache(client), gcache);
+     return skip;
+ }
+ 
+ int
+ LbxDecodeDrawableCache(client, cacheEnts, after, drawp)
+     ClientPtr		client;
+     CARD8		cacheEnts;
+     char		*after;
+     Drawable		*drawp;
+ {
+     int	skip;
+     int	dcache;
+     
+     dcache = GFXdCacheEnt (cacheEnts);
+     skip = 0;
+     if (dcache == GFXCacheNone)
+     {
+ 	bcopy (after, drawp, sizeof (Drawable));
+ 	push (DrawableCache(client), *drawp);
+ 	after += sizeof (Drawable);
+ 	skip += sizeof (Drawable);
+     }
+     else
+ 	*drawp = use (DrawableCache(client), dcache);
+     return skip;
+ }
+ 
+ int
+ LbxDecodeGCCache(client, cacheEnts, after, gcp)
+     ClientPtr		client;
+     CARD8		cacheEnts;
+     char		*after;
+     GContext		*gcp;
+ {
+     int	skip;
+     int	gcache;
+     
+     gcache = GFXgCacheEnt (cacheEnts);
+     skip = 0;
+     if (gcache == GFXCacheNone)
+     {
+ 	bcopy (after, gcp, sizeof (GContext));
+ 	push (GContextCache(client), *gcp);
+ 	after += sizeof (GContext);
+ 	skip += sizeof (GContext);
+     }
+     else
+ 	*gcp = use (GContextCache(client), gcache);
+     return skip;
+ }
+ 
+ #define GFX_GET_DRAWABLE_AND_GC(type,in,len) {\
+     int	    skip;   \
+     len = (stuff->length << 2) - SIZEOF(type); \
+     in = ((char *) stuff) + SIZEOF(type);\
+     skip = LbxDecodeGFXCache(client, stuff->cacheEnts, in, \
+ 			     &drawable, &gc); \
+     in += skip; \
+     len -= skip; \
+ }
+     
+ #define GFX_GET_DST_DRAWABLE_AND_GC(type,in,len) {\
+     int	    skip;   \
+     len = (stuff->length << 2) - SIZEOF(type); \
+     in = ((char *) stuff) + SIZEOF(type);\
+     skip = LbxDecodeGFXCache(client, stuff->cacheEnts, in, \
+ 			     &dstDrawable, &gc); \
+     in += skip; \
+     len -= skip; \
+ }
+     
+ #define GFX_GET_SRC_DST_DRAWABLE_AND_GC(type, in, len) { \
+     int	    skip; \
+     len = (stuff->length << 2) - SIZEOF(type); \
+     in = ((char *) stuff) + SIZEOF(type); \
+     skip = LbxDecodeDrawableCache(client, stuff->srcCache, in, \
+ 				  &srcDrawable); \
+     in += skip; \
+     len -= skip; \
+     skip = LbxDecodeGFXCache(client, stuff->cacheEnts, in, \
+ 			     &dstDrawable, &gc); \
+     in += skip; \
+     len -= skip; \
+ }
+ 
+ #define GFX_GET_GC(type, in, len) { \
+     int	    skip; \
+     len = (stuff->length << 2) - SIZEOF(type); \
+     in = ((char *) stuff) + SIZEOF(type); \
+     skip = LbxDecodeGCCache(client, stuff->gcCache, in, &gc); \
+     in += skip; \
+     len -= skip; \
+ }
+ 
  int
  LbxDecodePoly(client, xreqtype, decode_rtn)
      register ClientPtr  client;
***************
*** 57,73 ****
      xPolyPointReq	*xreq;
      int			len;
      int			retval;
  
!     len = (stuff->length << 2) - sz_xLbxPolyPointReq;
      if ((xreq = (xPolyPointReq *) 
  	    xalloc(sizeof(xPolyPointReq) + (len << 1))) == NULL)
  	return BadAlloc;
-     in = (char *)stuff + sz_xLbxPolyPointReq;
      len = (*decode_rtn)(in, in + len - stuff->padBytes, &xreq[1]);
      xreq->reqType = xreqtype;
      xreq->coordMode = 1;
!     xreq->drawable = stuff->drawable;
!     xreq->gc = stuff->gc;
      client->req_len = xreq->length = (sizeof(xPolyPointReq) + len) >> 2;
      client->requestBuffer = (pointer)xreq;
  
--- 215,233 ----
      xPolyPointReq	*xreq;
      int			len;
      int			retval;
+     int			dcache, gcache;
+     Drawable		drawable;
+     GContext		gc;
  
!     GFX_GET_DRAWABLE_AND_GC(xLbxPolyPointReq, in, len);
      if ((xreq = (xPolyPointReq *) 
  	    xalloc(sizeof(xPolyPointReq) + (len << 1))) == NULL)
  	return BadAlloc;
      len = (*decode_rtn)(in, in + len - stuff->padBytes, &xreq[1]);
      xreq->reqType = xreqtype;
      xreq->coordMode = 1;
!     xreq->drawable = drawable;
!     xreq->gc = gc;
      client->req_len = xreq->length = (sizeof(xPolyPointReq) + len) >> 2;
      client->requestBuffer = (pointer)xreq;
  
***************
*** 85,100 ****
      xFillPolyReq	*xreq;
      int			len;
      int			retval;
! 
!     len = (stuff->length << 2) - sz_xLbxFillPolyReq;
      if ((xreq = (xFillPolyReq *) 
  	    xalloc(sizeof(xFillPolyReq) + (len << 1))) == NULL)
  	return BadAlloc;
-     in = (char *)stuff + sz_xLbxFillPolyReq;
      len = LbxDecodePoints(in, in + len - stuff->padBytes, (short *) &xreq[1]);
      xreq->reqType = X_FillPoly;
!     xreq->drawable = stuff->drawable;
!     xreq->gc = stuff->gc;
      xreq->shape = stuff->shape;
      xreq->coordMode = 1;
      client->req_len = xreq->length = (sizeof(xFillPolyReq) + len) >> 2;
--- 245,261 ----
      xFillPolyReq	*xreq;
      int			len;
      int			retval;
!     Drawable		drawable;
!     GContext		gc;
!     
!     GFX_GET_DRAWABLE_AND_GC(xLbxFillPolyReq, in, len);
      if ((xreq = (xFillPolyReq *) 
  	    xalloc(sizeof(xFillPolyReq) + (len << 1))) == NULL)
  	return BadAlloc;
      len = LbxDecodePoints(in, in + len - stuff->padBytes, (short *) &xreq[1]);
      xreq->reqType = X_FillPoly;
!     xreq->drawable = drawable;
!     xreq->gc = gc;
      xreq->shape = stuff->shape;
      xreq->coordMode = 1;
      client->req_len = xreq->length = (sizeof(xFillPolyReq) + len) >> 2;
***************
*** 120,126 ****
  
  #define DECODE_USHORT(in, val) \
      if ((*(in) & 0xf0) != 0xf0) \
! 	(val) = (unsigned short)*(in)++; \
      else { \
  	(val) = ((short)(*(in) & 0x0f) << 8) | (unsigned char)*((in) + 1); \
  	(in) += 2; \
--- 281,287 ----
  
  #define DECODE_USHORT(in, val) \
      if ((*(in) & 0xf0) != 0xf0) \
! 	(val) = (unsigned char)*(in)++; \
      else { \
  	(val) = ((short)(*(in) & 0x0f) << 8) | (unsigned char)*((in) + 1); \
  	(in) += 2; \
***************
*** 243,246 ****
--- 404,794 ----
  	out++;
      }
      return ((char *)out - start_out);
+ }
+ 
+ int
+ LbxDecodeCopyArea (client)
+     ClientPtr	client;
+ {
+     REQUEST(xLbxCopyAreaReq);
+     char		*in;
+     xCopyAreaReq    	req;
+     int			len;
+     Drawable		srcDrawable, dstDrawable;
+     GContext		gc;
+     
+     GFX_GET_SRC_DST_DRAWABLE_AND_GC(xLbxCopyAreaReq, in, len);
+     req.reqType = X_CopyArea;
+     client->req_len = req.length = SIZEOF(xCopyAreaReq) >> 2;
+     req.srcDrawable = srcDrawable;
+     req.dstDrawable = dstDrawable;
+     req.gc = gc;
+     DECODE_SHORT (in, req.srcX);
+     DECODE_SHORT (in, req.srcY);
+     DECODE_SHORT (in, req.dstX);
+     DECODE_SHORT (in, req.dstY);
+     DECODE_USHORT (in, req.width);
+     DECODE_USHORT (in, req.height);
+     client->requestBuffer = (pointer) &req;
+     return (*ProcVector[X_CopyArea])(client);
+ }
+ 
+ int
+ LbxDecodeCopyPlane (client)
+     ClientPtr	client;
+ {
+     REQUEST(xLbxCopyPlaneReq);
+     char		*in;
+     xCopyPlaneReq 	req;
+     int			len;
+     Drawable		srcDrawable, dstDrawable;
+     GContext		gc;
+     
+     GFX_GET_SRC_DST_DRAWABLE_AND_GC(xLbxCopyPlaneReq, in, len);
+     req.reqType = X_CopyPlane;
+     client->req_len = req.length = SIZEOF(xCopyPlaneReq) >> 2;
+     req.srcDrawable = srcDrawable;
+     req.dstDrawable = dstDrawable;
+     req.gc = gc;
+     DECODE_SHORT (in, req.srcX);
+     DECODE_SHORT (in, req.srcY);
+     DECODE_SHORT (in, req.dstX);
+     DECODE_SHORT (in, req.dstY);
+     DECODE_USHORT (in, req.width);
+     DECODE_USHORT (in, req.height);
+     req.bitPlane = stuff->bitPlane;
+     client->requestBuffer = (pointer) &req;
+     return (*ProcVector[X_CopyPlane])(client);
+ }
+ 
+ int
+ LbxDecodePolyText (client)
+     ClientPtr	client;
+ {
+     REQUEST(xLbxPolyTextReq);
+     char		*in, *pos;
+     xPolyTextReq	*xreq;
+     int			len;
+     int			retval;
+     Drawable		drawable;
+     GContext		gc;
+     
+     GFX_GET_DRAWABLE_AND_GC(xLbxPolyTextReq, in, len);
+     if ((xreq = (xPolyTextReq *) 
+ 	    xalloc (sizeof (xPolyTextReq) + len)) == NULL)
+ 	return BadAlloc;
+     xreq->reqType = stuff->lbxReqType == X_LbxPolyText8? X_PolyText8 : X_PolyText16;
+     xreq->drawable = drawable;
+     xreq->gc = gc;
+     pos = in;
+     DECODE_SHORT(in, xreq->x);
+     DECODE_SHORT(in, xreq->y);
+     len -= (in - pos);
+     bcopy (in, (char *) (xreq + 1), len);
+     client->req_len = xreq->length = (sizeof (xPolyTextReq) + len) >> 2;
+     client->requestBuffer = (pointer) xreq;
+     return (*ProcVector[xreq->reqType])(client);
+ }
+ 
+ int
+ LbxDecodeImageText (client)
+     ClientPtr	client;
+ {
+     REQUEST(xLbxImageTextReq);
+     char		*in, *pos;
+     xImageTextReq	*xreq;
+     int			len;
+     int			retval;
+     Drawable		drawable;
+     GContext		gc;
+     
+     GFX_GET_DRAWABLE_AND_GC(xLbxImageTextReq, in, len);
+     if ((xreq = (xImageTextReq *) 
+ 	    xalloc (sizeof (xImageTextReq) + len)) == NULL)
+ 	return BadAlloc;
+     xreq->reqType = stuff->lbxReqType == X_LbxImageText8? X_ImageText8 : X_ImageText16;
+     xreq->drawable = drawable;
+     xreq->gc = gc;
+     xreq->nChars = stuff->nChars;
+     pos = in;
+     DECODE_SHORT(in, xreq->x);
+     DECODE_SHORT(in, xreq->y);
+     bcopy (in, (char *) (xreq + 1), stuff->nChars);
+     client->req_len = xreq->length = (sizeof (xImageTextReq) + stuff->nChars + 3) >> 2;
+     client->requestBuffer = (pointer) xreq;
+     return (*ProcVector[xreq->reqType])(client);
+ }
+ 
+ 
+ int
+ LbxDecodePutImage (client)
+     register ClientPtr  client;
+ {
+     REQUEST		(xLbxPutImageReq);
+     char		*in;
+     xPutImageReq	*xreq;
+     int			len;
+     int			retval;
+ 
+     if (stuff->compressionMethod != LbxImageCompressFaxG42D &&
+         stuff->compressionMethod != LbxImageCompressPackBits)
+     {
+ 	return BadValue;
+     }
+ 
+     if ((xreq = (xPutImageReq *) xalloc (stuff->xLength << 2)) == NULL)
+ 	return BadAlloc;
+ 
+     in = (char *) stuff + sz_xLbxPutImageReq;
+ 
+     if (stuff->compressionMethod == LbxImageCompressFaxG42D)
+     {
+ 	len = LbxImageDecodeFaxG42D (
+ 	    (unsigned char *) in, (unsigned char *) &xreq[1],
+ 	    (int) ((stuff->xLength << 2) - sz_xPutImageReq),
+ 	    (int) stuff->width,
+ 	    ((xConnSetup *) ConnectionInfo)->bitmapBitOrder == LSBFirst);
+     }
+     else
+     {
+ 	len = LbxImageDecodePackBits (in, (char *) &xreq[1],
+ 	    (int) stuff->height, (int) stuff->width);
+     }
+ 
+     xreq->reqType = X_PutImage;
+     xreq->drawable = stuff->drawable;
+     xreq->gc = stuff->gc;
+     xreq->width = stuff->width;
+     xreq->height = stuff->height;
+     xreq->format = stuff->format;
+     xreq->dstX = stuff->dstX;
+     xreq->dstY = stuff->dstY;
+     xreq->leftPad = stuff->leftPad;
+     xreq->depth = stuff->depth;
+ 
+     client->req_len = xreq->length = stuff->xLength;
+     client->requestBuffer = (pointer) xreq;
+ 
+     retval = (*ProcVector[X_PutImage])(client);
+     xfree(xreq);
+     return retval;
+ }
+ 
+ 
+ 
+ int
+ GetTheImage (client, stuff, depth, visual, theImage, imageBytes)
+     register ClientPtr client;
+     xLbxGetImageReq *stuff;
+     int *depth;
+     VisualID *visual;
+     char **theImage;
+     int *imageBytes;
+ {
+     register DrawablePtr pDraw;
+     int			lines, linesPerBuf;
+     register int	height;
+     long		widthBytesLine, length;
+     Mask		plane;
+     char		*pBuf;
+ 
+     height = stuff->height;
+     if ((stuff->format != XYPixmap) && (stuff->format != ZPixmap))
+     {
+ 	client->errorValue = stuff->format;
+         return(BadValue);
+     }
+ 
+     VERIFY_DRAWABLE(pDraw, stuff->drawable, client);
+ 
+     *depth = pDraw->depth;
+ 
+     if(pDraw->type == DRAWABLE_WINDOW)
+     {
+       if( /* check for being viewable */
+ 	 !((WindowPtr) pDraw)->realized ||
+ 	  /* check for being on screen */
+          pDraw->x + stuff->x < 0 ||
+  	 pDraw->x + stuff->x + (int)stuff->width > pDraw->pScreen->width ||
+          pDraw->y + stuff->y < 0 ||
+          pDraw->y + stuff->y + height > pDraw->pScreen->height ||
+           /* check for being inside of border */
+          stuff->x < - wBorderWidth((WindowPtr)pDraw) ||
+          stuff->x + (int)stuff->width >
+ 		wBorderWidth((WindowPtr)pDraw) + (int)pDraw->width ||
+          stuff->y < -wBorderWidth((WindowPtr)pDraw) ||
+          stuff->y + height >
+ 		wBorderWidth ((WindowPtr)pDraw) + (int)pDraw->height
+         )
+ 	    return(BadMatch);
+ 	*visual = wVisual (((WindowPtr) pDraw));
+     }
+     else
+     {
+       if(stuff->x < 0 ||
+          stuff->x+(int)stuff->width > pDraw->width ||
+          stuff->y < 0 ||
+          stuff->y+height > pDraw->height
+         )
+ 	    return(BadMatch);
+ 	*visual = None;
+     }
+     if(stuff->format == ZPixmap)
+     {
+ 	widthBytesLine = PixmapBytePad(stuff->width, pDraw->depth);
+ 	length = widthBytesLine * height;
+     }
+     else 
+     {
+ 	widthBytesLine = BitmapBytePad(stuff->width);
+ 	plane = ((Mask)1) << (pDraw->depth - 1);
+ 	/* only planes asked for */
+ 	length = widthBytesLine * height *
+ 		 Ones(stuff->planeMask & (plane | (plane - 1)));
+     }
+ 
+     *imageBytes = length;
+ 
+     if (widthBytesLine == 0 || height == 0)
+ 	linesPerBuf = 0;
+     else
+ 	linesPerBuf = height;
+ 
+     if(!(pBuf = *theImage = (char *) xalloc(length + 4)))
+         return (BadAlloc);
+ 
+     if (linesPerBuf == 0)
+     {
+ 	/* nothing to do */
+     }
+     else if (stuff->format == ZPixmap)
+     {
+ 	(*pDraw->pScreen->GetImage) (pDraw,
+ 	                                 stuff->x,
+ 				         stuff->y,
+ 				         stuff->width, 
+ 				         height,
+ 				         stuff->format,
+ 				         stuff->planeMask,
+ 				         (pointer) pBuf);
+     }
+     else /* XYPixmap */
+     {
+ 	char *bufptr = pBuf;
+ 
+         for (; plane; plane >>= 1)
+ 	{
+ 	    if (stuff->planeMask & plane)
+ 	    {
+ 		(*pDraw->pScreen->GetImage) (pDraw,
+ 	                                         stuff->x,
+ 				                 stuff->y,
+ 				                 stuff->width, 
+ 				                 height,
+ 				                 stuff->format,
+ 				                 plane,
+ 				                 (pointer)bufptr);
+ 
+ 		    bufptr += (height * widthBytesLine);
+             }
+ 	}
+     }
+ 
+     return (client->noClientException);
+ }
+ 
+ 
+ 
+ int
+ LbxDecodeGetImage (client)
+     register ClientPtr  client;
+ {
+     REQUEST		(xLbxGetImageReq);
+     xLbxGetImageReply	*reply = NULL;
+     int			depth, uncompLen, lbxLen, n;
+     VisualID		visual;
+     char		*theImage;
+     int			method, bytes, status;
+ 
+     REQUEST_SIZE_MATCH(xLbxGetImageReq);
+ 
+     status = GetTheImage (client, stuff,
+ 	&depth, &visual, &theImage, &uncompLen);
+ 
+     if (status != Success)
+ 	return (status);
+ 
+     if ((reply = (xLbxGetImageReply *) xalloc (
+ 	sz_xLbxGetImageReply + uncompLen)) == NULL)
+     {
+ 	return (!Success);
+     }
+ 
+     if (!((stuff->format == ZPixmap && depth == 8) || depth == 1))
+     {
+ 	status = LBX_IMAGE_COMPRESS_UNSUPPORTED_FORMAT;
+     }
+     else if (depth == 1)
+     {
+ 	status = LbxImageEncodeFaxG42D ((unsigned char *) theImage,
+ 	      (unsigned char *) reply + sz_xLbxGetImageReply,
+ 	      uncompLen, uncompLen, (int) stuff->width,
+ 	      ((xConnSetup *) ConnectionInfo)->bitmapBitOrder == LSBFirst,
+ 	      &bytes);
+ 
+ 	method = LbxImageCompressFaxG42D;
+     }
+     else /* depth 8 and ZPixmap format */
+     {
+ 	status = LbxImageEncodePackBits ((char *) theImage,
+ 	      (char *) reply + sz_xLbxGetImageReply, uncompLen,
+ 	      (int) stuff->height, (int) stuff->width, &bytes);
+ 
+ 	method = LbxImageCompressPackBits;
+     }
+ 
+     reply->type = X_Reply;
+     reply->depth = depth;
+     reply->sequenceNumber = client->sequence;
+     reply->visual = visual;
+ 
+     if (status != LBX_IMAGE_COMPRESS_SUCCESS)
+     {
+ 	reply->compressionMethod = LbxImageCompressNone;
+ 	reply->lbxLength = reply->xLength = (uncompLen + 3) >> 2;
+     }
+     else
+     {
+ 	reply->compressionMethod = method;
+ 	reply->lbxLength = (bytes + 3) >> 2;
+ 	reply->xLength = (uncompLen + 3) >> 2;
+     }
+ 
+     lbxLen = reply->lbxLength;
+ 
+     if (client->swapped)
+     {
+ 	swaps (&reply->sequenceNumber, n);
+ 	swapl (&reply->lbxLength, n);
+ 	swapl (&reply->xLength, n);
+ 	swapl (&reply->visual, n);
+     }
+ 
+     if (reply->compressionMethod != LbxImageCompressNone)
+     {
+ 	UncompressedWriteToClient (client,
+ 	    sz_xLbxGetImageReply + (lbxLen << 2), reply);
+     }
+     else
+     {
+ 	UncompressedWriteToClient (client, sz_xLbxGetImageReply, reply);
+ 	UncompressedWriteToClient (client, lbxLen << 2, theImage);
+     }
+ 
+     xfree (theImage);
+ 
+     if (reply)
+ 	xfree ((char *) reply);
+ 
+     return (Success);
  }
*** -	Wed Jan 18 13:07:54 1995
--- xc/workInProgress/lbx/programs/Xserver/lbx/lbxprop.c	Wed Jan 18 13:07:54 1995
***************
*** 1,4 ****
! /* $XConsortium: lbxprop.c,v 1.6 94/03/27 13:17:07 dpw Exp $ */
  /*
   * Copyright 1993 Network Computing Devices, Inc.
   *
--- 1,4 ----
! /* $XConsortium: lbxprop.c,v 1.7 94/12/01 20:29:09 mor Exp $ */
  /*
   * Copyright 1993 Network Computing Devices, Inc.
   *
***************
*** 20,26 ****
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
!  * $NCDId: @(#)lbxprop.c,v 1.11 1994/03/24 17:54:36 lemke Exp $
   *
   * Author:  Dave Lemke, Network Computing Devices
   */
--- 20,26 ----
   * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
!  * $NCDId: @(#)lbxprop.c,v 1.12 1994/09/23 20:51:51 lemke Exp $
   *
   * Author:  Dave Lemke, Network Computing Devices
   */
***************
*** 61,73 ****
      PropertyPtr pProp;
  {
      LbxQueryTagData(client, pProp->owner_pid, pProp->tag_id, LbxTagTypeProperty, pProp);
!     ResetCurrentRequest(client);
      client->sequence--;
  
  /* XXX this won't work too well went done to a proxy client.
   * need finer grain of control
   */
!     IgnoreClient(client);
  }
  
  int
--- 61,73 ----
      PropertyPtr pProp;
  {
      LbxQueryTagData(client, pProp->owner_pid, pProp->tag_id, LbxTagTypeProperty, pProp);
!     LbxResetCurrentRequest(client);
      client->sequence--;
  
  /* XXX this won't work too well went done to a proxy client.
   * need finer grain of control
   */
!     LbxIgnoreClient(client);
  }
  
  int
***************
*** 421,427 ****
  		    reply.length = 0;
  		reply.nItems = len / (pProp->format / 8);
  		reply.propertyType = pProp->type;
!                 reply.tag = pProp->tag_id;
  
  		if (stuff->delete && (reply.bytesAfter == 0)) {
  		    LbxFlushPropertyTag(tid);
--- 421,427 ----
  		    reply.length = 0;
  		reply.nItems = len / (pProp->format / 8);
  		reply.propertyType = pProp->type;
! 		reply.tag = pProp->tag_id;
  
  		if (stuff->delete && (reply.bytesAfter == 0)) {
  		    LbxFlushPropertyTag(tid);
*** -	Wed Jan 18 13:08:00 1995
--- xc/workInProgress/lbx/programs/Xserver/lbx/lbxswap.c	Wed Jan 18 13:08:00 1995
***************
*** 1,6 ****
! /* $XConsortium: lbxswap.c,v 1.2 94/03/27 13:18:13 dpw Exp $ */
  /*
!  * $NCDId: @(#)lbxswap.c,v 1.2 1994/03/21 20:59:28 lemke Exp $
   * $NCDOr: lbxmain.c,v 1.4 1993/12/06 18:47:18 keithp Exp keithp $
   *
   * Copyright 1992 Network Computing Devices
--- 1,6 ----
! /* $XConsortium: lbxswap.c,v 1.4 94/12/01 20:31:47 mor Exp $ */
  /*
!  * $NCDId: @(#)lbxswap.c,v 1.7 1994/11/18 20:32:42 lemke Exp $
   * $NCDOr: lbxmain.c,v 1.4 1993/12/06 18:47:18 keithp Exp keithp $
   *
   * Copyright 1992 Network Computing Devices
***************
*** 83,91 ****
      REQUEST(xLbxStartProxyReq);
  
      swaps(&stuff->length, n);
-     swaps(&stuff->deltaN, n);
-     swaps(&stuff->deltaMaxLen, n);
-     swapl(&stuff->comptype, n);
      return ProcLbxStartProxy(client);
  }
  
--- 83,88 ----
***************
*** 324,333 ****
      register int n;
  
      REQUEST(xLbxPolyPointReq);
  
      swaps(&stuff->length, n);
!     swapl(&stuff->drawable, n);
!     swapl(&stuff->gc, n);
      return ProcLbxDispatch(client);
  }
  
--- 321,337 ----
      register int n;
  
      REQUEST(xLbxPolyPointReq);
+     char *after;
  
      swaps(&stuff->length, n);
!     after = ((char *) stuff) + SIZEOF(xLbxPolyPointReq);
!     if (GFXdCacheEnt (stuff->cacheEnts) == GFXCacheNone)
!     {
! 	swapl (((Drawable *) after), n);
! 	after += sizeof (Drawable);
!     }
!     if (GFXgCacheEnt (stuff->cacheEnts) == GFXCacheNone)
! 	swapl (((GContext *) after), n);
      return ProcLbxDispatch(client);
  }
  
***************
*** 337,347 ****
  {
      register int n;
  
!     REQUEST(xLbxPolyPointReq);
  
      swaps(&stuff->length, n);
!     swapl(&stuff->drawable, n);
!     swapl(&stuff->gc, n);
      return ProcLbxDispatch(client);
  }
  
--- 341,504 ----
  {
      register int n;
  
!     REQUEST(xLbxFillPolyReq);
!     char *after;
! 
!     swaps(&stuff->length, n);
!     after = ((char *) stuff) + SIZEOF(xLbxFillPolyReq);
!     if (GFXdCacheEnt (stuff->cacheEnts) == GFXCacheNone)
!     {
! 	swapl (((Drawable *) after), n);
! 	after += sizeof (Drawable);
!     }
!     if (GFXgCacheEnt (stuff->cacheEnts) == GFXCacheNone)
! 	swapl (((GContext *) after), n);
!     return ProcLbxDispatch(client);
! }
! 
! static int
! SProcLbxCopyArea (client)
!     register ClientPtr	client;
! {
!     register int    n;
! 
!     REQUEST(xLbxCopyAreaReq);
!     char *after;
! 
!     swaps(&stuff->length, n);
!     after = ((char *) stuff) + SIZEOF(xLbxCopyAreaReq);
!     if (GFXdCacheEnt (stuff->srcCache) == GFXCacheNone)
!     {
! 	swapl (((Drawable *) after), n);
! 	after += sizeof (Drawable);
!     }
!     if (GFXdCacheEnt (stuff->cacheEnts) == GFXCacheNone)
!     {
! 	swapl (((Drawable *) after), n);
! 	after += sizeof (Drawable);
!     }
!     if (GFXgCacheEnt (stuff->cacheEnts) == GFXCacheNone)
! 	swapl (((GContext *) after), n);
!     return ProcLbxDispatch(client);
! }
! 
! static int
! SProcLbxCopyPlane (client)
!     register ClientPtr	client;
! {
!     register int    n;
! 
!     REQUEST(xLbxCopyPlaneReq);
!     char *after;
! 
!     swaps(&stuff->length, n);
!     swapl(&stuff->bitPlane, n);
!     after = ((char *) stuff) + SIZEOF(xLbxCopyPlaneReq);
!     if (GFXdCacheEnt (stuff->srcCache) == GFXCacheNone)
!     {
! 	swapl (((Drawable *) after), n);
! 	after += sizeof (Drawable);
!     }
!     if (GFXdCacheEnt (stuff->cacheEnts) == GFXCacheNone)
!     {
! 	swapl (((Drawable *) after), n);
! 	after += sizeof (Drawable);
!     }
!     if (GFXgCacheEnt (stuff->cacheEnts) == GFXCacheNone)
! 	swapl (((GContext *) after), n);
!     return ProcLbxDispatch(client);
! }
! 
! static int
! SProcLbxPolyText(client)
!     register ClientPtr client;
! {
!     register int n;
! 
!     REQUEST(xLbxPolyTextReq);
!     char *after;
! 
!     swaps(&stuff->length, n);
!     after = ((char *) stuff) + SIZEOF(xLbxPolyTextReq);
!     if (GFXdCacheEnt (stuff->cacheEnts) == GFXCacheNone)
!     {
! 	swapl (((Drawable *) after), n);
! 	after += sizeof (Drawable);
!     }
!     if (GFXgCacheEnt (stuff->cacheEnts) == GFXCacheNone)
! 	swapl (((GContext *) after), n);
!     return ProcLbxDispatch(client);
! }
! 
! static int
! SProcLbxImageText(client)
!     register ClientPtr client;
! {
!     register int n;
! 
!     REQUEST(xLbxImageTextReq);
!     char *after;
! 
!     swaps(&stuff->length, n);
!     after = ((char *) stuff) + SIZEOF(xLbxImageTextReq);
!     if (GFXdCacheEnt (stuff->cacheEnts) == GFXCacheNone)
!     {
! 	swapl (((Drawable *) after), n);
! 	after += sizeof (Drawable);
!     }
!     if (GFXgCacheEnt (stuff->cacheEnts) == GFXCacheNone)
! 	swapl (((GContext *) after), n);
!     return ProcLbxDispatch(client);
! }
! 
! 
! static int
! SProcLbxPutImage(client)
!     register ClientPtr client;
! {
!     register int n;
! 
!     REQUEST(xLbxPutImageReq);
! 
!     swaps (&stuff->lbxLength, n);
!     swaps (&stuff->xLength, n);
!     swapl (&stuff->drawable, n);
!     swapl (&stuff->gc, n);
!     swaps (&stuff->width, n);
!     swaps (&stuff->height, n);
!     swaps (&stuff->dstX, n);
!     swaps (&stuff->dstY, n);
!     return ProcLbxPutImage(client);
! }
! 
! static int
! SProcLbxGetImage(client)
!     register ClientPtr client;
! {
!     register int n;
! 
!     REQUEST(xLbxGetImageReq);
! 
!     swaps (&stuff->length, n);
!     swapl (&stuff->drawable, n);
!     swaps (&stuff->x, n);
!     swaps (&stuff->y, n);
!     swaps (&stuff->width, n);
!     swaps (&stuff->height, n);
!     swapl (&stuff->planeMask, n);
!     return ProcLbxGetImage(client);
! }
! 
! static int
! SProcLbxQueryExtension(client)
!     ClientPtr	client;
! {
!     int	n;
! 
!     REQUEST(xLbxQueryExtensionReq);
  
      swaps(&stuff->length, n);
!     swapl(&stuff->nbytes, n);
      return ProcLbxDispatch(client);
  }
  
***************
*** 397,402 ****
--- 554,575 ----
  	return SProcLbxGetProperty(client);
      case X_LbxTagData:
  	return SProcLbxTagData(client);
+     case X_LbxCopyArea:
+ 	return SProcLbxCopyArea(client);
+     case X_LbxCopyPlane:
+ 	return SProcLbxCopyPlane(client);
+     case X_LbxPolyText8:
+     case X_LbxPolyText16:
+ 	return SProcLbxPolyText(client);
+     case X_LbxImageText8:
+     case X_LbxImageText16:
+ 	return SProcLbxImageText (client);
+     case X_LbxQueryExtension:
+ 	return SProcLbxQueryExtension(client);
+     case X_LbxPutImage:
+ 	return SProcLbxPutImage(client);
+     case X_LbxGetImage:
+ 	return SProcLbxGetImage(client);
      default:
  	return BadRequest;
      }
*** /dev/null	Wed Jan 18 13:08:01 1995
--- xc/workInProgress/lbx/programs/Xserver/lbx/lbxexts.c	Wed Jan 18 13:08:01 1995
***************
*** 0 ****
--- 1,232 ----
+ /* $XConsortium: lbxexts.c,v 1.1 94/12/01 20:27:29 mor Exp $ */
+ /*
+  * Copyright 1994 Network Computing Devices, Inc.
+  *
+  * Permission to use, copy, modify, distribute, and sell this software and
+  * its documentation for any purpose is hereby granted without fee, provided
+  * that the above copyright notice appear in all copies and that both that
+  * copyright notice and this permission notice appear in supporting
+  * documentation, and that the name Network Computing Devices, Inc. not be
+  * used in advertising or publicity pertaining to distribution of this
+  * software without specific, written prior permission.
+  *
+  * THIS SOFTWARE IS PROVIDED `AS-IS'.  NETWORK COMPUTING DEVICES, INC.,
+  * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT
+  * LIMITATION ALL IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
+  * PARTICULAR PURPOSE, OR NONINFRINGEMENT.  IN NO EVENT SHALL NETWORK
+  * COMPUTING DEVICES, INC., BE LIABLE FOR ANY DAMAGES WHATSOEVER, INCLUDING
+  * SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES, INCLUDING LOSS OF USE, DATA,
+  * OR PROFITS, EVEN IF ADVISED OF THE POSSIBILITY THEREOF, AND REGARDLESS OF
+  * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
+  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  *
+  * $NCDId: @(#)lbxexts.c,v 1.3 1994/09/16 22:33:36 lemke Exp $
+  */
+ 
+ #include "X.h"
+ #include "Xproto.h"
+ #include "misc.h"
+ #include "dixstruct.h"
+ #define _XLBX_SERVER_
+ #include "lbxstr.h"
+ 
+ typedef struct _lbxext {
+     char       *name;
+     char      **aliases;
+     int         num_aliases;
+     int         idx;
+     int         opcode;
+     int         ev_base;
+     int         err_base;
+     int         num_reqs;
+     CARD8      *rep_mask;
+     CARD8      *ev_mask;
+ }           LbxExtensionEntry;
+ 
+ static LbxExtensionEntry **lbx_extensions = NULL;
+ static int  num_exts = 0;
+ 
+ 
+ Bool
+ LbxAddExtension(name, opcode, ev_base, err_base)
+     char       *name;
+     int         opcode;
+     int         ev_base,
+                 err_base;
+ {
+     int         i;
+     register LbxExtensionEntry *ext,
+               **newexts;
+ 
+     ext = (LbxExtensionEntry *) xalloc(sizeof(LbxExtensionEntry));
+     if (!ext)
+ 	return FALSE;
+     ext->name = (char *) xalloc(strlen(name) + 1);
+     ext->num_aliases = 0;
+     ext->aliases = (char **) NULL;
+     if (!ext->name) {
+ 	xfree(ext);
+ 	return FALSE;
+     }
+     strcpy(ext->name, name);
+     i = num_exts;
+     newexts = (LbxExtensionEntry **) xrealloc(lbx_extensions,
+ 				      (i + 1) * sizeof(LbxExtensionEntry *));
+     if (!newexts) {
+ 	xfree(ext->name);
+ 	xfree(ext);
+ 	return FALSE;
+     }
+     num_exts++;
+     lbx_extensions = newexts;
+     lbx_extensions[i] = ext;
+     ext->idx = i;
+ 
+     ext->opcode = opcode;;
+     ext->ev_base = ev_base;;
+     ext->err_base = err_base;
+     ext->ev_mask = NULL;
+     ext->rep_mask = NULL;
+     ext->num_reqs = 0;
+ 
+     return TRUE;
+ }
+ 
+ Bool
+ LbxAddExtensionAlias(idx, alias)
+     int         idx;
+     char       *alias;
+ {
+     char       *name;
+     char      **aliases;
+     LbxExtensionEntry *ext = lbx_extensions[idx];
+ 
+     aliases = (char **) xrealloc(ext->aliases,
+ 				 (ext->num_aliases + 1) * sizeof(char *));
+     if (!aliases)
+ 	return FALSE;
+     ext->aliases = aliases;
+     name = (char *) xalloc(strlen(alias) + 1);
+     if (!name)
+ 	return FALSE;
+     strcpy(name, alias);
+     ext->aliases[ext->num_aliases] = name;
+     ext->num_aliases++;
+     return TRUE;
+ }
+ 
+ Bool
+ LbxRegisterExtensionGenerationMasks(idx, num_reqs, rep_mask, ev_mask)
+     int         idx;
+     int         num_reqs;
+     char       *rep_mask,
+                *ev_mask;
+ {
+     LbxExtensionEntry *ext = lbx_extensions[idx];
+     CARD8      *nrm,
+                *nem;
+     int         mlen = mlen = num_reqs / (8 * sizeof(CARD8)) + 1;
+ 
+     nrm = (CARD8 *) xalloc(sizeof(CARD8) * mlen);
+     nem = (CARD8 *) xalloc(sizeof(CARD8) * mlen);
+ 
+     if (!nrm || !nem) {
+ 	xfree(nrm);
+ 	xfree(nem);
+ 	return FALSE;
+     }
+     bcopy((char *) rep_mask, (char *) nrm, mlen);
+     bcopy((char *) ev_mask, (char *) nem, mlen);
+     ext->rep_mask = nrm;
+     ext->ev_mask = nem;
+     ext->num_reqs = num_reqs;
+ 
+     return TRUE;
+ }
+ 
+ int
+ LbxQueryExtension(client, ename, nlen)
+     ClientPtr   client;
+     char       *ename;
+     int         nlen;
+ {
+     xLbxQueryExtensionReply rep;
+     int         i,
+                 j;
+     int         mlen = 0;
+ 
+     rep.type = X_Reply;
+     rep.sequenceNumber = client->sequence;
+     rep.major_opcode = 0;
+     rep.present = FALSE;
+     rep.length = 0;
+     for (i = 0; i < num_exts; i++) {
+ 	if ((strlen(lbx_extensions[i]->name) == nlen) &&
+ 		(strncmp(lbx_extensions[i]->name, ename, nlen) == 0)) {
+ 	    rep.present = TRUE;
+ 	    break;
+ 	}
+ 	for (j = lbx_extensions[i]->num_aliases; --j >= 0;) {
+ 	    if ((strlen(lbx_extensions[i]->aliases[j]) == nlen) &&
+ 		(strncmp(lbx_extensions[i]->aliases[j], ename, nlen) == 0)) {
+ 		rep.present = TRUE;
+ 		break;
+ 
+ 	    }
+ 	}
+     }
+     if (rep.present) {
+ 	rep.major_opcode = lbx_extensions[i]->opcode;
+ 	rep.first_event = lbx_extensions[i]->ev_base;
+ 	rep.first_error = lbx_extensions[i]->err_base;
+ 	rep.numReqs = lbx_extensions[i]->num_reqs;
+ 	if (lbx_extensions[i]->rep_mask) {
+ 	    mlen = lbx_extensions[i]->num_reqs / (8 * sizeof(CARD8)) + 1;
+ 	    rep.length = ((mlen + 3) >> 2) * 2;
+ 	}
+     }
+     if (client->swapped) {
+     	char	n;
+ 
+ 	swaps(&rep.sequenceNumber, n);
+ 	swapl(&rep.length, n);
+     }
+     WriteToClient(client, sizeof(xLbxQueryExtensionReply), &rep);
+     if (mlen) {
+ 	WriteToClient(client, mlen, lbx_extensions[i]->rep_mask);
+ 	WriteToClient(client, mlen, lbx_extensions[i]->ev_mask);
+     }
+     return Success;
+ }
+ 
+ LbxCloseDownExtensions()
+ {
+     int         i;
+ 
+     for (i = 0; i < num_exts; i++) {
+ 	xfree(lbx_extensions[i]->name);
+ 	xfree(lbx_extensions[i]->aliases);
+ 	xfree(lbx_extensions[i]->rep_mask);
+ 	xfree(lbx_extensions[i]->ev_mask);
+ 	xfree(lbx_extensions[i]);
+     }
+     xfree(lbx_extensions);
+     lbx_extensions = NULL;
+     num_exts = 0;
+ }
+ 
+ void
+ LbxSetReqMask(mask, req, on)
+     CARD8      *mask;
+     int         req;
+     Bool        on;
+ {
+     int         mword = req / (8 * sizeof(CARD8));
+ 
+     req = req % (8 * sizeof(CARD8));
+     if (on) {
+ 	mask[mword] |= (1 << req);
+     } else {
+ 	mask[mword] &= ~(1 << req);
+     }
+ }
*** /dev/null	Wed Jan 18 13:08:03 1995
--- xc/workInProgress/lbx/programs/Xserver/lbx/lbxopts.c	Wed Jan 18 13:08:02 1995
***************
*** 0 ****
--- 1,320 ----
+ /* $XConsortium: lbxopts.c,v 1.1 94/12/01 20:27:29 mor Exp $ */
+ /*
+  * Copyright 1994 Network Computing Devices, Inc.
+  *
+  * Permission to use, copy, modify, distribute, and sell this software and
+  * its documentation for any purpose is hereby granted without fee, provided
+  * that the above copyright notice appear in all copies and that both that
+  * copyright notice and this permission notice appear in supporting
+  * documentation, and that the name Network Computing Devices, Inc. not be
+  * used in advertising or publicity pertaining to distribution of this
+  * software without specific, written prior permission.
+  *
+  * THIS SOFTWARE IS PROVIDED `AS-IS'.  NETWORK COMPUTING DEVICES, INC.,
+  * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT
+  * LIMITATION ALL IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
+  * PARTICULAR PURPOSE, OR NONINFRINGEMENT.  IN NO EVENT SHALL NETWORK
+  * COMPUTING DEVICES, INC., BE LIABLE FOR ANY DAMAGES WHATSOEVER, INCLUDING
+  * SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES, INCLUDING LOSS OF USE, DATA,
+  * OR PROFITS, EVEN IF ADVISED OF THE POSSIBILITY THEREOF, AND REGARDLESS OF
+  * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
+  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  *
+  * $NCDId: @(#)lbxopts.c,v 1.1 1994/09/15 22:44:55 dct Exp $
+  */
+ 
+ #ifdef OPTDEBUG
+ #include <stdio.h>
+ #endif
+ #include "X.h"
+ #include "misc.h"
+ #include "lbxopts.h"
+ #include "lbxsrvopts.h"
+ #ifndef NO_LZW
+ #include "lbxlzw.h"
+ #endif /* NO_LZW */
+ 
+ static int LbxDeltaOpt();
+ static int LbxProxyDeltaOpt();
+ static int LbxServerDeltaOpt();
+ static int LbxStreamCompOpt();
+ static int LbxBitmapCompOpt();
+ static int LbxPixmapCompOpt();
+ static int LbxMessageCompOpt();
+ 
+ /*
+  * List of LBX options we recognize and are willing to negotiate
+  */
+ static struct _LbxOptionParser {
+     CARD8	optcode;
+     int		(*parser)();
+ } LbxOptions[] = {
+     { LBX_OPT_DELTA_PROXY, 	LbxProxyDeltaOpt },
+     { LBX_OPT_DELTA_SERVER,	LbxServerDeltaOpt },
+     { LBX_OPT_STREAM_COMP,	LbxStreamCompOpt },
+ #ifdef notyet
+     { LBX_OPT_BITMAP_COMP,	LbxBitmapCompOpt },
+     { LBX_OPT_PIXMAP_COMP,	LbxPixmapCompOpt },
+ #endif
+     { LBX_OPT_MSG_COMP,		LbxMessageCompOpt },
+ };
+ 
+ #define LBX_N_OPTS	(sizeof(LbxOptions) / sizeof(struct _LbxOptionParser))
+ 
+ /*
+  * Set option defaults
+  */
+ LbxOptionInit(pno)
+     LbxNegOptsPtr pno;
+ {
+     bzero(pno, sizeof(LbxNegOptsRec));
+     pno->proxyDeltaN = pno->serverDeltaN = LBX_OPT_DELTA_NCACHE_DFLT;
+     pno->proxyDeltaMaxLen = pno->serverDeltaMaxLen = LBX_OPT_DELTA_MSGLEN_DFLT;
+     pno->squish = TRUE;
+ }
+ 
+ int
+ LbxOptionParse(pno, popt, optlen, preply)
+     LbxNegOptsPtr pno;
+     unsigned char *popt;
+     int		  optlen;
+     unsigned char *preply;
+ {
+     int		  i;
+     int		  nopts = *popt++;
+     unsigned char *pout = preply;
+ 
+     for (i = 0; i < nopts; i++) {
+ 	int j;
+ 	int len;
+ 	int hdrlen;
+ 	int replylen;
+ 
+ 	LBX_OPT_DECODE_LEN(popt + 1, len, hdrlen);
+ 	if (len < ++hdrlen || len > optlen) {
+ #ifdef OPTDEBUG
+ 	    fprintf(stderr, "bad option length, len = %d, hdrlen = %d, optlen = %d\n", len, hdrlen, optlen);
+ #endif
+ 	    return -1;
+ 	}
+ 
+ 	for (j = 0; j < LBX_N_OPTS; j++) {
+ 	    if (popt[0] == LbxOptions[j].optcode) {
+ 		replylen = (*LbxOptions[j].parser)(pno,
+ 						   popt + hdrlen,
+ 						   len - hdrlen,
+ 						   pout + LBX_OPT_SMALLHDR_LEN);
+ 		if (replylen < 0)
+ 		    return -1;
+ 		else if (replylen > 0) {
+ 		    /*
+ 		     * None of the current options require big headers,
+ 		     * so this works for now.
+ 		     */
+ 		    *pout++ = i;
+ 		    *pout++ = LBX_OPT_SMALLHDR_LEN + replylen;
+ 		    pout += replylen;
+ 		    pno->nopts++;
+ 		}
+ 		break;
+ 	    }
+ 	}
+ 
+ 	optlen -= len;
+ 	popt += len;
+     }
+ 
+     return (pout - preply);
+ }
+ 
+ static int
+ LbxProxyDeltaOpt(pno, popt, optlen, preply)
+     LbxNegOptsPtr pno;
+     unsigned char *popt;
+     int		  optlen;
+     unsigned char *preply;
+ {
+     return LbxDeltaOpt(popt, optlen, preply,
+ 		       &pno->proxyDeltaN, &pno->proxyDeltaMaxLen);
+ }
+ 
+ static int
+ LbxServerDeltaOpt(pno, popt, optlen, preply)
+     LbxNegOptsPtr pno;
+     unsigned char *popt;
+     int		  optlen;
+     unsigned char *preply;
+ {
+     return LbxDeltaOpt(popt, optlen, preply,
+ 		       &pno->serverDeltaN, &pno->serverDeltaMaxLen);
+ }
+ 
+ static int
+ LbxDeltaOpt(popt, optlen, preply, pn, pmaxlen)
+     unsigned char *popt;
+     int		  optlen;
+     unsigned char *preply;
+     short	  *pn;
+     short	  *pmaxlen;
+ {
+     short	  n;
+     short	  maxlen;
+ 
+     /*
+      * If there's more data than we expect, we just ignore it.
+      */
+     if (optlen < LBX_OPT_DELTA_REQLEN) {
+ #ifdef OPTDEBUG
+ 	fprintf(stderr, "bad delta option length = %d\n", optlen);
+ #endif
+ 	return -1;
+     }
+ 
+     /*
+      * Accept whatever value the proxy prefers, so skip the
+      * min/max offerings.  Note that the max message len value is
+      * encoded as the number of 4-byte values.
+      */
+     popt += 2;
+     n = *popt++;
+     popt += 2;
+     maxlen = *popt++;
+     if ((maxlen <<= 2) == 0)
+ 	n = 0;
+     else if (maxlen < 32) {
+ #ifdef OPTDEBUG
+ 	fprintf(stderr, "bad delta max msg length %d\n", maxlen);
+ #endif
+ 	return -1;
+      }
+ 
+     /*
+      * Put the response in the reply buffer
+      */
+     *preply++ = n;
+     *preply++ = maxlen >> 2;
+ 
+     *pn = n;
+     *pmaxlen = maxlen;
+ 
+     return LBX_OPT_DELTA_REPLYLEN;
+ }
+ 
+ static int LzwParse();
+ 
+ static struct _LbxStreamCompParser {
+     int		typelen;
+     char	*type;
+     int		(*parser)();
+ } LbxStreamComp[] = {
+ #ifndef NO_LZW
+     { LZW_STRCOMP_OPT_LEN,	LZW_STRCOMP_OPT, 	LzwParse },
+ #endif /* NO_LZW */
+ };
+ 
+ #define LBX_N_STRCOMP	\
+     (sizeof(LbxStreamComp) / sizeof(struct _LbxStreamCompParser))
+ 
+ static int
+ LbxStreamCompOpt(pno, popt, optlen, preply)
+     LbxNegOptsPtr pno;
+     unsigned char *popt;
+     int		  optlen;
+     unsigned char *preply;
+ {
+     int		  i;
+     int		  typelen;
+     int		  nopts = *popt++;
+ 
+     for (i = 0; i < nopts; i++) {
+ 	int j;
+ 	int len;
+ 	int lensize;
+ 	int replylen;
+ 
+ 	typelen = popt[0];
+ 	for (j = 0; j < LBX_N_STRCOMP; j++) {
+ 	    if (typelen == LbxStreamComp[j].typelen &&
+ 		!strncmp((char *) popt + 1, LbxStreamComp[j].type, typelen))
+ 		break;
+ 	}
+ 
+ 	popt += 1 + typelen;
+ 	optlen -= 1 + typelen;
+ 	LBX_OPT_DECODE_LEN(popt, len, lensize);
+ 
+ 	if (j < LBX_N_STRCOMP) {
+ 	    if (len > optlen)
+ 		return -1;
+ 	    replylen = (*LbxStreamComp[j].parser)(pno,
+ 						  popt + lensize,
+ 						  len - lensize,
+ 						  preply + 1);
+ 	    if (replylen == -1)
+ 		return -1;
+ 	    else if (replylen >= 0) {
+ 		*preply = i;
+ 		return replylen + 1;
+ 	    }
+ 	}
+ 
+ 	optlen -= len;
+ 	popt += len;
+     }
+ 
+     return 0;
+ }
+ 
+ /*
+  * LZW-specific option data is a list of code-sizes.  Select the
+  * first value we support.
+  */
+ static int
+ LzwParse(pno, popt, optlen, preply)
+     LbxNegOptsPtr  pno;
+     unsigned char  *popt;
+     int		   optlen;
+     unsigned char  *preply;
+ {
+     int		   ncodes = *popt++;
+     int		   i;
+     extern pointer LzwInit();
+ 
+     if (ncodes + 1 < optlen) {
+ #ifdef OPTDEBUG
+ 	fprintf(stderr, "bad number of lzw code-sizes specified %d\n", ncodes);
+ #endif
+ 	return -1;
+     }
+ 
+     for (i = 0; i < ncodes; i++) {
+ 	int codesize = *popt++;
+ 	if (codesize == 12 || codesize == 14) {
+ 	    *preply++ = i;
+ 	    pno->streamCompInit = LzwInit;
+ 	    pno->streamCompArg = (pointer) codesize;
+ 	    return 1;
+ 	}
+     }
+ 
+     return -2;
+ }
+ 
+ static int
+ LbxMessageCompOpt(pno, popt, optlen, preply)
+     LbxNegOptsPtr pno;
+     unsigned char *popt;
+     int		  optlen;
+     unsigned char *preply;
+ {
+ 
+     if (optlen == 0) {
+ #ifdef OPTDEBUG
+ 	fprintf(stderr, "bad message-comp option length specified %d\n", optlen);
+ #endif
+ 	return -1;
+     }
+ 
+     pno->squish = *preply = *popt;
+     return 1;
+ }
*** /dev/null	Wed Jan 18 13:08:04 1995
--- xc/workInProgress/lbx/programs/Xserver/lbx/lbxsquish.c	Wed Jan 18 13:08:03 1995
***************
*** 0 ****
--- 1,227 ----
+ /* $XConsortium: lbxsquish.c,v 1.1 94/12/01 20:27:29 mor Exp $ */
+ /*
+  * Copyright 1994 Network Computing Devices, Inc.
+  *
+  * Permission to use, copy, modify, distribute, and sell this software and
+  * its documentation for any purpose is hereby granted without fee, provided
+  * that the above copyright notice appear in all copies and that both that
+  * copyright notice and this permission notice appear in supporting
+  * documentation, and that the name Network Computing Devices, Inc. not be
+  * used in advertising or publicity pertaining to distribution of this
+  * software without specific, written prior permission.
+  *
+  * THIS SOFTWARE IS PROVIDED `AS-IS'.  NETWORK COMPUTING DEVICES, INC.,
+  * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT
+  * LIMITATION ALL IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
+  * PARTICULAR PURPOSE, OR NONINFRINGEMENT.  IN NO EVENT SHALL NETWORK
+  * COMPUTING DEVICES, INC., BE LIABLE FOR ANY DAMAGES WHATSOEVER, INCLUDING
+  * SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES, INCLUDING LOSS OF USE, DATA,
+  * OR PROFITS, EVEN IF ADVISED OF THE POSSIBILITY THEREOF, AND REGARDLESS OF
+  * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
+  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  *
+  * $NCDId: @(#)lbxsquish.c,v 1.3 1994/09/01 18:22:13 lemke Exp $
+  */
+ #define NEED_REPLIES
+ #define NEED_EVENTS
+ #include "X.h"
+ #include "Xproto.h"
+ #include "Xos.h"
+ #include "misc.h"
+ #include "lbxserve.h"
+ #define _XLBX_SERVER_
+ #include "lbxstr.h"
+ 
+ /* handles server-side protocol squishing */
+ 
+ LbxEventLength(proxy, ev)
+     LbxProxyPtr	proxy;
+     xEvent     *ev;
+ {
+     if (!proxy->dosquishing)
+ 	return 32;
+ 
+     if (ev->u.u.type == X_Error || ev->u.u.type == X_Reply)
+ 	return 32;
+ 
+     switch (ev->u.u.type) {
+     case KeyPress:
+     case KeyRelease:
+     case ButtonPress:
+     case ButtonRelease:
+     case MotionNotify:
+ 	return lbxsz_KeyButtonEvent;
+     case EnterNotify:
+     case LeaveNotify:
+ 	return lbxsz_EnterLeaveEvent;
+     case FocusIn:
+     case FocusOut:
+ 	return lbxsz_FocusEvent;
+     case KeymapNotify:
+ 	return lbxsz_KeymapEvent;
+     case Expose:
+ 	return lbxsz_ExposeEvent;
+     case GraphicsExpose:
+ 	return lbxsz_GfxExposeEvent;
+     case NoExpose:
+ 	return lbxsz_NoExposeEvent;
+     case VisibilityNotify:
+ 	return lbxsz_VisibilityEvent;
+     case CreateNotify:
+ 	return lbxsz_CreateNotifyEvent;
+     case DestroyNotify:
+ 	return lbxsz_DestroyNotifyEvent;
+     case UnmapNotify:
+ 	return lbxsz_UnmapNotifyEvent;
+     case MapNotify:
+ 	return lbxsz_MapNotifyEvent;
+     case MapRequest:
+ 	return lbxsz_MapRequestEvent;
+     case ReparentNotify:
+ 	return lbxsz_ReparentEvent;
+ 
+     case ConfigureNotify:
+ 	return lbxsz_ConfigureNotifyEvent;
+     case ConfigureRequest:
+ 	return lbxsz_ConfigureRequestEvent;
+     case GravityNotify:
+ 	return lbxsz_GravityEvent;
+     case ResizeRequest:
+ 	return lbxsz_ResizeRequestEvent;
+     case CirculateNotify:
+     case CirculateRequest:
+ 	return lbxsz_CirculateEvent;
+     case PropertyNotify:
+ 	return lbxsz_PropertyEvent;
+     case SelectionClear:
+ 	return lbxsz_SelectionClearEvent;
+     case SelectionRequest:
+ 	return lbxsz_SelectionRequestEvent;
+     case SelectionNotify:
+ 	return lbxsz_SelectionNotifyEvent;
+     case ColormapNotify:
+ 	return lbxsz_ColormapEvent;
+     case ClientMessage:
+ 	return lbxsz_ClientMessageEvent;
+     default:
+ 	return lbxsz_UnknownEvent;
+     }
+ }
+ 
+ static void
+ repack_event(src, dst)
+     xEvent     *src,
+                *dst;
+ {
+     int	etype = src->u.u.type;
+ 
+     switch (etype) {
+     case KeyPress:
+     case KeyRelease:
+     case ButtonPress:
+     case ButtonRelease:
+     case MotionNotify:
+ 	memmove(dst, src, lbxsz_KeyButtonEvent);
+ 	break;
+     case EnterNotify:
+     case LeaveNotify:
+ 	memmove(dst, src, lbxsz_EnterLeaveEvent);
+ 	break;
+     case FocusIn:
+     case FocusOut:
+ 	memmove(dst, src, lbxsz_FocusEvent);
+ 	break;
+     case KeymapNotify:
+ 	memmove(dst, src, lbxsz_KeymapEvent);
+ 	break;
+     case Expose:
+ 	memmove(dst, src, lbxsz_ExposeEvent);
+ 	break;
+     case GraphicsExpose:
+ 	memmove(dst, src, lbxsz_GfxExposeEvent);
+ 	break;
+     case NoExpose:
+ 	memmove(dst, src, lbxsz_NoExposeEvent);
+ 	break;
+     case VisibilityNotify:
+ 	memmove(dst, src, lbxsz_VisibilityEvent);
+ 	break;
+     case CreateNotify:
+ 	memmove(dst, src, lbxsz_CreateNotifyEvent);
+ 	break;
+     case DestroyNotify:
+ 	memmove(dst, src, lbxsz_DestroyNotifyEvent);
+ 	break;
+     case UnmapNotify:
+ 	memmove(dst, src, lbxsz_UnmapNotifyEvent);
+ 	break;
+     case MapNotify:
+ 	memmove(dst, src, lbxsz_MapNotifyEvent);
+ 	break;
+     case MapRequest:
+ 	memmove(dst, src, lbxsz_MapRequestEvent);
+ 	break;
+     case ReparentNotify:
+ 	memmove(dst, src, lbxsz_ReparentEvent);
+ 	break;
+     case ConfigureNotify:
+ 	memmove(dst, src, lbxsz_ConfigureNotifyEvent);
+ 	break;
+     case ConfigureRequest:
+ 	memmove(dst, src, lbxsz_ConfigureRequestEvent);
+ 	break;
+     case GravityNotify:
+ 	memmove(dst, src, lbxsz_GravityEvent);
+ 	break;
+     case ResizeRequest:
+ 	memmove(dst, src, lbxsz_ResizeRequestEvent);
+ 	break;
+     case CirculateNotify:
+     case CirculateRequest:
+ 	memmove(dst, src, lbxsz_CirculateEvent);
+ 	break;
+     case PropertyNotify:
+ 	memmove(dst, src, lbxsz_PropertyEvent);
+ 	break;
+     case SelectionClear:
+ 	memmove(dst, src, lbxsz_SelectionClearEvent);
+ 	break;
+     case SelectionRequest:
+ 	memmove(dst, src, lbxsz_SelectionRequestEvent);
+ 	break;
+     case SelectionNotify:
+ 	memmove(dst, src, lbxsz_SelectionNotifyEvent);
+ 	break;
+     case ColormapNotify:
+ 	memmove(dst, src, lbxsz_ColormapEvent);
+ 	break;
+     case MappingNotify:
+ 	memmove(dst, src, lbxsz_MappingNotifyEvent);
+ 	break;
+     case ClientMessage:
+ 	memmove(dst, src, lbxsz_ClientMessageEvent);
+ 	break;
+     default:
+ 	*dst = *src;
+ 	break;
+     }
+ }
+ 
+ int
+ LbxSquishEvent(proxy, ev, evbuf)
+     LbxProxyPtr	proxy;
+     xEvent     *ev;
+     char       *evbuf;
+ {
+     int         len;
+ 
+     len = LbxEventLength(proxy, ev);
+ 
+     /* repack if necessary */
+     if (len != sizeof(xEvent)) {
+ 	repack_event(ev, (xEvent *) evbuf);
+     } else {
+ 	memmove(evbuf, (char *) ev, len);
+     }
+     return len;
+ }
*** /dev/null	Wed Jan 18 13:08:05 1995
--- xc/workInProgress/lbx/programs/Xserver/lbx/lbxsrvopts.h	Wed Jan 18 13:08:04 1995
***************
*** 0 ****
--- 1,48 ----
+ /* $XConsortium: lbxsrvopts.h,v 1.1 94/12/01 20:27:29 mor Exp $ */
+ /*
+  * Copyright 1994 Network Computing Devices, Inc.
+  *
+  * Permission to use, copy, modify, distribute, and sell this software and
+  * its documentation for any purpose is hereby granted without fee, provided
+  * that the above copyright notice appear in all copies and that both that
+  * copyright notice and this permission notice appear in supporting
+  * documentation, and that the name Network Computing Devices, Inc. not be
+  * used in advertising or publicity pertaining to distribution of this
+  * software without specific, written prior permission.
+  *
+  * THIS SOFTWARE IS PROVIDED `AS-IS'.  NETWORK COMPUTING DEVICES, INC.,
+  * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT
+  * LIMITATION ALL IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
+  * PARTICULAR PURPOSE, OR NONINFRINGEMENT.  IN NO EVENT SHALL NETWORK
+  * COMPUTING DEVICES, INC., BE LIABLE FOR ANY DAMAGES WHATSOEVER, INCLUDING
+  * SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES, INCLUDING LOSS OF USE, DATA,
+  * OR PROFITS, EVEN IF ADVISED OF THE POSSIBILITY THEREOF, AND REGARDLESS OF
+  * WHETHER IN AN ACTION IN CONTRACT, TORT OR NEGLIGENCE, ARISING OUT OF OR IN
+  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  *
+  * $NCDId: @(#)lbxsrvopts.h,v 1.1 1994/09/15 22:44:56 dct Exp $
+  */
+ 
+ #ifndef _LBX_SRVOPTS_H_
+ #define _LBX_SRVOPTS_H_
+ 
+ typedef struct _LbxNegOpts {
+     int		nopts;
+     short	proxyDeltaN;
+     short	proxyDeltaMaxLen;
+     short	serverDeltaN;
+     short	serverDeltaMaxLen;
+     pointer	(*streamCompInit)();
+     pointer	streamCompArg;
+ #ifdef notyet
+     pointer	(*bitmapCompInit)();
+     pointer	bitmapCompArg;
+     pointer	(*pixmapCompInit)();
+     pointer	pixmapCompArg;
+ #endif
+     Bool	squish;
+ } LbxNegOptsRec;
+ 
+ typedef LbxNegOptsRec *LbxNegOptsPtr;
+ 
+ #endif /* _LBX_SRVOPTS_H_ */
*** -	Wed Jan 18 17:19:31 1995
--- xc/doc/specs/Xext/Imakefile	Wed Jan 18 17:19:30 1995
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile,v 1.10 94/04/18 12:05:22 rws Exp $
  
  MakeSimpleDoc(shape,shape.ms)
  
--- 1,4 ----
! XCOMM $XConsortium: Imakefile,v 1.11 94/10/04 18:37:13 gildea Exp $
  
  MakeSimpleDoc(shape,shape.ms)
  
***************
*** 14,45 ****
  
  MakeTblDoc(buffer,buffer.ms)
  
- #if HasLatex
- 
- #ifndef LatexCmd
- #define LatexCmd latex
- #endif
- #ifndef DvipsCmd
- #define DvipsCmd dvips
- #endif
- 
- LATEX = LatexCmd
- DVIPS = DvipsCmd
- 
- #ifndef MakeLatexDoc
- #define MakeLatexDoc(file,srcs)						@@\
- all:: file.PS								@@\
- 									@@\
- file.dvi: srcs								@@\
- 	$(LATEX) srcs							@@\
- 									@@\
- file.PS: file.dvi							@@\
- 	$(DVIPS) -o file.nPS file && $(MV) file.nPS $@			@@\
- 									@@\
- clean::									@@\
- 	RemoveFiles(file.nPS file.PS file.dvi file.aux file.log)
- #endif /* MakeLatexDoc */
- 
  MakeLatexDoc(sync,sync.tex)
- 
- #endif
--- 14,17 ----
