\&
.sp 1
.ce 3
\s+1\fBChapter 1\fP\s-1

\s+1\fB\*(tk Overview\fP\s-1
.sp 2
.nr H1 1
.nr H2 0
.nr H3 0
.nr H4 0
.nr H5 0
.LP
.XS
Chapter 1 \- \*(tk Overview
.XE
.LP
The \*(tk provides the base functionality necessary to build a wide variety
of application environments.
It is fully extensible and supportive of the independent development
of new or extended components.
This is accomplished by defining interfaces that mask
implementation details from both applications 
and common component implementors.
By following a small set of conventions,
a programmer can extend the \*(tk in new ways 
and have these extensions function smoothly with the existing facilities.
.LP
The \*(tk is a library package layered on top of the X Window System.
This layer extends the basic abstractions provided by X and, thus, provides
the next layer of functionality by supplying mechanisms for intercomponent 
and intracomponent interactions.
In the \*(tk, 
a widget is a combination of an X window (or subwindow) 
and its associated semantics.
.LP
To the extent possible,
the \*(tk is policy free.
The application environment, not the \*(tk, defines, implements, and enforces:
.IP \(bu 5
Policy
.IP \(bu 5
Consistency
.IP \(bu 5
Style
.LP
Each individual widget implementation defines its own policy.
The \*(tk design allows for the development of radically differing
widget implementations.
.NH 2
Introduction
.XS
\*(SN Introduction
.XE
.LP
The \*(tk provides tools that simplify the design of application user
interfaces in the X Window System programming environment.
It assists application programmers by providing a commonly used set
of underlying user-interface functions to manage:
.IP \(bu 5
Toolkit initialization
\.IP \(bu 5
Widgets
.IP \(bu 5
Memory
.IP \(bu 5
Window, file, and timer events
.IP \(bu 5
Widget geometry
.IP \(bu 5
Input focus
.IP \(bu 5
Selections
.IP \(bu 5
Resources and resource conversion
.IP \(bu 5                       
Translation of events
.IP \(bu 5                       
Graphics contexts
.IP \(bu 5
Pixmaps
.IP \(bu 5
Errors and warnings
.LP
At present,
the \*(tk consists of:
.IP \(bu 5
A set of Intrinsic mechanisms for building widgets
.IP \(bu 5
An architectural model for constructing and composing widgets
.IP \(bu 5
A consistent interface (widget set) for programming
.LP
The Intrinsics mechanisms are intended for the widget programmer.
The architectural model lets the widget programmer design new widgets
by using the Intrinsics or by combining other widgets.
The application interface layers built on top of the \*(tk include a 
coordinated set of widgets and composition policies.
Some of these widgets and policies are application domain specific,
while others are common across a number of application domains.
.LP
The \*(tk provides an architectural model that is flexible enough to 
accommodate a number of different application interface layers.
In addition,
the supplied set of \*(tk functions are:
.IP \(bu 5
Functionally complete and policy free
.IP \(bu 5
Stylistically and functionally consistent with the X Window System primitives
.IP \(bu 5
Portable across languages, computer architectures, and operating systems
.LP
Applications that use the \*(tk must include the following header files:
.IP \(bu 5
.Pn < X11/Xlib.h >
.IP \(bu 5
.Pn < X11/Intrinsic.h >
.IP \(bu 5
.Pn < X11/StringDefs.h >
.LP
and possibly also:
.IP \(bu 5
.Pn < X11/Xatoms.h >
.IP \(bu 5
.Pn < X11/Shell.h >
.LP
Widget implementations should include
.IP \(bu 5
.Pn < X11/IntrinsicP.h >
instead of 
.Pn < X11/Intrinsic.h >.
.LP
The applications should also include the additional headers for 
each widget class that they are to use (for example,
.Pn < X11/Label.h >
or
.Pn < X11/Scroll.h >).
The Intrinsics object library file is named
.PN libXt.a
and, on a UNIX-based system, is normally referenced as \-lXt.
.NH 2
Terminology
.LP
.XS
\*(SN Terminology
.XE
The following terms are used throughout this manual.
.LP
.PN "Application programmer"
.IP
A programmer who uses the \*(tk to produce an application user interface.
.LP
.PN Class
.IP
The general group that a specific object belongs to.
.LP
.PN Client
.IP
A routine that uses a widget in an application or for composing
another widget.
.LP
.PN Instance
.IP
A specific widget object as opposed to a general widget class.
.LP
.PN Method
.IP
The functions or procedures that a widget itself implements.
.LP
.PN Name
.IP
The name that is specific to an instance of a widget for a given client.
.LP 
.PN Object 
.IP
A software data abstraction consisting of private data and private and public 
routines that operate on the private data.
Users of the abstraction can interact with the object only through calls 
to the object's public routines.
In the \*(tk,
some of the object's public routines are called directly by the application,
while others are called indirectly when the application calls the common
Routines.
In general, if a function is common to all widgets, 
an application uses a single Intrinsic routine to invoke the function for all
types of widgets.
If a function is unique to a single widget type,
the widget exports the function as another ``Xt'' routine.
.LP
.PN Resource
.IP
A named piece of data in a widget that can be set by a client,
by an application, or by user defaults.
.LP
.PN User
.IP
A person interacting with a workstation.
.LP
.PN Widget
.IP
An object providing a user-interface abstraction (for example, a Scrollbar
widget).
.LP
.PN "Widget class"
.IP
The general group that a specific widget belongs to,
which is otherwise know as the type of the widget.
.LP
.PN "Widget programmer"
.IP
A programmer who adds new widgets to the \*(tk.
.bp
\&
.sp 1
.ce 3
\s+1\fBChapter 2\fP\s-1

\s+1\fBWidgets\fP\s-1
.sp 2
.nr H1 2
.nr H2 0
.nr H3 0
.nr H4 0
.nr H5 0
.LP
.XS
Chapter 2 \- Widgets
.XE
The fundamental data type of the \*(tk is the widget, 
which is dynamically allocated and contains state information.
Every widget belongs to exactly one ``widget class'' that is statically 
allocated and initialized and that contains the operations allowable on
widgets of that class.
.LP
Logically, a widget is a rectangle with associated input/output semantics.
Some widgets display information (for example, text or graphics), 
while others are merely containers for other widgets 
(for example, a menu box).
Some widgets are output-only and do not react to pointer or keyboard input,
while others change their display in response to input 
and can invoke functions that an application has attached to them.
.LP
Much of the input/output of a widget is customizable by users.
Such customization includes fonts, colors, sizes, border widths, and so on.
.LP
A widget instance is composed of two parts:
.IP \(bu 5
A data structure that contains instance-specific values.
.IP \(bu 5
A class structure that contains information that is applicable to
all widgets of that class.
.LP
Logically, a widget class is the procedures and data that is associated 
with all widgets belonging to that class.
These procedures and data can be inherited by
subclasses.
.LP
Physically, a widget class is a pointer to a structure.
The contents of this structure are constant for all widgets of the widget
class, even though the values can vary from widget class to widget class.
(Here, ``constant'' means the class structure is initialized at compile-time 
and never changed, except for a one-shot class initialization 
and in-place compilation of resource lists,
which takes place when the first widget of the class or subclass is created.)
A widget instance is allocated and initialized by
.PN XtCreateWidget .
For further information,
see ``Creating Widgets''. 
.LP
The organization of the declarations and code for a new widget class 
between a public ``.h'' file, a private ``.h'' file, 
and the implementation ``.c''
file is described in ``Widget Classes''.  
The predefined widget classes adhere to these conventions.
.NH 2
Core Widget Definition
.XS
\*(SN Core Widget Definition
.XE
.LP
The Core widget contains the definitions of fields common to all widgets.
All widgets are subclasses of Core.
.NH 3
CoreClassPart
.XS
\*(SN CoreClassPart 
.XE
.LP
The common fields for all widget classes are defined in the 
.PN CoreClassPart 
structure:
.LP
.IN "CoreClassPart" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	WidgetClass superclass;	See ``Widget Classes''
	String class_name;	See ``Widget Classes''
	Cardinal widget_size;	See ``Creating Widgets''
	XtProc class_initialize;	See ``Widget Classes''
	XtWidgetClassProc class_part_initialize;	See ``Widget Classes''
	Boolean class_inited;	Private to ``XtCreateWidget''
	XtInitProc initialize;	See ``Creating Widgets''
	XtArgsProc initialize_hook;	See ``Creating Widgets''
	XtRealizeProc realize;	See ``Creating Widgets''
	XtActionList actions;	See ``Translation Management''
	Cardinal num_actions;	See ``Translation Management''
	XtResourceList resources;	See ``Resource Management''
	Cardinal num_resources;	See ``Resource Management''
	XrmClass xrm_class;	Private to ``Resource Management''
	Boolean compress_motion;	See ``Mouse Motion Compression''
	Boolean compress_exposure;	See ``Exposure Compression''
	Boolean compress_enterleave;	See ``Enter/Leave Compression''
	Boolean visible_interest;	See ``Widget Exposure and Visibility''
	XtWidgetProc destroy;	See ``Destroying Widgets''
	XtWidgetProc resize;	See ``Geometry Management''
	XtExposeProc expose;	See ``Widget Exposure and Visibility''
	XtSetValuesFunc set_values;	See ``Reading and Writing Widget State''
	XtArgsFunc set_values_hook;	See ``Reading and Writing Widget State''
	XtAlmostProc set_values_almost;	See ``Reading and Writing Widget State''
	XtArgsProc get_values_hook;	See ``Reading and Writing Widget State''
	XtWidgetProc accept_focus;	See ``Focus Management''
	XtVersionType version;	See ``Widget Classes''
	_XtOffsetList callback_private;	Private to ``Callbacks''
	String tm_table;		See ``Translation Management''
	XtGeometryHandler query_geometry;	See ``Geometry Management''
} CoreClassPart;
.De
.LP
All widget classes have the core class fields as their first component.
The prototypical type 
.PN WidgetClass 
is defined with only this set of fields.
Various routines can cast widget class pointers, as needed, 
to specific widget class types.
.LP
.IN "WidgetClass" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	CoreClassPart core_class;
} WidgetClassRec, *WidgetClass;
.De
.LP
The predefined class record and pointer for 
.PN WidgetClassRec 
are:
.LP
.Ds
.TA .5i 3i
.ta .5i 3i
extern WidgetClassRec widgetClassRec;
.sp 6p
extern WidgetClass widgetClass;
.De
.LP
The opaque types 
.PN Widget 
and 
.PN WidgetClass 
and the opaque variable 
.PN widgetClass 
are defined for generic actions on widgets.
.NH 3
CorePart
.XS
\*(SN CorePart
.XE
.LP
The common fields for all widget instances are defined in the 
.PN CorePart 
structure:
.LP
.IN "CorePart" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	Widget self;
	WidgetClass widget_class;	See ``Widget Classes''
	Widget parent;	See ``Widget Classes''
	String name;	See ``Resource Management''
	XrmName xrm_name;	Private to ``Resource Management''
	Screen *screen;	See ``Obtaining Window Information''
	Colormap colormap;	See ``Obtaining Window Information''
	Window window;	See ``Obtaining Window Information''
	Position x;	See ``Geometry Management''
	Position y;	See ``Geometry Management''
	Dimension width;	See ``Geometry Management''
	Dimension height;	See ``Geometry Management''
	Cardinal depth;	See ``Window Attributes''
	Dimension border_width;	See ``Geometry Management''
	Pixel border_pixel;	See ``Obtaining Window Information''
	Pixmap border_pixmap;	See ``Obtaining Window Information''
	Pixel background_pixel;	See ``Obtaining Window Information''
	Pixmap background_pixmap;	See ``Obtaining Window Information''
	_XtEventTable event_table;	Private to ``Event Management''
	struct _TMRec tm;	Private to ``Translation Management''
	caddr_t constraints;	See ``Constrained Composite Widgets''
	Boolean visible;	See ``Widget Visibility and Exposure''
	Boolean sensitive;	See ``Setting and Checking Sensitivity''
	Boolean ancestor_sensitive;	See ``Setting and Checking Sensitivity''
	Boolean managed;	See ``Composite Widgets''
	Boolean mapped_when_managed;	See ``Composite Widgets''
	Boolean being_destroyed;	See ``Destroying Widgets''
	XtCallbackList destroy_callbacks;	See ``Destroying Widgets''
	WidgetList popup_list;	See``Pop-up Widgets''
	Cardinal num_popups;	See ``Pop-up Widgets''
} CorePart;
.De
.LP
All widget instances have the core fields as their first component.
The prototypical type 
.PN Widget
is defined with only this set of fields. 
Various routines can cast widget pointers, as needed, 
to specific widget types.
.LP
.IN "Widget" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	CorePart core;
} WidgetRec, *Widget;
.De
.NH 3
CorePart Default Values
.XS
\*(SN CorePart Default Values
.XE
.LP
The default values for the core fields, which are filled in by the Core
resource list and the Core initialize procedure, are:
.LP
.TS
lw(1.5i) lw(4.25i) .
_
.sp 6p
Field	Default Value
.sp 6p
_
.sp 6p
self	address of the widget structure (may not be changed)
T{
widget_class
T}	T{
widget_class argument to 
.PN XtCreateWidget
(may not be changed)
T}
T{
parent
T}	T{
parent argument to 
.PN XtCreateWidget
(may not be changed)
T}
T{
name
T}	T{
name argument to 
.PN XtCreateWidget
(may not be changed)
T}
T{
screen
T}	T{
parent's screen, but top-level widget from display specifier
(may not be changed)
T}
colormap	the default color map for the screen
window	NULL
x	0
y	0
width	0
height	0
depth	parent's depth, but top-level widget gets root window depth
border_width	1
border_pixel	BlackPixel of screen
border_pixmap	NULL
background_pixel	WhitePixel of screen
background_pixmap	NULL
visible	TRUE
sensitive	TRUE
ancestor_sensitive	bitwise AND of parent's sensitive & ancestor_sensitive
managed	FALSE
map_when_managed	TRUE
being_destroyed	parent's being_destroyed
destroy_callbacks	NULL
.sp 6p
_
.TE
.NH 2
Composite Widget Definition
.XS
\*(SN Composite Widget Definition
.XE
.LP
Composite widgets are a subclass of the Core widget and are more fully
described in ``Composite Widgets''.
.NH 3
CompositeClassPart
.XS
\*(SN CompositeClassPart
.XE
.LP
In addition to the Core widget class fields,
Composite widgets have the following class fields:
.LP
.IN "CompositeClassPart" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	XtGeometryHandler geometry_manager;	See ``Geometry Management''
	XtWidgetProc change_managed;	See ``Composite Widgets''
	XtWidgetProc insert_child;	See ``Composite Widgets''
	XtWidgetProc delete_child;	See ``Composite Widgets''
	XtWidgetProc move_focus_to_next;	See ``Focus Management''
	XtWidgetProc move_focus_to_prev;	See ``Focus Management''
} CompositeClassPart;
.De
.LP
Composite widget classes have the composite fields immediately following the
core fields:
.LP
.IN "CompositeWidgetClass" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	CoreClassPart core_class;
	CompositeClassPart composite_class;
} CompositeClassRec, *CompositeWidgetClass;
.De
.LP
The predefined class record and pointer for 
.PN CompositeClassRec 
are:
.LP
.Ds 
.TA .5i 3i
.ta .5i 3i
extern CompositeClassRec compositeClassRec;
.sp 6p
extern WidgetClass compositeWidgetClass;
.De
.LP
The opaque types 
.PN CompositeWidget 
and 
.PN CompositeWidgetClass
and the opaque variable 
.PN compositeWidgetClass 
are defined for generic operations on widgets that are a subclass of 
.PN CompositeWidget .
.NH 3
CompositePart
.XS
\*(SN CompositePart
.XE
.LP
In addition to the 
.PN CorePart
fields,
Composite widgets have the following fields defined in the 
.PN CompositePart 
structure:
.LP
.IN "CompositePart" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	WidgetList children;	See ``Widget Classes''
	Cardinal num_children;	See ``Widget Classes''
	Cardinal num_slots;	See ``Composite Widgets''
	Cardinal num_mapped_children;	See ``Composite Widgets''
	XtOrderProc insert_position;	See ``Creating Widgets''
} CompositePart;
.De
.LP
Composite widgets have the composite fields immediately following the core
fields:
.LP
.IN "CompositeWidget" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	CorePart core;
	CompositePart composite;
} CompositeRec, *CompositeWidget;
.De
.NH 3
CompositePart Default Values
.XS
\*(SN CompositePart Default Values
.XE
.LP
The default values for the composite fields,
which are filled in by the Composite resource list 
and the Composite initialize procedure, are:
.LP
.TS
l l .
_
.sp 6p
Field	Default Value
.sp 6p
_
.sp 6p
children	NULL
num_children	0
num_slots	0
num_mapped_children	0
insert_position	internal function InsertAtEnd 
.sp 6p
_
.TE
.NH 2
Constraint Widget Definition
.XS
\*(SN Constraint Widget Definition
.XE
.LP
Constraint widgets are a subclass of the Composite 
widget and are more fully described in ``Constrained Composite Widgets''.
.NH 3
ConstraintClassPart
.XS
\*(SN ConstraintClassPart
.XE
.LP
In addition to the Composite class fields,
Constraint widgets have the following class fields:
.LP
.IN "ConstraintClassPart" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	XtResourceList resources;	See ``Constrained Composite Widgets''
	Cardinal num_resources;	See ``Constrained Composite Widgets''
	Cardinal constraint_size;	See ``Constrained Composite Widgets''
	XtInitProc initialize;	See ``Constrained Composite Widgets''
	XtWidgetProc destroy;	See ``Constrained Composite Widgets''
	XtSetValuesFunc set_values;	See ``Constrained Composite Widgets''
} ConstraintClassPart;
.De
.LP
Constraint widget classes have the constraint fields immediately following the
composite fields:
.LP
.IN "ConstraintWidgetClass" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	CoreClassPart core_class;
	CompositeClassPart composite_class;
	ConstraintClassPart constraint_class;
} ConstraintClassRec, *ConstraintWidgetClass;
.De
.LP
The predefined class record and pointer for 
.PN ConstraintClassRec 
are:
.LP
.Ds
.TA .5i 3i
.ta .5i 3i
extern ConstraintClassRec constraintClassRec;
.sp 6p
extern WidgetClass constraintWidgetClass;
.De
.LP
The opaque types 
.PN ConstraintWidget 
and 
.PN ConstraintWidgetClass
and the opaque variable 
.PN constraintWidgetClass 
are defined for generic operations on widgets that are a subclass of
.PN ConstraintWidgetClass .
.NH 3
ConstraintPart
.XS
\*(SN ConstraintPart
.XE
.LP
In addition to the
.PN CompositePart
fields,
Constraint widgets have the following fields defined in the 
.PN ConstraintPart
structure:
.LP
.IN "ConstraintPart" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct { int empty; } ConstraintPart;
.De
.LP
Constraint widgets have the constraint fields immediately following the
composite fields:
.LP
.IN "ConstraintWidget" "" "@DEF@"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	CorePart core;
	CompositePart composite;
	ConstraintPart constraint;
} ConstraintRec, *ConstraintWidget;
.De
.bp
\&
.sp 1
.ce 3
\s+1\fBChapter 3\fP\s-1

\s+1\fBWidget Classes\fP\s-1
.sp 2
.nr H1 3
.nr H2 0
.nr H3 0
.nr H4 0
.nr H5 0
.LP
.XS
Chapter 3 \- Widget Classes
.XE
The widget_class field of a widget points to its widget class structure.
This structure contains information that is constant across all
widgets of that class.
.LP
This class-oriented structure means that widget classes do not usually 
implement directly callable procedures. 
Rather, they implement procedures that are available through 
their widget class structure.
These class procedures are invoked by
generic procedures that envelop common actions around the procedures
implemented by the widget class.
Such procedures are applicable to all widgets
of that class and also to widgets that are subclasses of that class.
.LP
All widget classes are a subclass of the Core class and can be subclassed
further.
Subclassing reduces the amount of code and declarations you write to make a
new widget class that is similar to an existing class.
For example, you do not have to describe every resource your widget uses in an 
.PN XtResourceList .
Instead, you just describe the resources your widget has
that its superclass does not.  
Subclasses usually inherit many of their superclass's procedures
(for example, the expose procedure or geometry handler).
.LP
Subclassing can be taken too far.
If you create a subclass that inherits none of the procedures of its
superclass,
you then should consider whether or not you have chosen the most
appropriate superclass.
.LP
In order to make good use of subclassing, widget declarations and naming
conventions are highly stylized.
A widget consists of three files: 
.IP \(bu 5
A public ``.h'' file that is used by client widgets or applications 
.IP \(bu 5
A private ``.h'' file used by widgets that are subclasses of the widget
.IP \(bu 5
A ``.c'' file that implements the widget class
.NH 2
Widget Naming Conventions
.XS
\*(SN Widget Naming Conventions
.XE
.LP
The \*(tk Intrinsics are merely a vehicle by which programmers can create
new widgets and organize a collection of widgets into an application.
So that an application need not deal with as many styles of capitalization 
and spelling as the number of widget classes it uses, 
the following guidelines should be followed when writing new widgets:
.IP \(bu 5
Use the X naming conventions that are applicable.
For example, a record component name is all lower-case
and uses underscore (_) for compound words (for example, background_pixmap).
Type and procedure names start with upper-case and use capitalization for
compound words (for example, 
.PN XtArgList 
or 
.PN XtSetValues ).
.IP \(bu 5
A resource name string is spelled identically to the field name, 
except that compound names use capitalization rather than underscore.
To let the compiler catch spelling errors, 
each resource name should have a macro definition prefixed with 
.PN XtN .
For example,
the background_pixmap field has the corresponding resource name identifier
XtNbackgroundPixmap, 
which is defined as the string ``backgroundPixmap''.
Many predefined names are listed in the
.Pn < X11/StringDefs.h >
header file.
Before you invent a new name,
you should make sure that your proposed name is not already defined
or that there already is not name that you can use.
.IP \(bu 5
A resource class string starts with a capital letter, and uses
capitalization for compound names (for example,``BorderWidth'').
Each resource class string should have a macro definition prefixed with 
.PN XtC 
(for example, XtCBorderWidth).
.IP \(bu 5
A resource representation string is spelled identically to the type name 
(for example, ``TranslationTable'').
Each representation string should have a macro definition prefixed with 
.PN XtR
(for example, XtRTranslationTable).
.IP \(bu 5
New widget classes start with a capital and use capitalization for compound
words.
Given a new class name ``AbcXyz'' you should derive several names:
.RS
.IP \- 5
Partial widget instance structure name AbcXyzPart
.IP \- 5
Complete widget instance structure names AbcXyzRec and _AbcXyzRec
.IP \- 5
Widget instance pointer type name AbcXyzWidget
.IP \- 5
Partial class structure name AbcXyzClassPart 
.IP \- 5
Complete class structure names AbcXyzClassRec and _AbcXyzClassRec
.IP \- 5
Class structure variable abcXyzClassRec
.IP \- 5
Class pointer variable abcXyzWidgetClass
.RE
.IP \(bu 5
Action procedures available to translation specifications should follow the
same naming conventions as procedures.
That is, 
they start with a capital letter and compound names use capitalization.
For example, ``Highlight'' and ``NotifyClient''.
.NH 2
Widget Subclassing in Public ``.h'' Files
.XS
\*(SN Widget Subclassing in Public ``.h'' Files
.XE
.LP
The public ``.h'' file for a widget class is imported by clients
and contains:
.IP \(bu 5
A reference to the public ``.h'' files for the superclass.
.IP \(bu 5
The names and classes of the new resources that this widget adds
to its superclass.
.IP \(bu 5
The class record pointer you use to create widget instances.
.IP \(bu 5
The C type you use to declare widget instances of this class.
.LP
For example, the following is the public ``.h'' file for a possible
implementation of the Label widget:
.LP
.Ds 0
.TA .5i 1.75i
.ta .5i 1.75i

/* New resources */
#define XtNjustify	"justify"
#define XtNforeground	"foreground"
#define XtNlabel	"label"
#define XtNfont	"font"
#define XtNinternalWidth	"internalWidth"
#define XtNinternalHeight	"internalHeight"
 
/* Class record pointer */
extern WidgetClass labelWidgetClass;

/* C Widget type definition */
typedef struct _LabelRec      *LabelWidget;
.De
.LP
To accommodate operating systems with file name length restrictions,
the name of the public ``.h'' file is the first ten characters of the
widget class.
For example,
the public ``.h'' file for the Constraint widget is ``Constraint.h.''.
.NH 2
Widget Subclassing in Private ``.h'' Files
.XS
\*(SN Widget Subclassing in Private ``.h'' Files
.XE
.LP
The private ``.h'' file for a widget is imported by widget classes that are 
subclasses of the widget and contains:
.IP \(bu 5
A reference to the public ``.h'' file for the class.
.IP \(bu 5
A reference to the private ``.h'' file for the superclass.
.IP \(bu 5
The new fields that the widget instance adds to its superclass's
widget structure.
.IP \(bu 5
The complete widget instance structure for this widget.
.IP \(bu 5
The new fields that this widget class adds to its superclass's
.PN Constraint 
structure, if the widget is a subclass of
.PN Constraint .
.IP \(bu 5
The complete
.PN Constraint
structure, if the widget is a subclass of
.PN Constraint .
.IP \(bu 5
The new fields that this widget class adds to its superclass's widget class
structure.
.IP \(bu 5
The complete widget class structure for this widget.
.IP \(bu 5
The name of a ``constant'' of the generic widget class structure.
.IP \(bu 5
For each new procedure in the widget class structure, an "InheritOperation"
procedure for subclasses that wish to merely inherit a superclass operation.
.LP
For example, the following is the private ``.h'' file for the Label widget:
.LP
.Ds 0
.TA .5i 3i
.ta .5i 3i
#include <X11/Label.h>

/* New fields for the Label widget record */
typedef struct {
/* Settable resources */
	Pixel foreground;
	XFontStruct *font;
	String label;	/* text to display */
	XtJustify justify;
	Dimension internal_width;	/* # of pixels horizontal border */
	Dimension internal_height;	/* # of pixels vertical border */

/* Data derived from resources */
	GC normal_GC;
	GC gray_GC;
	Pixmap gray_pixmap;
	Position label_x;
	Position label_y;
	Dimension label_width;
	Dimension label_height;
	Cardinal label_len;
	Boolean display_sensitive;
} LabelPart;
.De
.Ds 0
.TA .5i 3i
.ta .5i 3i
/* Full instance record declaration */
typedef struct _LabelRec {
	CorePart core;
	LabelPart label;
} LabelRec;

/* New fields for the Label widget class record */
typedef struct { int empty; } LabelClassPart;

/* Full class record declaration */
typedef struct _LabelClassRec {
	CoreClassPart core_class;
	LabelClassPart label_class;
} LabelClassRec;

/* Class record variable */
extern LabelClassRec labelClassRec;
.De
.LP
To accommodate operating systems with file name length restrictions,
the name of the private ``.h'' file is the first nine characters of the
widget class followed by a capital ``P''.
For example,
the private ``.h'' file for the Constraint widget is ``ConstrainP.h.''.
.NH 2
Widget Subclassing in ``.c'' Files
.XS
\*(SN Widget Subclassing in ``.c'' Files
.XE
.LP
The ``.c'' file for a widget contains the structure initializer
for the class record variable.  This initializer can be broken
up into several parts:
.IP \(bu 5
Class information (for example, superclass, class_name, widget_size, 
class_initialize, class_inited).
.IP \(bu 5
Data Constants (for example, resources and num_resources,
actions and num_actions, visible_interest, compress_motion, compress_exposure,
version).
.IP \(bu 5
Widget Operations (for example, initialize, realize, destroy, resize,
expose, set_values, accept_focus, and any operations specific to the widget).
.LP
The superclass field points to the superclass 
.PN WidgetClass
record.
For direct subclasses of the generic core widget, 
superclass should be initialized to the address of the 
.PN widgetClassRec
structure.
The superclass is used for class chaining operations and for
inheriting or enveloping a superclass's operations.
(See ``Superclass Chaining,'' ``Inheriting Superclass Operations,'' 
and ``Calling Superclass Operations.'')
.LP
The class_name field contains the text name for this class (used by
the resource manager).
For example, the Label widget has the string ``Label''.
.LP
The widget_size field is the size of the corresponding Widget structure
(not the size of the Class structure).
.LP
The version field indicates the toolkit version number and is used for
runtime consistency checking of the \*(tk and widgets in an application.
Widget writers must set it to the symbolic value 
.PN XtVersion
in the widget class initialization.
.LP
All other fields are described in their respective sections.
.LP
The following is a somewhat compressed version of the ``.c'' file 
for the Label widget.
(The ``resources'' table is described in the section ``Resource Management'').
.LP
.Ds 0
.TA .5i 1.5i 3i
.ta .5i 1.5i 3i
/* Resources specific to Label */
#define XtRjustify	"Justify"
static XtResource resources[] = {
	{XtNforeground, XtCForeground, XtRPixel, sizeof(Pixel),
	   XtOffset(LabelWidget, label.foreground), XtRString, "Black"},
	{XtNfont,  XtCFont, XtRFontStruct, sizeof(XFontStruct *),
 	   XtOffset(LabelWidget, label.font),XtRString, "Fixed"},
	{XtNlabel,  XtCLabel, XtRString, sizeof(String),
	   XtOffset(LabelWidget, label.label), XtRString, NULL},
		.
		.
		.
}

/* Forward declarations of procedures */
static void ClassInitialize();
static void Initialize();
static void Realize();
	.
	.
	.
.De
.Ds 0
.TA .5i 2i 3i
.ta .5i 2i 3i
/* Class record constant */
LabelClassRec labelClassRec = {
  {
    /* core_class fields */	
	/* superclass	*/	(WidgetClass) &widgetClassRec,
	/* class_name	*/	"Label",
	/* widget_size	*/	sizeof(LabelRec),
	/* class_initialize	*/	ClassInitialize,
	/* class_part_initialize	*/	NULL,
	/* class_inited	*/	FALSE,
	/* initialize	*/	Initialize,
	/* initialize_hook	*/	NULL,
	/* realize	*/	Realize,
	/* actions	*/	NULL,
	/* num_actions	*/	0,
	/* resources	*/	resources,
	/* num_resources	*/	XtNumber(resources),
	/* xrm_class	*/	NULLQUARK,
	/* compress_motion	*/	TRUE,
	/* compress_exposure	*/	TRUE,
	/* compress_enterleave	*/	TRUE,
	/* visible_interest	*/	FALSE,
	/* destroy	*/	NULL,
	/* resize	*/	Resize,
	/* expose	*/	Redisplay,
	/* set_values	*/	SetValues,
	/* set_values_hook	*/	NULL,
	/* set_values_almost	*/	XtInheritSetValuesAlmost,
	/* get_values_hook	*/	NULL,
	/* accept_focus	*/	NULL,
	/* version	*/	XtVersion,
	/* callback_offsets	*/	NULL,
	/* tm_table	*/	NULL
  }
};

/* Class record pointer */
WidgetClass labelWidgetClass = (WidgetClass) &labelClassRec;

/* Private procedures */
	.
	.
	.
.De
.NH 2
Initialization of a Class: the class_initialize and class_part_initialize procedures
.XS
\*(SN Initialization of a Class: the class_initialize and class_part_initialize procedures
.XE
.LP
.IN "Class Initialization"
.IN "Initialization"
Many class records can be initialized completely at compile time.
But in some cases, 
a class may want to register type converters or perform other sorts of
``one-shot'' initialization.
.LP
Because the C language does not have initialization procedures 
that are invoked automatically when a program starts up, 
a widget class can declare a class_initialize procedure 
that will be automatically called exactly once by the \*(tk.
A class initialization procedure is of type
.PN XtProc :
.IN "class_initialize procedure" "" "@DEF@"
.IN "XtProc" "" "@DEF@"
.FD 0
typedef void (*XtProc)();
.sp
void \fIProc\fP()
.FN
.LP
A widget class indicates that it has no class initialization procedure by
specifying NULL in the class_initialize field.
.LP
.LP
In addition to doing class initializations that get done exactly once,
some classes need to perform additional initialization for fields in its part
of the class record.
These get done not just for the particular class but for subclasses as well.
This is done in the class's class part initialization procedure.
The class part initialization procedure is of type
.PN XtClassProc :
.IN "XtClassProc" "" "@DEF@"
.FD 0
typedef void (*XtClassProc)();
.sp
void \fIClassProc\fP(\fIwidgetClass\fP)
.br
      WidgetClass \fIwidgetClass\fP;
.FN
During class initialization,
the class part initialization procedure for the class and all its superclasses
are called in a superclass to subclass order on the class record.
These procedures have the responsibility of doing any dynamic initializations
necessary to their class's part of the record.
The most common is the resolution of any inherited methods defined in the 
class.
For example,
if a widget class C has superclasses Core, Composite, A, and B,
the class record for C first is passed to Core's class_part_initialize
record.
This resolves any inherited core methods and compiles the textual
representations of the resource list and action table that are defined in the
class record.
Next, the Composite's class_part_initialize is called to initialize the
composite part of C's class record.
Finally, the class_part_initialize procedures for A, B, and C (in order)
are called.
For further information,
see ``Inheriting Superclass Operations''.
Classes that do not define any new class fields
or that need no extra processing for them can specify NULL 
in the class_part_initialize field.
.LP
All widget classes (whether they have a class initialization procedure or not)
should start off with their class_inited field FALSE.
.LP
The first time a widget of that class is created, 
.PN XtCreateWidget
ensures that the widget class and all superclasses are initialized, in
superclass to subclass order, by checking each class_inited field and,
if it is FALSE, calling the class_initialize
and the class_part_initialize procedures for the class and all its
superclasses.
The class_inited field is then set to TRUE.  
After the one-time initialization, 
a class structure is constant.
.LP
The following provides the class initialization procedure for Label.
.LP
.Ds 0
.TA .5i 3i
.ta .5i 3i
static void ClassInitialize()
{
	XtQEleft   = XrmStringToQuark("left");
	XtQEcenter = XrmStringToQuark("center");
	XtQEright  = XrmStringToQuark("right");

	XtAddConverter(XtRString, XtRJustify, CvtStringToJustify, NULL, 0);
}
.De
.NH 2
Obtaining the Class and Superclass of a Widget
.XS
\*(SN Obtaining the Class and Superclass of a Widget
.XE
.LP
To obtain the class of a widget, use
.PN XtClass .
.IN "XtClass" "" "@DEF@"
.FD 0
WidgetClass XtClass(\fIw\fP)
.br
      Widget \fIw\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.LP
.PN XtClass 
returns a pointer to the widget's class structure.  
.sp
.LP
To obtain the superclass of a widget, use
.PN XtSuperclass .
.IN "XtSuperclass" "" "@DEF@"
.FD 0
WidgetClass XtSuperclass(\fIw\fP)
.br
      Widget \fIw\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.LP
.PN XtSuperclass 
returns a pointer to the widget's superclass class structure.
.NH 2
Verifying the Subclass of a Widget
.XS
\*(SN Verifying the Subclass of a Widget
.XE
.LP
To check the subclass that a widget belongs to, use
.PN XtIsSubclass .
.IN "XtIsSubclass" "" "@DEF@"
.FD 0
Boolean XtIsSubclass(\fIw\fP, \fIwidget_class\fP)
.br
      Widget \fIw\fP;
.br
      WidgetClass \fIwidget_class\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget under question.
.IP \fIwidget_class\fP 1i
Specifies the widget class to test against.
.LP
.PN XtIsSubclass 
returns TRUE if the class of the specified widget w is equal to 
or is a subclass of widget_class.
The specified widget w may be arbitrarily far down the subclass chain;
it need not be an immediate subclass of widget_class.
Composite widgets that wish to restrict the class of the items they
contain can use 
.PN XtIsSubclass 
to find out if a widget belongs to the desired class of objects.
.sp
.LP
To check the subclass that a widget belongs to 
and to generate a debugging error message, use
.PN XtCheckSubclass .
.IN "XtCheckSubclass" "" "@DEF@"
.FD 0
void XtCheckSubclass(\fIw\fP, \fIwidget_class\fP, \fImessage\fP)
.br
      Widget \fIw\fP;
.br
      WidgetClass \fIwidget_class\fP;
.br
      String \fImessage\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget under question.
.IP \fIwidget_class\fP 1i
Specifies the widget class to test against.
.IP \fImessage\fP 1i
Specifies an error message.
.LP
.PN XtCheckSubclass 
determines if the class of the specified w is equal to 
or is a subclass of widget_class.
Again, w may be any number of subclasses down the chain 
and need not be an immediate subclass of widget_class.
If w is not a subclass,
.PN XtCheckSubclass
constructs an error message from the supplied message,
the widget's actual class, and the expected class.
Then, it calls 
.PN XtError .
.PN XtCheckSubclass
should be used at the entry-point
of exported routines to ensure that the client
has passed in a valid widget class for the exported operation.
.LP
.PN XtCheckSubclass
is only executed when including and linking against the 
debugging version of the Intrinsics.
Otherwise, it is defined as the empty string and so generates no code.
.NH 2
Superclass Chaining
.XS
\*(SN Superclass Chaining
.XE
.LP
.IN "Chaining"
.IN "Superclass Chaining"
.IN "Inheritance"
Some fields defined in the widget class structure are self-contained 
and are independent of the values for these fields defined in superclasses.
Among these are:
.IP \(bu 5
class_name
.IP \(bu 5
widget_size
.IP \(bu 5
realize
.IP \(bu 5
visible_interest
.IP \(bu 5
resize
.IP \(bu 5
expose
.IP \(bu 5
accept_focus
.IP \(bu 5
compress_motion
.IP \(bu 5
compress_exposure
.IP \(bu 5
compress_enterleave
.IP \(bu 5
set_values_almost
.IP \(bu 5
tm_table
.IP \(bu 5
version
.LP
Some fields defined in the widget class structure make sense only after 
their superclass has been operated on.
In this case, 
the invocation of a single operation actually first accesses the 
Core class, then the subclass, and
so on down the class chain to the widget class of the widget.
These superclass-to-subclass fields are:  
.IP \(bu 5
class_initialize
.IP \(bu 5
class_part_initialize
.IP \(bu 5
initialize_hook
.IP \(bu 5
set_values_hook
.IP \(bu 5
get_values_hook
.IP \(bu 5
initialize
.IP \(bu 5
set_values
.IP \(bu 5
resources 
.LP
For subclasses of 
.PN Constraint , 
the constraint resources field is chained from the 
.PN Constraint 
class down to the subclass.
.LP
Some fields defined in the widget class structure make sense only after their
subclass has been operated on.
In this case, 
the invocation of a single operation actually first accesses the widget class, 
then its superclass, 
and so on up the class chain to the Core class.
The subclass-to-superclass fields are:
.IP \(bu 5
destroy
.IP \(bu 5
actions
.NH 2
Inheriting Superclass Operations
.XS
\*(SN Inheriting Superclass Operations
.XE
.LP
A widget class is free to use any of its superclass's self-contained 
operations rather than implementing its own code.
The most frequently inherited operations are:
.IP \(bu 5
expose
.IP \(bu 5
realize
.IP \(bu 5
insert_child
.IP \(bu 5
delete_child
.IP \(bu 5
geometry_manager
.LP
To inherit an operation ``xyz'',
you simply specify the procedure 
.PN XtInheritXyz 
in your class record.
.LP
Every class that declares a new procedure in its widget class part must
provide for inheriting the procedure in its class_part_initialize
procedure.
(The special chained operations initialize, set_values, 
and destroy declared in the Core record do not have inherit procedures.
Widget classes that do nothing beyond what their superclass does 
for these procedures just specify NULL for the procedure 
in their class records.)
.LP
Inheriting works by comparing the value of the field with a known, special
value and by copying in the superclass's value for that field if a match
occurs.
This special value is usually the intrinsic routine
.PN _XtInherit
cast to the appropriate type.
.LP
For example, the Composite class's private include file contains these
definitions:
.LP
.Ds 0
.TA .5i 1.5i 3i
.ta .5i 1.5i 3i
#define XtInheritGeometryManager ((XtGeometryHandler) _XtInherit)
#define XtInheritChangeManaged ((XtWidgetProc) _XtInherit)
#define XtInheritInsertChild ((XtArgsProc) _XtInherit)
#define XtInheritDeleteChild ((XtWidgetProc) _XtInherit)
#define XtInheritMoveFocusToNext ((XtWidgetProc) _XtInherit)
#define XtInheritMoveFocusToPrev ((XtWidgetProc) _XtInherit)
.De
.LP
The Composite's class_part_initialize procedure begins:
.Ds 0
.TA .5i 1.5i 3i
.ta .5i 1.5i 3i
static void CompositeClassPartInitialize(widgetClass)
	WidgetClass widgetClass;
{
	register CompositeWidgetClass wc = (CompositeWidgetClass) widgetClass;
	CompositeWidgetClass super = (CompositeWidgetClass) wc->core.class.superclass

	if (wc->composite_class.geometry_manager == XtInheritGeometryManager) {
	    wc->composite_class.geometry_manager = super->composite_class.geometry_manager;
	}

	if (wc->composite_class.change_managed == XtInheritChangeManaged) {
	    wc->composite_class.change_managed = super->composite_class.change_managed;
	}
	.
	.
	.
.De
.LP
The inherit procedures defined for Core are:
.IP \(bu 5
.PN XtInheritRealize 
.IP \(bu 5
.PN XtInheritResize 
.IP \(bu 5
.PN XtInheritExpose
.IP \(bu 5
.PN XtInheritSetValuesAlmost
.IP \(bu 5
.PN XtInheritAcceptFocus
.LP
The inherit procedures defined for Composite are:
.IP \(bu 5
.PN XtInheritGeometryManager
.IP \(bu 5
.PN XtInheritChangeManaged
.IP \(bu 5
.PN XtInheritInsertChild
.IP \(bu 5
.PN XtInheritDeleteChild
.IP \(bu 5
.PN XtInheritMoveFocusToNext
.IP \(bu 5
.PN XtInheritMoveFocusToPrev
.NH 2
Calling Superclass Operations
.XS
\*(SN Calling Superclass Operations
.XE
.LP
A widget class sometimes explicitly wants to call a superclass operation 
that normally is not chained.
For example, 
a widget's expose procedure might call its superclass's expose 
and then perform a little more work of its own.
Composite classes with fixed children can implement insert_child 
by first calling their superclass's insert_child procedure 
.IN "insert_child procedure"
and then calling
.PN XtManageChild
to add the child to the managed list.
.LP
Note that the class procedure should call its own superclass procedure,
not the widget's superclass procedure.
That is, it should use its own class pointers only,
not the widget's class pointers.
This technique is referred to as ``enveloping'' the superclass's operation.
.LP
The following is abbreviated code for a possible implementation of 
a Shell's insert_child procedure:
.LP
.Ds 0
.TA .5i 1i 3i
.ta .5i 1i 3i
static void InsertChild(w)
	Widget w;
{
	(*(((CompositeWidgetClass)XtSuperclass(shellWidgetClass))
		->composite_class.insert_child)) (w);
	XtManageChild(w);		/* Add to managed set now */
}
.De
.bp
\&
.sp 1
.ce 3
\s+1\fBChapter 4\fP\s-1

\s+1\fBInstantiating Widgets\fP\s-1
.sp 2
.nr H1 4
.nr H2 0
.nr H3 0
.nr H4 0
.nr H5 0
.LP
.XS
Chapter 4 \- Instantiating Widgets
.XE
Widgets are either ``primitive'' or ``composite''.
Either kind of widget can have ``pop-up'' children widgets, 
but only composite widgets can have ``normal'' children widgets.
A composite widget may in unusual circumstances
have zero normal children but usually has at least one.  
Widgets with no children of any kind are leaves of a widget tree.
Widgets with one or more children are intermediate nodes of a tree.
The shell widget returned by
.PN XtInitialize
or
.PN XtCreateApplicationShell
is the root of a widget tree.
.LP
The ``normal'' children of the widget tree exactly duplicates the
associated window tree.
Each pop-up child has a window which is a child of
the root window so that the pop-up window is not clipped. 
Again, the normal children of a pop-up exactly duplicates the window tree 
associated with the pop-up window.
.LP
A widget tree is manipulated by several \*(tk functions.  
For example, 
.PN XtRealizeWidget
traverses the tree downward to recursively realize normal children widgets. 
.PN XtDestroyWidget 
traverses the tree downward to destroy all children.
The functions that fetch and modify resources traverse the tree upward 
to determine the inheritance of resources from a widget's ancestors.
.PN XtMakeGeometryRequest 
traverses the tree one level upward to get the geometry manager responsible 
for a normal widget child's geometry.
.LP
To facilitate up-traversal of the widget tree, 
each widget has a pointer to its parent widget.
Shell widgets returned by 
.PN XtInitialize
and
.PN XtCreateApplicationShell
have a parent pointer of NULL.
.LP
To facilitate down-traversal of the widget tree, 
each composite widget has a pointer to an array of children widgets.
This array includes all normal children created, 
not just the subset of children that are managed by the composite widget's 
geometry manager.
.LP
In addition, 
every widget has a pointer to an array of pop-up children widgets.
.NH 2
Initializing the \*(tk 
.XS
\*(SN Initializing the \*(tk 
.XE
.LP
Before any of the \*(tk functions can be called by the application,
it must initialize the toolkit.
.LP
To initialize the \*(tk, the application must call the
.PN XtInitialize 
function.
.IN "XtInitialize" "" "@DEF@"
.FD 0
Widget XtInitialize(\fIshell_name\fP, \fIapplication_class\fP, \fIoptions\fP, \
\fInum_options\fP, \fIargc\fP, \fIargv\fP)
.br
      String \fIshell_name\fP;
.br
      String \fIapplication_class\fP;
.br
      XrmOptionDescRec \fIoptions\fP[];
.br
      Cardinal \fInum_options\fP;
.br
      Cardinal *\fIargc\fP;
.br
      String \fIargv\fP[];
.FN
.IP \fIshell_name\fP 1i
Specifies the name of the application shell widget instance,
which usually is something generic like ``main''.
.IP \fIapplication_class\fP 1i
Specifies the class name of this application,
which usually is the generic name for all instances of this application.
By convention, the class name is formed by reversing the case of the
application's first two letters.
For example,
an application named ``xterm'' would have a class name of ``XTerm''.
.IP \fIoptions\fP 1i
Specifies how to parse the command line for any application-specific resources.
The options argument is passed as a parameter to 
.PN XrmParseCommand .
For further information,
see \fI\*(xL\fP.
.IP \fInum_options\fP 1i
Specifies the number of entries in options list.
.IP \fIargc\fP 1i
Specifies a pointer to the number of command line parameters.
.IP \fIargv\fP 1i
Specifies the command line parameters.
.LP
.PN XtInitialize
builds the resource database, parses the command line, opens the display, 
and initializes the \*(tk.
It returns a
.PN TopLevelShell
widget to use as the parent of the application's root widget.
.LP
.PN XtInitialize
modifies argc and argv to contain just the parameters that
were not a display, geometry, or resource specification.  
If the modified argc is not zero (0),
most applications simply print out the modified argv along with a message 
about the allowable options.
.LP
An application can have multiple top-level widgets.
The widget returned by
.PN XtInitialize
has the WM_COMMAND property set for session managers.
See ``Shell Widgets'' for more information.
.LP
.PN XtInitialize 
saves the application name and class_name for qualifying all widget
resource specifiers.
On UNIX-based systems, 
the application name is the final component of argv[0].
(This can be modified from the command line by specifying the \-name option.)
The application name and class_name are used as the left-most components
in all widget resource names for this application.
.NH 2
Loading the Resource Database
.XS
\*(SN Loading the Resource Database
.XE
.LP
.PN XtInitialize
loads the application's resource database from three sources in the following
order:
.IP \(bu 5
Application-specific class resource file
.IP \(bu 5
Server resource file
.IP \(bu 5
User's environment resource file
.LP
The application-specific resource file name is constructed from the
class name of the application and points to a site-specific resource
file that usually is installed by the site manager when the
application is installed.
On UNIX-based systems,
the application resource file is
.br
.PN /usr/lib/X11/app-defaults/ \fIclass\fP,
where class is the application class name.
.LP
The server resource file is the contents of the X server's RESOURCE_MANAGER
property, as returned by
.PN XOpenDisplay .
If no such property exists for the display, 
the
.PN \.Xdefaults
file in the user's home directory, if it exists, 
is loaded in place of the server property.
.LP
The user's environment resource file name is constructed by using the 
value of the user's
.br
.PN XENVIRONMENT
variable for the full path of the file.
If this environment variable does not exist,
.PN XtInitialize
looks in the user's home directory for the
.PN \.Xdefaults-host 
file, where host is the name of the user's host machine.
If the resulting resource file exists,
.PN XtInitialize 
loads its contents into the resource database.
.NH 2
Parsing the Command Line
.XS
\*(SN Parsing the Command Line
.XE
.LP
.PN XtInitialize
first parses the command line looking for the following options: 
.IP \-display 1i
Specifies the display name for
.PN XOpenDisplay .
.IP \-synchronize 1i
Calls 
.PN XSynchronize
to put Xlib into synchronous mode.
.IP \-name 1i
Sets the resource name prefix in place of argv[0].
.LP
.PN XtInitialize
has a table of standard command line options for adding resources to the
resource database, and it takes as a parameter additional 
application-specific resource abbreviations.
.IN "XrmOptionDescRec" "" "@DEF@"
The format of this table is:
.Ds 0
.TA .5i 2.75i
.ta .5i 2.75i
typedef enum {
	XrmoptionNoArg,	/* Value is specified in OptionDescRec.value	    */
	XrmoptionIsArg,	/* Value is the option string itself		    */
	XrmoptionStickyArg,	/* Value is characters immediately following option */
	XrmoptionSepArg,	/* Value is next argument in argv		    */
	XrmoptionSkipArg,	/* Ignore this option and the next argument in argv */
	XrmoptionSkipLine	/* Ignore this option and the rest of argv	    */
} XrmOptionKind;

typedef struct {
	char *option;	/* Option name in argv		    */
	char *specifier;	/* Resource name (sans application name)    */
	XrmOptionKind argKind;	/* Which style of option it is	    */
	caddr_t value;	/* Value to provide if XrmoptionNoArg    */
} XrmOptionDescRec, *XrmOptionDescList;

.De
.LP
The standard table contains the following entries:
.TS
l l l l .
_
.sp 6p
Option string	Resource name	Argument Kind	Resource value
.sp 6p
_
.sp 6p
\-background	background	SepArg	next argument
\-bd	borderColor	SepArg	next argument
\-bg	background	SepArg	next argument
\-borderwidth	borderWidth	SepArg	next argument
\-bordercolor	borderColor	SepArg	next argument
\-bw	borderWidth	SepArg	next argument
\-display	display	SepArg	next argument
\-fg	foreground	SepArg	next argument
\-fn	font	SepArg	next argument
\-font	font	SepArg	next argument
\-foreground	foreground	SepArg	next argument
\-geometry	geometry	SepArg	next argument
\-name	name	SepArg	next argument
\-reverse	reverseVideo	NoArg	on [not implemented]
\-rv	reverseVideo	NoArg	on [not implemented]
+rv	reverseVideo	NoArg	off [not implemented]
\-synchronize	synchronize	NoArg	on
\-title	title	SepArg	next argument
\-xrm	next argument	ResArg	next argument
.sp 6p
_
.TE
.NT Notes
.IP 1. 5
Any unique abbreviation for an option name in the standard table
or in the application table is accepted.
.IP 2. 5
For backwards compatibility with older command line syntax,
an \*(tk installation (compile time) option allows the following
arguments on the command line:
.IP
.Ds
.TA .5i 1.25i 2i 2.75i
.ta .5i 1.25i 2i 2.75i
=	geometry	IsArg	this argument
:	display	IsArg	this argument
.De
.IP
The colon (:) can appear anywhere within the argument,
and the argument will be accepted as the display string, 
if the \-display argument is not specified on the command line.
.NE
.LP
The \-xrm option provides a method of setting any resource in an application.
The next argument should be a quoted string identical in format to a line in
the user resources file.
For example, 
to give a red background to all command buttons in an application named 
.PN xmh ,
you can start it up as:
.LP
.Ds
xmh \-xrm 'xmh*Command.background: red'
.DE
.LP
When it fully parses the command line,
.PN XtInitialize
merges the application option table with the standard option table
and then calls the Xlib
.PN XrmParseCommand
function.
An entry in the application table with the same name as an entry
in the standard table over-rides the standard table entry.
If an option name is a prefix of another option name,
both names are kept in the merged table.
Although option tables need not be sorted by option name,
.PN XrmParseCommand
is somewhat more efficient if they are.
.NH 2
Obtaining Window Information from a Widget 
.XS
\*(SN Obtaining Window Information from a Widget
.XE
.LP
The Core widget definition contains the screen and window IDs. 
The window field may be NULL for a while 
(see ``Creating Widgets'' and ``Realizing Widgets'').
.LP
The display pointer, the parent widget, screen pointer, 
and window of a widget are returned by the following macros:
.IN "XtDisplay" "" "@DEF@"
.FD 0
Display *XtDisplay(\fIw\fP)
.br
      Widget \fIw\fP;
.FN
.sp
.LP
.IN "XtParent" "" "@DEF@"
.FD 0
Widget XtParent(\fIw\fP)
.br
     Widget \fIw\fP;
.FN
.sp
.LP
.IN "XtScreen" "" "@DEF@"
.FD 0
Screen *XtScreen(\fIw\fP)
.br
      Widget \fIw\fP;
.FN
.sp
.LP
.IN "XtWindow" "" "@DEF@"
.FD 0
Window XtWindow(\fIw\fP)
.br
      Widget \fIw\fP;
.FN
.LP
These macros take a widget and return the specified value.
.LP
Several window attributes are locally cached in the widget. 
Thus, they can be set by the resource manager and 
.PN XtSetValues ,
as well as used by routines that derive structures from these values 
(for example, depth for deriving pixmaps,
background_pixel for deriving GCs, and so on) or in the
.PN XtCreateWindow 
call.
.LP
The x, y, width, height, and border_width window attributes are available to 
geometry managers.  
These fields are maintained synchronously inside the \*(tk.
When an 
.PN XConfigureWindow 
is issued on the widget's window (on request of its parent),
these values are updated immediately rather than sometime later 
when the server gets around to generating a 
.PN ConfigureNotify 
event.
(In fact, most widgets do not have 
.PN SubstructureNotify
turned on.)
This ensures that all geometry calculations are based on the internally 
consistent toolkit world, rather than on either of the following:
.IP \(bu 5
An inconsistent world updated by asynchronous
.PN ConfigureNotify 
events
.IP \(bu 5
A consistent but slow world in which geometry managers ask the server 
for window sizes whenever they need to layout their managed children.
See ``Geometry Management'' for further information.
.NH 2
Creating Widgets
.XS
\*(SN Creating Widgets
.XE
.LP
The creation of widget instances is a three-phase process: 
.IP 1. 5
The widgets are allocated and initialized with resources 
and are optionally added to the managed subset of their parent.
.IP 2. 5
All composite widgets are notified of their managed children 
in a bottom-up traversal of the widget tree.
.IP 3. 5
The widgets create X windows that, then, get mapped.
.LP
To start the first phase, the application calls 
.PN XtCreateWidget 
for all its widgets and adds some (usually, most or all) of its widgets 
to their respective parent's managed set by calling
.PN XtManageChild .
In order to avoid an O(n^2) creation process 
where each composite widget lays itself out each time a widget is created 
and managed, 
parent widgets are not notified of changes in their managed set
during this phase.
.LP
After all widgets have been created, 
the application calls 
.PN XtRealizeWidget 
on the top-level widget to start the second and third phases.  
.PN XtRealizeWidget
first recursively traverses the widget tree in a post-order (bottom-up)
traversal and then notifies each composite widget with one 
or more managed children by means of its change_managed procedure.
.LP
Notifying a parent about its managed set involves geometry layout and
possibly geometry negotiation.
A parent deals with constraints on its size imposed from above 
(as when a user specifies the application window size),
and suggestions made from below (as when a primitive child computes its
preferred size).
The clash between the two can cause geometry changes to ripple 
in both directions through the widget tree.
The parent may force some of its children to change size and position 
and may issue geometry requests to its own parent in order to better 
accommodate all its children.
You do not really know where anything should go on the screen
until this process settles down.
.LP
Consequently, in the first and second phases, 
no X windows are actually created because it is highly likely 
that they would just get moved around after creation.
This avoids unnecessary requests to the X server.
.LP
Finally, 
.PN XtRealizeWidget 
starts the third phase by making a pre-order
(top-down) traversal of the widget tree, and allocates an X window to each
widget by means of its realize procedure, 
and finally maps the widgets that are managed.
.NH 3
Creating and Merging Argument Lists
.XS
\*(SN Creating and Merging Argument Lists
.XE
.LP
Many Intrinsics routines need to be passed pairs of resource names and
values.
These are passed as an
.PN ArgList ,
which contains:
.IN "ArgList" "" "@DEF@"
.LP
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef long XtArgVal;

typedef struct {
	String \fIname\fP;
	XtArgVal \fIvalue\fP;
} Arg, *ArgList;
.De
.LP
If the size of the resource is less than or equal to the size of an
.PN XtArgVal
the resource value is stored directly in value. 
Otherwise, a pointer to it is stored into value.
.LP
To set values in an
.PN ArgList ,
use
.PN XtSetArg .
.IN "XtSetArg" "" "@DEF@"
.FD 0
XtSetArg(\fIarg\fP, \fIname\fP, \fIvalue\fP)
.br
      Arg \fIarg\fP;
.br
      String \fIname\fP;
.br
      XtArgVal \fIvalue\fP;
.FN
.IP \fIarg\fP 1i
Specifies the name-value pair to set.
.IP \fIname\fP 1i
Specifies the name of the resource.
.IP \fIvalue\fP 1i
Specifies the value of the resource if it will fit in an 
.PN XtArgVal , 
otherwise the address.
.LP
An
.PN ArgList
usually is specified in a highly stylized manner in order to
minimize the probability of making a mistake, for example:
.LP
.Ds 0
.TA .5i 3i
.ta .5i 3i
	Arg args[20];
	int n;

	n = 0;
	XtSetArg(args[n], XtNheight, 100);	n++;
	XtSetArg(args[n], XtNwidth, 200);	n++;
	XtSetValues(widget, args, n);
.De
.NT
You should not use auto-increment or auto-decrement 
within the first argument to
.PN XtSetArg .
As it is currently implemented,
.PN XtSetArg
is a macro that dereferences the first argument twice.
.NE
.sp
.LP
To merge two 
.PN ArgList
structures, use 
.PN XtMergeArgLists .
.IN "XtMergeArgLists" "" "@DEF@"
.FD 0
ArgList XtMergeArgLists(\fIargs1\fP, \fInum_args1\fP, \fIargs2\fP, \
\fInum_args2\fP)
.br
     ArgList \fIargs1\fP;
.br
     Cardinal \fInum_args1\fP;
.br
     ArgList \fIargs2\fP;
.br
     Cardinal \fInum_args2\fP;
.FN
.IP \fIargs1\fP 1i
Specifies the first 
.PN ArgList
to include.
.IP \fInum_args1\fP 1i
Specifies number of arguments in the first 
.PN ArgList .
.IP \fIargs2\fP 1i
Specifies the second ArgList to include.
.IP \fInum_args2\fP 1i
Specifies the number of arguments in the second 
.PN ArgList .
.LP
.PN XtMergeArgLists
allocates storage large enough to hold the combined 
.PN ArgList 
structures and copies them into it.
It does not check for duplicate entries.
When it is no longer needed,
the returned storage should be freed by the client with
.PN XtFree .
.NH 3
Creating a Widget Instance
.XS
\*(SN Creating a Widget Instance
.XE
.LP
To create an instance of a widget, use
.PN XtCreateWidget .
.IN "XtCreateWidget" "" "@DEF@"
.FD 0
Widget XtCreateWidget(\fIname\fP, \fIwidget_class\fP, \fIparent\fP, \
\fIargs\fP, \fInum_args\fP)
.br
      String \fIname\fP;
.br
      WidgetClass \fIwidget_class\fP;
.br
      Widget \fIparent\fP;
.br
      ArgList \fIargs\fP;
.br
      Cardinal \fInum_args\fP;
.FN
.IP \fIname\fP 1i
Specifies the resource name for the created widget.
This name is used for retrieving resources 
and, for that reason, should not be the same as any other widget 
that is a child of same parent.
.IP \fIwidget_class\fP 1i
Specifies the widget class pointer for the created widget.
.IP \fIparent\fP 1i
Specifies the parent widget.
.IP \fIargs\fP 1i
Specifies the argument list to override the resource defaults.
.IP \fInum_args\fP 1i
Specifies the number of arguments in args.
The number of arguments in an argument list can be automatically
computed by using the
.PN  XtNumber
macro.
For further information, see ``Determining the Number of Elements''.
.LP
.PN XtCreateWidget 
performs much of the ``boiler-plate'' operations of widget creation. 
That is, it performs the following:
.IP \(bu 5
Checks to see if class_initialize has been called for this class
and for all superclasses and, if not, calls those necessary in a
superclass to subclass order.
.IP \(bu 5
Checks that the parent is a subclass of 
.PN compositeWidgetClass .
.IP \(bu 5
Allocates memory for the widget instance.
.IP \(bu 5
If the parent is a subclass of 
.PN constraintWidgetClass , 
it allocates memory for the parent's constraints 
and stores the address of this memory into the constraints field.
.IP \(bu 5
Initializes the core nonresource data fields 
(for example, parent and visible).
.IP \(bu 5
Initializes the resource fields (for example, background_pixel) 
by using the resource lists specified for this class and all superclasses.
.IP \(bu 5
If the parent is a subclass of 
.PN constraintWidgetClass , 
it initializes the resource fields of the constraints record 
by using the constraint resource list specified for the parent's class 
and all superclasses up to 
.PN constraintWidgetClass .
.IP \(bu 5
Calls the initialize procedures for the widget, starting at the Core
initialize procedure on down to the widget's initialize procedure.
.IP \(bu 5
If the parent is a subclass of 
.PN constraintWidgetClass , 
it calls the constraint initialize procedures, 
starting at 
.PN constraintWidgetClass 
on down to the parent's constraint initialize procedure.
.IP \(bu 5
Puts the widget into its parent's children list by calling its parent's
insert_child procedure.
For further information,
see ``Addition of Children to a Composite Widget''.
.NH 3
Creating an Application Shell Instance
.XS
\*(SN Creating an Application Shell Instance
.XE
.LP
To create an instance of an application shell widget, use
.PN XtCreateApplicationShell .
.IN "XtCreateApplicationShell" "" "@DEF@"
.FD 0
Widget XtCreateApplicationShell(\fIname\fP, \fIwidget_class\fP, \fIargs\fP, \
\fInum_args\fP)
.br
      String \fIname\fP;
.br
      WidgetClass \fIwidget_class\fP;
.br
      ArgList \fIargs\fP;
.br
      Cardinal \fInum_args\fP;
.FN
.IP \fIname\fP 1i
Specifies the resource name for the created application shell widget.
.IP \fIwidget_class\fP 1i
Specifies the widget class pointer for the created application shell widget.
This will usually be 
.PN topLevelShellWidgetClass 
or a subclass thereof.
.IP \fIargs\fP 1i
Specifies the argument list to override the resource defaults.
.IP \fInum_args\fP 1i
Specifies the number of arguments in args.
.LP
.PN XtCreateApplicationShell
creates another top-level widget that is the root of another
widget tree.
The initial top-level widget is returned from 
.PN XtInitialize .
An application uses this procedure if it needs to have
several independent windows.
.NH 3
Initialization of a Widget Instance: the initialize procedure
.XS
\*(SN Initialization of a Widget Instance: the initialize procedure
.XE
.IN "Initialization"
.IN "Chaining"
.IN "Superclass Chaining"
.IN "Inheritance"
.LP
The initialize procedure for a widget class is of type
.PN XtInitProc :
.IN "XtInitProc" "" "@DEF@"
.IN "initialize procedure" "" "@DEF@"
.FD 0
typedef void (*XtInitProc)();
.sp
void \fIInitProc\fP(\fIrequest\fP, \fInew\fP)
.br
      Widget \fIrequest\fP, \fInew\fP;
.FN
.IP \fIrequest\fP 1i
Specifies the widget with resource values as requested by the
argument list, the resource database, and the widget defaults.
.IP \fInew\fP 1i
Specifies a widget with the new values, both resource and non-resource, 
that are actually allowed.
.LP
The three main jobs of an initialization procedure are to:
.IP \(bu 5
Allocate space for and copy any resources that are referenced by address.
For example, 
if a widget has a field that is a string (char *) it cannot depend
upon the characters at that address remaining constant but must dynamically
allocate space for the string and copy it to the new space.
(Note that you should not allocate space for or copy callback lists.)
.IP \(bu 5
Compute values for unspecified resource fields.
For example, if width and height are zero (0), 
the widget should compute a nice width and height based on other resources.
This is the only time that a widget may ever directly assign its own
width and height.
.IP \(bu 5
Compute values for uninitialized non-resource fields that are derived from
resource fields.
For example, GCs that the widget uses are derived from 
resources like background, foreground, and font.
.LP
An initialization procedure can also check certain fields for 
internal consistency.
For example, it makes no sense to specify a color map for a depth
that does not support that color map.
.LP
Initialization procedures are called in ``superclass-to-subclass order''.
Most of the initialization code for a specific widget class deals with fields
defined in that class and not with fields defined in its superclasses.
.LP
If a subclass does not need an initialization procedure 
because it does not need to perform any of the above operations, 
you can specify NULL for the initialize field in the class record.
.LP
Sometimes a subclass may want to overwrite values filled in by its
superclass.
In particular, size calculations of a superclass are often
incorrect for a subclass and, in this case, 
the subclass must modify or recalculate fields declared 
and computed by its superclass.
.LP
As an example, 
a subclass can visually surround its superclass display.
In this case, the width and height calculated by the superclass initialize 
procedure are too small and need to be incremented by the size of the surround.
The subclass needs to know if its superclass's size was calculated by the
superclass or was specified explicitly.
All widgets must place themselves into whatever size is explicitly given,
but they should compute a reasonable size if no size is requested.
How does a subclass know the difference between a specified size 
and a size computed by a superclass?
.LP
The request and new parameters provide the necessary information.
The ``request'' widget is the widget as originally requested.
The ``new'' widget starts with the values in the request, 
but it has been updated by all superclass initialization procedures called
so far.
A subclass initialize procedure can compare these two to resolve 
any potential conflicts.  
.LP
In the above example, 
the subclass with the visual surround can see
if the width and height in the request widget are zero.
If so, 
it adds its surround size to the width and height fields in the new widget.
If not, it must make do with the size originally specified.
.LP
The ``new'' widget will become the actual widget instance record. 
Therefore, 
if the initialization procedure needs to call any routines 
that operate on a widget, 
it should specify ``new'' as the widget instance.
.NH 3
Initialization of a Constraint Widget Instance: the constraint_initialize procedure
.XS
\*(SN Initialization of a Constraint Widget: the constraint_initialize procedure
.XE
.IN "Initialization"
.IN "XtInitProc"
.IN "initialize procedure"
.IN "Chaining"
.IN "Superclass Chaining"
.IN "Inheritance"
.LP
The constraint initialize procedure is of type
.PN XtInitProc .
The values passed to the parent constraint initialization procedure 
are the same as those passed to the child's class widget initialization 
procedure.
.LP
The constraint initialization procedure should compute any constraint fields
derived from constraint resources.
It can make further changes to the widget in order to make the widget 
conform to the specified constraints, changing, for example, 
the widget's size or position.
.LP
If a constraint class does not need a constraint initialization procedure, 
it should specify NULL for the initialize field of the 
.PN ConstraintClassPart 
in the class record.
.NH 3
Initialization of Nonwidget Data: the initialize_hook procedure
.XS
\*(SN Initialization of Nonwidget Data: the initialize_hook procedure
.XE
.IN "Initialization"
.LP
The initialize_hook procedure is of type 
.PN XtArgsProc :
.IN "initialize_hook procedure" "" "@DEF@"
.IN "XtArgsProc" "" "@DEF@"
.FD 0
typedef void (*XtArgsProc)();
.sp
void \fIArgsProc\fP(\fIw\fP, \fIargs\fP, \fInum_args\fP)
.br
     Widget \fIw\fP;
.br
     ArgList \fIargs\fP;
.br
     Cardinal *\fInum_args\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.IP \fIargs\fP 1i
Specifies the argument list to override the resource defaults.
.IP \fInum_args\fP 1i
Specifies the number of arguments in args.
.LP
If this procedure is not NULL, 
it is called immediately after the corresponding initialize
procedure, or in its place if the initialize procedure is NULL. 
.LP
The initialize_hook procedure allows a widget instance to initialize
non-widget data using information from the arglist.
For example, 
the Text widget has subparts that are not widgets, 
yet these subparts have resources that can be specified by means of the 
resource file or an argument list.
See also ``XtGetSubresources''.
.NH 2
Realizing Widgets
.XS
\*(SN Realizing Widgets
.XE
.LP
To realize a widget instance, use
.PN XtRealizeWidget .
.IN "XtRealizeWidget" "" "@DEF@"
.FD 0
void XtRealizeWidget(\fIw\fP)
.br
      Widget \fIw\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.LP
.PN XtRealizeWidget
performs the following:
.IP \(bu 5
If the widget is already realized, 
.PN XtRealizeWidget 
simply returns.
.IP \(bu 5
Otherwise, it makes a post-order traversal of the widget tree rooted
at the specified widget and calls the change_managed procedure 
of each composite widget that has one or more managed children.  
.IP \(bu 5
It then constructs an 
.PN XSetWindowAttributes
structure filled in with information derived from the Core widget fields 
and calls the realize procedure for the widget, 
which adds any widget-specific attributes and creates the X window.
.IP \(bu 5
If the widget is a primitive widget, nothing else need be done, and 
.PN XtRealizeWidget 
returns.
Otherwise, it recursively descends to each of the widget's
managed children and calls the realize procedures.
.IP \(bu 5
Finally, 
.PN XtRealizeWidget 
maps all of the managed children windows that have mapped_when_managed TRUE.
(If a widget is managed, but mapped_when_managed is FALSE, the widget is
allocated visual space but is not displayed.
Some people seem to like this to indicate certain states.)
.LP
If num_children equals num_mapped_children, 
.PN XtRealizeWidget
calls 
.PN XMapSubwindows 
to map all the children at once.
Otherwise, it maps each child individually.
If the widget is a top-level shell widget (that is, it has no parent),
.PN XtRealizeWidget 
maps the widget window.
.LP
.PN XtCreateWidget , 
.PN XtRealizeWidget , 
.PN XtManageChildren , 
.PN XtUnmanageChildren , 
and
.PN XtDestroyWidget 
maintain the following invariants:
.IP \(bu 5
If w is realized, then all managed children of w are realized.
.IP \(bu 5
If w is realized, then all managed children of w that are also
mapped_when_managed are mapped.
.LP
All Intrinsic routines and all widget routines should work 
with either realized or unrealized widgets.
.sp
.LP
To check whether or not a widget has been realized, use
.PN XtIsRealized .
.IN "XtIsRealized" "" "@DEF@"
.FD 0
Boolean XtIsRealized(\fIw\fP)
.br
      Widget \fIw\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.LP
.PN XtIsRealized 
returns TRUE if the widget has been realized. 
That is, it returns TRUE if the widget has a nonzero X window ID.
.LP
Some widget procedures (for example, set_values) might wish to
operate differently
after the widget has been realized.
.NH 3
Creation of a Window for a Widget Instance: the realize procedure
.XS
\*(SN Creation of a Window for a Widget Instance: the realize procedure
.XE
.LP
The realize procedure for a widget class is of type
.PN XtRealizeProc :
.IN "XtRealizeProc" "" "@DEF@"
.FD 0
typedef void (*XtRealizeProc)();
.sp
void \fIRealizeProc\fP(\fIw\fP, \fIvalue_mask\fP, \fIattributes\fP)
.br
      Widget \fIw\fP;
.br
      XtValueMask *\fIvalue_mask\fP;
.br
      XSetWindowAttributes *\fIattributes\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.IP \fIvalue_mask\fP 1i
Specifies which fields in the attributes structure to use.
.IP \fIattributes\fP 1i
Specifies the window attributes to use in the 
.PN XCreateWindow
call.
.LP
The realize procedure must make the window a reality.
.LP
The generic 
.PN XtRealizeWidget 
function fills in a mask and a corresponding 
.PN XSetWindowAttributes 
structure.
It sets the following fields based on information in the widget 
Core structure:
.IP \(bu 5
background_pixmap (or background_pixel if background_pixmap is NULL) 
is filled in from the corresponding field.
.IP \(bu 5
border_pixmap (or border_pixel if border_pixmap is NULL)
is filled in from the corresponding field.
.IP \(bu 5
event_mask is filled in based on the event handlers registered,
the event translations specified, whether expose is non-NULL, 
and whether visible_interest is TRUE.
.IP \(bu 5
bit_gravity is set to 
.PN NorthWestGravity
if the expose field is NULL.
.IP \(bu 5
do_not_propagate_mask is set to propagate all pointer and keyboard events
up the window tree.
A composite widget can implement functionality caused by
an event anywhere inside it (including on top of children widgets) 
as long as children do not specify a translation for the event.
.LP
All other fields in attributes (and the corresponding bits in
value_mask) can be set by the realize procedure.
.LP
.IN "Inheritance"
A widget class can inherit its realize procedure from its superclass
during class initialization.
The realize procedure defined for 
Core simply calls
.PN XtCreateWindow
with the passed value_mask and attributes, 
and with windowClass and visual set to 
.PN CopyFromParent .
Both 
.PN CompositeWidgetClass 
and 
.PN ConstraintWidgetClass 
inherit this realize procedure, and most new widget subclasses 
can do the same. 
See ``Inheriting Superclass Operations'' for further information.
.LP
The most common noninherited realize procedures set bit_gravity in the mask 
and attributes to the appropriate value and then create the window.
For example, Label sets bit_gravity to 
.PN WestGravity , 
.PN CenterGravity , 
or 
.PN EastGravity .
Consequently, shrinking a Label just moves the bits appropriately, 
and no 
.PN Expose 
event is needed for repainting.
.LP
If a composite widget wants to have its children realized in a particular
order (typically to control the stacking order) it should call
.PN XtRealizeWidget
on its children itself in the appropriate order from within its own
realize procedure.
.NH 3
Create Window Convenience Routine
.XS
\*(SN Create Window Convenience Routine
.XE
.LP
Rather than call the Xlib
.PN XCreateWindow
.IN "realize procedure"
function explicitly, a realize procedure should call the \*(tk analog
.PN XtCreateWindow .
This routine simplifies the creation of windows for widgets.
.IN "XtCreateWindow" "" "@DEF@"
.FD 0
void XtCreateWindow(\fIw\fP, \fIwindow_class\fP, \fIvisual\fP, \
\fIvalue_mask\fP, \fIattributes\fP)
.br
      Widget \fIw\fP;
.br
      unsigned int \fIwindow_class\fP;
.br
      Visual *\fIvisual\fP;
.br
      XtValueMask \fIvalue_mask\fP;
.br
      XSetWindowAttributes *\fIattributes\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget used to set x, y, and so on
.IP \fIwindow_class\fP 1i
Specifies the Xlib window class (for example, 
.PN InputOutput ,
.PN InputOnly ,
or 
.PN CopyFromParent ).
.IP \fIvisual\fP 1i
Specifies the visual type (usually 
.PN CopyFromParent ).
.IP \fIvalue_mask\fP 1i
Specifies which fields in attributes to use.
.IP \fIattributes\fP 1i
Specifies the window attributes to use in the
.PN XCreateWindow
call.
.LP
.PN XtCreateWindow
calls 
.PN XCreateWindow
with values from the widget structure and the passed parameters.
Then, it assigns the created window into the widget's window field.
.LP
.PN XtCreateWindow
evaluates the following fields of the
Core widget structure:
.IP \(bu 5
depth
.IP \(bu 5
screen
.IP \(bu 5
parent -> core.window
.IP \(bu 5
x
.IP \(bu 5
y
.IP \(bu 5
width
.IP \(bu 5
height
.IP \(bu 5
border_width
.NH 2
Destroying Widgets
.XS
\*(SN Destroying Widgets
.XE
.LP
Destroying widgets is simple.
The \*(tk provides support to:
.IP \(bu 5
Destroy all the children of the widget being destroyed.
.IP \(bu 5
Remove (and unmap) the widget from its parent.
.IP \(bu 5
Call procedures that have been registered to trigger when the widget
is destroyed.
.IP \(bu 5
Minimize the number of things a widget has to deallocate when destroyed.
.IP \(bu 5
Minimize the number of 
.PN XDestroyWindow 
calls.
.sp
.LP
To destroy a widget instance, use 
.PN XtDestroyWidget .
.IN "XtDestroyWidget" "" "@DEF@"
.FD 0
void XtDestroyWidget(\fIw\fP)
.br
      Widget \fIw\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.LP
.PN XtDestroyWidget
provides the only method of destroying a widget, 
including widgets that wish to destroy themselves.
It can be called at any time, 
including from an application callback routine of the widget being destroyed.
This requires a two-phase destroy process in order to avoid dangling 
references to destroyed widgets.
.LP
In phase one,
.PN XtDestroyWidget
performs the following actions:
.IP \(bu 5
If the being_destroyed field of the widget is TRUE, 
.PN XtDestroyWidget
returns immediately.
.IP \(bu 5
Removes the widget from its parent's managed set
which, in turn, causes the widget to be unmapped.
.IP \(bu 5
Sets the being_destroyed field to TRUE 
and the visible bit to FALSE for the widget and all descendants.
.IP \(bu 5
Adds the widget to a list of widgets (the destroy list) that should be
destroyed when it is safe to do so.
.LP
Entries on the destroy list satisfy the invariant:
.IP \(bu 5
If w1 occurs before w2 on the destroy list, 
then there is no ancestor/child relationship between the two, 
or w1 is a descendant of w2.
(The terms ``child'' and ``descendant'' here refer to both normal and pop-up
children.)
.LP
Phase two occurs when all procedures that should execute as a result of
the current event have been called (including all procedures registered with 
the Event and Translation Managers).
That is, phase two occurs when 
.PN XtNextEvent
is called. 
.NT Issues
.IP 1. 5
.PN XtDestroyWidget 
may get rid of all widgets, and then the next call to 
.PN XtNextEvent 
won't ever get any events.
So we expect to move phase two to happen at the end of 
.PN XtDispatchEvent ,
allowing customized event loops to test a flag before looping back to
.PN XtNextEvent .
.IP 2. 5
The phase two destroy should happen only at the end of the outermost
call to 
.PN XtDispatchEvent , 
because there may be nested calls to an event dispatch loop
in applications/widgets that maintain some state in the program counter.
.NE
.LP
In phase two,
.PN XtDestroyWidget
performs the following actions on each entry in the destroy list:
.IP \(bu 5
Calls the destroy callbacks registered on the widget (and all descendants) 
in post-order. 
That is, it calls children callbacks before parent callbacks.
.IP \(bu 5
Calls the widget's parent's delete_child procedure.
(See ``Deletion of Children''.)
.IP \(bu 5
If the widget's parent is a subclass of 
.PN constraintWidgetClass , 
it calls the constraint destroy procedure for the parent, 
then the parent's superclass, 
until finally it calls the constraint destroy procedure for
.PN constraintWidgetClass .
.IP \(bu 5
Calls the destroy class procedures for the widget (and all descendants) 
in post-order.
For each such widget, 
it calls the destroy procedure declared in the widget class,
then the destroy procedure declared in its superclass, 
until finally it calls the destroy procedure declared in the Core 
class record.
.IP \(bu 5
Calls 
.PN XDestroyWindow 
if the widget is realized (that is, has an X window).
The server recursively destroys all descendant windows.
.LP
Finally,
.PN XtDestroyWidget
recursively descends the tree and deallocates all widgets and constraint
records.
.NH 3
Adding and Removing Destroy Callbacks
.XS
\*(SN Adding and Removing Destroy Callbacks
.XE
.LP
The destroy callback uses the mechanism described in ``Callbacks''. 
.IN "Destroy Callbacks"
The destroy callback list is identified by the resource name
XtNdestroyCallback.
To add a destroy callback procedure ClientDestroy with client
data \fIclient_data\fP to Widget w, call
.PN XtAddCallback .
To remove the callback, call
.PN XtRemoveCallback .
Both calls take the following parameter list:
.LP
.Ds 0
(\fIw\fP, XtNdestroyCallback, \fIClientDestroy\fP, \fIclient_data\fP)
.De
.NH 3
Deallocation of Dynamic Data: the destroy procedure
.XS
\*(SN Deallocation of Dynamic Data: the destroy procedure
.XE
.LP
The destroy procedure is of type
.PN XtWidgetProc :
.IN "XtWidgetProc" "" "@DEF@"
.FD 0
typedef void (*XtWidgetProc)();
.sp
void \fIWidgetProc\fP(\fIw\fP)
.br
        Widget \fIw\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.LP
The destroy procedures are called in subclass-to-superclass order. 
Therefore, a widget's destroy procedure should only deallocate storage
that is specific to the subclass and should not bother with the storage
allocated by any of its superclasses.
If a widget does not need to deallocate any storage,
the destroy procedure entry in its widget class record can be NULL.
.LP
Deallocating storage includes but is not limited to:
.IP \(bu 5
Calling 
.PN XtFree 
on dynamic storage allocated with
.PN XtMalloc ,
.PN XtCalloc ,
and so on.
.IP \(bu 5
Calling 
.PN XtRemoveAllCallbacks
on callback lists.
.IP \(bu 5
Calling 
.PN XtDestroyPixmap
on pixmaps allocated with 
.PN XtGetPixmap .
.\" Beta release
.\"
.\"[[ yet to be defined or implemented ]]
.IP \(bu 5
Calling
.PN XFreePixmap
on pixmaps created with direct X calls.
.IP \(bu 5
Calling 
.PN XtDestroyGC
on GCs allocated with 
.PN XtGetGC .
.IP \(bu 5
Calling
.PN XFreeGC
on GCs allocated with direct X calls.
.IP \(bu 5
Calling
.PN XtRemoveEventHandler
on event handlers added with
.PN XtAddEventHandler .
.IP \(bu 5
Calling
.PN XtRemoveTimeOut
on timers created with
.PN XtAddTimeOut .
.NH 3
Deallocation of Dynamic Constraint Data: the constraint destroy procedure
.XS
\*(SN Deallocation of Dynamic Constraint Data: the constraint destroy procedure
.XE
.LP
The constraint destroy procedure is of type
.PN XtWidgetProc .
They are called for a widget 
whose parent is a subclass of 
.PN constraintWidgetClass .
The constraint destroy procedures are called in subclass-to-superclass order, 
starting at the widget's parent and ending at 
.PN constraintWidgetClass . 
Therefore, a parent's constraint destroy procedure should only deallocate
storage that is specific to the constraint subclass 
and not the storage allocated by any of its superclasses.
.LP
If a parent does not need to deallocate any constraint storage, 
the constraint destroy procedure entry
in its class record can be NULL.
.NH 2
Exiting an Application
.XS
\*(SN Exiting an Application
.XE
.LP
All \*(tk applications that wish to terminate should just do so
by calling
.PN XCloseDisplay
and exiting
using the
standard method for their operating system (typically, by calling
.PN exit
for UNIX-based systems).
The quickest way to make the windows disappear while exiting is to call
.PN XtUnmapWidget
on each top-level shell widgets.
The \*(tk has no resources beyond those in the program image, 
and the X server will free its resources when its connection
to the application is broken.
.bp
\&
.sp 1
.ce 3
\s+1\fBChapter 5\fP\s-1

\s+1\fBCallbacks\fP\s-1
.sp 2
.nr H1 5
.nr H2 0
.nr H3 0
.nr H4 0
.nr H5 0
.LP
.XS
Chapter 5 \- Callbacks
.XE
.IN "Destroy Callbacks"
Applications and other widgets (clients) often want to register a procedure
with a widget that gets called under certain conditions.
For example, 
when a widget is destroyed,
every procedure on the widget's destroy_callbacks
list is called to notify clients of the widget's impending doom.
.LP
Every widget has a destroy_callbacks list.
Widgets can define additional callback lists as they see fit.
For example, the Command widget has a callback
list to notify clients when the button has been activated.
.NH 2
Callback Procedure and Callback List Definitions
.XS
\*(SN Callback Procedure and Callback List Definitions
.XE
.IN "XtCallbackList"
.IN "XtCallbackProc"
.LP
Callback procedures for use in callback lists are of type
.PN XtCallbackProc :
.IN "XtCallbackProc" "" "@DEF@"
.FD 0
typedef void (*XtCallbackProc)();
.sp
void \fICallbackProc\fP(\fIw\fP, \fIclient_data\fP, \fIcall_data\fP)
.br
      Widget \fIw\fP;
.br
      caddr_t \fIclient_data\fP;
.br
      caddr_t \fIcall_data\fP;
.FN
.IP \fIw\fP 1i
Specifies widget for which the callback is registered.
.IP \fIclient_data\fP 1i
Specifies the data that the widget should pass back to the client when
the widget executes the client's callback procedure.
This is a way for the
client registering the callback to also register client-specific data:
a pointer to additional information about the widget, a reason for invoking
the callback, and so on.
It is perfectly normal to have client_data be NULL 
if all necessary information is in the widget.
.IP \fIcall_data\fP 1i
Specifies any callback-specific data the widget wants to pass to the client.
For example,  when Scrollbar executes its thumbChanged callback list, 
it passes the new position of the thumb.
The call_data argument merely is a convenience to avoid having simple
cases where the client could otherwise need to call
.PN XtGetValues
or a widget-specific function to retrieve data from the widget.
Complex state information in call_data generally should be avoided.
The client can use the more general data retrieval methods, if necessary.
.LP
Whenever a client wants to pass a callback list as an argument in an
.PN XtCreateWidget , 
.PN XtSetValues , 
or 
.PN XtGetValues 
call, it should specify the address
of a NULL-terminated array of type 
.PN XtCallbackList :
.LP
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	XtCallbackProc callback;
	caddr_t client_data;
} XtCallbackRec, *XtCallbackList;
.De
.LP
For example, the callback list for procedures A and B with client data
clientDataA and clientDataB, respectively, is:
.LP
.Ds 0
.TA .5i 3i
.ta .5i 3i
static XtCallbackRec \fIcallbacks\fP[] = {
	{A, (caddr_t) clientDataA},
	{B, (caddr_t) clientDataB},
	{(XtCallbackProc) NULL, (caddr_t) NULL}
};
.De
.LP
Though callback lists are passed by address in argument lists, 
the Intrinsics know about callback lists.
Your widget initialize and set_values procedures
should not allocate memory for the callback list.
The Intrinsics do this for you, using a different structure for their
internal representation.
.NH 2
Identifying Callback Lists
.XS
\*(SN Identifying Callback Lists
.XE
.LP
Whenever a widget contains a callback list for use by clients, it also exports 
in its public ``.h'' file the resource name of the callback list.
Applications and client widgets never access callback list fields directly.
Instead, they always identify the desired callback list using the exported
resource name.
All callback manipulation routines described below check that the requested 
callback list is indeed implemented by the widget.
.LP
In order for the Intrinsics to find and correctly handle callback lists, they
should always be declared with a resource type of 
.PN XtRCallback .
.NH 2
Adding Callback Procedures
.XS
\*(SN Adding Callback Procedures
.XE
.LP
To add a callback procedure to a callback list, use
.PN XtAddCallback .
.IN "XtAddCallback" "" "@DEF@"
.FD 0
void XtAddCallback(\fIw\fP, \fIcallback_name, \fP\fIcallback\fP, \
\fIclient_data\fP)
.br
      Widget \fIw\fP;
.br
      String \fIcallback_name\fP;
.br
      XtCallbackProc \fIcallback\fP;
.br
      caddr_t \fIclient_data\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget to add the callback to.
.IP \fIcallback_name\fP 1i
Specifies the callback list within the widget to append to.
.IP \fIcallback\fP 1i
Specifies the callback procedure to add.
.IP \fIclient_data\fP 1i
Specifies the client data to be passed to the callback when it is invoked by
.PN XtCallCallbacks .
The client_data parameter is often NULL).
.sp
.LP
To add a list of callback procedures to a callback list, use
.PN XtAddCallbacks .
.IN "XtAddCallbacks" "" "@DEF@"
.FD 0
void XtAddCallbacks(\fIw\fP, \fIcallback_name, \fP\fIcallbacks\fP)
.br
      Widget \fIw\fP;
.br
      String \fIcallback_name\fP;
.br
      XtCallbackList \fIcallbacks\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget to add the callbacks to.
.IP \fIcallback_name\fP 1i
Specifies the callback list within the widget to append to.
.IP \fIcallbacks\fP 1i
Specifies the null-terminated list of callback procedures and corresponding 
client data to add.
.NH 2
Removing Callback Procedures
.XS
\*(SN Removing Callback Procedures
.XE
.LP
To remove a callback procedure from a callback list, use
.PN XtRemoveCallback .
.IN "XtRemoveCallback" "" "@DEF@"
.FD 0
void XtRemoveCallback(\fIw\fP, \fIcallback_name\fP, \fIcallback\fP, \
\fIclient_data\fP)
.br
      Widget \fIw\fP;
.br
      String \fIcallback_name\fP;
.br
      XtCallbackProc \fIcallback\fP;
.br
      caddr_t \fIclient_data\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget to delete the callback from.
.IP \fIcallback_name\fP 1i
Specifies the callback list within the widget to remove the callback from.
.IP \fIcallback\fP 1i
Specifies the callback procedure to delete.
.IP \fIclient_data\fP 1i
Specifies the client data to match on the registered callback procedure. (The
.PN XtRemoveCallback
routine removes a callback only if both the procedure and the client
data match).
.sp
.LP
To remove a list of callback procedures from a callback list, use
.PN XtRemoveCallbacks .
.IN "XtRemoveCallbacks" "" "@DEF@"
.FD 0
void XtRemoveCallbacks(\fIw\fP, \fIcallback_name\fP, \fIcallbacks\fP)
.br
      Widget \fIw\fP;
.br
      String \fIcallback_name\fP;
.br
      XtCallbackList \fIcallbacks\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget to delete the callbacks from.
.IP \fIcallback_name\fP 1i
Specifies the callback list within the widget to remove the callbacks from.
.IP \fIcallbacks\fP 1i
Specifies the list of callbacks to delete.
.sp
.LP
To remove all callback procedures from a callback list 
(and, thus, free all storage associated with the callback list), use
.PN XtRemoveAllCallbacks .
.IN "XtRemoveAllCallbacks" "" "@DEF@"
.FD 0
void XtRemoveAllCallbacks(\fIw\fP, \fIcallback_name\fP)
.br
      Widget \fIw\fP;
.br
      String \fIcallback_name\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget to remove the callback from.
.IP \fIcallback_name\fP 1i
Specifies the callback list within the widget to remove.
.NH 2
Executing Callback Procedures
.XS
\*(SN Executing Callback Procedures
.XE
.LP
To execute the procedures in a callback list, use
.PN XtCallCallbacks .
.IN "XtCallCallbacks" "" "@DEF@"
.FD 0
void XtCallCallbacks(\fIw\fP, \fIcallback_name\fP, \fIcall_data\fP)
.br
      Widget \fIw\fP;
.br
      String \fIcallback_name\fP;
.br
      caddr_t \fIcall_data\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget containing the callback list that is to be executed.
.IP \fIcallback_name\fP 1i
Specifies the callback list within the widget to execute.
.IP \fIcall_data\fP 1i
Specifies a callback-list specific data value to pass to each of the callback
procedure in the list.  The call_data is NULL if no data is needed (for
example, the commandActivated callback list in Command needs only to
notify its clients that the button has been activated). 
The call_data is the actual data if only one (32-bit) long word is needed. 
The call_data is the address of the data if more than one word is needed.
.NH 2
Checking the Status of a Callback List
.XS
\*(SN Checking the Status of a Callback List
.XE
.LP
To find out the status of a callback list, use 
.PN XtHasCallbacks .
.IN "XtHasCallbacks" "" "@DEF@"
.FD 0
typedef enum {XtCallbackNoList, XtCallbackHasNone, XtCallbackHasSome} \
XtCallbackStatus;
.sp 
XtCallbackStatus XtHasCallbacks(\fIw\fP, \fIcallback_name\fP)
.br
      Widget \fIw\fP;
.br
      String \fIcallback_name\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget to check.
.IP \fIcallback_name\fP 1i
Specifies the callback list within the widget to check.
.LP
.PN XtHasCallbacks 
first checks if the widget has a callback list identified by callback_name.
If not, it returns 
.PN XtCallbackNoList .
Otherwise, it returns 
.PN XtCallbackHasNone 
if the callback list is empty, and
.PN XtCallbackHasSome 
if the callback list has at least one callback registered.
.bp
\&
.sp 1
.ce 3
\s+1\fBChapter 6\fP\s-1

\s+1\fBComposite Widgets\fP\s-1
.sp 2
.nr H1 6
.nr H2 0
.nr H3 0
.nr H4 0
.nr H5 0
.LP
.XS
Chapter 6 \- Composite Widgets
.XE
.IN "Composite widgets"
Composite widgets can have children.
Consequently, they are responsible for much more than primitive widgets.
Their responsibilities (either implemented directly by the widget class 
or indirectly by Intrinsic procedures) include:
.IP \(bu 5
Overall management of children from creation to destruction.
.IP \(bu 5
Destruction of descendants when the composite widget is destroyed.
.IP \(bu 5
Physical arrangement (geometry management) of a displayable subset of 
children (that is, the ``managed'' children).
.IP \(bu 5
Mapping and unmapping of a subset of the managed children.
.IP \(bu 5
Focus management for the displayable children.
.LP
Overall management is handled by the generic procedures
.PN XtCreateWidget
and 
.PN XtDestroyWidget .
.PN XtCreateWidget
adds children to their parent by calling the parent's insert_child 
procedure. 
.PN XtDestroyWidget
removes children from their parent by calling the parent's delete_child
procedure and ensures all children of a destroyed composite widget 
also get destroyed.
.LP
Only a subset of the total number of children are actually managed by
the geometry manager and, hence, possibly visible.
For example, a multi-buffer composite editor widget might allocate one child 
widget per file buffer, 
but it might only display a small number of the existing buffers.
Windows that are in this displayable subset are called ``managed'' windows 
and enter into geometry manager calculations.
The other children are ``unmanaged'' windows 
and, by definition, are not mapped.
.LP
Children are added to and removed from the managed set by using 
.PN XtManageChild ,
.PN XtManageChildren ,
.PN XtUnmanageChild ,
and 
.PN XtUnmanageChildren ,
which notify the parent to recalculate the physical layout of its children 
by calling the parent's change_managed procedure. 
A convenience routine, 
.PN XtCreateManagedWidget ,
calls 
.PN XtCreateWidget 
and 
.PN XtManageChild 
on the result.
It has the same parameters as 
.PN XtCreateWidget .
.LP
Most managed children are mapped, 
but some widgets can be in a state where they take up physical space 
but do not show anything.
Managed widgets will not be mapped automatically
if their map_when_managed field is FALSE.  
This field default is TRUE and is changed by using
.PN XtSetMappedWhenManaged .
.LP
Each composite widget class has a geometry manager, 
which is responsible for figuring out where the managed children 
should appear within the composite widget's window.
Geometry management techniques fall into four classes:
.IP \(bu 5
Fixed boxes have a fixed number of children that are created by the parent.
All of these children are managed, 
and none ever make geometry manager requests.
.IP \(bu 5
Homogeneous boxes treat all children equally and apply the same geometry
constraints to each child.
Many clients insert and delete widgets freely.
.IP \(bu 5
Heterogeneous boxes have a specific location where each child is placed.
This location is usually not specified in pixels, 
because the window may be resized but is expressed rather 
in terms of the relationship between a child
and the parent or between the child and other specific children.
Heterogeneous boxes are usually subclasses of 
.PN Constraint .
.IP \(bu 5
Shell boxes have only one child, 
which is exactly the size of the shell.
The geometry manager must communicate with the window manager if it exists, 
and the box must also accept 
.PN ConfigureNotify
events when the window size is changed by the window manager.
.LP
Each composite widget, especially those that are heterogeneous,
can define ways for one child to change focus to another child by means
of the move_focus_to_next and move_focus_to_prev procedures.
For example,
typing carriage return in one child widget may move to the ``next'' child
widget, while typing a number in one child widget may move focus to any
of a number of children widgets.
.NH 2
Verifying the Class of a Composite Widget
.XS
\*(SN Verifying the Class of a Composite Widget
.XE
.LP
To test if a widget is a subclass of Composite, use
.PN XtIsComposite .
.IN "XtIsComposite" "" "@DEF@"
.FD 0
void XtIsComposite(\fIw\fP)
.br
      Widget \fIw\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget under question.
.LP
.PN XtIsComposite (w)
is just an abbreviation for
.PN XtIsSubclass 
(\fIw\fP, \fIcompositeWidgetClass\fP).
.NH 2
Addition of Children to a Composite Widget: the insert_child procedure
.XS
\*(SN Addition of Children to a Composite Widget: the insert_child procedure
.XE
.LP
.IN "insert_child procedure"
To add the child to
the parent's children array,
.PN XtCreateWidget
calls the parent's class routine insert_child.
The insert_child procedure for a composite widget is of type 
.PN XtWidgetProc .
An insert_child procedure takes the widget to insert and the argument list used
to create the widget.
.LP
Most composite widgets just inherit their superclass's operation.
Composite's insert_child routine merely calls the insert_position procedure 
and inserts the child at the specified position.  
.LP
Some composite widgets define their own insert_child routine 
so that they can order their children in some convenient way, 
so that they can create companion ``controller'' widgets for a new widget, 
or so they can limit the number or type of their children widgets.
.LP
If there is not enough room to insert a new child in the children array
(num_children = num_slots), 
the insert_child procedure must first realloc the array and update num_slots.
The insert_child procedure then places the child wherever it wants 
and increments the num_children field.  
.NH 3
Insertion Order of Children: the insert_position procedure
.XS
\*(SN Insertion Order of Children: the insert_position procedure
.XE
.LP
Instances of composite widgets may care about the order in which 
their children are kept.
For example, 
an application may want a set of command buttons in some logical order 
grouped by function, 
while it may want buttons that represent file names to be kept 
in alphabetical order.
.LP
The insert_position procedure for a composite widget instance is of type
.PN XtOrderProc :
.IN "XtOrderProc" "" "@DEF@"
.FD 0
typedef Cardinal (*XtOrderProc)();
.sp
Cardinal \fIOrderProc\fP(\fIw\fP)
.br
      Widget \fIw\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.LP
Composite widgets that allow clients to order their children (usually
homogeneous boxes) can call their widget instance's insert_position
function from the class's insert_child procedure to determine where a new
child should go in its children array.
Thus, a client of a composite class can apply different sorting criteria 
to widget instances of the class passing in a different insert_position 
procedure when it creates each composite widget instance.
.LP
The return value of the insert_position procedure
indicates how many children should go before the widget.
Returning zero (0) means before all other children,
while returning num_children means after all other children.  
The default insert_position function returns num_children.
This can be overridden by a specific composite widget's resource list 
or by the argument list provided when the composite widget is created.
.NH 2
Deletion of Children: the delete_child procedure
.XS
\*(SN Deletion of Children: the delete_child procedure
.XE
.LP
.IN "delete_child procedure"
.PN XtDestroyWidget
eventually causes a call to the parent's class routine delete_child
in order to remove the child from the parent's children array.
.LP
A deletion procedure is of type 
.PN XtWidgetProc ,
and it takes the widget being deleted.
.LP
Most widgets just inherit delete_children from their superclass.
Composite widgets that create companion widgets define their own 
delete_children routine to remove these companion widgets.
.NH 2
Adding and Removing Children from the Managed Set
.XS
\*(SN Adding and Removing Children from the Managed Set
.XE
.LP
The \*(tk provides a set of generic routines to permit the addition of
widgets to or the removal of widgets from a composite widget's managed set.
.IN "change_managed procedure"
These generic routines eventually call the widget's class procedure,
change_managed, which is of type 
.PN XtWidgetProc .
.NH 3
Managing Children
.XS
\*(SN Managing Children
.XE
.LP
To add a list of widgets to the geometry-managed (and, hence, displayable)
subset of their parent widget, 
the application must first create the widgets by using
.PN XtCreateWidget 
and then call 
.PN XtManageChildren .
.IN "XtManageChildren" "" "@DEF@"
.FD 0
typedef Widget *WidgetList;
.sp
void XtManageChildren(\fIchildren\fP, \fInum_children\fP)
.br
      WidgetList \fIchildren\fP;
.br
      Cardinal \fInum_children\fP;
.FN
.IP \fIchildren\fP 1i
Specifies a list of children to add.
.IP \fInum_children\fP 1i
Specifies the number of children to add.
.LP
.PN XtManageChildren 
performs the following:
.IP \(bu 5
Issues an error if the children do not all have the same parent.
.IP \(bu 5
Returns immediately if the common parent is being destroyed.
.IP \(bu 5
Otherwise, for each unique child on the list:
.RS
.IP \- 5
The child is ignored if it is already managed or being destroyed.
.IP \- 5
Otherwise, the child is marked as managed, and the parent's
num_mapped_children field is incremented if the child has map_when_managed 
TRUE.
.RE
.IP \(bu 5
If the parent is realized and after all children have been marked,
.PN XtManageChildren
makes some of the newly managed children visible:
.RS
.IP \- 5
Calls the change_managed routine of the widgets' parent.
.IP \- 5
Calls 
.PN XtRealizeWidget
on each previously unmanaged child that is unrealized.
.IP \- 5
Maps each previously unmanaged child that has map_when_managed TRUE.
.RE
.LP
Managing children is independent of the ordering of children and
independent of creating and deleting children.
The layout routine of the parent
should only bother with children whose managed field is 
TRUE and should ignore all other children.
(Note that some composite widgets, especially fixed boxes, call 
.PN XtManageChild
from their insert_child procedure.)
.LP
If the parent widget is realized, 
its change_managed procedure is called to notify the
that that its set of managed children has changed.
The parent can reposition and resize any of its children.
It moves each child as needed by calling the
.PN XtMoveWidget
procedure.
.PN XtMoveWidget
first updates the x and y fields and then calls
.PN XMoveWindow
if the widget is realized.
.LP
If the composite widget wishes to change the size or border width of any of 
its children, it calls the
.PN XtResizeWidget
procedure.
.PN XtResizeWidget 
first updates the 
Core fields and then calls
.PN XConfigureWindow
if the widget is realized.
.sp
.LP
To add a single child to the managed children of its parent widget, 
the application must first create the widget by using 
.PN XtCreateWidget 
and then call 
.PN XtManageChild .
.IN "XtManageChild" "" "@DEF@"
.FD 0
void XtManageChild(\fIchild\fP)
.br
      Widget \fIchild\fP;
.FN
.IP \fIchild\fP 1i
Specifies the child to add.
.LP
.PN XtManageChild
constructs a 
.PN WidgetList 
of length one (1) and calls 
.PN XtManageChildren .
.sp
.LP
To create and manage a widget in a single procedure, use 
.PN XtCreateManagedWidget .
.IN "XtCreateManagedWidget" "" "@DEF@"
.FD 0
Widget XtCreateManagedWidget(\fIname\fP, \fIwidget_class\fP, \fIparent\fP, \
\fIargs\fP, \fInum_args\fP)
.br
      String \fIname\fP;
.br
      WidgetClass \fIwidget_class\fP;
.br
      Widget \fIparent\fP;
.br
      ArgList \fIargs\fP;
.br
      Cardinal \fInum_args\fP;
.FN
.IP \fIname\fP 1i
Specifies the text name for the created widget.
.IP \fIwidget_class\fP 1i
Specifies the widget class pointer for the created widget.
.IP \fIparent\fP 1i
Specifies the parent widget.
.IP \fIargs\fP 1i
Specifies the argument list to override the resource defaults.
.IP \fInum_args\fP 1i
Specifies the number of arguments in args.
.LP
.PN XtCreateManagedWidget
is a convenience routine that calls
.PN XtCreateWidget 
followed by
.PN XtManageChild .
.NH 3
Unmanaging Children
.XS
\*(SN Unmanaging Children
.XE
.LP
To remove a list of children from the managed list of their parent, use
.PN XtUnmanageChildren .
.IN "XtUnmanageChildren" "" "@DEF@"
.FD 0
void XtUnmanageChildren(\fIchildren\fP, \fInum_children\fP)
.br
      WidgetList \fIchildren\fP;
.br
      Cardinal \fInum_children\fP;
.FN
.IP \fIchildren\fP 1i
Specifies the children to remove.
.IP \fInum_children\fP 1i
Specifies the number of children to remove.
.LP
.PN XtUnmanageChildren
performs the following:
.IP \(bu 5
Issues an error if the children do not all have the same parent.
.IP \(bu 5
Returns immediately if the common parent is being destroyed.
.IP \(bu 5
Otherwise, for each unique child on the list:
.RS 
.IP \- 5
The child is ignored if it is already unmanaged or being destroyed.
.IP \- 5
Otherwise,
.PN XtUnmanagedChildren
marks the child as unmanaged.
.IP \- 5
If the child is realized, 
.PN XtUnmanageChildren
makes it non-visible by unmapping it.
.IP \- 5
Decrements the parent's num_mapped_children field 
if the widget has map_when_managed TRUE.
.RE
.IP \(bu 5
Calls the change_managed routine of the widgets' parent
after all children have been marked 
if the parent is realized.
.LP
.PN XtUnmanageChildren
does not destroy the children widgets.
Removing widgets from a parent's managed set is often a temporary banishment, 
and, some time later, you may add the children again.
To destroy widgets entirely, 
see ``Destroying Widgets''.
.sp
.LP
To remove a single child from its parent's managed set, use
.PN XtUnmanageChild .
.IN "XtUnmanageChild" "" "@DEF@"
.FD 0
void XtUnmanageChild(\fIchild\fP)
.br
      Widget \fIchild\fP;
.FN
.IP \fIchild\fP 1i
Specifies the child to remove.
.LP
.PN XtUnmanageChild
constructs a widget list
of length one and calls 
.PN XtUnmanageChildren .
.LP
These generic routines are low-level routines used by ``generic''
composite widget building routines.
In addition, composite widgets can provide widget-specific, 
high-level convenience routines to allow applications to create 
and manage children more easily.
.NH 2
Controlling When Widgets Get Mapped
.XS
\*(SN Controlling When Widgets Get Mapped
.XE
.LP
A widget is normally mapped if it is managed.
However, 
this behavior can be overridden by setting the XtNmappedWhenManaged resource 
for the widget when it is created
or by setting the map_when_managed field to False.  
.LP
To change the map_when_managed field, use
.PN XtSetMappedWhenManaged .
.IN "XtSetMappedWhenManaged" "" "@DEF@"
.FD 0
void XtSetMappedWhenManaged(\fIw\fP, \fImap_when_managed\fP)
.br
      Widget \fIw\fP;
.br
      Boolean \fImap_when_managed\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.IP \fImap_when_managed\fP 1i
Specifies the new value (either True or False).
.LP
If the widget is realized and managed
and if the new value of map_when_managed is True,
.PN XtSetMappedWhenManaged
maps the window.
If the widget is realized and managed
and if the new value of map_when_managed is False,
it unmaps the window.
.LP
When a widget's mapped_when_managed field is False,
the client is responsible for mapping and unmapping the widget.
.LP
.PN XtSetMappedWhenManaged
is a convenience function that is equivalent to (but slightly faster than)
calling
.PN XtSetValues
and setting the new value for the mappedWhenManaged resource.
.LP
.sp
To map a widget explicitly, use
.PN XtMapWidget .
.IN "XtMapWidget" "" "@DEF@"
.FD 0
XtMapWidget(\fIw\fP)
.br
     Widget \fIw\fP\^;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.LP
.sp
To unmap a widget explicitly, use
.PN XtUnmapWidget .
.IN "XtUnmapWidget" "" "@DEF@"
.FD 0
XtUnmapWidget(\fIw\fP)
.br
     Widget \fIw\fP\^;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.NH 2
Constrained Composite Widgets
.XS
\*(SN Constrained Composite Widgets
.XE
.LP
Constraint widgets are a subclass of Composite widgets.
The name comes from the fact that they manage the geometry of their children 
based upon constraints associated with each child.
Constraints can be as simple as information such as
the maximum width and height the parent will allow the child to occupy, 
or they can be more complicated information such as how other children should 
change if this child is moved or resized.
.LP
Constraint widgets have all the responsibilities of normal composite widgets,
and, in addition, must process and act upon the constraint information 
associated with each of their children.
.LP
In order to make it easy for widgets and the Intrinsics to keep track of the
constraints a parent associated with each child, every widget has a constraints
field.
This field is the address of a parent-specific structure containing
constraint information about the child.
If a child's parent is not a subclass of 
.PN constraintWidgetClass , 
then the child's constraints field is NULL.
.LP
Subclasses of a constrained widget can add additional constraint fields to
their superclass.
To allow this, widget writers should define the constraint
records in their private ``.h'' file using the same conventions as used for
widget records.
For example, a widget that wished to maintain a maximum
width and height for each child might define its constraint record like this:
.LP
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	Dimension max_width, max_height;
} MaxConstraintPart;

typedef struct {
	MaxConstraintPart max;
} MaxConstraintRecord, *MaxConstraint;
.De
.LP
A subclass of this widget that also wished to maintain a minimum size would
define its constraint record thus:
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	Dimension min_width, min_height;
} MinConstraintPart;

typedef struct {
	MaxConstraintPart max;
	MinConstraintPart min;
} MaxMinConstraintRecord, *MaxMinConstraint;
.De
.LP
Constraints are allocated, initialized, deallocated, and otherwise maintained 
insofar as possible by the Intrinsics.
The constraint class record part has several entries that facilitate this.
All entries in 
.PN ConstraintClassPart 
are information and procedures that are defined and implemented by the parent, 
but they are called whenever actions are performed upon the parent's children.
.LP
.PN XtCreateWidget
uses the constraint_size field to allocate a constraint record 
when a child is created.
The constraint_size field gives the number of bytes occupied 
by a constraint record.
.LP
.PN XtCreateWidget 
uses the constraint resources to fill in resource fields in the
constraint record associated with a child. 
It then calls the constraint initialize procedure so that a the parent 
can compute constraint fields that are derived from constraint resources 
and can possible move or resize the child to conform to the given constraints.
.LP
.PN XtGetValues 
and 
.PN XtSetValues 
use the constraint resources to get the values or
set the values of constraints associated with a child.
.PN XtSetValues 
then calls the constraint set_values procedures so that a parent can 
recompute derived constraint fields and move or resize the child 
as appropriate.
.LP
.PN XtDestroyWidget 
calls the constraint destroy procedure to deallocate any
dynamic storage associated with a constraint record.
The constraint record itself must not be deallocated by the constraint
destroy procedure;
.PN XtDestroyWidget
does this automatically.
.bp
\&
.sp 1
.ce 3
\s+1\fBChapter 7\fP\s-1

\s+1\fBPop-up Widgets\fP\s-1
.sp 2
.nr H1 7
.nr H2 0
.nr H3 0
.nr H4 0
.nr H5 0
.LP
.XS
Chapter 7 \- Pop-up Widgets
.XE
There are three kinds of pop-ups: 
.IP \(bu 5
Modeless pop-ups
.IP \(bu 5
Modal pop-ups
.IP \(bu 5
Spring-loaded pop-ups
.LP
A modeless dialog box, an example of a modeless pop-up, 
is normally visible to the window manager 
and looks much like just another application from the
user point of view.
(The application itself is a special form of a modeless pop-up.)
.LP
A modal dialog box, an example of a modal pop-up, 
is not normally visible to the window manager, 
and, except for events that occur in the dialog box,
it disables user-event processing by the application.
.LP
A menu, an example of a  spring-loaded pop-up, 
is not visible to the window manager 
and, except for events that occur in the menu,
disables user-event processing by all applications.
.LP
Modal pop-ups and spring-loaded pop-ups are really almost the same thing 
and should be coded as such.
In fact, the same widget (for example, a ButtonBox or Menu) can be used both 
as a modal pop-up or as a spring-loaded pop-up within the same application.
The main difference is that spring-loaded pop-ups are brought up 
with the pointer and, because of the grab that the pointer button causes, 
they can require different processing by the Intrinsics.
Further, button up takes down a spring-loaded pop-up no matter where the
button up occurs.
.LP
Any kind of pop-up can, in turn, pop up other widgets.
Modal and spring-loaded pop-ups can constrain user events to just 
the most recent such pop-up or to any of the modal/spring-loaded pop-ups 
currently mapped.
.NH 2
Pop-ups and the Widget/Window Hierarchy
.XS
\*(SN Pop-ups and the Widget/Window Hierarchy
.XE
.LP
The one thing all pop-ups have in common is that they break the widget/window
hierarchy.
Pop-ups windows are not geometry constrained by their parent widget.
Instead, they are window children of ``root''. 
This means pop-ups are created and attached to their widget parent differently 
than from normal widget children.
.LP
Because the \*(tk does not support multiple inheritance, and because you can
pop up a widget that belongs to any arbitrary widget (for example, 
Command, MenuBar, Text, and so on), the 
.PN CorePart
record includes the list of the widget's pop-up children.
This means that a primitive widget can be a parent, 
but this is very different from being a composite widget parent.
Think of it more like being a godfather.
The pop-up list exists mainly to provide the proper place in the widget
hierarchy for the pop-up to get resources and to provide a place for
.PN XtDestroyWidget
to look for all extant children.
A parent of a pop-up widget does not actively manage its pop-up children.
In fact, it usually never notices them or operates upon them.
.LP
A composite widget can have both normal and pop-up children.
A pop-up can be popped up from just about anywhere, not just by its parent.
The term ``child'' always refers to a normal, geometry-managed child on
the children list.
The term ``pop-up child'' always refers to a child on the pop-ups list.
.NH 2
Creating a Pop-up Shell
.XS
\*(SN Creating a Pop-up Shell
.XE
.LP
In order to pop up some arbitrary widget,
it must be the only child of a pop-up widget ``shell''.
This shell is responsible for communication with the
X window manager on geometry requests and is responsible for 
proper handling of the bookkeeping associated with actual pop up and pop down.
Pop-up shells never allow more than one child.
.LP
.IN "pop-up" "shell"
.IN "pop-up" "child"
This shell is always referred to as the ``pop-up shell''.
The single (normal) child is always referred to as the ``pop-up child''.
Both taken together are referred to as the ``pop-up''.
.sp
.LP
To create a pop-up shell, use 
.PN XtCreatePopupShell .
.IN "XtCreatePopupShell" "" "@DEF@"
.FD 0
Widget XtCreatePopupShell(\fIname\fP, \fIwidget_class\fP, \fIparent\fP, \
\fIargs\fP, \fInum_args\fP)
.br
      String \fIname\fP;
.br
      WidgetClass \fIwidget_class\fP;
.br
      Widget \fIparent\fP;
.br
      ArgList \fIargs\fP;
.br
      Cardinal \fInum_args\fP;
.FN
.IP \fIname\fP 1i
Specifies the text name for the created shell widget.
.IP \fIwidget_class\fP 1i
Specifies the widget class pointer for the created shell widget.
.IP \fIparent\fP 1i
Specifies the parent widget.
.IP \fIargs\fP 1i
Specifies the argument list to override the resource defaults.
.IP \fInum_args\fP 1i
Specifies the number of arguments in args.
.LP
.PN XtCreatePopupShell 
ensures that the specified class is a subclass of 
.PN Shell
and that rather than using insert_child to attach the widget to the parent's
.IN "insert_child procedure"
children list just attaches the shell to the parent's pop-ups list directly.
.LP
To use a spring-loaded pop-up, 
the pop-up shell must be created at application
start-up so that the translation manager can find the shell by name.
Otherwise, 
the pop-up shell can be created ``on-the-fly'' when the pop-up is actually 
needed.
This delayed creation of the shell is particularly useful when you pop up 
an unspecified number of pop-ups. 
You can look to see if an appropriate unused shell (that is, not
currently popped up) exists and create a new shell if needed.
.NH 2
Creating Pop-up Children
.XS
\*(SN Creating Pop-up Children
.XE
.LP
Once a pop-up shell is created, 
the single child of the pop-up shell can be created.
The two styles for this are: 
.IP \(bu 5
Static 
.IP \(bu 5
Dynamic
.LP
At application start up, 
an application can create the child of the pop-up shell.
This is appropriate for pop-up children that are composed of a fixed set 
of widgets, and the application can change the state of the subparts of
the pop-up child as the application state changes.
For example, if an application creates a static menu,
it can call 
.PN XtSetSensitive 
(or, in general, 
.PN XtSetValues ) 
on any of the buttons that make up the menu.  
Creating the pop-up child early means that pop-up time is minimized, 
especially if the application calls 
.PN XtRealizeWidget 
on the pop-up shell at startup time.
When the menu is needed, 
all the widgets that make up the menu already exist and need only be mapped. 
The menu should pop up as quickly as the X server can respond.
.LP
Alternatively, 
an application can postpone the creation of the child until it is needed.
This minimizes application startup time and allows the pop-up child to
reconfigure itself each time it is popped up.
In this case, 
the pop-up child creation routine should ``poll'' the application 
to find out if it should change the sensitivity of any of its subparts.
.LP
Pop-up child creation does not map the pop-up, 
even if you create the child and call 
.PN XtRealizeWidget
on the pop-up shell.
All pop-up shells automatically perform an 
.PN XtManageChild 
on their child within their insert_child procedure.  
.IN "insert_child procedure"
There is no need for the creator of a pop-up child to call 
.PN XtManageChild .
.LP
All shells have pop-up and pop-down callbacks.
These provide the opportunity either to make last-minute changes to a
pop-up child before it is popped up or to change it after it is popped down.
Programmers should be aware that excessive use of pop-up callbacks can make 
popping up occur more slowly.
.NH 2
Mapping a Pop-up Widget
.XS
\*(SN Mapping a Pop-up Widget
.XE
.LP
Pop-ups can be popped up through several mechanisms: 
.IP \(bu 5
A call to 
.PN XtPopup .
.IP \(bu 5
One of the supplied callback procedures (for example,
.PN XtCallbackNone ,
.PN XtCallbackNonexclusive , 
or 
.PN XtCallbackExclusive ).
.IP \(bu 5
The standard translation action 
.PN MenuPopup .
.LP
Some of these routines take an argument of type
.PN XtGrabKind ,
which is defined as:
.LP
.Ds 0
typedef enum {XtGrabNone, XtGrabNonexclusive, XtGrabExclusive} XtGrabKind;
.De
.sp
.LP
To map a pop-up from within an application, use 
.PN XtPopup .
.IN "XtPopup" "" "@DEF@"
.FD 0
void XtPopup(\fIpopup_shell\fP, \fIgrab_kind\fP)
.br
      Widget \fIpopup_shell\fP;
.br
      XtGrabKind \fIgrab_kind\fP;
.FN
.IP \fIpopup_shell\fP 1i
Specifies the widget shell to pop up.
.IP \fIgrab_kind\fP 1i
Specifies the way in which user events should be constrained.
.LP
.PN XtPopup 
performs the following actions:
.IP \(bu 5
Calls 
.PN XtCheckSubclass
.\".PN XtCheckSubclass(popup_shell, popupShellWidgetClass) 
to ensure popup_shell is a subclass of 
.PN Shell .
.IP \(bu 5
Generates an error if the shell's popped_up field is already TRUE.
.IP \(bu 5
Calls the callback procedures on the shell's popup_callback list.
.IP \(bu 5
Sets the shell popped_up field to TRUE,
the shell spring_loaded field to FALSE,
and the shell grab_kind field from grab_kind.
.IP \(bu 5
If the shell's create_popup_child field is non-NULL, 
.PN XtPopup 
calls it with popup_shell as the parameter.
.IP \(bu 5
If grab_kind is either 
.PN XtGrabNonexclusive 
or 
.PN XtGrabExclusive , 
.PN XtPopup 
calls:
.LP
.Ds
XtAddGrab(popup_shell, (grab_kind == XtGrabExclusive), FALSE)
.De
.IP \(bu 5
Calls 
.PN XtRealizeWidget (popup_shell)
.IP \(bu 5
Calls 
.PN XMapWindow (popup_shell)
.sp
.LP
To map a pop-up from a callback list,
you can use the
.PN XtCallbackNone ,
.PN XtCallbackNonexclusive ,
or
.PN XtCallbackExclusive
convenience routines.
.IN "XtCallbackNone" "" "@DEF@"
.FD 0
void XtCallbackNone(\fIw\fP, \fIclient_data\fP, \fIcall_data\fP)
.br
      Widget \fIw\fP;
.br
      XtClosure \fIclient_data\fP;
.br
      caddr_t \fIcall_data\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget executing the callback.
.IP \fIclient_data\fP 1i
Specifies the pop-up shell to pop up.
.IP \fIcall_data\fP 1i
Specifies the callback data.
This parameter is not used by this procedure.
.sp
.LP
.IN "XtCallbackNonexclusive" "" "@DEF@"
.FD 0
void XtCallbackNonexclusive(\fIw\fP, \fIclient_data\fP, \fIcall_data\fP)
.br
      Widget \fIw\fP;
.br
      XtClosure \fIclient_data\fP;
.br
      caddr_t \fIcall_data\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget executing the callback.
.IP \fIclient_data\fP 1i
Specifies the pop-up shell to pop up.
.IP \fIcall_data\fP 1i
Specifies the callback data.
This parameter is not used by this procedure.
.sp
.LP
.IN "XtCallbackExclusive" "" "@DEF@"
.FD 0
void XtCallbackExclusive(\fIw\fP, \fIclient_data\fP, \fIcall_data\fP)
.br
      Widget \fIw\fP;
.br
      XtClosure \fIclient_data\fP;
.br
      caddr_t \fIcall_data\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget executing the callback.
.IP \fIclient_data\fP 1i
Specifies the pop-up shell to pop up.
.IP \fIcall_data\fP 1i
Specifies the callback data.
This parameter is not used by this procedure.
.LP
Each of these routines calls 
.PN XtPopup 
with the shell specified by the client data parameter 
and grab_kind set as the name specifies.
.PN XtCallbackNone 
specifies 
.PN XtGrabNone , 
and so on.
Each then sets the widget that executed the callback list to be insensitive.
.LP
The use of these routines in callbacks is not required.
In particular,
callbacks that create pop-up shells dynamically or that must do more than
desensitizing the button will have custom code.
.sp
.LP
To pop up a menu when a pointer button is pressed or when the pointer
is moved into some window, use
.PN MenuPopup .  
From a translation writer's point of view,
the definition for this translation action is: 
.IN "MenuPopup" "" "@DEF@"
.FD 0
void MenuPopup(\fIshell_name\fP)
.br
      String \fIshell_name\fP;
.FN
.IP \fIshell_name\fP 1i
Specifies the name of the widget shell to pop up.
.LP
.PN MenuPopup 
is known to the translation manager, 
which must perform special actions for spring-loaded pop-ups.
Calls to 
.PN MenuPopup 
in a translation specification are mapped into calls to a
non-exported action procedure
and the translation manager fills in parameters
based upon the event specified on the left-hand side of a translation.
.LP
If 
.PN MenuPopup 
is invoked upon 
.PN ButtonPress 
(possibly with modifiers), 
the translation manager pops up the shell with grab_kind
.PN XtExclusive 
and spring_loaded TRUE.
If 
.PN MenuPopup 
is invoked upon 
.PN EnterWindow
(possibly with modifiers), 
the translation manager pops up the shell with grab_kind
.PN XtNonexclusive 
and spring_loaded FALSE.
Otherwise, the translation manager generates an error.
When the widget is popped up,
the following actions are performed:
.IP \(bu 5
Calls 
.PN XtCheckSubclass
.\".PN XtCheckSubclass(popup_shell, popupShellWidgetClass) 
to ensure popup_shell is a subclass of 
.PN Shell .
.IP \(bu 5
Generates an error if the shell's popped_up field is already TRUE.
.IP \(bu 5
Calls the callback procedures on the shell's popup_callback list.
.IP \(bu 5
Sets the shell popped_up field to TRUE
and the shell grab_kind and spring_loaded fields appropriately.
.IP \(bu 5
If the shell's create_popup_child field is non-NULL, 
it is called with popup_shell as the parameter.
.IP \(bu 5
.PN MenuPopup
then calls:
.LP
.Ds
XtAddGrab(popup_shell, (grab_kind == XtGrabExclusive), spring_loaded)
.De
.IP \(bu 5
Calls 
.PN XtRealizeWidget (popup_shell)
.IP \(bu 5
Calls 
.PN XMapWindow (popup_shell)
.LP
Note that these actions are the same as those for
.PN XtPopup .
.LP
.PN MenuPopup 
tries to find the shell by looking up the widget tree starting at
the parent of the widget in which it is invoked.
If it finds a shell with the specified name in the pop-up children of 
that parent, it pops up the shell with the appropriate parameters.
Otherwise, it moves up the parent chain as needed.
If 
.PN MenuPopup 
gets to the application widget and cannot find a matching shell, 
it generates an error.
.NH 2
Unmapping a Pop-up Widget
.XS
\*(SN Unmapping a Pop-up Widget
.XE
.LP
Pop-ups can be popped down through several mechanism: 
.IP \(bu 5
A call to
.PN XtPopdown . 
.IP \(bu 5
The supplied callback procedure 
.PN XtCallbackPopdown .
.IP \(bu 5
The standard translation action 
.PN MenuPopdown .
.sp
.LP
To unmap a pop-up from within an application, use
.PN XtPopdown .
.IN "XtPopdown" "" "@DEF@"
.FD 0
void XtPopdown(\fIpopup_shell\fP)
.br
      Widget \fIpopup_shell\fP;
.FN
.IP \fIpopup_shell\fP 1i
Specifies the widget shell to pop down.
.LP
.PN XtPopdown 
performs the following:
.IP \(bu 5
Calls 
.PN XtCheckSubclass
.\".PN XtCheckSubclass(popup_shell, popupShellWidgetClass) 
to ensure popup_shell is a subclass of 
.PN Shell .
.IP \(bu 5
Checks that popup_shell is currently popped_up.
If not, it generates an error.
.IP \(bu 5
Unmaps popup_shell's window.
.IP \(bu 5
If popup_shell's grab_kind is either 
.PN XtGrabNonexclusive 
or 
.PN XtGrabExclusive ,
calls 
.PN XtRemoveGrab .
.\".PN XtRemoveGrab(popup_shell)
.IP \(bu 5
Sets popup_shell's popped_up field to FALSE.
.IP \(bu 5
Calls the callback procedures on the shell's popdown_callback list.
.sp
.LP
Pop-ups that have been popped up with one of the callback routines (that is,
.PN XtCallbackNone , 
.PN XtCallbackNonexclusive , 
.PN XtCallbackExclusive )
can be popped down by the callback routine 
.PN XtCallbackPopdown . 
.IN "XtCallbackPopdown" "" "@DEF@"
.FD 0
void XtCallbackPopdown(\fIw\fP, \fIclient_data\fP, \fIcall_data\fP)
.br
      Widget \fIw\fP;
.br
      XtClosure \fIclient_data\fP;
.br
      caddr_t \fIcall_data\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget executing the callback.
.IP \fIclient_data\fP 1i
Specifies the pop-up shell to pop down
and the widget used to originally pop it up.
.IP \fIcall_data\fP 1i
Specifies the callback data.
This parameter is not used by this procedure.
.LP
.PN XtCallbackPopdown 
casts the client data parameter to an 
.PN XtPopdownID 
pointer:
.LP
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	Widget shell_widget;
	Widget enable_widget;
} XtPopdownIDRec, *XtPopdownID;
.De
.PN XtCallbackPopdown 
calls 
.PN XtPopdown 
with the specified shell_widget.
It then calls 
.PN XtSetSensitive
to resensitize the enable_widget.
.sp
.LP
To pop down a spring-loaded menu when a pointer button is released or when the
pointer is moved into some window, use 
.PN MenuPopdown . 
From a translation writer's point of view,
the definition for this translation action is:
.IN "MenuPopdown" "" "@DEF@"
.FD 0
void MenuPopdown()
.FN
.LP
.PN MenuPopdown 
calls 
.PN XtPopdown 
with the widget for which the translation is specified.
.bp
\&
.sp 1
.ce 3
\s+1\fBChapter 8\fP\s-1

\s+1\fBShell Widgets\fP\s-1
.sp 2
.nr H1 8
.nr H2 0
.nr H3 0
.nr H4 0
.nr H5 0
.LP
.XS
Chapter 8 \- Shell Widgets
.XE
.LP
Shell widgets hold an application's top-level widgets to allow them to
communicate with the window manager.
Shells have been designed to be as nearly invisible as possible. 
That is, while clients have to create them, 
they should never have to worry about their sizes.
.LP
If a shell widget is resized from the outside, typically by a window manager,
the shell widget will resize its child widget automatically.
Similarly, if the shell's child widget wants to change size, 
it can make a geometry request to the shell,
and the shell will negotiate the size change with the outer environment.
Clients should never attempt to change the size of their shells directly.
.LP
There are three classes of public shells:
.TS
lw(1.5i) lw(4.25i).
T{
.PN OverrideShell
T}	T{
This class is used for shell windows that completely bypass the window manager.
Pop-up menu shells will typically be of this class or a subclass.
T}
.sp
T{
.PN TransientShell
T}	T{
This class is used for shell windows that can be manipulated 
by the window manager but are not allowed to be separately iconified.
They get iconified by the window manager if the
main application shell is iconified.
Dialog boxes that make no sense without their associated application 
will typically be in a shell of this class or a subclass.
T}
.sp
T{
.PN TopLevelShell
T}	T{
This class is used for normal top level windows.
Any additional top-level widgets an application needs will typically be 
in a shell of this class or a subclass.
T}
.TE
.NH 2
Shell Widget Definitions
.XS
\*(SN Shell Widget Definitions
.XE
.LP
Widgets negotiate their size and position with their parent widget, the
widget that directly contains them.  Widgets at the top level of the
hierarchy do not have parent widgets; instead they must deal with the outside
world.  To provide for this, top level widgets are encapsulated in special
widgets called ``Shells''.
.LP
Shell widgets are subclasses of the Composite widget.
They encapsulate other widgets and can allow a widget to ``jump out'' of the
geometry clipping imposed by the parent/child window relationship.
If desired, they provide a layer of communication with the window manager.
.LP
There are six different types of shell:
.TS
lw(1.5i) lw(4.5i).
T{
.PN Shell
T}	T{
This is the base class for shell widgets and provides
fields needed for all types of shells.
.PN Shell
is a direct subclass of 
.PN Composite .
T}
.sp 6p
T{
.PN OverrideShell
T}	T{
This class is used for shell windows that completely
bypass the window manager.
It is a subclass of 
.PN Shell .
T}
.sp 6p
T{
.PN WMShell
T}	T{
Contains fields needed by the common window manager protocol. 
It is a subclass of 
.PN Shell .
T}
.sp 6p
T{
.PN VendorShell
T}	T{
Contains fields used by vendor-specific window managers.  
It is a subclass of 
.PN WMShell .
T}
.sp 6p
T{
.PN TransientShell
T}	T{
This class is used for shell windows that can be
manipulated by the window manager but are not allowed
to be iconified.
It is a subclass of 
.PN VendorShell .
T}
.sp 6p
T{
.PN TopLevelShell
T}	T{
This class is used for normal top level windows.  
It is a subclass of 
.PN VendorShell .
T}
.TE
.LP
The classes 
.PN Shell , 
.PN WMShell , 
and 
.PN VendorShell 
are internal and should not be instantiated.
Only 
.PN OverrrideShell , 
.PN TransientShell , 
and
.PN TopLevelShell . 
are for public use.
.NH 3
ShellClassPart Definitions
.XS
\*(SN ShellClassPart Definitions
.XE
.LP
No shell widget classes have any additional fields:
.LP
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct { int empty; } ShellClassPart, OverrideShellClassPart, 
	WMShellClassPart, VendorShellClassPart, TransientShellClassPart,
	TopLevelShellClassPart;
.De
.LP
Shell widget classes have the (empty) shell fields immediately following the
composite fields:
.LP
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct _ShellClassRec {
	CoreClassPart core_class;
	CompositeClassPart composite_class;
	ShellClassPart shell_class;
} ShellClassRec;

typedef struct _OverrideShellClassRec {
	CoreClassPart core_class;
	CompositeClassPart composite_class;
	ShellClassPart shell_class;
	OverrideShellClassPart override_shell_class;
} OverrideShellClassRec;
.De
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct _WMShellClassRec {
	CoreClassPart core_class;
	CompositeClassPart composite_class;
	ShellClassPart shell_class;
	WMShellClassPart wm_shell_class;
} WMShellClassRec;
.De
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct _VendorShellClassRec {
	CoreClassPart core_class;
	CompositeClassPart composite_class;
	ShellClassPart shell_class;
	WMShellClassPart wm_shell_class;
	VendorShellClassPart vendor_shell_class;
} VendorShellClassRec;
.De
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct _TransientShellClassRec {
	CoreClassPart core_class;
	CompositeClassPart composite_class;
	ShellClassPart shell_class;
	WMShellClassPart wm_shell_class;
	VendorShellClassPart vendor_shell_class;
	TransientShellClassPart transient_shell_class;
} TransientShellClassRec;
.De
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct _TopLevelShellClassRec {
	CoreClassPart core_class;
	CompositeClassPart composite_class;
	ShellClassPart shell_class;
	WMShellClassPart wm_shell_class;
	VendorShellClassPart vendor_shell_class;
	TopLevelShellClassPart top_level_shell_class;
} TopLevelShellClassRec;
.De
.LP
The predefined class records and pointers for shells are:
.LP
.Ds 0
.TA .5i 3i
.ta .5i 3i
extern ShellClassRec shellClassRec;
extern OverrideShellClassRec overrideShellClassRec;
extern WMShellClassRec wmShellClassRec;
extern VendorShellClassRec vendorShellClassRec;
extern TransientShellClassRec transientShellClassRec;
extern TopLevelShellClassRec topLevelShellClassRec;

extern WidgetClass shellWidgetClass;
extern WidgetClass overrideShellWidgetClass;
extern WidgetClass wmShellWidgetClass;
extern WidgetClass vendorShellWidgetClass;
extern WidgetClass transientShellWidgetClass;
extern WidgetClass topLevelShellWidgetClass;
.De
.LP
The following opaque types and the opaque variables are defined
for generic operations on widgets that are a subclass of
.PN ShellWidgetClass .
.TS
lw(2.75i) lw(2.75i).
_
.sp 6p
Types	Variables
.sp 6p
_
.sp 6p
T{
.PN ShellWidget 
T}	T{
.PN shellWidgetClass 
T}
T{
.PN OverrideShellWidget
T}	T{
.PN overrideShellWidgetClass
T}
T{
.PN WMShellWidget
T}	T{
.PN wmShellWidgetClass
T}
T{
.PN VendorShellWidget
T}	T{
.PN vendorShellWidgetClass
T}
T{
.PN TransientShellWidget
T}	T{
.PN transientShellWidgetClass
T}
T{
.PN TopLevelShellWidget
T}	T{
.PN topLevelShellWidgetClass
T}
.PN ShellWidgetClass
.PN OverrideShellWidgetClass
.PN WMShellWidgetClass 
.PN VendorShellWidgetClass
.PN TransientShellWidgetClass
.PN TopLevelShellWidgetClass
.sp 6p
_
.TE
.NH 3
ShellPart Definition
.XS
\*(SN ShellPart Definition
.XE
.LP
The various shells have the following additional fields defined in
their widget records:
.LP
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	String geometry;
	XtCreatePopupChildProc create_popup_child_proc;
	XtGrabKind grab_kind;
	Boolean spring_loaded;
	Boolean popped_up;
	Boolean allow_shell_resize;
	Boolean client_specified;
	Boolean save_under;
	Boolean override_redirect;
	XtCallbackList popup_callback;
	XtCallbackList popdown_callback;
} ShellPart;
.De
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct { int empty; } OverrideShellPart;
.De
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	String title;
	int wm_timeout;
	Boolean wait_for_wm;
	Boolean transient;
	XSizeHints size_hints;
	XWMHints wm_hints;
} WMShellPart;

typedef struct {
	int vendor_specific;
} VendorShellPart;
.De
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct { int empty; } TransientShellPart;

typedef struct {
	String icon_name;
	Boolean iconic;
} TopLevelShellPart;
.De
The full definitions of the various shell widgets have shell fields
following composite fields:
.LP
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	CorePart core;
	CompositePart composite;
	ShellPart shell;
} ShellRec, *ShellWidget;

typedef struct {
	CorePart core;
	CompositePart composite;
	ShellPart shell;
	OverrideShellPart override;
} OverrideShellRec, *OverrideShellWidget;
.De
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	CorePart core;
	CompositePart composite;
	ShellPart shell;
	WMShellPart wm;
} WMShellRec, *WMShellWidget;

typedef struct {
	CorePart core;
	CompositePart composite;
	ShellPart shell;
	WMShellPart wm;
	VendorShellPart vendor;
} VendorShellRec, *VendorShellWidget;
.De
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	CorePart core;
	CompositePart composite;
	ShellPart shell;
	WMShellPart wm;
	VendorShellPart vendor;
	TransientShellPart transient;	
} TransientShellRec, *TransientShellWidget;
.De
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	CorePart core;
	CompositePart composite;
	ShellPart shell;
	WMShellPart wm;
	VendorShellPart vendor;
	TopLevelShellPart topLevel;
} TopLevelShellRec, *TopLevelShellWidget;
.De
.NH 3
ShellPart Default Values
.XS
\*(SN ShellPart Default Values
.XE
.LP
The default values for all shell fields (filled in by the Shell
resource lists and the Shell initialize procedures) are:
.TS
l l.
_
.sp 6p
Field	Default Value
.sp 6p
_
.sp 6p
geometry	NULL
create_popup_child_proc	NULL
grab_kind	(internal)
spring_loaded	(internal)
popped_up	(internal)
allow_shell_resize	FALSE
client_specified	(internal)
save_under	FALSE
T{
override_redirect
T}	T{
TRUE for 
.PN OverrideShells , 
FALSE otherwise
T}
popup_callback	NULL
popdown_callback	NULL
.sp 6p
title	Icon name, if specified, otherwise the application's name
wm_timeout	5 seconds
wait_for_wm	TRUE
T{
transient
T}	T{
TRUE for 
.PN TransientShells ,
FALSE otherwise
T}
.sp 6p
_
.TE
.LP
The geometry resource can be used to specify size and position.
This is usually done only from a command line or a defaults file.
The create_popup_child_proc is called by the
.PN XtPopup
procedure and usually is NULL.
The allow_shell_resize field controls whether or not the widget contained 
by the shell is allowed to try to resize itself.
If it is FALSE, any geometry requests will always return
.PN XtGeometryNo .
Setting save_under instructs the server to attempt 
to save the contents of windows obscured by the shell when it is mapped 
and to restore it automatically later.
It is useful for pop-up menus.
Setting overrideRedirect determines
whether or not the shell window will be visible to the window manager.
If TRUE, 
the window will be immediately mapped without the manager's intervention.
The popup and popdown callbacks are called during
.PN XtPopup
and
.PN XtPopdown .
The title is a string to be displayed by the window manager.
The wm_timeout resource limits the amount of time a shell will wait for
confirmation of a geometry request to the window manager.
If none comes back within that time,
the shell decides the window manager is broken 
and sets wait_for_wm to be FALSE (Later events may reset this value).
The wait_for_wm resource sets the initial state for this flag.
When the flag is FALSE, 
the shell does not wait for a response. 
Rather, it  relies upon asynchronous notification.
All other resources are for fields in the window manager hints
and the window manager size hints. 
For further information,
see \fI\*(xL\fP.
.LP
.PN Transient 
and 
.PN TopLevel 
shells all have the following extra resources:
.LP
.TS
l l.
_
.sp 6p
Resource	Default Value
.sp 6p
_
.sp 6p
minWidth	none
minHeight	none
maxWidth	none
maxHeight	none
widthInc	none
heightInc	none
minAspectX	none
minAspectY	none
maxAspectX	none
maxAspectY	none
input	FALSE
initialState	Normal
iconPixmap	none
iconWindow	none
iconX	none
iconY	none
IconMask	none
windowGroup	none
.sp 6p
_
.TE
.LP
.PN TopLevel 
shells have the the following additional resources:
.TS
l l.
_
.sp 6p
Field   Default Value
.sp 6p
_
.sp 6p
icon_name	Shell widget's name
iconic	FALSE
.sp 6p
_
.TE
.LP
The icon_name is the string to display in the shell's icon,  
and iconic is an alternative way to set the initialState resource 
to indicate that a shell should be initially displayed as an icon.
.bp
\&
.sp 1
.ce 3
\s+1\fBChapter 9\fP\s-1

\s+1\fBUtility Functions\fP\s-1
.sp 2
.nr H1 9
.nr H2 0
.nr H3 0
.nr H4 0
.nr H5 0
.LP
.XS
Chapter 9 \- Utility Functions
.XE
The \*(tk provides a number of utility functions for:
.IP \(bu 5
Memory management
.IP \(bu 5
Sharing graphics contexts
.IP \(bu 5
Exposure regions
.IP \(bu 5
Error handling
.NH 2
Memory Management
.XS
\*(SN Memory Management
.XE
.LP
The \*(tk memory management routines provide uniform checking for
null pointers, and error reporting on memory allocation errors.
These routines are completely compatible with the standard C language runtime
routines 
.PN malloc , 
.PN calloc , 
.PN realloc , 
and 
.PN free 
with the added functionality:
.IP \(bu 5
.PN XtMalloc ,
.PN XtNew ,
.PN XtCalloc ,
and 
.PN XtRealloc
give an error if there is not enough memory.
.IP \(bu 5
.PN XtFree
simply returns if passed a NULL pointer.
.IP \(bu 5
.PN XtRealloc
simply allocates new storage if passed a NULL pointer.
.LP
See the C library documentation on 
.PN malloc , 
.PN calloc , 
.PN realloc ,
and 
.PN free
for more information.
.sp
.LP
To allocate storage, use
.PN XtMalloc .
.IN "XtMalloc" "" "@DEF@"
.FD 0
char *XtMalloc(\fIsize\fP);
.br
      Cardinal \fIsize\fP;
.FN
.IP \fIsize\fP 1i
Specifies the number of bytes desired.
.LP
.PN XtMalloc
returns a pointer to a block of storage of at least the specified size bytes.
If there is insufficient memory to allocate the new block,
.PN XtMalloc
calls
.PN XtError .
.sp
.LP
To allocate storage for a new instance of a data type, use
.PN XtNew .
.IN "XtNew" "" "@DEF@"
.FD 0
\fItype\fP *XtNew(\fItype\fP);
.br
      \fItype\fP;
.FN
.IP \fItype\fP 1i
Specifies a previously declared data type
.LP
.PN XtNew
returns a pointer to the allocated storage.
If there is insufficient memory to allocate the new block,
.PN XtNew
calls
.PN XtError .
.PN XtNew
is an abbreviation for:
.LP
.Ds 0
.TA .5i
.ta .5i
	((type *) XtMalloc((unsigned) sizeof(type))
.De
.sp
.LP
To allocate and initialize an array, use
.PN XtCalloc .
.IN "XtCalloc" "" "@DEF@"
.FD 0
char *XtCalloc(\fInum\fP, \fIsize\fP);
.br
      Cardinal \fInum\fP;
.br
      Cardinal \fIsize\fP;
.FN
.IP \fInum\fP 1i
Specifies the number of array elements to allocate.
.IP \fIsize\fP 1i
Specifies the size of an array element in bytes.
.LP
.PN XtCalloc
allocates space for the specified number of array elements of the specified
size bytes and initializes the space to zero.
If there is insufficient memory to allocate the new block,
.PN XtCalloc
calls
.PN XtError .
.sp
.LP
To change the size of an allocated block of storage, use
.PN XtRealloc .
.IN "XtRealloc" "" "@DEF@"
.FD 0
char *XtRealloc(\fIptr\fP, \fInum\fP);
.br
      char *\fIptr\fP;
.br
      Cardinal \fInum\fP;
.FN
.IP \fIptr\fP 1i
Specifies a pointer to old storage.
.IP \fInum\fP 1i
Specifies number of bytes desired in new storage.
.LP
.PN XtRealloc
changes the size of a block of storage (possibly moving it).
Then, it copies the old contents (or as much as will fit) into the new block
and frees the old block.
If there is insufficient memory to allocate the new block,
.PN XtRealloc
calls
.PN XtError .
If the specified ptr argument is NULL,
.PN XtRealloc
allocates the new storage without copying the ``old'' contents.
That is, it simply calls
.PN XtMalloc .
.sp
.LP
To free an allocated block of storage, use
.PN XtFree .
.IN "XtFree" "" "@DEF@"
.FD 0
void XtFree(\fIptr\fP);
.br
      char *\fIptr\fP;
.FN
.IP \fIptr\fP 1i
Specifies a pointer to the block of storage that is to be freed.
.LP
.PN XtFree
returns storage and allows it to be reused.
If the specified ptr argument is NULL,
.PN XtFree
returns immediately.
.NH 2
Sharing Graphics Contexts
.XS
\*(SN Sharing Graphics Contexts
.XE
.LP
The \*(tk provides a mechanism whereby cooperating clients can share
Graphics Contexts, thereby, reducing both the number of Graphics Contexts 
created and the total number of server calls in any given application. 
The mechanism implemented is a simple caching scheme and all Graphics Contexts
obtained by means of this mechanism must be treated as read-only. 
If a changeable Graphics Context is needed, 
the
.PN XCreateGC 
Xlib function should be used instead. 
.LP
To obtain shared GCs, use 
.PN XtGetGC .
.IN "XtGetGC" "" "@DEF@"
.FD 0
GC XtGetGC(\fIw\fP, \fIvalue_mask\fP, \fIvalues\fP)
.br
      Widget \fIw\fP;
.br
      XtGCMask \fIvalue_mask\fP;
.br
      XGCValues *\fIvalues\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.IP \fIvalue_mask\fP 1i
Specifies which fields of the values are specified. (See 
.PN XCreateGC .)
.IP \fIvalues\fP 1i
Specifies the actual values for this GC. (See 
.PN XCreateGC .)
.LP
.PN XtGetGC 
returns a Graphics Context. 
The parameters to this function are the same as those for 
.PN XCreateGC , 
except that a widget is passed instead of a Display.
.LP
.PN XtGetGC
shares only GCs in which all values in the GC returned by
.PN XCreateGC
are the same. 
In particular, it does not use the value_mask provided to
determine which fields of the GC a widget considers relevant.
The value_mask is used only to tell the server which fields should be 
filled in with widget data and which it should fill in with default values.
.sp
.LP
To deallocate a graphics context when it is no longer needed, use
.PN XtDestroyGC .
.IN "XtDestroyGC" "" "@DEF@"
.FD 0
void XtDestroyGC(\fIgc\fP)
.br
      GC \fIgc\fP;
.FN
.IP \fIgc\fP 1i
Specifies the gc to be deallocated.
.LP
References to sharable GCs are counted and a free request is generated to the
server when the last user of a GC destroys it.
.NH 2
Merging Exposure Events into a Region
.XS
\*(SN Merging Exposure Events into a Region
.XE
.LP
The \*(tk provides the
.PN XtAddExposureToRegion
utility function that merges
.PN Expose
and
.PN GraphicsExpose
events into a region that clients can process at once,
rather than processing individual rectangles.
(For further information about regions,
see \fI\*(xL\fP.)
.sp
.LP
To merge
.PN Expose
and
.PN GraphicsExpose
events into a region, use
.PN XtAddExposureToRegion .
.IN "XtAddExposureToRegion" "" "@DEF@"
.FD 0
void XtAddExposureToRegion(\fIevent\fP, \fIregion\fP)
.br
     XEvent *\fIevent\fP;
.br
     Region \fIregion\fP;
.FN
.IP \fIevent\fP 1i
Specifies a pointer to the
.PN Expose
or
.PN GraphicsExpose
event.
.IP \fIregion\fP 1i
Specifies the region object (as defined in
.PN X11/Xutil.h ).
.LP
.PN XtAddExposureToRegion
computes the union of the rectangle defined by the exposure
event and the specified region.
Then, it stores the results back in region.
If the event argument is not an
.PN Expose
or 
.PN GraphicsExpose
event,
.PN XtAddExposureToRegion
returns without an error and without modifying region.
.LP
This function is used by the exposure compression mechanism (see
``Exposure Compression'').
.NH 2
Translating Strings to Widget Instances
.XS
\*(SN Translating Strings to Widget Instances
.XE
.LP
To translate a widget name to widget instance, use
.PN XtNameToWidget .
.IN "XtNameToWidget" "" "@DEF@"
.FD 0
Widget XtNameToWidget(\fIreference\fP, \fInames\fP);
.br
      Widget \fIreference\fP;
.br
      String \fInames\fP;
.FN
.IP \fIreference\fP 1i
Specifies the widget to start searching from.
.IP \fInames\fP 1i
Specifies the fully qualified name of the desired widget.
.LP
The names argument contains the name of a widget with respect to the reference
widget parameter.
The names argument can contain more than one widget name 
for widgets that are not direct children of the reference widget.
A dot (``.'') separates each component name.
.LP
.PN XtNameToWidget
looks for a widget whose name is the first component in the names parameter
and who is a child (pop-up or normal) of the reference widget.
It then uses that widget as the new reference and repeats the search
after deleting the first component from the specified names argument.
.PN XtNameToWidget
returns NULL if it cannot find the specified widget.
.LP
If more than one child of the reference widget matches the name,
.PN XtNameToWidget
may return any of the children.
The \*(tk does not require that all children of a widget have unique names.
If the names argument contains more than one component
and if more than one child matches the first component,
.PN XtNameToWidget
may return NULL if the single branch that it follows does not
contained the named widget.
That is,
.PN XtNameToWidget
does not back up and follow other matching branches of the widget tree.
.NH 2
Translating Widget Coordinates
.XS
\*(SN Translating Widget Coordinates
.XE
.LP
To translate an x-y coordinate pair from widget coordinates to root
coordinates, use
.PN XtTranslateCoords .
.IN "XtTranslateCoords" "" "@DEF@"
.FD 0
void XtTranslateCoords(\fIw\fP, \fIx\fP, \fIy\fP, \fIrootx_return\fP, \
\fIrooty_return\fP)
.br
      Widget \fIw\fP;
.br
      Position \fIx\fP, \fIy\fP;
.br
      Position *\fIrootx_return\fP, *\fIrooty_return\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.IP \fIx\fP 1i
.br
.ns
.IP \fIy\fP 1i
Specify the widget-relative coordinates.
.IP \fIrootx_return\fP 1i
.br
.ns
.IP \fIrooty_return\fP 1i
Returns the root-relative x and y coordinates.
.LP
While
.PN XtTranslateCoords
is similar to
.PN XTranslateCoordinates ,
it does not generate a server request because all the required
information already is in the widget's data structures. 
.NH 2 
Translating a Window to a Widget
.XS
\*(SN Translating a Window to a Widget
.XE
.LP
To translate a window and display pointer into a widget instance, use
.PN XtWindowToWidget .
.IN "XtWindowToWidget" "" "@DEF@"
.FD 0
Widget XtWindowToWidget(\fIdisplay\fP, \fIwindow\fP)
.br
      Display *\fIdisplay\fP;
.br
      Window \fIwindow\fP;
.FN
.IP \fIdisplay\fP 1i
Specifies the display on which the window is defined.
.br
.ns
.IP \fIwindow\fP 1i
Specify the window for which you want the widget.
.NH 2
Handling Errors
.XS
\*(SN Handling Errors
.XE
.LP
The \*(tk allows a client to register a procedure to be called 
whenever a fatal or non-fatal error occurs. 
This facility is intended for error reporting and logging 
but not for error correction or recovery. 
.LP
Error and warning handlers are of type 
.PN XtErrorHandler : 
.IN "XtErrorHandler" "" "@DEF@"
.FD 0
typedef void (*XtErrorHandler)();
.sp
void \fIErrorHandler\fP(\fImessage\fP)
.br
    String \fImessage\fP;
.FN
.LP
To register a procedure to be called on fatal error conditions, use
.PN XtSetErrorHandler .
.IN "XtSetErrorHandler" "" "@DEF@"
.FD 0
void XtSetErrorHandler(\fIhandler\fP)
.br
      XtErrorHandler \fIhandler\fP;
.FN
.IP \fIhandler\fP 1i
Specifies the new fatal error procedure.
Fatal error handlers should not return.
.LP
The default error handler provided by the \*(tk is
.PN _XtError .
On UNIX-based systems,
it prints the message to standard error and terminates the application.
.sp
.LP
To call the installed fatal error procedure, use
.PN XtError .
.IN "XtError" "" "@DEF@"
.FD 0
void XtError(\fImessage\fP)
.br
      String \fImessage\fP;
.FN
.IP \fImessage\fP 1i
Specifies the error message to report.
.sp
.LP
To register a procedure to be called on non-fatal error conditions, use
.PN XtSetWarningHandler .
.IN "XtSetWarningHandler" "" "@DEF@"
.FD 0
void XtSetWarningHandler(\fIhandler\fP)
.br
      XtErrorHandler \fIhandler\fP;
.FN
.IP \fIhandler\fP 1i
Specifies the new non-fatal error procedure.
Warning handlers usually return.
.LP
The default warning handler provided by the \*(tk is
.PN _XtWarning .
On UNIX-based systems,
it prints the message to standard error and returns to the caller.
.sp
.LP
To call the installed non-fatal error procedure, use
.PN XtWarning .
.IN "XtWarning" "" "@DEF@"
.FD 0
void XtWarning(\fImessage\fP)
.br
      String \fImessage\fP;
.FN
.IP \fImessage\fP 1i
Specifies the non-fatal error message to report.
.bp
\&
.sp 1
.ce 3
\s+1\fBChapter 10\fP\s-1

\s+1\fBEvent Handling\fP\s-1
.sp 2
.nr H1 10
.nr H2 0
.nr H3 0
.nr H4 0
.nr H5 0
.LP
.XS
Chapter 10 \- Event Handling
.XE
While X allows the reading and processing of events anywhere in an application,
widgets in the \*(tk neither directly read events 
nor grab the server or pointer.
Widgets merely register procedures that are to be called 
when an event or class of events occurs in that widget.
.LP
A typical application consists of startup code followed by an event loop
(see 
.PN XtMainLoop ,
which reads events and dispatches them by calling
the procedures that widgets have registered.
.LP
The event manager is a collection of routines to:
.IP \(bu 5
Add or remove event sources other that X server events (in particular,
timer interrupts and file input).
.IP \(bu 5
Query the status of event sources.
.IP \(bu 5
Add or remove procedures to be called when an event occurs for a particular
widget.
.IP \(bu 5
Enable and
disable the dispatching of user-initiated events (keyboard and pointer events)
for a particular widget.
.IP \(bu 5
Constrain the dispatching of events to a cascade of ``pop-up'' widgets.
.IP \(bu 5
Focus keyboard events within a composite widget to a particular child.
.IP \(bu 5
Call the appropriate set of procedures currently registered when an event
is read.
.LP
Most widgets do not need to call any of the event manager routines explicitly.
The normal interface to X events is through the higher-level 
Translation Manager, 
which maps sequences of X events (with modifiers) into procedure calls.
Applications rarely use any of the event manager routines besides
.PN XtMainLoop .
.NH 2
Adding and Deleting Additional Event Sources
.XS
\*(SN Adding and Deleting Additional Event Sources
.XE
.LP
While most applications are driven only by X events, 
some need to incorporate other sources of input into the \*(tk event 
handling philosophy.
The event manager provides routines to integrate notification of timer events
and file data pending into this mechanism.
.LP
The next two functions provide input gathering from files.
The application registers the files with the \*(tk read routine.
When input is pending on one of the files, 
the registered callback procedures are invoked.
.NH 3
Adding and Removing Input Sources
.XS
\*(SN Adding and Removing Input Sources
.XE
.LP
To register a new file for input, use
.PN XtAddInput .
.IN "XtAddInput" "" "@DEF@"
.FD 0
XtInputId XtAddInput(\fIsource\fP, \fIcondition\fP, \fIproc\fP, \
\fIclient_data\fP)
.br
      int \fIsource\fP;
.br
      caddr_t \fIcondition\fP;
.br
      XtInputCallbackProc \fIproc\fP;
.br
      caddr_t \fIclient_data\fP;
.FN
.IP \fIsource\fP 1i
Specifies the source file descriptor on a UNIX-based system 
or other operating system dependent device specification.
.IP \fIcondition\fP 1i
Specifies the mask that indicates either a read, write, or exception condition
or some operating system dependent condition.
.IP \fIproc\fP 1i
Specifies the procedure that is called when input is available.
.IP \fIclient_data\fP 1i
Specifies the parameter to be passed to proc when input is available.
.LP
The 
.PN XtAddInput
function registers with the \*(tk read routine a new source of events, 
which is usually file input but can also be file output.
(The word ``file'' should be loosely interpreted to mean any sink 
or source of data.)
.PN XtAddInput
also specifies the conditions under which the source can generate events.
When input is pending on this source, 
the callback procedure is called.
.LP
Callback procedures that are called when there are file events are of 
type 
.PN XtInputCallbackProc :
.IN "XtInputCallbackProc" "" "@DEF@"
.FD 0
typedef void (*XtInputCallbackProc)();
.sp
void \fIInputCallbackProc\fP(\fIclient_data\fP, \fIsource\fP, \fIid\fP)
.br
	caddr_t \fIclient_data\fP;
.br
	int \fIsource\fP;
.br
	XtInputId \fIid\fP;
.FN
.IP \fIclient_data\fP 1i
Specifies the client data that was registered for this procedure in 
.PN XtAddInput .
.IP \fIsource\fP 1i
Specifies the source file descriptor generating the event.
.IP \fIid\fP 1i
Specifies the ID returned from the corresponding 
.PN XtAddInput 
call.
.sp
.LP
To discontinue a source of input, use 
.PN XtRemoveInput .
.IN "XtRemoveInput" "" "@DEF@"
.FD 0
void XtRemoveInput(\fIid\fP)
.br
      XtInputId *\fIid\fP;
.FN
.IP \fIid\fP 1i
Specifies the ID returned from the corresponding 
.PN XtAddInput 
call.
.LP
The 
.PN XtRemoveInput
function causes the \*(tk read routine to stop watching for input 
from the input source.
.NH 3
Adding and Removing Timeouts
.XS
\*(SN Adding and Removing Timeouts
.XE
.LP
The timeout facility notifies the application or the widget
through a callback procedure that a specified time interval has elapsed.  
Timeout values are uniquely identified by an interval ID.
.sp
.LP
To create a timeout value, use 
.PN XtAddTimeOut .
.IN "XtAddTimeOut" "" "@DEF@"
.FD 0
XtIntervalId XtAddTimeOut(\fIinterval\fP, \fIproc\fP, \fIclient_data\fP)
.br
      unsigned long \fIinterval\fP;
.br
      XtTimerCallbackProc \fIproc\fP;
.br
      caddr_t \fIclient_data\fP;
.FN
.IP \fIinterval\fP 1i
Specifies the time interval in milliseconds.
.IP \fIproc\fP 1i
Specifies the procedure to be called when time expires.
.IP \fIclient_data\fP 1i
Specifies the parameter to be passed to proc when it is called.
.LP
The 
.PN XtAddTimeOut
function creates a timeout and returns an identifier for it.
The timeout value is set to interval.
The callback procedure will be called when
the time interval elapses, after which the timeout is removed.
.LP
Callback procedures that are called when timeouts expire are of 
type 
.PN XtTimerCallbackProc :
.IN "XtTimerCallbackProc" "" "@DEF@"
.FD 0
typedef void (*XtTimerCallbackProc)();
.sp
void \fITimerCallbackProc\fP(\fIclient_data\fP, \fIid\fP)
.br
	caddr_t \fIclient_data\fP;
.br
	XtIntervalId *\fIid\fP;
.FN
.IP \fIclient_data\fP 1i
Specifies the client data that was registered for this procedure in 
.PN XtAddTimeOut .
.IP \fIid\fP 1i
Specifies the ID returned from the corresponding 
.PN XtAddTimeOut
call.
.sp
.LP
To clear a timeout value, use 
.PN XtRemoveTimeOut .
.IN "XtRemoveTimeOut" "" "@DEF@"
.FD 0
void XtRemoveTimeOut(\fItimer\fP)
.br
      XtIntervalId \fItimer\fP;
.FN
.IP \fItimer\fP 1i
Specifies the unique identifier for the timeout request to be destroyed.
.LP
.PN XtRemoveTimeOut 
removes the timeout.
Note that timeouts are automatically removed once they trigger.
.NH 2
Filtering X Events
.XS
\*(SN Filtering X Events
.XE
.LP
The event manager provides two filters that can be applied to X user events.
These filters screen out events that are redundant or that are temporarily
unwanted.
.NH 3
Pointer Motion Compression
.XS
\*(SN Pointer Motion Compression
.XE
.LP
Widgets can have a hard time keeping up with pointer motion events.  Further,
they usually do not actually care about every motion event.  To throw out
redundant motion events, the widget class field compress_motion should be
TRUE. 
.IN "compress_motion"
When a request for an event would return a motion event, 
the Intrinsics check if there are any other motion events immediately 
following the current one, and, if so, skip all but the last of them.
.NH 3
Enter/Leave Compression
.XS
\*(SN Enter/Leave Compression
.XE
.LP
To throw out pairs of enter and leave events that have no intervening events, 
the widget class field compress_enter/leave should be TRUE. 
.IN "compress_enterleave"
These enter and leave events will never be delivered to the client.
.NH 3
Exposure Compression
.XS
\*(SN Exposure Compression
.XE
.LP
.IN "compress_expose field"
Many widgets will prefer to process a series of exposure events as a
single expose region rather than as individual rectangles.  Widgets
with complex displays might use the expose region as a clip list
in a graphics context, while widgets with simple displays might
ignore the region entirely and redisplay their whole window or
might get the bounding box from the region and redisplay only that
rectangle.
.LP
In either case, these widgets do not care about getting partial expose events.
If the compress_exposure field in the widget class structure is TRUE, 
the Event Manager calls the widget's expose procedure only 
once for each series of exposure events.  In this case, all
.PN Expose
events are accumulated into a region.  When the 
.PN Expose
event with count zero is received,
the Event Manager replaces the rectangle in the event with the
bounding box for the region
and calls the widget's expose procedure passing the
(modified) exposure event and the region.
.LP
If compress_exposure is FALSE, the Event Manager will call the widget's
expose procedure for every exposure event, passing the event and
a region argument of NULL.
.NH 3
Setting and Checking the Sensitivity State of a Widget
.XS
\*(SN Setting and Checking the Sensitivity State of a Widget
.XE
.LP
To set the sensitivity state of a widget, use
.PN XtSetSensitive .
.IN "XtSetSensitive" "" "@DEF@"
.FD 0
void XtSetSensitive(\fIw\fP, \fIsensitive\fP)
.br
      Widget \fIw\fP;
.br
      Boolean \fIsensitive\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.IP \fIsensitive\fP 1i
Specifies whether or not the widget should receive keyboard and pointer events.
.LP
Many widgets, especially those with callback lists that get executed 
in response to some user-initiated action (for example, clicking down or up), 
have a mode in which they take on a different appearance 
(for example, greyed out or stippled) and do not respond to user events.
.LP
This dormant state means the widget is ``insensitive''.
If a widget is insensitive,
the Event Manager does not dispatch any events to the widget 
with an event type of 
.PN KeyPress , 
.PN KeyRelease , 
.PN ButtonPress , 
.PN ButtonRelease ,
.PN MotionNotify , 
.PN EnterNotify , 
.PN LeaveNotify , 
.PN FocusIn , 
or 
.PN FocusOut .
.LP
A widget can be insensitive because its sensitive field is FALSE 
or because one of its parents is insensitive, and, thus, the widget's
ancestor_sensitive field also is FALSE.  
A widget may but does not need to distinguish these two cases visually.
.LP
.PN XtSetSensitive 
first calls 
.PN XtSetValues 
on the current widget with an argument list specifying that the 
sensitive field should change to the new value.
It then recursively propagates the new value
down the managed children tree by calling 
.PN XtSetValues
on each child to set the ancestor_sensitive to the new value if the new
values for sensitive and the child's ancestor_sensitive are not the same.
.PN XtSetSensitive
thus maintains the invariant:
.IP \(bu 5
If parent has either sensitive or ancestor_sensitive FALSE, 
then all children have ancestor_sensitive FALSE.
.LP
.PN XtSetSensitive
calls 
.PN XtSetValues
to change sensitive and ancestor_sensitive.
Therefore, when one of these changes,
the widget's set_values procedure should
take whatever display actions are needed, 
such as greying out or stippling the widget.
.sp
.LP
To check the current sensitivity state of a widget,
use
.PN XtIsSensitive .
.IN "XtIsSensitive" "" "@DEF@"
.FD 0
Boolean XtIsSensitive(\fIw\fP)
.br
     Widget \fIw\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget that is to be checked.
.LP
To indicate whether or not user input events are being dispatched,
.PN XtIsSensitive
returns TRUE or FALSE.
If both core.sensitive and core.ancestor_sensitive are TRUE,
.PN XtIsSensitive
returns TRUE.
Otherwise, it returns FALSE.
.NH 2
Adding and Removing X Event Handlers
.XS
\*(SN Adding and Removing X Event Handlers
.XE
.LP
Event handlers are procedures that are called when specified events
occurs in a widget.
Most widgets will not need to use event handlers explicitly. 
Instead, they use the Intrinsic's translation manager.
Event handlers are of the type
.PN XtEventHandler :
.IN "XtEventHandler" "" "@DEF@"
.FD 0
typedef void (*XtEventHandler)();
.sp
void \fIEventHandler\fP(\fIw\fP, \fIclient_data\fP, \fIevent\fP)
.br
      Widget \fIw\fP;
.br
      caddr_t \fIclient_data\fP; 
.br
      XEvent *\fIevent\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget that this event handler was registered with.
.IP \fIclient_data\fP 1i
Specifies the client specific information registered with the event handler.
This is usually NULL if the event handler is registered by the widget itself.
.IP \fIevent\fP 1i
Specifies the triggering event.
.sp
.LP
To register an event handler procedure with the dispatch mechanism, use 
.PN XtAddEventHandler .
.IN "XtAddEventHandler" "" "@DEF@"
.FD 0
void XtAddEventHandler(\fIw\fP, \fIevent_mask\fP, \fInonmaskable\fP, \
\fIproc\fP, \fIclient_data\fP)
.br
      Widget \fIw\fP;
.br
      XtEventMask \fIevent_mask\fP;
.br
      Boolean \fInonmaskable\fP;
.br
      XtEventHandler \fIproc\fP;
.br
      caddr_t \fIclient_data\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget for which this event handler is being registered.
.IP \fIevent_mask\fP 1i
Specifies the event mask for which to call this procedure.
.IP \fInonmaskable\fP 1i
Specifies whether this procedure should be called on the nonmaskable events.
These are event of type 
.PN GraphicsExpose , 
.PN NoExpose , 
.PN SelectionClear ,
.PN SelectionRequest , 
.PN SelectionNotify , 
.PN ClientMessage , 
and 
.PN MappingNotify .
.IP \fIproc\fP 1i
Specifies the client event handler procedure. 
.IP \fIclient_data\fP 1i
Specifies additional data to be passed to the client's event handler.
.LP
The 
.PN XtAddEventHandler
function registers a procedure with the dispatch mechanism that is
to be called when an event that matches the mask occurs on the specified
widget.  
If the procedure is already registered, 
the specified mask is ORed into the existing mask.
If the widget is realized,
.PN XtAddEventHandler
calls
.PN XSelectInput ,
if necessary.
.sp
.LP
To remove a previously registered event handler, use 
.PN XtRemoveEventHandler .
.IN "XtRemoveEventHandler" "" "@DEF@"
.FD 0
void XtRemoveEventHandler(\fIw\fP, \fIevent_mask\fP, \fInonmaskable\fP, \
\fIproc\fP, \fIclient_data\fP)
.br
      Widget \fIw\fP;
.br
      XtEventMask \fIevent_mask\fP;
.br
      Boolean \fInonmaskable\fP;
.br
      XtEventHandler \fIproc\fP;
.br
      caddr_t \fIclient_data\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget for which this procedure is registered.
.IP \fIevent_mask\fP 1i
Specifies the event mask for which to unregister this procedure.
.IP \fInonmaskable\fP 1i
Specifies the events for which to unregister this procedure.
.IP \fIproc\fP 1i
Specifies the event handler procedure registered.
.IP \fIclient_data\fP 1i
Specifies the client data registered.
.LP
.PN XtRemoveEventHandler
stops the specified procedure from receiving the specified events.
If the widget is realized ,
.PN XtRemoveEventHandler
calls
.PN XSelectInput ,
if necessary.
.LP
To stop a procedure from receiving any events (which will remove it from the
widget's event_table entirely), call
.PN XtRemoveEventHandler
with an event_mask of 
.PN XtAllEvents 
and with nonmaskable TRUE.
.NH 3
Adding and Removing Event Handlers without Selecting Events
.XS
\*(SN Adding and Removing Event Handlers without Selecting Events
.XE
.LP
On occasions, 
clients need to register an event handler procedure with the 
dispatch mechanism without causing the server to select for that event.
To do this, use 
.PN XtAddRawEventHandler .
.IN "XtAddRawEventHandler" "" "@DEF@"
.FD 0
void XtAddRawEventHandler(\fIw\fP, \fIevent_mask\fP, \fInonmaskable\fP, \
\fIproc\fP, \fIclient_data\fP)
.br
      Widget \fIw\fP;
.br
      XtEventMask \fIevent_mask\fP;
.br
      Boolean \fInonmaskable\fP;
.br
      XtEventHandler \fIproc\fP;
.br
      caddr_t \fIclient_data\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget for which this event handler is being registered.
.IP \fIevent_mask\fP 1i
Specifies the event mask for which to call this procedure.
.IP \fInonmaskable\fP 1i
Specifies whether this procedure should be called on the nonmaskable events.
.IP \fIproc\fP 1i
Specifies the client event handler procedure. 
.IP \fIclient_data\fP 1i
Specifies additional data to be passed to the client's event handler.
.LP
This function has the same behavior as 
.PN XtAddEventHandler ,
except that it does not affect the widget's mask and it never causes an
.PN XSelectInput
for its events.
Note that the widget might already have those mask bits set
because of other non-raw, event handlers registered on it.
.sp
.LP
To remove a previously registered raw event handler, use
.PN XtRemoveRawEventHandler .
.IN "XtRemoveRawEventHandler" "" "@DEF@"
.FD 0
void XtRemoveRawEventHandler(\fIw\fP, \fIevent_mask\fP, \fInonmaskable\fP, \
\fIproc\fP, \fIclient_data\fP)
.br
      Widget \fIw\fP;
.br
      XtEventMask \fIevent_mask\fP;
.br
      Boolean \fInonmaskable\fP;
.br
      XtEventHandler \fIproc\fP;
.br
      caddr_t \fIclient_data\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget for which this procedure is registered.
.IP \fIevent_mask\fP 1i
Specifies the event mask for which to unregister this procedure.
.IP \fInonmaskable\fP 1i
Specifies the events for which to unregister this procedure.
.IP \fIproc\fP 1i
Specifies the event handler procedure registered.
.IP \fIclient_data\fP 1i
Specifies the client data registered.
.LP
.PN XtRemoveRawEventHandler
stops the specified procedure from receiving the specified events.
Because the procedure is a raw event handler, 
this will not affect the widget's mask and will never cause a call on 
.PN XSelectInput .
.NH 2
Constraining Events to a Cascade of Widgets
.XS
\*(SN Constraining Events to a Cascade of Widgets
.XE
.LP
.IN "Grabbing Input"
.IN "Input Grabbing"
Some widgets lock out any user input to the application except input to that
widget.
These are called ``modal'' widgets.
.LP
When a modal menu or modal dialog box is popped up using 
.PN XtPopup , 
user events (that is, keyboard and pointer events) that occur outside the modal
widget should be delivered to the modal widget or ignored.
In no case should user events be delivered to a widget outside 
of the modal widget.
.LP
Menus can pop-up submenus and dialog boxes can pop-up further dialog
dialog boxes to create a pop-up ``cascade''. 
In this case, 
user events should be delivered to one of several modal widgets in the cascade.
.LP
Display-related events should be delivered outside the modal cascade so that
expose events and the like keep the application's display up-to-date.
Any event that occurs within the cascade is delivered normally.
Events that are delivered to the most recent spring-loaded shell in the cascade
if they occur outside the cascade are called ``remap'' events and consist
of the following events: 
.PN KeyPress , 
.PN KeyRelease , 
.PN ButtonPress ,
and
.PN ButtonRelease .
.LP
Events that are ignored if they occur outside the cascade are:
.PN MotionNotify , 
.PN EnterNotify , 
and
.PN LeaveNotify .
All other events are delivered normally.
.LP
.PN XtPopup
uses the procedures
.PN XtAddGrab
and
.PN XtRemoveGrab
to constrain user events to a modal cascade and subsequently to remove a grab
when the modal widget goes away.
There is usually no need to call them explicitly.
.sp
.LP
To redirect user input to a modal widget, use
.PN XtAddGrab .
.IN "XtAddGrab" "" "@DEF@"
.FD 0
void XtAddGrab(\fIw\fP, \fIexclusive\fP, \fIspring_loaded\fP)
.br
      Widget \fIw\fP;
.br
      Boolean \fIexclusive\fP;
.br
      Boolean \fIspring_loaded\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget to add to the modal cascade.
.IP \fIexclusive\fP 1i
Specifies if user events should be dispatched exclusively to this widget or
also to previous widgets in the cascade.
.IP \fIspring_loaded\fP 1i
Specifies if this widget was popped up because the user pressed 
a pointer button.
.LP
.PN XtAddGrab
appends the widget (and associated parameters) to the modal cascade.
.PN XtAddGrab
checks that exclusive is TRUE if spring_loaded is TRUE. 
If not, it generates an error.
.LP
When
.PN XtDispatchEvent
tries to dispatch a user event when at least one modal widget is in the 
widget cascade, it first determines if the event should be delivered.
It starts at the most recent cascade entry and follows the cascade up to and 
including the most recent cascade entry added with the exclusive parameter
TRUE.
.LP
This subset of the modal cascade is the active subset.
User events that occur outside the widgets in this subset are ignored 
or remapped.  
Modal menus with submenus generally add a submenu widget to the cascade 
with exclusive FALSE.
Modal dialog boxes that wish to restrict user input to the most deeply nested 
dialog box add a subdialog widget to the cascade with exclusive TRUE.
.LP
User events that occur within the active subset are delivered to the
appropriate widget, which is usually a child or further descendant of the modal
widget.
.LP
Regardless of where on the screen they occur, 
remap events are always delivered to the most recent widget in the active 
subset of the cascade that has spring_loaded TRUE (if any such widget exists).
.sp
.LP
To remove the redirection of user input to a modal widget, use
.PN XtRemoveGrab .
.IN "XtRemoveGrab" "" "@DEF@"
.FD 0
void XtRemoveGrab(\fIw\fP)
.br
      Widget \fIw\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget to remove from the modal cascade.
.LP
.PN XtRemoveGrab
removes widgets from the modal cascade starting at the most recent widget 
up to and including the specified widget.
It issues an error if w is not on the modal cascade.
.NH 2
Focusing Events on a Child
.XS
\*(SN Focusing Events on a Child
.XE
.LP
To redirect keyboard input to a child of a composite widget without calling
.PN XSetInputFocus , 
use
.PN XtSetKeyboardFocus .
.IN "XtSetKeyboardFocus" "" "@DEF@"
.FD 0
XtSetKeyboardFocus(\fIw\fP\, \fIdescendant\fP)
.br
     Widget \fIw\fP, \fIdescendant\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget for which the keyboard focus is to be set.
.IP \fIdescendant\fP 1i
Specifies the widget to which the keyboard event is to be sent or
.PN None .
.LP
If a future keyboard event
.Pn ( KeyPress 
or
.PN KeyRelease )
occurs on the specified widget,
.PN XtSetKeyboardFocus
causes
.PN XtDispatchEvent
to remap and send the event to the specified descendant widget.
.LP
If widget A is an ancestor of widget W
and if no modal cascade has been created,
a keyboard event is defined as occurring within W if one of the following
focus conditions are true:
.IP \(bu 5
W has the X server input focus.
.IP \(bu 5
The event occurs within A or a descendent of A,
and W has the keyboard focus for A.
.IP \(bu 5
The event occurs within A, and no descendant of A has the keyboard
focus for A, and the pointer is within W.
.LP
If widget A is an ancestor of widget W,
and if a modal cascade exists,
a keyboard event is defined as occurring within W 
if A is in the active subset of the modal cascade 
and if one of the previous focus conditions are true.
.LP
When W acquires the X input focus 
or the keyboard focus for one of its ancestors, a 
.PN FocusIn
event is generated for descendant if
.PN FocusNotify
events have been selected by the descendant.
Similarly, when W looses the X input focus 
or the keyboard focus for one of its ancestors, a
.PN FocusOut
event is generated for descendant if 
.PN FocusNotify
events have been selected by the descendant.
.LP
.IN "accept_focus procedure"
Widgets that want the input focus may call 
.PN XSetInputFocus 
explicitly.
To allow outside agents to cause a widget to get the input focus, 
every widget exports an accept_focus procedure.
Widgets interested in knowing when they lose the input focus must use 
the Xlib focus notification mechanism explicitly, 
typically by specifying translations for 
.PN FocusIn
and 
.PN FocusOut
events.
Widgets that never want the input focus should set their
accept_focus procedure to NULL.
.LP
.IN "move_focus_to_next procedure"
.IN "move_focus_to_prev procedure"
Composite widgets have two additional functions:
.IP \(bu 5
move_focus_to_next 
.IP \(bu 5
move_focus_to_prev
.LP
These procedures (which may be NULL) move the focus 
to the next child widget that wants it
and to the previous child widget that wants it, respectively. 
The definition of next and previous is left to each individual widget. 
In addition, composite widgets are free to implement other
procedures to move the focus between their children.
Both move_focus_to_next and move_focus_to_prev should be entered in 
the widget class action table, so that they are available to translation
specifications.
.NH 2
Querying Event Sources
.XS
\*(SN Querying Event Sources
.XE
.LP
The event manager provides several routines to examine and read events
(including file and timer events) that are in the queue.
.LP
The next three functions handle \*(tk equivalents of the
.PN XPending , 
.PN XPeekEvent ,
and 
.PN XNextEvent  
Xlib calls.
.sp
.LP
.IN "Events
To determine if there are any events on the input queue, 
use
.PN XtPending .
.IN "XtPending" "" "@DEF@"
.FD 0
Boolean XtPending()
.FN
The 
.PN XtPending
returns a nonzero value if there are 
events pending from the X server or other input sources.  
If there are no events pending, 
it flushes the output buffer and returns a zero value.
.sp
.LP
To return the value from the head of the input queue 
without removing input from the queue, use
.PN XtPeekEvent .
.IN "XtPeekEvent" "" "@DEF@"
.FD 0
Boolean XtPeekEvent(\fIevent_return\fP)
.br
      XEvent *\fIevent_return\fP;
.FN
.IP \fIevent_return\fP 1i
Returns the event information to the specified event structure.
.LP
If there is an event in the queue, 
.PN XtPeekEvent
fills in the event and returns a non-zero value.
If no X input is on the queue, 
.PN XtPeekEvent
flushes the output buffer and blocks until input is available, possibly
calling some timeout callbacks in the process.
If the input is an event,
.PN XtPeekEvent
fills in the event and returns a non-zero value. 
Otherwise, the input is for an alternate input source, and
.PN XtPeekEvent
returns zero.
.sp
.LP
To return the value from the head of the input queue, 
use 
.PN XtNextEvent .
.IN "XtNextEvent" "" "@DEF@"
.FD 0
void XtNextEvent(\fIevent_return\fP)
.br
      XEvent *\fIevent_return\fP;
.FN
.IP \fIevent_return\fP 1i
Returns the event information to the specified event structure.
.LP
If no input is on the X input queue, 
.PN XtNextEvent 
flushes the X output buffer 
and waits for an event while looking at the other input sources 
and timeout values and calling any callback procedures triggered by them.
.NH 2
Dispatching Events
.XS
\*(SN Dispatching Events
.XE
.LP
The \*(tk provides functions that dispatch events
to widgets or other application code. 
Every client interested in events on a widget uses
.PN XtAddEventHandler 
to register which events it is 
interested in and a procedure (event handler) that is to be called 
when the event happens in that window. 
.LP
When an event is received, 
it is passed to a dispatching procedure. 
This procedure calls the appropriate event handlers 
and passes them the widget, the event, and client-specific data 
registered with each procedure.
If there are no handlers for that event registered, 
the event is ignored and the dispatcher simply returns.
.LP
The order in which the handlers are called is not defined.
.sp
.LP
To send events to registered functions and widgets, use 
.PN XtDispatchEvent .
Usually, this procedure is not called by client applications (see
.PN XtMainLoop ).
.IN "XtDispatchEvent" "" "@DEF@"
.FD 0
void XtDispatchEvent(\fIevent\fP)
.br
      XEvent *\fIevent\fP;
.FN
.IP \fIevent\fP 1i
Specifies a pointer to the event structure that is to be dispatched 
to the appropriate event handler.
.LP
The 
.PN XtDispatchEvent
function sends those events to those event handler functions that
have been previously registered with the dispatch routine.
The most common use of 
.PN XtDispatchEvent
is to dispatch events acquired with the 
.PN XtNextEvent
or
.PN XtPeekEvent
procedure. 
However, it also can be used to dispatch user-constructed events.
.PN XtDispatchEvent
also is responsible for processing grabs and keyboard focus.
.NH 2
Processing Input
.XS
\*(SN Processing Input
.XE
.LP
To process input, an application can call
.PN XtMainLoop .
.IN "XtMainLoop" "" "@DEF@"
.FD 0
void XtMainLoop()
.FN
.PN XtMainLoop
first reads the next incoming file, timer, or X event by calling
.PN XtNextEvent .
Then, it dispatches this to the appropriate registered procedure by calling
.PN XtDispatchEvent .
This is the main loop of \*(tk applications, 
and, as such, it does not return.
Applications are expected to exit in response to some user action.
.LP
There is nothing special about
.PN XtMainLoop .
It is simply an infinite loop that calls
.br
.PN XtNextEvent
then
.PN XtDispatchEvent .
.LP
Applications can provide their own version of this loop, 
which tests some global termination flag or tests that the number 
of top-level widgets is larger than 0 before circling back to the call to 
.PN XtNextEvent .
.NH 2
Widget Exposure and Visibility 
.XS
\*(SN Widget Exposure and Visibility
.XE
.LP
Every primitive widget and some composite widgets display data on the screen
by means of raw X calls.
Widgets cannot simply write to the screen and forget what they have done. 
They must keep enough state to redisplay the window or parts
of it if a portion is obscured and then re-exposed.
.NH 3
Redisplay of a Widget: the expose procedure
.XS
\*(SN Redisplay of a Widget: the expose procedure
.XE
.IN "expose procedure"
.LP
The expose procedure for a widget class is of type
.PN XtExposeProc :
.IN "XtExposeProc" "" "@DEF@"
.FD 0
typedef void (*XtExposeProc)();
.sp
void \fIExposeProc\fP(\fIw\fP, \fIevent\fP, \fIregion\fP)
.br
      Widget \fIw\fP;
.br
      XEvent *\fIevent\fP;
.br
      Region \fIregion\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget instance requiring redisplay.
.IP \fIevent\fP 1i
Specifies the exposure event giving the rectangle requiring redisplay.
.IP \fIregion\fP 1i
Specifies the union of all rectangles in this exposure sequence.
.LP
Redisplay of a widget upon exposure is the responsibility of the 
expose procedure in the widget's class record.
If a widget has no display semantics,
it can specify NULL for the expose field.
Many composite widgets serve only as containers for their children
and have no expose procedure.
.NT
If the expose proc is NULL,
.PN XtRealizeWidget
fills in a default bit gravity of
.PN NorthWestGravity
before it calls the widget's realize proc.
.NE
.LP
If the widget's compress_exposure field is FALSE (see "Exposure Compression"),
region will always be NULL.  If the widget's compress_exposure field is
TRUE, event will contain the bounding box for region.
.LP
A small simple widget (for example, Label) can ignore the bounding box 
information in the event and just redisplay the entire window.
A more complicated widget (for example, Text) can use the bounding box 
information to minimize the amount of calculation and redisplay it does.
A very complex widget will use the region as a clip list in a GC and
ignore the event information.
.LP
The expose procedure is responsible for exposure of all superclass data 
as well as its own,
This is because, in general, this operation cannot be cleanly broken up.
.LP
However, 
it often possible to anticipate the display needs of several levels 
of subclassing.
For example, rather than separate display procedures for
the widgets Label, Command, and Toggle, 
you could write a single display routine in Label that uses ``display state'' 
fields like:
.LP
.Ds 
Boolean invert
Boolean highlight
Dimension highlight_width
.De
Label would have invert and highlight always FALSE and
highlight_width zero(0).  
Command would dynamically set highlight and highlight_width, but it would 
leave invert always FALSE.
Finally, Toggle would dynamically set all three.
.LP
In this case, 
the expose procedures for Command and Toggle inherit
their superclass's expose procedure. 
For further information, see ``Inheriting Superclass Operations''.
.NH 3
Widget Visibility
.XS
\*(SN Widget Visibility
.XE
.LP
Some widgets may use substantial computing resources to display data.
However, this effort is wasted if the widget is not actually visible 
on the screen.
That is, the widget can be obscured by another application or iconified.
.LP
.IN "Visibility"
.IN "Visible"
The visible field in the 
Core 
widget structure provides a hint to the widget that it need not display data.
This field is guaranteed TRUE (by the time an 
.PN Expose 
event is processed) if the widget is visible 
and is usually FALSE if the widget is not visible.
.LP
Widgets can use or ignore the visible hint as they wish.
If they ignore it, 
they should have visible_interest in their widget class record set FALSE.  
In such cases, 
the visible field is initialized TRUE and never changes.
If visible_interest is TRUE, 
the Event Manager asks for
.PN VisibilityNotify 
events for the widget and updates the visible field accordingly.
.NH 2 
Geometry Management \- Sizing and Positioning Widgets
.XS
\*(SN Geometry Management \- Sizing and Positioning Widgets
.XE
.LP
.IN "geometry_manager field"
.IN "Geometry Management"
.IN "Configure Window"
A widget does not directly control its size and location,
which is the responsibility of the parent of that widget.
Although the position of children is usually left up to their parent,
the widgets themselves often have the best idea of their optimal sizes
and, possibly, preferred locations. 
.LP
To resolve physical layout conflicts between sibling widgets and between
a widget and its parent, the \*(tk provides the Geometry Management mechanism. 
Almost all composite widgets have a geometry manager (geometry_manager field
in the widget class record) that is responsible for the size, position, and 
stacking order of the widget's children.
The only exception are fixed boxes, 
which create their children themselves and can ensure that
their children will never make a geometry request.
.LP
Widgets that wish to change their size, position, border width, or stacking
depth must not use X calls directly. 
Instead, they must ask their parent's geometry manager 
to make the desired changes.
When a child makes a request of the parent's geometry manager, 
the geometry manager can do one of the following:
.IP \(bu 5
Allow the request
.IP \(bu 5
Disallow the request
.IP \(bu 5
Suggest a compromise
.LP
Geometry requests are always made by the child itself. 
Clients that wish to change the geometry of a widget should call
.PN XtSetValues
on the appropriate geometry fields.
Parents that wish to change the geometry of a child can use
.PN XtMoveWidget
or
.PN XtResizeWidget
at any time.
.LP
When the geometry manager is asked to change the geometry of a child, 
the geometry manager may also rearrange and resize any or all 
of the other children that it controls.
The geometry manager can move children around freely using
.PN XtMoveWidget .
When it resizes a child (that is, changes width, height, or 
border_width) other than the one making the request,
it should do so by calling
.PN XtResizeWidget .
.LP
Often, geometry managers find that they can satisfy a request only if
they can reconfigure a widget that they are not in control of (in particular,
when the composite widget wants to change its own size).
In this case,
the geometry manager makes a request to its parent's geometry manager.
Geometry requests can cascade this way to arbitrary depth.
.LP
Because such cascaded arbitration of widget geometry can involve extended
negotiation, 
windows are not actually allocated to widgets at application
startup until all widgets are satisfied with their geometry.
See ``Realizing Widgets'' and ``Creating Widgets'' for more details.
.NH 3
Making General Geometry Manager Requests
.XS
\*(SN Making General Geometry Manager Requests
.XE
.LP
To make a general geometry manager request from a widget, use 
.PN XtMakeGeometryRequest .
.IN "XtMakeGeometryRequest" "" "@DEF@"
.FD 0
XtGeometryResult XtMakeGeometryRequest(\fIw\fP, \fIrequest\fP, \
\fIreply_return\fP)
.br
      Widget \fIw\fP;
.br
      XtWidgetGeometry *\fIrequest\fP;
.br
      XtWidgetGeometry *\fIreply_return\fP;	
.FN
.IP \fIw\fP 1i
Specifies the widget ID of the widget that is making the request.
.IP \fIrequest\fP 1i
Specifies the desired widget geometry (size, position, border width, 
and stacking order).
.IP \fIreply_return\fP 1i
Returns the allowed widget size.
If a widget is not interested in handling 
.PN XtGeometryAlmost , 
the reply parameter can be NULL.
.LP
The return codes from geometry managers are:
.IN "XtGeometryResult"
.LP
.Ds 0
.TA .5i 1.75i
.ta .5i 1.75i
typedef enum _XtGeometryResult {
	XtGeometryYes,	
	XtGeometryNo,	
	XtGeometryAlmost,	
	XtGeometryDone,
} XtGeometryResult; 
.De
.LP
The 
.PN XtWidgetGeometry 
structure is quite similar but not
identical to the corresponding Xlib structure:
.LP
.IN "XtGeometryMask"
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef unsigned long XtGeometryMask;

typedef struct {
	XtGeometryMask request_mode;
	Position x, y;
	Dimension width, height;
	Dimension border_width;
	Widget sibling;
	int stack_mode;
} XtWidgetGeometry;
.De
.LP
The request_mode definitions are from
.Pn < X11/X.h >:
.LP
.Ds 0
.TA .5i 2.5i
.ta .5i 2.5i
	#define CWX	(1<<0)
	#define CWY	(1<<1)
	#define CWWidth	(1<<2)
	#define CWHeight	(1<<3)
	#define CWBorderWidth	(1<<4)
	#define CWSibling	(1<<5)
	#define CWStackMode	(1<<6)
.De
.LP
.PN XtMakeGeometryRequest ,
in exactly the same manner as the Xlib routine 
.PN XConfigureWindow ,
uses the request_mode to determine which fields in the 
.PN XtWidgetGeometry 
structure you want to specify. 
.LP
The stack_mode definitions are from
.Pn < X11/X.h >:
.LP
.Ds 0
.TA .5i 2.5i
.ta .5i 2.5i
	#define Above	0
	#define Below	1
	#define TopIf	2
	#define BottomIf	3
	#define Opposite	4
	#define XtSMDontChange	5
.De
.LP
For definition and behavior of 
.PN Above , 
.PN Below , 
.PN TopIf ,
.PN BottomIf , 
and 
.PN Opposite ,
see \fI\*(xL\fP.
.PN XtSMDontChange
indicates that the widget wants its current stacking order preserved.
.LP
The
.PN XtMakeGeometryRequest 
function performs the following:
.IP \(bu 5
If the parent is not a subclass of 
.PN Composite , 
or the parent's geometry_manager is NULL,
it issues an error.
.IP \(bu 5
If the widget's being_destroyed field is TRUE,
it returns 
.PN XtGeometryNo .
.IP \(bu 5
If the widget x, y, width, height and border_width fields are
all equal to the requested values,
it returns
.PN XtGeometryYes .
.IP \(bu 5
If the widget is unmanaged or the widget's parent is not realized,
it makes the changes and returns
.PN XtGeometryYes .
Otherwise,
.PN XtMakeGeometryRequest
calls the parent's geometry_manager procedure with the given parameters.
.IP \(bu 5
If the parent's geometry manager returns 
.PN XtGeometryYes
and if the widget is realized,
it reconfigures the widget's window, setting its size, location, and stacking
order as appropriate, by calling
.PN XConfigureWindow .
.IP \(bu 5
If the geometry manager returns
.PN XtGeometryDone ,
it means that it has approved the change 
and, furthermore,  has already done it.
it does no configuring and changes the return value into
.PN XtGeometryYes .
.PN XtMakeGeometryRequest
never returns
.PN XtGeometryDone .
.IP \(bu 5
Finally,
.PN XtMakeGeometryRequest
returns the resulting value from the parent's geometry manager.
.NH 3
Making Resize Requests
.XS
\*(SN Making Resize Requests
.XE
.LP
To make a simple resize request from a widget, you can use
.PN XtMakeResizeRequest 
as an alternative to
.PN XtMakeGeometryRequest .
.IN "XtMakeResizeRequest" "" "@DEF@"
.FD 0
XtGeometryResult XtMakeResizeRequest(\fIw\fP, \fIwidth\fP, \fIheight\fP, \
\fIwidth_return\fP, \fIheight_return\fP)
.br
      Widget \fIw\fP;
.br
      Dimension \fIwidth\fP, \fIheight\fP;
.br
      Dimension *\fIwidth_return\fP, *\fIheight_return\fP
.FN
.IP \fIw\fP 1i
Specifies the widget.
.IP \fIwidth\fP 1i
Specifies the desired widget width.
.IP \fIheight\fP 1i
Specifies the desired widget height.
.IP \fIwidth_return\fP 1i
Returns the allowed widget width.
.IP \fIheight_return\fP 1i
Returns the allowed widget height.
.LP
.PN XtMakeResizeRequest
is a simple interface to 
.PN XtMakeGeometryRequest .
It creates a 
.PN XtWidgetGeometry 
structure and specifies that width and height should change. 
The geometry manager is free to modify any of the other window attributes
(position or stacking order) in order to satisfy the resize request.
If the return value is 
.PN XtGeometryAlmost ,
replyWidth and replyHeight contain a
``compromise'' width and height.
If these are acceptable the widget should immediately make an 
.PN XtMakeResizeRequest
requesting the compromise width and height.
.LP
If the widget is not interested in 
.PN XtGeometryAlmost 
replies, it can pass NULL for replyWidth and replyHeight.
.NH 3
Management of Child Geometry: the geometry_manager procedure
.XS
\*(SN Management of Child Geometry: the geometry_manager procedure
.XE
.LP
The geometry_manager procedure for a composite widget class is of type
.PN XtGeometryHandler :
.IN "XtGeometryHandler" "" "@DEF@"
.FD 0
typedef XtGeometryResult (*XtGeometryHandler)();
.sp
XtGeometryResult \fIGeometryHandler\fP(\fIw\fP, \fIrequest\fP, \
\fIgeometry_return\fP)
.br
      Widget \fIw\fP;
.br
      XtWidgetGeometry *\fIrequest\fP;
.br
      XtWidgetGeometry *\fIgeometry_return\fP;	
.FN
.LP
A class can inherit its superclass's geometry manager during class
initialization.
.LP
A zero (0) bit in the request's mask field means that the child widget
does not care about the value of the corresponding field.
Then, the geometry manager can change it as it wishes.
A one (1) bit means that the child wants that geometry element changed 
to the value in the corresponding field.
.LP
If the geometry manager can satisfy all changes requested, 
it updates the widget's x, y, width, height, and border_width appropriately, 
and then returns 
.PN XtGeometryYes .  
The value of the preferred_return argument is undefined.  
The widget's window is moved and resized automatically by
.PN XtMakeGeometryRequest .
.LP
Homogeneous composite widgets often find it convenient to treat the widget
making the request the same as any other widget, possibly reconfiguring
it as part of its layout process.
If it does this,
it should return
.PN XtGeometryDone
to inform
.PN XtMakeGeometryRequest
that it does not need to do the configure itself.
Although 
.PN XtMakeGeometryRequest
resizes the widget's window, 
it does not call the widget class's resize procedure if the geometry 
manager returns 
.PN XtGeometryYes .
The requesting widget must perform whatever
resizing calculations are needed explicitly.
.LP
If the geometry manager chooses to disallow the request, 
the widget cannot change its geometry.
The value of the preferred_return parameter is undefined, 
and the geometry manager returns 
.PN XtGeometryNo .
.LP
Sometimes the geometry manager cannot satisfy the request exactly,
but it may be able to satisfy what it considers a similar request. 
That is, 
it could satisfy only a subset of the requests (for example, 
size but not position) or a lesser request
(for example, it cannot make the child as big as the
request but it can make the child bigger than its current size).
In such cases, 
the geometry manager fills in preferred_return with the actual changes
it is willing to make, including a appropriate mask, and returns 
.PN XtGeometryAlmost .
If a bit in reply.request_mode is zero (0), 
the geometry manager will not change the corresponding value
if the preferred_return is used immediately
in a new request.
If a bit is one (1), 
the geometry manager will change that element to the corresponding
value in preferred_return.
More bits may be set in preferred_return than in the original request if
the geometry manager intends to change other fields should the
child accept the compromise.
.LP
When 
.PN XtGeometryAlmost 
is returned, 
the widget must decide if the compromise suggested in preferred_return 
is acceptable. 
If so, the widget must not change its geometry directly.
Rather, it must make another call to
.PN XtMakeGeometryRequest .
.LP
If the next geometry request from this child uses the 
preferred_return box filled in by an
.PN XtGeometryAlmost 
return and if there have been no intervening geometry requests on
either its parent or any of its other children, 
the geometry manager must grant the request. 
That is, if the child asks again right away with the returned geometry,
it will get an answer of 
.PN XtGeometryYes .
.LP
To return an 
.PN XtGeometryYes , 
the geometry manager will frequently
rearrange the position of other managed children. 
To do this, it should call
the procedure
.PN XtMoveWidget
described below.
However, a few geometry managers sometimes may change the
size of other managed children.
To do this, they should call the procedures
.PN XtResizeWidget
or
.PN XtConfigureWidget .
.LP
Geometry managers must not assume that the request 
and preferred_return arguments point to independent storage.
The caller is permitted to use the same field for both,
and the geometry manager must allocate its own temporary storage,
if necessary.
.NH 3
Moving and Resizing Widgets
.XS
\*(SN Moving and Resizing Widgets
.XE
.LP
To move a sibling widget of the child making the geometry request, use
.PN XtMoveWidget .
.IN "XtMoveWidget" "" "@DEF@"
.FD 0
void XtMoveWidget(\fIw\fP, \fIx\fP, \fIy\fP)
.br
      Widget \fIw\fP;
.br
      Position \fIx\fP;
.br
      Position \fIy\fP;	
.FN
.IP \fIw\fP 1i
Specifies the widget.
.IP \fIx\fP 1i
.br
.ns
.IP \fIy\fP 1i
Specifies the new widget coordinates.
.LP
.PN XtMoveWidget
writes the new x and y values into the widget and, if the widget is realized,
issues an
.PN XMoveWindow
call on the widget's window.
.sp
.LP
To resize a sibling widget of the child making the geometry request, use
.PN XtResizeWidget .
.IN "XtResizeWidget" "" "@DEF@"
.FD 0
void XtResizeWidget(\fIw\fP, \fIwidth\fP, \fIheight\fP, \fIborder_width\fP)
.br
      Widget \fIw\fP;
.br
      Dimension \fIwidth\fP;
.br
      Dimension \fIheight\fP;	
.br
      Dimension \fIborder_width\fP;	
.FN
.IP \fIw\fP 1i
Specifies the widget.
.br
.IP \fIwidth\fP 1i
.br
.ns
.IP \fIheight\fP 1i
.br
.ns
.IP \fIborder_width\fP 1i
Specify the new widget size.
.LP
.PN XtResizeWidget
returns immediately if the new width, height, and border_width
are the same as the old values.
Otherwise,
.PN XtResizeWidget
writes the new width, height, and border_width values into 
the widget and, if the widget is realized, issues an
.PN XConfigureWindow
call on the widget's window.
.LP
If the new width or height are different from the old values, 
.PN XtResizeWidget
calls the widget's resize procedure to notify it of the size change.
.LP
A geometry manager must not call
.PN XtResizeWidget
on the child that is making the request.
.sp
.LP
To move and resize the sibling widget of the child making the geometry request,
use
.PN XtConfigureWidget .
.IN "XtConfigureWidget" "" "@DEF@"
.FD 0
void XtConfigureWidget(\fIw\fP, \fIx\fP, \fIy\fP, \fIwidth\fP, \fIheight\fP, \
\fIborder_width\fP)
.br
      Widget \fIw\fP;
.br
      Position \fIx\fP;
.br
      Position \fIy\fP;
.br
      Dimension \fIwidth\fP;
.br
      Dimension \fIheight\fP;
.br
      Dimension \fIborder_width\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.IP \fIx\fP 1i
.br
.ns
.IP \fIy\fP 1i
Specify the new widget position.
.IP \fIwidth\fP 1i
.br
.ns
.IP \fIheight\fP 1i
.br
.ns
.IP \fIborder_width\fP 1i
Specify the new widget size.
.LP
.PN XtConfigureWidget
writes the new x, y, width, height, and border_width values into the widget
and, if the widget is realized, makes an
.PN XConfigureWindow
call on the widget's window.
.LP
If the new width or height are different from the old values,
.PN XtConfigureWidget
calls the widget's resize procedure to notify it of the size change.
Otherwise, it simply returns.
.NH 3
Querying Preferred Geometry
.XS
\*(SN Querying Preferred Geometry
.XE
.LP
To query a widget's preferred geometry, use
.PN XtQueryGeometry .
.IN "XtQueryGeometry" "" "@DEF@"
.FD 0
XtGeometryResult XtQueryGeometry(\fIw\fP, \fIintended\fP, \
\fIpreferred_return\fP)
.br
     Widget \fIw\fP\^;
.br
     XtWidgetGeometry *\fIintended\fP, *\fIpreferred_return\fP\^;
.FN
.IP \fIw\fP 1i
Specifies the child widget.
.IP \fIintended\fP 1i
Specifies any changes the parent plans to make to the child's geometry
(can be NULL).
.IP \fIpreferred_return\fP 1i
Returns the child widget's preferred geometry.
.LP
The parent that wants to know a child's preferred geometry sets any changes
that it intends to make to the child's geometry in the corresponding fields of
the intended structure, sets the corresponding bits in intended.request_mode
and calls
.PN XtQueryGeometry .
.LP
.PN XtQueryGeometry
clears all bits in the preferred_return->request_mode and checks the 
query_geometry field of the specified widget's class record.
If query_geometry is not NULL,
.PN XtQueryGeometry
calls the query_geometry proc passing as arguments the 
specified widget, intended, and preferred_return structures.
If the intended argument is NULL,
it is replaced with a pointer to an
.PN XtWidgetGeometry
structure with request_mode=0 before calling query_geometry.
.LP
The query_geometry procedure is of type
.PN XtGeometryHandler .
.IN "query_geometry procedure" "" "@DEF@"
.FD 0
XtGeometryResult \fIQueryGeometry\fP(\fIw\fP, \fIrequest\fP, \
\fIpreferred_return\fP)
.br
      Widget \fIw\fP;
.br
      XtWidgetGeometry *\fIrequest\fP;
.br
      XtWidgetGeometry *\fIpreferred_return\fP;
.FN
.IN "query_geometry procedure"
The query_geometry procedure is expected to examine the bits set in
intended->request_mode, evaluate the preferred geometry of the widget,
and store the result in preferred_return 
(setting the bits in preferred_return->request_mode corresponding 
to those geometry field that it cares about).
If the proposed geometry change is acceptable without modification,
the query_geometry procedure should return
.PN XtGeometryYes .
If at least one field in preferred_return is different 
from the corresponding field in intended 
or if a bit was set in preferred_return that was not set in intended,
the query_geometry procedure should return
.PN XtGeometryAlmost .
If the preferred geometry is identical to the current geometry,
the query_geometry procedure should return
.PN XtGeometryNo .
.LP
After calling the query_geometry proc
or if the query_geometry field is NULL,
.PN XtQueryGeometry
examines all the unset bits in preferred_return->request_mode
and sets the corresponding fields in preferred_return 
to the current values from the widget instance.
If
.PN CWStackMode
is not set,
the stack_mode field is set to
.PN XtSMDontChange .
.PN XtQueryGeometry
then returns the value returned by the query_geometry procedure or
.PN XtGeometryYes
if the query_geometry field is NULL.
.LP
Therefore, the caller can interpret a return of
.PN XtGeometryYes
as not needing to evaluate the contents of reply and, more importantly,
not needing to modify it's layout plans. 
A return of
.PN XtGeometryAlmost
means either that both the parent and the child expressed interest
in at least one common field,
and the child's preference does not match the parent's intentions, 
or that the child expressed interest in a field that
the parent might need to consider.
A return value of
.PN XtGeometryNo
means that both the parent and the child expressed interest in a field and
that the child suggests that the field's current value is it's preferred value.
.LP
In addition, whether or not the caller ignores the return value or the
reply mask, it is guaranteed that the reply structure contains complete
geometry information for the child.
.LP
Parents are expected to call
.PN XtQueryGeometry
in their layout routine and wherever else they may care after
change_managed has been called.
The changed_managed procedure may assume that the child's current geometry 
is it's preferred geometry.
Thus, the child is still responsible for storing values
into its own geometry during it's initialize proc.
.NH 3
Management of Size Changes: the resize procedure
.XS
\*(SN Management of Size Changes: the resize procedure
.XE
.LP
A child can be involuntarily resized by its parent at any time.
Widgets usually want to know when they have changed size 
so that they can re-layout their displayed data to match the new size.
When a parent resizes a child, it calls
.PN XtResizeWidget .
This function updates the geometry fields in the widget, 
configures the window if the widget is realized, 
and calls the child's resize procedure to notify the child.
The resize procedure is of type
.PN XtWidgetProc :
.IN "resize procedure" "" "@DEF@"
.FD 0
void \fIResize\fP(\fIw\fP)
.br
     Widget \fIw\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.LP
If a class need not recalculate anything when a widget is resized, 
it can specify NULL for the resize field in its class record.
This is an unusual case and should only occur for widgets 
with very trivial display semantics.
.LP
The resize procedure takes a widget as its only argument.
The x, y, width, height
and border_width fields of the widget contain the new values.
.LP
The resize procedure should recalculate the layout of internal data
as needed.
(For example, a centered Label in a window that changes size
should recalculate the starting position of the text.)
The widget must obey resize as a command and must not treat it as a request.
A widget must not issue an 
.PN XtMakeGeometryRequest
or
.PN XtMakeResizeRequest
call from its resize procedure.
.NH 2 
Selections
.XS
\*(SN Selections
.XE
.LP
Arbitrary widgets (possibly not all in the same application) communicate with
each other by means of the selection mechanism defined by the server and Xlib.
For further information,
see \fI\*(xL\fP.
.bp
\&
.sp 1
.ce 3
\s+1\fBChapter 11\fP\s-1

\s+1\fBResource Management\fP\s-1
.sp 2
.nr H1 11
.nr H2 0
.nr H3 0
.nr H4 0
.nr H5 0
.LP
.XS
Chapter 11 \- Resource Management
.XE
Writers of widgets need to obtain a large set of resources at widget
creation time.
Some of the resources come from the resource database,
some from the argument list supplied in the call to
.PN XtCreateWidget , 
and some from the internal defaults specified for the widget.  
Resources are obtained first from the argument list, 
then from the resource database for all resources not specified 
in the argument list, 
and lastly from the internal default, if needed.
.LP
A resource is a field in the widget record with a corresponding
resource entry in the widget's resource list (or in a superclass's resource
list).
This means that the field is
settable by 
.PN XtCreateWidget
(by naming the field in the argument list), by an
entry in the default resource files (by using either the name or class), and by
.PN XtSetValues .
In addition, it is readable by 
.PN XtGetValues .
.LP
Not all fields in a widget record are resources.  
Some are for ``bookkeeping'' use by the
generic routines (like managed and being_destroyed). 
Other can be for local bookkeeping, 
while still others are derived from resources (many GCs and Pixmaps).
.NH 2
Resource Lists
.XS
\*(SN Resource Lists
.XE
.LP
.IN "Resource Management"
A resource entry specifies a field in the widget, 
the textual name and class of the field that argument lists 
and external resource files use to refer to the field, 
as well as a default value that the field should get if no value is specified.
The declaration for the 
.PN XtResource 
structure is:
.LP
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	String resource_name;
	String resource_class;
	String resource_type;
	Cardinal resource_size;
	Cardinal resource_offset;
	String default_type;
	caddr_t default_address;
} XtResource, *XtResourceList;
.De
.IN "XtResourceList"
.LP
The resource_name field contains the name used by clients to access the field
in the widget.
By convention, it starts with a lower-case letter 
and is spelled almost identically to the field name,
except (underbar, character) is replaced by (capital character). 
For example, the resource name for background_pixel is ``backgroundPixel''.
Widget header files typically contain a symbolic name for each resource name.
All resource names, classes, and types used by the Intrinsics are named in
the file
.Pn < X11/StringDefs.h >.
The Intrinsic's symbolic resource names begin with 
.PN XtN 
and are followed by the string name (for example, XtNbackgroundPixel 
for ``backgroundPixel'').
.LP
A resource class offers two functions: 
.IP \(bu 5
It isolates you from different representations that widgets can use for a 
similar resource.
.IP \(bu 5
It lets you specify values for several actual resources with a single name.
A resource class should be chosen to span a group of closely-related fields.
.LP
For example, 
a widget can have several pixel resources: background, foreground,
border, block cursor, pointer cursor, and so on.
Typically, the background defaults to ``white'' 
and everything else to ``black''.
The resource class for each of these resources in the resource list
should be chosen so that it takes the minimal number of entries 
in the resource database to make background ``offwhite'' 
and everything else ``darkblue''.
.LP
In this case, the background pixel should have a resource class of 
.PN Background 
and all the other pixel entries a resource class of 
.PN Foreground .
Then, the resource file needs just two lines to
change all pixels to ``offwhite'' or ``darkblue'':
.LP
.Ds 0
.TA .5i 1.5i
.ta .5i 1.5i
Background:	offwhite
Foreground:	darkblue
.De
.LP
Similarly, a widget may have several resource fonts (such as normal and bold), 
but all fonts should have the class Font.
Thus, to change all fonts, simply requires a single line in the default file:
.LP
.Ds 0
.TA .5i 3i
.ta .5i 3i
Font:	6x13
.De
.LP
By convention, 
resource classes are always spelled starting with a capital letter.
Their symbolic names are preceded with 
.PN XtC  
(for example, XtCBackground).
.LP
The resource_type field is the physical representation type of the resource.
By convention, it starts with an upper-case letter and is
spelled identically to the type name of the field.
The resource type is used when resources are fetched, to
convert from the resource database format (usually String) or the default
resource format (just about anything, but often String) to the desired
physical representation (see ``Resource Conversions'').
The Intrinsics define the following resource types:
.TS
lw(2.75i) lw(2.75i).
T{
.PN XtRBoolean 
T}	T{
.PN XtRGeometry
T}
T{
.PN XtRLongBoolean 
T}	T{
.PN XtRInt 
T}
T{
.PN XtRCallback
T}	T{
.PN XtRJustify 
T}
T{
.PN XtRColor 
T}	T{
.PN XtROrientation
T}
T{
.PN XtRCursor 
T}	T{
.PN XtRPixel
T}
T{
.PN XtRDefaultColor 
T}	T{
.PN XtRPixmap
T}
T{
.PN XtRDisplay 
T}	T{
.PN XtRPointer
T}
T{
.PN XtREditMode 
T}	T{
.PN XtRString
T}
T{
.PN XtRFile 
T}	T{
.PN XtRStringTable
T}
T{
.PN XtRFloat
T}	T{
.PN XtRTranslationTable
T}
T{
.PN XtRFont
T}	T{
.PN XtRWidget
T}
T{
.PN XtRFontStruct 
T}	T{
.PN XtRWindow
T}
.PN XtRFunction 
.TE
.LP
The resource_size field is the size of the physical representation in bytes
and normally should be specified as ``sizeof(\fItype\fP)'' so that the
compiler fills in the value.
.LP
The resource_offset is the offset in bytes of the field within the widget.
The 
.PN XtOffset
macro should be used to retrieve this value.
.LP
The default_type field is the representation type of the default 
resource value.
If default_type is different from resource_type and the default_type is needed,
the resource manager invokes a conversion procedure from default_type 
to resource_type.
Whenever possible, 
the default type should be identical to the resource type in order 
to minimize widget creation time.
.LP
The default_address field is the address of the default resource value.
The default is used only if a resource is not specified in the argument list 
or in the resource database.
.LP
The routines
.PN XtSetValues
and
.PN XtGetValues
also use the resource list to set and get widget state.
For further information, see ``Obtaining Widget State'' 
and ``Setting Widget State''.
.LP
Here is an abbreviated version of the resource list in the Label widget:
.LP
.Ds 0
.TA .5i 1.5 3i
.ta .5i 1.5 3i
/* Resources specific to Label */
static XtResource resources[] = {
	{XtNforeground, XtCForeground, XtRPixel, sizeof(Pixel),
	   XtOffset(LabelWidget, label.foreground), XtRString, "Black"},
	{XtNfont,  XtCFont, XtRFontStruct, sizeof(XFontStruct *),
 	   XtOffset(LabelWidget, label.font),XtRString, "Fixed"},
	{XtNlabel,  XtCLabel, XtRString, sizeof(String),
	   XtOffset(LabelWidget, label.label), XtRString, NULL},
		.
		.
		.
}
.De
.LP
The complete resource name for a field of a widget instance is the
concatenation of the application name (from argv[0]) or the \-name
command-line option (see
.PN XtInitialize ),
the instance names of all the widget's parents, 
the instance name of the widget itself, 
and the resource name of the specified field of the widget.
Likewise,
the full resource class of a field of a widget instance is the
concatenation of the application class (from
.PN XtInitialize ),
the widget class names of all the widget's parents
(not the superclasses), the widget class name of the widget itself,
and the resource name of the specified field of the widget.
.NH 2
Determining the Byte Offset
.XS
\*(SN Determining the Byte Offset
.XE
.LP
To determine the byte offset of a field within a structure, use
.PN XtOffset .
.IN "XtOffset" "" "@DEF@"
.FD 0
Cardinal XtOffset(\fIpointer_type\fP, \fIfield_name\fP)
.br
      Type \fIpointer_type\fP;
.br
      Field \fIfield_name\fP;
.FN
.IP \fIpointer_type\fP 1i
Specifies a type that is declared as a pointer to the structure.
.IP \fIfield_name\fP 1i
Specifies the name of the field for which to calculate the byte offset.
.LP
.PN XtOffset
is usually used to determine the offset of various resource fields from the 
beginning of a widget.
.NH 2
Determining the Number of Elements
.XS
\*(SN Determining the Number of Elements
.XE
.LP
To determine the number of elements in a fixed-size array, use
.PN XtNumber .
.IN "XtNumber" "" "@DEF@"
.FD 0
Cardinal XtNumber(\fIarray\fP)
.br
      ArrayVariable \fIarray\fP;
.FN
.IP \fIarray\fP 1i
Specifies a fixed-size array.
.LP
.PN XtNumber
is used to pass the number of elements in argument lists, resources lists, 
and other counted arrays.
.NH 2
Superclass to Subclass Chaining of Resource Lists
.XS
\*(SN Superclass to Subclass Chaining of Resource Lists
.XE
.LP
.IN "Inheritance"
.IN "Superclass Chaining"
.IN "Chaining"
The procedure
.PN XtCreateWidget
gets resources as a ``superclass-to-subclass'' operation.
That is, the resources specified in Core's resource list are fetched, 
then those in the subclass, and so on down to the resources specified 
for this widget's class.
.LP
In general, if a widget resource field is declared in a superclass,
that field is included in the superclass's resource list and need not be
included in the subclass's resource list.
For example, the 
Core class contains a resource entry for background_pixel.
Consequently, 
the implementation of ``Label'' need not also have a resource entry 
for background_pixel.
However, a subclass, 
just by specifying a resource entry for that field in its own resource list,
can override the resource entry for any field declared in a superclass.
This is most often done to override the defaults provided in the
superclass with new ones.
.NH 2
Obtaining Subresources
.XS
\*(SN Obtaining Subresources
.XE
.LP
A widget does not do anything to get its own resources.
Instead,
.PN XtCreateWidget
does this automatically before calling the class initialize procedure.
.LP
Some widgets have subparts that are not widgets but for which the widget 
would like to fetch resources.
For example, the Text widget fetches resources for its source and sink.
Such widgets call
.PN XtGetSubresources
to accomplish this.
.IN "XtGetSubresources" "" "@DEF@"
.FD 0
void XtGetSubresources(\fIw\fP, \fIbase\fP, \fIname\fP, \fIclass\fP, \
\fIresources\fP, \fInum_resources\fP, \fIargs\fP, \fInum_args\fP)
.br
      Widget \fIw\fP;
.br
      caddr_t \fIbase\fP;
.br
      String \fIname\fP;
.br
      String \fIclass\fP;
.br
      XtResourceList \fIresources\fP;
.br
      Cardinal \fInum_resources\fP;
.br
      ArgList \fIargs\fP;
.br
      Cardinal \fInum_args\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget that wants resources for a subpart.
.IP \fIbase\fP 1i
Specifies the base address of the subpart data structure where the resources
should be written.
.IP \fIname\fP 1i
Specifies the name of the subpart.
.IP \fIclass\fP 1i
Specifies the class of the subpart.
.IP \fIresources\fP 1i
Specifies the resource list for the subpart.
.IP \fInum_resources\fP 1i
Specifies the number of resources in the resource list.
.IP \fIargs\fP 1i
Specifies the argument list to override resources obtained from the resource
database.
.IP \fInum_args\fP 1i
Specifies the number of arguments in the argument list.  
If the specified args is NULL, 
num_args must be zero (0).
However, if num_args is zero (0),
args is not referenced.
.LP
.PN XtGetSubresources
constructs a name/class list from the application name/class, 
the name/classes of all its ancestors, and the widget itself.
Then, it appends to this list the name/class pair passed in.
The resources are fetched from the argument list, the resource database, 
or the default values in the resource list.
Then, they are copied into the subpart record.
.NH 2
Obtaining Application Resources
.XS
\*(SN Obtaining Application Resources
.XE
.LP
To retrieve resources that are not specific to a widget
but apply to the overall application, use
.PN XtGetApplicationResources .
.IN "XtGetApplicationResources" "" "@DEF@"
.FD 0
void XtGetApplicationResources(\fIw\fP, \fIbase\fP, \fIresources\fP, \
\fInum_resources\fP, \fIargs\fP, \fInum_args\fP)
.br
      Widget \fIw\fP;
.br
      caddr_t \fIbase\fP;
.br
      XtResourceList \fIresources\fP;
.br
      Cardinal \fInum_resources\fP;
.br
      ArgList \fIargs\fP;
.br
      Cardinal \fInum_args\fP;
.FN
.IP \fIw\fP 1i
Is currently ignored and can be specified as NULL.
.IP \fIbase\fP 1i
Specifies the base address of the subpart data structure where the resources
should be written.
.IP \fIresources\fP 1i
Specifies the resource list for the subpart.
.IP \fInum_resources\fP 1i
Specifies the number of resources in the resource list.
.IP \fIargs\fP 1i
Specifies the argument list to override resources obtained from the resource
database.
.IP \fInum_args\fP 1i
Specifies the number of arguments in the argument list.
If the specified args is NULL,
num_args must be zero (0).
However, if num_args is zero (0),
args is not referenced.
.LP
.PN XtGetApplicationResources
first reconstructs the application name and class
and then retrieves the resources from the argument list, 
the resource database, or the resource list default values.
After adding base to each address,
the resources are copied into the address given in the resource list.
.NH 2
Resource Conversions
.XS
\*(SN Resource Conversions
.XE
.LP
The \*(tk provides a mechanism for registering representation converters that
are automatically invoked by the resource fetching routines.
The \*(tk additionally provides and registers several commonly used converters.
.LP
This resource conversion mechanism serves several purposes:
.IP \(bu 5
It permit user and application resource files to contain ASCII 
representations of non-textual values.
.IP \(bu 5
It allows textual or other representations of default resource values that
are dependent upon the display, screen, or color map, and thus must be
computed at run-time.
.IP \(bu 5
It caches all conversion source and result data.
Conversions that require much computation or space 
(for example, string to translation table), 
or that require round trips to the server 
(for example, string to font or color) are performed only once.
.NH 3
Predefined Resource Converters
.XS
\*(SN Predefined Resource Converters
.XE
.LP
The \*(tk defines all the representations
used in the Core, Composite, Constraint, and Shell widgets. 
Furthermore, 
it registers resource converters from string to all these representations.
.LP
The \*(tk registers converters for 
.PN XtRString 
to the following representations:
.TS
lw(2.75i) lw(2.75i).
T{
.PN XtRBoolean
T}	T{
.PN XtRFont
T}
T{
.PN XtRLongBoolean
T}	T{
.PN XtRFontStruct
T}
T{
.PN XtRCursor
T}	T{
.PN XtInt
T}
T{
.PN XtRDisplay
T}	T{
.PN XtPixel
T}
.PN XtRFile
.TE
.\"LP
.\"The \*(tk registers converters for XtRInt to the following representations:
.\"XtRBoolean, XtRLongBoolean, XtRPixel.
.\".LP
.\"The \*(tk registers converters for XtRPixel to the following
.\"representations:
.\"XtRColor.
.NH 3
Writing a New Resource Converter
.XS
\*(SN Writing a New Resource Converter
.XE
.LP
Type converters use pointers to 
.PN XrmValue 
structures (defined in 
.PN X11/Xresource.h )
for input and output values.
.LP
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct {
	unsigned int \fIsize\fP;
	caddr_t \fIaddr\fP;
} XrmValue, *XrmValuePtr;
.De
.LP
A resource converter is a procedure of type 
.PN XtConverter :
.IN "XtConverter" "" "@DEF@"
.FD 0
typedef void (*XtConverter)();
.sp
void \fIConverter\fP(\fIargs\fP, \fInum_args\fP, \fIfrom\fP, \fIto\fP)
.br
      XrmValue *\fIargs\fP;
.br
      Cardinal *\fInum_args\fP;
.br
      XrmValue *\fIfrom\fP;
.br
      XrmValue *\fIto\fP;
.FN
.IP \fIargs\fP 1i
Specifies a list of additional 
.PN XrmValue 
arguments to the converter if additional context is needed 
to perform the conversion.
For example, the string to font converter needs the widget's screen,
or the string to pixel converter needs the widget's screen and color map.
This argument is often NULL.
.IP \fInum_args\fP 1i
Specifies the number of additional XrmValue arguments.
This argument is often 0.
.IP \fIfrom\fP 1i
Specifies the value to convert.
.IP \fIto\fP 1i
Specifies the descriptor to use to return the converted value.
.LP
Type converters should perform the following actions:
.IP \(bu 5
Check to see that the number of arguments passed is correct.
.IP \(bu 5
Attempt the type conversion.
.IP \(bu 5
If successful, return a pointer to the data in the to parameter.
Otherwise, optionally call 
.PN XtWarning 
and return.
.LP
Most type converters just take the data described by the specified from 
argument and return data by writing into the specified to argument.
A few need other information, which is available in the specified args.
.LP
A type converter can invoke another type converter.
This allows differing sources which may convert into a common intermediate 
result to make maximum use of the type converter cache.
.LP
Note that the address written to to.addr cannot be a local variable of 
the converter because this will disappear when the converter returns.
It should be a pointer to a static variable,
as in the following example where screenColor is returned.
.LP
The following is an example of a converter that takes a string 
and converts it to a Pixel:
.LP
.Ds 0
.TA .5i 1.5i 3i
.ta .5i 1.5i 3i
static void CvtStringToPixel(args, num_args, fromVal, toVal)
	XrmValuePtr args;
	Cardinal *num_args;
	XrmValuePtr fromVal;
	XrmValuePtr toVal;
{
	static XColor screenColor;
	XColor exactColor;
	Screen *screen;
	Colormap colormap;
	Status status;
	char message[1000];

	if (*num_args != 2)
	XtError("String to pixel conversion needs screen and colormap arguments");

	screen = *((Screen **) args[0].addr);
	colormap = *((Colormap *) args[1].addr);

	status = XAllocNamedColor(DisplayOfScreen(screen), colormap,
	  (String) fromVal->addr, &screenColor, &exactColor);
	if (status == 0) {
 	  sprintf(message, "Cannot allocate colormap entry for %s",
	    (String) fromVal->addr);
	XtWarning(message);
	} else {
	  (*toVal).addr = &(screenColor.pixel);
	  (*toVal).size = sizeof(Pixel);
	}
};
.De
.NH 3
Registering a New Resource Converter
.XS
\*(SN Registering a New Resource Converter
.XE
.LP
To register a new converter, use the procedure
.PN XtAddConverter .
.IN "XtAddConverter" "" "@DEF@"
.FD 0
void XtAddConverter(\fIfrom_type\fP, \fIto_type\fP, \fIconverter\fP, \fIconvert_args\fP, \fInum_args\fP)
.br
    String \fIfrom_type\fP;
.br
    String \fIto_type\fP;
.br
    XtConverter \fIconverter\fP;
.br
    XtConvertArgList \fIconvert_args\fP;
.br
    Cardinal \fInum_args\fP;
.FN
.IP \fIfrom_type\fP 1i
Specifies the source type.
.IP \fIto_type\fP 1i
Specifies the destination type.
.IP \fIconverter\fP 1i
Specifies the type converter procedure.
.IP \fIconvert_args\fP 1i
Specifies how to compute the additional arguments to the converter.
Most type converters have none, so convert_args is NULL.
.IP \fInum_args\fP 1i
Specifies the number of additional arguments to the converter.
Most type converters have none, so num_args is 0.
.LP
For the few type converters that need additional arguments,
the \*(tk conversion mechanism provides a method of specifying 
how these arguments should be computed.
The enumerated type 
.PN XtAddressMode 
and the structure
.PN XtConvertArgRec 
specify how each argument is derived.
These are defined in the
.Pn < X11/Convert.h >
header file.
.LP
.Ds 0
.TA .5i 2.5i
.ta .5i 2.5i
typedef enum {
	/* address mode	parameter representation */
	   XtAddress,	/* address */
	   XtBaseOffset,	/* offset */
	   XtImmediate,	/* constant */
	   XtResourceString,	/* resource name string */
	   XtResourceQuark	/* resource name quark */
} XtAddressMode;

typedef struct {
	XtAddressMode address_mode;
	caddr_t address_id;
	Cardinal size;
} XtConvertArgRec, *XtConvertArgList;
.De
The address_mode field specifies how the address_id field should be 
interpreted.
.PN XtAddress 
causes address_id to be interpreted as the address of the data.
.PN XtBaseOffset 
causes address_id to be interpreted as the offset from the widget base.
.PN XtImmediate
causes address_id to be interpreted as a 4-byte constant.
.PN XtResourceString
causes address_id to be interpreted as the name of a resource 
that is to be converted into an offset from widget base.
.PN XtResourceQuark 
is an internal compiled form of an
.PN XtResourceString .
.LP
The size field specifies the length of the data in bytes.
.LP
Here is the code used to register the CvtStringToPixel routine shown above:
.LP
.Ds 0
.TA .5i 3i
.ta .5i 3i
static XtConvertArgRec colorConvertArgs[] = {
	{XtBaseOffset, (caddr_t) XtOffset(Widget, core.screen),  sizeof(Screen *)},
	{XtBaseOffset, (caddr_t) XtOffset(Widget, core.colormap),sizeof(Colormap)}
};

XtAddConverter(XtRString, XtRPixel, CvtStringToPixel,
    colorConvertArgs, XtNumber(colorConvertArgs));
.De
.LP
The conversion argument descriptors colorConvertArgs and screenConvertArg are
predefined for you.
The screenConvertArg descriptor puts the widget's screen field into args[0].
The colorConvertArgs descriptor puts the widget's screen field into args[0], 
and the widget's colormap field into args[1].
.LP
It might seem easier to just create a descriptor that puts the widget's base
address into args[0], and do your own indexing off that in the conversion 
routine.
But you should not.
If you constrain the dependencies of your conversion procedure to the minimum
possible, 
you improve the chance that subsequent conversions will find what they need 
in the conversion cache. 
Then, you decrease the size of the cache by having fewer but more 
widely applicable entries.
.NH 3
Invoking Resource Converters
.XS
\*(SN Invoking Resource Converters
.XE
.LP
All resource-fetching routines (for example,
.PN XtGetSubresources ,
.PN XtGetApplicationResources ,
and so on) call resource converters if the user specifies a resource
that is a different representation from the desired representation, or if the
widget's default resource value representation is different from the desired
representation.
.sp
.LP
To invoke resource conversions, use
.PN XtConvert
or
.PN XtDirectConvert .
.LP
.sp
The definition for 
.PN XtConvert
is:
.IN "XtConvert" "" "@DEF@"
.FD 0
void XtConvert(\fIw\fP, \fIfrom_type\fP, \fIfrom\fP, \fIto_type\fP, \
\fIto_return\fP)
.br
    Widget \fIw\fP;
.br
    String \fIfrom_type\fP;
.br
    XrmValuePtr \fIfrom\fP;
.br
    String \fIto_type\fP;
.br
    XrmValuePtr \fIto_return\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget to use for additional arguments (if any are needed).
.IP \fIfrom_type\fP 1i
Specifies the name of the source type.
.IP \fIfrom\fP 1i
Specifies the value to be converted.
.IP \fIto_type\fP 1i
Specifies the name of the destination type.
.IP \fIto_return\fP 1i
Returns the converted value.
.LP
.PN XtConvert
looks up the type converter registered to convert from_type to to_type and
computes any additional arguments needed.
It then calls
.PN XtDirectConvert .
.LP
.sp
The definition for
.PN XtDirectConvert
is:
.IN "XtDirectConvert" "" "@DEF@"
.FD 0
void XtDirectConvert(\fIconverter\fP, \fIargs\fP, \fInum_args\fP, \fIfrom\fP, \
\fIto_return\fP)
.br
    XtConverter \fIconverter\fP;
.br
    XrmValuePtr \fIargs\fP;
.br
    Cardinal \fInum_args\fP;
.br
    XrmValuePtr \fIfrom\fP;
.br
    XrmValuePtr \fIto_return\fP;
.FN
.IP \fIconverter\fP 1i
Specifies the widget to use for additional arguments (if any are needed).
.IP \fIargs\fP 1i
Specifies the additional arguments needed
to perform the conversion (often NULL).
.IP \fInum_args\fP 1i
Specifies the number of additional arguments (often 0).
.IP \fIfrom\fP 1i
Specifies the value to be converted.
.IP \fIto_return\fP 1i
Returns the converted value.
.LP
.PN XtDirectConvert
looks in the converter cache to see if this conversion procedure 
has been called with the specified arguments.
If so, it just returns a descriptor for information stored in the cache.
Otherwise, it calls the converter and enters the result in the cache.
.NH 2
Reading and Writing Widget State
.XS
\*(SN Reading and Writing Widget State
.XE
.LP
Any resource field in a widget can be read or written by a client.
On a write,
the widget decides what changes it will actually allow and updates all
derived fields appropriately.
.NH 3
Obtaining Widget State
.XS
\*(SN Obtaining Widget State
.XE
.LP
To retrieve the current value of a resource associated with a
widget instance, use 
.PN XtGetValues .
.IN "XtGetValues" "" "@DEF@"
.FD 0
void XtGetValues(\fIw\fP, \fIargs\fP, \fInum_args\fP)
.br
      Widget \fIw\fP;
.br
      ArgList \fIargs\fP;
.br
      Cardinal \fInum_args\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.IP \fIargs\fP 1i
Specifies a variable length argument list of name/address
pairs that contain the resource name and the address to store the resource
value into.
The argument names in args are dependent on the widget.
.IP \fInum_args\fP 1i
Specifies the number of arguments in argument list.
.LP
.PN XtGetValues
starts with the resources specified for the core widget fields
and proceeds down the subclass chain to the widget.
.LP
The value field of a passed Arg should contain the
address into which to store the corresponding resource value.
.LP
If the widget's parent is a subclass of 
.PN constraintWidgetClass ,
.PN XtGetValues
then fetches the values for any constraint resources requested.
It starts with the constraint resources specified for 
.PN constraintWidgetClass 
and proceeds down to the subclass chain to the parent's constraint resources.
.LP
.IN "hook"
Finally, the get_values_hook procedures, if non-NULL, are called in
superclass-to-subclass order after all the resource values have been fetched by 
.PN XtGetValues .
This permits a subclass to provide non-widget resource data by means of the 
GetValues mechanism.
.NH 4
Widget Subpart Resource Data: the get_values_hook procedure
.XS
\*(SN Widget Subpart Resource Data: the get_values_hook procedure
.XE
.LP
Widgets that have subparts can return the resource values by using
.PN XtGetValues
and supplying a get_values_hook procedure.
The get_values_hook procedure is of type
.PN XtArgsProc :
.IN "get_values_hook procedure" "" "@DEF@"
.FD 0
void \fIget_values_hook\fP(\fIw\fP, \fIargs\fP, \fInum_args\fP)
.br
     Widget \fIw\fP;
.br
     ArgList \fIargs\fP;
.br
     Cardinal *\fInum_args\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget whose non-widget resource values are to be retrieved.
.IP \fIargs\fP 1i
Specifies the argument list that was passed to
.PN XtCreateWidget .
.IP \fInum_args\fP 1i
Specifies the number of arguments in the argument list.
.NH 4
Obtaining Widget Subpart State
.XS
\*(SN Obtaining Widget Subpart State
.XE
.LP
To retrieve the current value of a non-widget resource data associated with a
widget instance, use 
.PN XtGetSubvalues .
For a discussion of non-widget subclass resources resources, 
see ``Obtaining Subresources''.
.IN "XtGetSubvalues" "" "@DEF@"
.FD 0
void XtGetSubvalues(\fIbase\fP, \fIresources\fP, \fInum_resources\fP, \
\fIargs\fP, \fInum_args\fP)
.br
      caddr_t \fIbase\fP;
.br
      XtResourceList \fIresources\fP;
.br
      Cardinal \fInum_resources\fP;
.br
      ArgList \fIargs\fP;
.br
      Cardinal \fInum_args\fP;
.FN
.IP \fIbase\fP 1i
Specifies the base address of the subpart data structure from which 
the resources should be retrieved.
.IP \fIresources\fP 1i
Specifies the non-widget resources list.
.IP \fInum_resources\fP 1i
Specifies the number of resources in the resource list.
.IP \fIargs\fP 1i
Specifies a variable length argument list of name/address
pairs that contain the resource name and the address to store the resource
value into.
The arguments and values passed in args are dependent on
the subpart.
The storage for argument values that are pointed to by
args must be deallocated by the application when no longer needed.
.IP \fInum_args\fP 1i
Specifies the number of arguments in argument list.
.NH 3
Setting Widget State
.XS
\*(SN Setting Widget State
.XE
.LP
To modify the current value of a resource associated with a widget
instance, use 
.PN XtSetValues .
.IN "XtSetValues" "" "@DEF@"
.FD 0
void XtSetValues(\fIw\fP, \fIargs\fP, \fInum_args\fP)
.br
      Widget \fIw\fP;
.br
      ArgList \fIargs\fP;
.br
      Cardinal \fInum_args\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget.
.IP \fIargs\fP 1i
Specifies a variable length argument list of name/value
pairs that contain the resources to be modified and their new
values.
The resources and values passed are dependent on
the widget being modified.
.IP \fInum_args\fP 1i
Specifies the number of resources in the argument list.
.LP
.PN XtSetValues
starts with the resources specified for the core widget
fields and proceeds down the subclass chain to the widget.
At each stage, 
it writes the new value (if specified by one of the arguments) or the existing
value (if no new value is specified) to a new widget data record.
.LP
.PN XtSetValues
then calls the set_values procedures for the widget in
``superclass-to-subclass'' order. 
.IN "hook"
If the widget has non-NULL set_values_hook fields, 
these are called with the arguments immediately after the
corresponding set_values procedure.
This procedure permits subclasses to set non-widget data using the 
SetValues mechanism.
.LP
If the widget's parent is a subclass of 
.PN constraintWidgetClass , 
.PN XtSetValues 
also updates the widget's constraints.
It starts with the constraint resources specified for 
.PN constraintWidgetClass
and proceeds down the subclass chain to the parent's class.
At each stage,
it writes the new value or the existing value to a new constraint record.
It then calls the constraint set_values procedures from 
.PN constraintWidgetClass 
down to the parent's class.
The constraint set_values procedures are called with widget arguments
(as for all set_values procs, not just the constraint record arguments), 
so that they can make adjustments to the desired values based 
on full information about the widget.
.LP
.PN XtSetValues
determines if a geometry request is needed by comparing the current widget to 
the new widget.
If any geometry changes are required, 
it makes the request, and the geometry manager returns
.PN XtGeometryYes , 
.PN XtGeometryAlmost , 
or 
.PN XtGeometryNo .
If 
.PN XtGeometryYes , 
.PN XtSetValues 
calls the widget's resize procedure.
If 
.PN XtGeometryNo , 
.PN XtSetValues 
resets the geometry fields to their original values.
If 
.PN XtGeometryAlmost ,
.PN XtSetValues 
calls the set_values_almost procedure, 
which determines what should be done and writes new values for the
geometry fields into the new widget. 
.PN XtSetValues
then repeats this process, 
deciding once more whether the geometry manager should be called.
.LP
Finally, if any of the set_values procedures returned TRUE,
.PN XtSetValues
causes the widget's expose procedure to be invoked by calling
.PN XClearArea
on the widget's window.
.NE
.NH 4
Widget State: the set_values procedure
.XS
\*(SN Widget State: the set_values procedure
.XE
.LP
The set_values procedure for a widget class is of type
.PN XtSetValuesFunc :
.IN "XtSetValuesFunc" "" "@DEF@"
.IN "set_values procedure" "" "@DEF@"
.FD 0
typedef Boolean (*XtSetValuesFunc)();
.sp
Boolean \fISetValuesFunc\fP(\fIcurrent\fP, \fIrequest\fP, \fInew\fP)
.br
      Widget \fIcurrent\fP;
.br
      Widget \fIrequest\fP;
.br
      Widget \fInew\fP;
.FN
.IP \fIcurrent\fP 1i
Specifies the existing widget.
.IP \fIrequest\fP 1i
Specifies a copy of the widget asked for by the
.PN XtSetValues
call before any class set_values procedures have been called.
.IP \fInew\fP 1i
Specifies a copy of the widget with the new values that are actually allowed.
.LP
The set_values procedure should recompute any field 
derived from resources that are changed 
(for example, many GCs depend upon foreground and background).
If no recomputation is necessary and if none of the resources specific to a
subclass require the window to be redisplayed when their values are changed, 
then you can specify NULL for the set_values field in the class record.
.LP
Like the initialize procedure,
set_values mostly deals only with the fields defined in the subclass, 
but it has to resolve conflicts with its superclass, 
especially conflicts over width and height.
In this case, though, the ``reference'' widget is ``request'', 
not ``new''.
.LP
``New'' starts with the values of ``request'' but has been modified by
any superclass set_values procedures.
A widget need not refer to ``request'' unless it must resolve conflicts
between ``current'' and ``new''.
Any changes that the widget wishes to make should be made in ``new''.
.PN XtSetValues 
will copy the ``new'' values back into the ``current'' widget instance record 
after all class set_values procedures have been called.
.LP
Finally, the set_values procedure must return a Boolean that indicates whether
the widget needs to be redisplayed.
Note that a change in the geometry fields alone does not require
the set_values procedure to return TRUE;
the X server will eventually generate an 
.PN Expose 
event, if necessary.
After calling all the set_values procedures,
.PN XtSetValues
will force a redisplay (by calling
.PN XClearArea )
if any of the set_values procedures returned TRUE.
Therefore, a set_values procedure should not try to do its own redisplaying.
.LP
It is permissible to call
.PN XtSetValues 
before a widget is realized.
Therefore, the set_values proc must not assume that the widget is realized.
.NH 4
Widget State: the set_values_almost procedure
.XS
\*(SN Widget State: the set_values_almost procedure
.XE
.LP
The set_values_almost procedure for a widget class is of type
.PN XtAlmostProc :
.IN "set_values_almost procedure" "" "@DEF@"
.IN "XtAlmostProc" "" "@DEF@"
.FD 0
typedef void (*XtAlmostProc)();
.sp
void \fIAlmostProc\fP(\fIw\fP, \fInew_widget\fP, \fIrequest\fP, \fIreply\fP)
.br
      Widget \fIw\fP;
.br
      Widget \fInew_widget\fP;
.br
      XtWidgetGeometry *\fIrequest\fP;
.br
      XtWidgetGeometry *\fIreply\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget on which the geometry change is requested.
.IP \fInew_widget\fP 1i
The return value, with relevant geometry fields modified based on the
geometry requests.
.IP \fIrequest\fP 1i
Specifies the original geometry request that was sent to the geometry
manager that returned 
.PN XtGeometryAlmost .
.IP \fIreply\fP 1i
Specifies the compromise geometry that was returned by the geometry
manager that returned 
.PN XtGeometryAlmost .
.LP
Most classes inherit this operation from their superclass by
copying the Core set_values_almost procedure in their class_initialize 
procedure.
The Core's set_values_almost procedure simply accepts the compromise suggested.
.LP
The set_values_almost procedure is called when a client tries to set a widget's
geometry by means of a call to 
.PN XtSetValues , 
and the geometry manager cannot
satisfy the request but instead returns 
.PN XtGeometryAlmost 
and a compromise geometry.
The set_values_almost procedure takes the original geometry and the
compromise geometry and determines whether the compromise is acceptable or a
different compromise might work.
It returns its results in the new_widget parameter, 
which will then be sent back to the geometry manager for another try.
.NH 4
Widget State: the constraint set_values procedure
.XS
\*(SN Widget State: the constraint set_values procedure
.XE
.IN "set_values procedure"
.IN "XtSetValuesProc"
.LP
The constraint set_values procedure is of type
.PN XtSetValuesFunc .
The values passed to the parent's constraint set_values procedure 
are the same as those passed to the child's class
set_values procedure.
A class can specify NULL for the set_values field of the 
.PN ConstraintPart 
if it need not compute anything.
.LP
The constraint set_values procedure should recompute any constraint fields
derived from constraint resource that are changed.
Further, it should modify the widget fields as appropriate.
For example, if a constraint for the maximum height of a widget is changed 
to a value smaller than the widget's current height, 
the constraint set_values procedure should reset the height field in the
widget.
.NH 4
Setting Widget Subpart State
.XS
\*(SN Setting Widget Subpart State
.XE
.LP
To set the current value of a non-widget resource associated with a
widget instance, use 
.IN "XtSetSubresources"
.PN XtSetSubvalues .
For a discussion of non-widget subclass resources, 
see ``Obtaining Subresources''.
.IN "XtSetSubvalues" "" "@DEF@"
.FD 0
void XtSetSubvalues(\fIbase\fP, \fIresources\fP, \fInum_resources\fP, \
\fIargs\fP, \fInum_args\fP)
.br
      caddr_t \fIbase\fP;
.br
      XtResourceList \fIresources\fP;
.br
      Cardinal \fInum_resources\fP;
.br
      ArgList \fIargs\fP;
.br
      Cardinal \fInum_args\fP;
.FN
.IP \fIbase\fP 1i
Specifies the base address of the subpart data structure where the resources
should be written.
.IP \fIresources\fP 1i
Specifies the current non-widget resources values.
.IP \fInum_resources\fP 1i
Specifies the number of resources in the resource list.
.IP \fIargs\fP 1i
Specifies a variable length argument list of name/value
pairs that contain the resources to be modified and their new values.
The resources and values passed are dependent on
the subpart of the widget being modified.
.IP \fInum_args\fP 1i
Specifies the number of resources in argument list.
.NH 4
Widget Subpart Resource Data: the set_values_hook procedure
.XS
\*(SN Widget Subpart Resource Data: the set_values_hook procedure
.XE
.IN "set_values_hook procedure"
.LP
Widgets that have a subpart can set the resource values by using
.PN XtSetValues
and supplying a set_values_hook procedure.
The set_values_hook procedure for a widget class is of type
.PN XtArgsFunc :
.IN "set_values_hook procedure" "" "@DEF@"
.IN "XtArgsFunc" "" "@DEF@"
.FD 0
typedef Boolean (*XtArgsFunc)();
.sp
Boolean \fIArgsFunc\fP(\fIw\fP, \fIargs\fP, \fInum_args\fP)
.br
     Widget \fIw\fP;
.br
     ArgList \fIargs\fP;
.br
     Cardinal *\fInum_args\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget whose non-widget resource values are to be changed.
.IP \fIargs\fP 1i
Specifies the argument list that was passed to
.PN XtCreateWidget .
.IP \fInum_args\fP 1i
Specifies the number of arguments in the argument list.
.bp
\&
.sp 1
.ce 3
\s+1\fBChapter 12\fP\s-1

\s+1\fBTranslation Management \- Handling User Input\fP\s-1
.sp 2
.nr H1 12
.nr H2 0
.nr H3 0
.nr H4 0
.nr H5 0
.LP
.XS
Chapter 12 Translation Management \- Handling User Input
.XE
Except under unusual circumstances,
widgets do not hardwire the mapping of user events into widget behavior 
by using the Event Manager.
Instead, they provide a user-overridable default mapping of events 
into behavior.
.LP
The translation manager provides an interface to specify and manage the
mapping of X Event sequences into widget-supplied functionality. 
The simplest example would be to call procedure Abc when key ``y'' is pressed.
.LP
The translation manager uses two kinds of tables to perform translations.
The ``action table'', which is in the widget class structure, 
specifies the mapping of externally available procedure name strings 
to the corresponding procedure implemented by the widget class.
The ``translation table'', which is in the widget class structure, 
specifies the mapping of event sequence to procedure names.
.LP
The translation table in the class structure can be over-ridden 
for a specific widget instance by supplying a different translation table
for the widget instance.
.NH 2 
Action Tables
.XS
\*(SN Action Tables
.XE
.LP
All widget class records contain an action table.
In addition, 
an application can register its own action tables with the translation manager,
so that the translation tables it provides to widget instances can access 
application functionality.
The translation action_proc procedure is of type
.PN XtActionProc :
.IN "action_proc procedure" "" "@DEF@"
.IN "XtActionProc" "" "@DEF@"
.FD 0
typedef void (*XtActionProc)();
.sp
void \fIActionProc\fP(\fIw\fP, \fIevent\fP, \fIparams\fP, \fInum_params\fP)
.br
      Widget \fIw\fP;
.br
      XEvent *\fIevent\fP;
.br
      String *\fIparams\fP;
.br
      Cardinal *\fInum_params\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget that caused the action to be called.
.IP \fIevent\fP 1i
Specifies the event that caused the action to be called.
If the action is called after a sequence of events, 
then the last event in the sequence is used.
.IP \fIparams\fP 1i
Specifies a pointer to the list of strings that were specified 
in the translation table as arguments to the action.
.IP \fInum_params\fP 1i
Specifies the number of arguments specified in the translation table.
.IN "XtActionsRec"
.IN "XtActionList"
.LP
.Ds 0
.TA .5i 3i
.ta .5i 3i
typedef struct _XtActionsRec {
	String action_name;
	XtActionProc action_proc;
} XtActionsRec, *XtActionList;
.De
The action_name field is the name that you use in translation tables to access
the procedure.
The action_proc field is a pointer to a procedure that implements 
the functionality.
.LP
For example, the Command widget has procedures to:
.IP \(bu 5
Set the command button to indicate it is activated
.IP \(bu 5
Unset the button back to its normal mode
.IP \(bu 5
Highlight the button borders
.IP \(bu 5
Unhighlight the button borders
.IP \(bu 5
Notify any callbacks that the button has been activated
.LP
The action table for the Command widget class makes these functions 
available to translation tables written for Command or any subclass.
The string entry is the name used in translation tables.
The procedure entry (usually spelled identically to the string) 
is the name of the C procedure that implements that function:
.LP
.IN "Action Table"
.Ds 0
.TA .5i 1.5i
.ta .5i 1.5i
XtActionsRec actionTable[] = {
	{"Set",	Set},
	{"Unset",	Unset},
	{"Highlight",	Highlight},
	{"Unhighlight",	Unhighlight}
	{"Notify",	Notify},
};
.De
.NH 3 
Registering Action Tables
.XS
\*(SN Registering Action Tables
.XE
.LP
To make functionality available by declaring an action
table and registering this with the translation manager, use 
.PN XtAddActions .
.IN "XtAddActions" "" "@DEF@"
.FD 0
void XtAddActions(\fIactions\fP, \fInum_actions\fP)
.br
      XtActionList \fIactions\fP;
.br
      Cardinal \fInum_actions\fP;
.FN
.IP \fIactions\fP 1i
Specifies the action table to register.
.IP \fInum_args\fP 1i
Specifies the number of entries in actions.
.LP
The \*(tk registers an action table for
.PN MenuPopup
and
.PN MenuPopdown
as part of \*(tk initialization.
.NH 3 
Translating Action Names to Procedures
.XS
\*(SN Translating Action Names to Procedures
.XE 
.LP
The translation manager uses a simple algorithm to convert the name of
procedure specified in a translation table into the actual procedure specified
in an action table.
It performs a search for the name in the following tables:
.IP \(bu 5
The widget's class action table for the name
.IP \(bu 5
The widget's superclass action table, and on up the superclass chain
.IP \(bu 5
The action tables registered with
.PN XtAddActions ,
from the most recently added table to the oldest table.
.LP
As soon as it finds a name, 
it stops the search.
If it cannot find a name,
the translation manager generates an error.
.NH 2 
Translation Tables
.XS
\*(SN Translation Tables
.XE
.LP
All widget instance records contain a translation table, 
which is a resource with no default value.
A translation table specifies what action procedures are invoked for
an event or a sequence of events.
It is a string containing a list of translations from an event 
(or event sequence) into one or more procedure calls. 
The translations are separated from one another by new-line characters
(ASCII LF).
.LP
For example, the default behavior of Command is:
.IP \(bu 5
Highlight on enter window
.IP \(bu 5
Unhighlight on exit window
.IP \(bu 5
Invert on left button down
.IP \(bu 5
Call callbacks and reinvert on left button up
.LP
Command's default translation table is:
.LP
.IN "Translation Table"
.Ds 0
.TA .5i 1.5i
.ta .5i 1.5i
static String defaultTranslations = 
	"<EnterWindow>:	Highlight()\\n\\
	<LeaveWindow>:	Unhighlight()\\n\\
	<Btn1Down>:	Set()\\n\\
	<Btn1Up>:	Notify() Unset()";
.De
.LP
For details on the syntax of translation tables, see Appendix B. 
.LP
The tm_table field of the 
.PN CoreClass 
record should be filled in at static initialization time with 
the string containing the class's default translations.
If a class wishes to just inherit its superclass's translations,
it can store the special value
.PN XtInheritTranslations
into tm_table.
After the class initialization procedures have been called,
the Intrinsics compile this translation table into an efficient internal form.
Then, at widget creation time, 
this default translation table will be used for any widgets 
that have not had their core translations field set by the
resource manager or the initialize procedures.
.LP
The resource conversion mechanism takes care of automatically compiling
string translation tables that are resources.
If a client uses translation tables that are not resources, 
it must compile them itself using
.PN XtParseTranslations .
.LP
The \*(tk uses the compiled form of the translation table to register the 
necessary events with the event manager.
Widgets need do nothing other than specify the action and translation tables 
for events to be processed by the translation manager.
.NH 2
Merging Translation Tables
.XS
\*(SN Merging Translation Tables
.XE
.LP
Sometimes an application needs to destructively or non-destructively add
its own translations to a widget's translation.
For example, a window manager provides functions to move a window.
It normally may moves the window when any pointer button is pressed down 
in a title bar.
It allows the user to specify other translations for the middle
or right button down in the title bar, 
but it ignores any user translations for left button down.
.LP
To accomplish this, 
the window manager first should create the title bar 
and then should merge the two translation tables into 
the title bar's translations.
One translation table contains the translations that the window manager 
wants only if the user has not specified a translation for a particular event
(or event sequence).
The other translation table contains the translations that the 
window manager wants regardless of what the user has specified.
.LP
Three \*(tk functions support this merging:
.TS
lw(2i) lw(3.75i).
T{
.PN XtParseTranslationTable
T}	T{
Compiles a translation table.
T}
.sp
T{
.PN XtAugmentTranslations 
T}	T{
Merges (non-destructively) a compiled translation table into a widget's
compiled translation table.
T}
.sp
T{
.PN XtOverrideTranslations
T}	T{
Merges destructively a compiled translation table into a widget's
compiled translation table.
T}
.TE
.sp
.LP
To compile a translation table, use
.PN XtParseTranslationTable .
.IN "XtParseTranslationTable" "" "@DEF@"
.FD 0
XtTranslations XtParseTranslationTable(\fItable\fP)
.br
      String \fItable\fP;
.FN
.IP \fItable\fP 1i
Specifies the translation table to compile.
.LP
.PN XtParseTranslationTable
compiles the translation table into the opaque internal representation 
(of type
.PN XtTranslations ).
.sp
.LP
To merge new translations into an existing translation table, use
.PN XtAugmentTranslations .
.IN "XtAugmentTranslations" "" "@DEF@"
.FD 0
void XtAugmentTranslations(\fIw\fP, \fItranslations\fP)
.br
      Widget \fIw\fP;
.br
      XtTranslations \fItranslations\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget to merge the new translations into.
.IP \fItranslations\fP 1i
Specifies the compiled translation table to merge in.
.LP
.PN XtAugmentTranslations
non-destructively merges the new translations into the existing widget
translations.
If the new translations contain an event or event sequence that
already exists in the widget's translations, 
the new translation is ignored.
.sp
.LP
To overwrite existing translations with new translations, use
.PN XtOverrideTranslations .
.IN "XtOverrideTranslations" "" "@DEF@"
.FD 0
void XtOverrideTranslations(\fIw\fP, \fItranslations\fP)
.br
      Widget \fIw\fP;
.br
      XtTranslations \fItranslations\fP;
.FN
.IP \fIw\fP 1i
Specifies the widget to merge the new translations into.
.IP \fItranslations\fP 1i
Specifies the compiled translation table to merge in.
.LP
.PN XtOverrideTranslations
destructively merges the new translations into the existing widget
translations.
If the new translations contain an event or event sequence that
already exists in the widget's translations, 
the new translation is merged in and override the widget's translation.
.bp
\&
.sp 1
.ce 3
\s+1\fBAppendix A\fP\s-1

\s+1\fBResource File Format\fP\s-1
.sp 2
.LP
.XS
Appendix A \- Resource File Format
.XE
A resource file contains text representing the default resource values for an
application or set of applications.
The resource file is an ASCII text file that consists of a number of lines 
with the following EBNF syntax:
.TS
l l .
Xdefault	= {line "\\\\n"}.
line	= (comment | production).
comment	= "!" string.
production	= resourcename ":" string.
resourcename	= ["*"] name {("." | "*") name}.
string	= {<any character not including eol>}.
name	= {"A"-"Z" | "a"-"z" | "0"-"9"}.
.TE
.LP
If the last character on a line is a backslash (\\),
that line is assumed to continue on the next line.
.LP
To include a new-line character in a string, use ``\\n''.
.bp
\&
.sp 1
.ce 3
\s+1\fBAppendix B\fP\s-1

\s+1\fBTranslation Table File Syntax\fP\s-1
.sp 2
.LP
.XS
Appendix B \- Translation Table File Syntax
.XE
.IN "Translation tables"
.LP
A translation table file is an ASCII text file.
.SH
Notation
.LP
Syntax is specified in EBNF notation, where:
.LP
	[ a ]
.LP
means either nothing or ``a''.
.LP
	{ a }
.LP
means 0 or more occurrences of ``a''
.LP
All terminals are enclosed in "double" quotes. Informal 
descriptions are enclosed in <angle> brackets.
.SH
Syntax
.LP
The syntax of the translation table file is:
.TS
l l .
translationTable	= [ production { "\\\\n" production } ]
production	= lhs ":" rhs
lhs	= ( event | keyseq ) { "," (event | keyseq) }
keyseq	= """ keychar {keychar} """
keychar	= [ "^" | "$" ] <ascii character>
event	= [modifier_list] "<"event_type">" [ "(" count["+"] ")" ] {detail}
modifier_list	= [!] modifier {modifier} | "None"
modifier	= [~] modifier_name
count	= (2 | 3 | 4 | ...)
modifier_name	= <see ModifierNames table below>
event_type	= <see Event Types table below>
detail	= <event specific details>
rhs	= { name "(" [params] ")" }
name	= namechar { namechar }
namechar	= { "a"-"z" | "A"-"Z" | "0"-"9" | "$" | "_" }
params	= string {"," string}.
string	= quoted_string | unquoted_string
quoted_string	= """ {<ascii character>} """
unquoted_string	= {<ascii character except space, tab, ",", newline, ")">}
.TE
Informally, 
the productions are an event specifier on the left (terminated with a colon) 
and a list of action specifications on the right (terminated with a newline).
.LP
The information on the left specifies the X Event, 
complete with modifiers and detail fields, 
while that on the right specifies what to do when that event is detected.
An action is the name of an exported function.
The parameters are strings.
.LP
It is often convenient to include newlines in a translation table to make it
more readable.
In C, the newline should be preceded by a backslash (\\):
.LP
.Ds
.TA .5i 1.5i
.ta .5i 1.5i
	"<Btn1Down>:	DoSomething()\\n\\
	<Btn2Down>:	DoSomethingElse()"
.De
.SH
Modifier Names
.LP
The Modifier field is used to specify normal X keyboard and button
modifier mask bits.
If the modifier_list has no entries and is not ``None'', 
it means ``don't care'' on all modifiers.
If any modifiers are specified, and ``!'' is not specified, 
it means that the listed modifiers must be in the
correct state and ``don't care'' about any other modifiers.
If ``!'' is specified at the beginning of the modifier list,
it means that the listed modifiers must be in the correct state 
and no other modifiers can be asserted.
If a modifier is preceded by a ``~'' it means that that modifier
must not be asserted.
If ``None'' is specified, it means no modifiers can be asserted.
Briefly:
.LP
.Ds 0
.TA 2.5i
.ta 2.5i
No Modifiers:	None <event> detail
Any Modifiers:	<event> detail
Only these Modifiers:	! mod1 mod2 <event> detail
These modifiers and any others:	mod1 mod2 <event> detail
.De
.TS H
l l.
_
.sp 6p
.TB
Modifier	Meaning
.sp 6p
_
.sp 6p
.TH
.R
c	Control Key
Ctrl	Control Key
s	Shift Key
Shift	Shift Key
m	Modifier 1
Meta	Modifier 1
l	Lock Key
Lock	Lock Key
1	Modifier 1
Mod1	Modifier 1
2	Modifier 2
Mod2	Modifier 2
3	Modifier 3
Mod3	Modifier 3
4	Modifier 4
Mod4	Modifier 4
5	Modifier 5
Mod5	Modifier 5
ANY	Any combination
.sp 6p
_
.TE
.SH
Event Types
.LP
The EventType field describes XEvent types.
The following are the currently defined EventType values:
.TS H
lw(1.5i) lw(3i).
_
.sp 6p
.TB
Type	Meaning
.sp 6p
_
.sp 6p
.TH
T{
Key
T}	T{
.PN KeyPress
T}
T{
KeyDown
T}	T{
.PN KeyPress
T}
T{
KeyUp
T}	T{
.PN KeyRelease
T}
T{
BtnDown
T}	T{
.PN ButtonPress
T}
T{
BtnUp
T}	T{
.PN ButtonRelease
T}
T{
Motion
T}	T{
.PN MotionNotify
T}
T{
BtnMotion
T}	T{
.PN MotionNotify
with any button down
T}
T{
Btn1Motion
T}	T{
.PN MotionNotify
with button 1 down
T}
T{
Btn2Motion
T}	T{
.PN MotionNotify
with button 2 down
T}
T{
Btn3Motion
T}	T{
.PN MotionNotify
with button 3 down
T}
T{
Btn4Motion
T}	T{
.PN MotionNotify
with button 4 down
T}
T{
Btn5Motion
T}	T{
.PN MotionNotify
with button 5 down
T}
T{
Enter
T}	T{
.PN EnterNotify
T}
T{
Leave
T}	T{
.PN LeaveNotify
T}
T{
FocusIn
T}	T{
.PN FocusIn
T}
T{
FocusOut
T}	T{
.PN FocusOut
T}
T{
Keymap
T}	T{
.PN KeymapNotify
T}
T{
Expose
T}	T{
.PN Expose
T}
T{
GrExp
T}	T{
.PN GraphicsExpose
T}
T{
NoExp
T}	T{
.PN NoExpose
T}
T{
Visible
T}	T{
.PN VisibilityNotify
T}
T{
Create
T}	T{
.PN CreateNotify
T}
T{
Destroy
T}	T{
.PN DestroyNotify
T}
T{
Unmap
T}	T{
.PN UnmapNotify
T}
T{
Map
T}	T{
.PN MapNotify
T}
T{
MapReq
T}	T{
.PN MapRequest
T}
T{
Reparent
T}	T{
.PN ReparentNotify
T}
T{
Configure
T}	T{
.PN ConfigureNotify
T}
.TE
.br
.ns
.TS
lw(1.5i) lw(3i).
T{
ConfReq
T}	T{
.PN ConfigureRequest
T}
T{
Grav
T}	T{
.PN GravityNotify
T}
T{
ResReq
T}	T{
.PN ResizeRequest
T}
T{
Circ
T}	T{
.PN CirculateNotify
T}
T{
CircReq
T}	T{
.PN CirculateRequest
T}
T{
Prop
T}	T{
.PN PropertyNotify
T}
T{
SelClr
T}	T{
.PN SelectionClear
T}
T{
SelReq
T}	T{
.PN SelectionRequest
T}
T{
Select
T}	T{
.PN SelectionNotify
T}
T{
Clrmap
T}	T{
.PN ColormapNotify
T}
T{
Message
T}	T{
.PN ClientMessage
T}
T{
Mapping
T}	T{
.PN MappingNotify
T}
.sp 6p
_
.TE
Supported Abbreviations:
.TS H
lw(1.5i) lw(3i).
_
.sp 6p
.TB
Abbreviation	Meaning
.sp 6p
_
.sp 6p
.TH
.R
T{
Ctrl
T}	T{
.PN KeyPress 
with control modifier
T}
T{
Meta
T}	T{
.PN KeyPress 
with meta modifier
T}
T{
Shift
T}	T{
.PN KeyPress 
with shift modifier
T}
T{
Btn1Down
T}	T{
.PN ButtonPress 
with Btn1 detail
T}
T{
Btn1Up
T}	T{
.PN ButtonRelease 
with Btn1 detail
T}
T{
Btn2Down
T}	T{
.PN ButtonPress 
with Btn2 detail
T}
T{
Btn2Up
T}	T{
.PN ButtonRelease
with Btn2 detail
T}
T{
Btn3Down
T}	T{
.PN ButtonPress 
with Btn3 detail
T}
T{
Btn3Up
T}	T{
.PN ButtonRelease
with Btn3 detail
T}
T{
Btn4Down
T}	T{
.PN ButtonPress
with Btn4 detail
T}
T{
Btn4Up
T}	T{
.PN ButtonRelease
with Btn4 detail
T}
T{
Btn5Down
T}	T{
.PN ButtonPress
with Btn5 detail
T}
T{
Btn5Up
T}	T{
.PN ButtonRelease
with Btn5 detail
T}
.sp 6p
_
.TE
.LP
The Detail field is event specific and normally corresponds to the 
detail field of an X Event, for example, <Key>A.
If no detail field is specified, then ANY is assumed.
.LP
.SH
Useful Examples
.LP
.IP \(bu 5
Always put more specific events in the table before more general ones:
.LP
.Ds
Shift <Btn1Down> : twas()\\n\\
<Btn1Down> : brillig()
.De
.LP
.IP \(bu 5
For double-click on Button 1 Up with Shift, use:
.IP
.Ds
Shift<Btn1Up>(2) : and()
.DE
.IP
This is equivalent to
.IP
.Ds
Shift<Btn1Down>,Shift<Btn1Up>,Shift<Btn1Down>,Shift<Btn1Up> : and()
.De
.IP
with appropriate timers set between events.
.IP \(bu 5
For double-click on Button 1 Down with Shift, use:
.IP
.Ds
Shift<Btn1Down>(2) : the()
.De
.IP
This is equivalent to
.IP
.Ds
Shift<Btn1Down>,Shift<Btn1Up>,Shift<Btn1Down> : the()
.De
.IP
with appropriate timers set between events.
.IP \(bu 5
Mouse motion is always discarded when it occurs between events in a table
where no motion event is specified:
.IP
.Ds
<Btn1Down> <Btn1Up> : slithy()
.De
.IP
This is taken, even if the pointer jiggles a bit between the down and
up events.
Similarly, any motion event specified in a translation matches any number 
of motion events.
If the motion event causes an action procedure to be invoked,
the procedure is invoked after each motion event.
.IP \(bu 5
If an event sequence consists of a sequence of events that is also a
non-initial subsequence of another translation,
it is not taken if it occurs in the context of the longer sequence.
This occurs mostly in sequences like:
.IP
.Ds
<Btn1Down> <Btn1Up> : toves()\\n\\
<Btn1Up> :  did()
.De
.IP
The second translation is taken only if the button release is not
preceded by a button press or if there are intervening events between the
press and the release.
Be particularly aware of this when using the repeat notation, above, 
with buttons and keys 
because their expansion includes additional events, 
and when specifying motion events because they are implicitly included 
between any two other events.
.IP \(bu 5
For single click on Button 1 Up with Shift and Meta, use:
.IP
.Ds
Shift Meta <Btn1Down>, Shift Meta<Btn1Up>: gyre()
.De
.IP \(bu 5
The ``+'' notation allows you to say ``for any number of clicks greater
than or equal to count'', such as:
.IP
.Ds
Shift <Btn1Up>(2+) : and()
.De
.IP \(bu 5
To say EnterNotify with any modifiers, use:
.IP
.Ds
<Enter> : gimble()
.De
.IP \(bu 5
To say EnterNotify with no modifiers, use:
.IP
.Ds
None <Enter> : in()
.De
.IP \(bu 5
To say EnterNotify with Button 1 Down and Button 2 Up and don't care about
the other modifiers, use:
.IP
.Ds
Button1 ~Button2 <Enter> : the()
.De
.IP \(bu 5
To say EnterNotify with Button1 Down and Button2 Down exclusively, use:
.IP
.Ds
! Button1 Button2 <Enter> : wabe()
.De
.IP
It is never necessary to use ~ with !.
.bp
\&
.sp 1
.ce 3
\s+1\fBAppendix C\fP\s-1

\s+1\fBConversion Notes\fP\s-1
.sp 2
.LP
.XS
Appendix C \- Conversion Notes
.XE
.IP 1. 5
In the alpha release \*(tk, each widget class
implemented an Xt<\^\fIWidget\fP\^>Create (for example,
.PN XtLabelCreate )
function, in which most of the code was identical from widget to widget.
In this \*(tk, a single generic 
.PN XtCreateWidget
performs most of the common work and then calls the initialize procedure
implemented for the particular widget class.
.IP 2. 5
Each composite widget class also implemented the procedures
Xt<\^\fIWidget\fP\^>Add and an Xt<\^\fIWidget\fP\^>Delete (for example,
.PN XtButtonBoxAddButton
and
.PN XtButtonBoxDeleteButton ).
In the beta release \*(tk, the composite generic procedures
.PN XtManageChildren
and
.PN XtUnmanageChildren
perform error-checking and screening out of certain children.
Then, they call the change_managed procedure
implemented for the widget's composite class. 
If the widget's parent has not yet been realized, 
the call on the change_managed procedure is delayed until realization time.
.IP 3. 5
The new \*(tk can be used to implement old-style calls by defining
one-line procedures or macros that invoke a generic routine.  For example,
you could define the macro
.PN XtCreateLabel :
as the :
.IP
.Ds 0
.TA .5i 3i
.ta .5i 3i
#define XtCreateLabel(\fIname\fP, \fIparent\fP, \fIargs\fP, \fInum_args\fP) \\
        ((LabelWidget) XtCreateWidget(\fIname\fP, \fIlabelWidgetClass\fP,   \
\fIparent\fP, \fIargs\fP, \fInum_args\fP))
.De
.TC
